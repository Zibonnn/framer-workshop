"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_components_LinkingTest_tsx"],{

/***/ "(app-pages-browser)/./node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MotionConfigContext: () => (/* binding */ MotionConfigContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n\n/**\n * @public\n */\nconst MotionConfigContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    transformPagePoint: (p) => p,\n    isStatic: false,\n    reducedMotion: \"never\",\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9Nb3Rpb25Db25maWdDb250ZXh0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9EQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRThCIiwic291cmNlcyI6WyIvVXNlcnMvemlib24vRG9jdW1lbnRzL1ZpYmUvQ3Vyc29yL0ZyYW1lciBXb3Jrc2hvcC9mcmFtZXItd29ya3Nob3Avbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L01vdGlvbkNvbmZpZ0NvbnRleHQubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBNb3Rpb25Db25maWdDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7XG4gICAgdHJhbnNmb3JtUGFnZVBvaW50OiAocCkgPT4gcCxcbiAgICBpc1N0YXRpYzogZmFsc2UsXG4gICAgcmVkdWNlZE1vdGlvbjogXCJuZXZlclwiLFxufSk7XG5cbmV4cG9ydCB7IE1vdGlvbkNvbmZpZ0NvbnRleHQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/framer-motion/dist/es/frameloop/batcher.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/framer-motion/dist/es/frameloop/batcher.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createRenderBatcher: () => (/* binding */ createRenderBatcher),\n/* harmony export */   stepsOrder: () => (/* binding */ stepsOrder)\n/* harmony export */ });\n/* harmony import */ var _render_step_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./render-step.mjs */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/frameloop/render-step.mjs\");\n\n\nconst stepsOrder = [\n    \"prepare\",\n    \"read\",\n    \"update\",\n    \"preRender\",\n    \"render\",\n    \"postRender\",\n];\nconst maxElapsed = 40;\nfunction createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\n    let runNextFrame = false;\n    let useDefaultElapsed = true;\n    const state = {\n        delta: 0,\n        timestamp: 0,\n        isProcessing: false,\n    };\n    const steps = stepsOrder.reduce((acc, key) => {\n        acc[key] = (0,_render_step_mjs__WEBPACK_IMPORTED_MODULE_0__.createRenderStep)(() => (runNextFrame = true));\n        return acc;\n    }, {});\n    const processStep = (stepId) => steps[stepId].process(state);\n    const processBatch = () => {\n        const timestamp = performance.now();\n        runNextFrame = false;\n        state.delta = useDefaultElapsed\n            ? 1000 / 60\n            : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);\n        state.timestamp = timestamp;\n        state.isProcessing = true;\n        stepsOrder.forEach(processStep);\n        state.isProcessing = false;\n        if (runNextFrame && allowKeepAlive) {\n            useDefaultElapsed = false;\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const wake = () => {\n        runNextFrame = true;\n        useDefaultElapsed = true;\n        if (!state.isProcessing) {\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const schedule = stepsOrder.reduce((acc, key) => {\n        const step = steps[key];\n        acc[key] = (process, keepAlive = false, immediate = false) => {\n            if (!runNextFrame)\n                wake();\n            return step.schedule(process, keepAlive, immediate);\n        };\n        return acc;\n    }, {});\n    const cancel = (process) => stepsOrder.forEach((key) => steps[key].cancel(process));\n    return { schedule, cancel, state, steps };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZnJhbWVsb29wL2JhdGNoZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtFQUFnQjtBQUNuQztBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQSxhQUFhO0FBQ2I7O0FBRTJDIiwic291cmNlcyI6WyIvVXNlcnMvemlib24vRG9jdW1lbnRzL1ZpYmUvQ3Vyc29yL0ZyYW1lciBXb3Jrc2hvcC9mcmFtZXItd29ya3Nob3Avbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9mcmFtZWxvb3AvYmF0Y2hlci5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlUmVuZGVyU3RlcCB9IGZyb20gJy4vcmVuZGVyLXN0ZXAubWpzJztcblxuY29uc3Qgc3RlcHNPcmRlciA9IFtcbiAgICBcInByZXBhcmVcIixcbiAgICBcInJlYWRcIixcbiAgICBcInVwZGF0ZVwiLFxuICAgIFwicHJlUmVuZGVyXCIsXG4gICAgXCJyZW5kZXJcIixcbiAgICBcInBvc3RSZW5kZXJcIixcbl07XG5jb25zdCBtYXhFbGFwc2VkID0gNDA7XG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJCYXRjaGVyKHNjaGVkdWxlTmV4dEJhdGNoLCBhbGxvd0tlZXBBbGl2ZSkge1xuICAgIGxldCBydW5OZXh0RnJhbWUgPSBmYWxzZTtcbiAgICBsZXQgdXNlRGVmYXVsdEVsYXBzZWQgPSB0cnVlO1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICBkZWx0YTogMCxcbiAgICAgICAgdGltZXN0YW1wOiAwLFxuICAgICAgICBpc1Byb2Nlc3Npbmc6IGZhbHNlLFxuICAgIH07XG4gICAgY29uc3Qgc3RlcHMgPSBzdGVwc09yZGVyLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgYWNjW2tleV0gPSBjcmVhdGVSZW5kZXJTdGVwKCgpID0+IChydW5OZXh0RnJhbWUgPSB0cnVlKSk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIGNvbnN0IHByb2Nlc3NTdGVwID0gKHN0ZXBJZCkgPT4gc3RlcHNbc3RlcElkXS5wcm9jZXNzKHN0YXRlKTtcbiAgICBjb25zdCBwcm9jZXNzQmF0Y2ggPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBydW5OZXh0RnJhbWUgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuZGVsdGEgPSB1c2VEZWZhdWx0RWxhcHNlZFxuICAgICAgICAgICAgPyAxMDAwIC8gNjBcbiAgICAgICAgICAgIDogTWF0aC5tYXgoTWF0aC5taW4odGltZXN0YW1wIC0gc3RhdGUudGltZXN0YW1wLCBtYXhFbGFwc2VkKSwgMSk7XG4gICAgICAgIHN0YXRlLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgc3RhdGUuaXNQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICAgICAgc3RlcHNPcmRlci5mb3JFYWNoKHByb2Nlc3NTdGVwKTtcbiAgICAgICAgc3RhdGUuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChydW5OZXh0RnJhbWUgJiYgYWxsb3dLZWVwQWxpdmUpIHtcbiAgICAgICAgICAgIHVzZURlZmF1bHRFbGFwc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBzY2hlZHVsZU5leHRCYXRjaChwcm9jZXNzQmF0Y2gpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB3YWtlID0gKCkgPT4ge1xuICAgICAgICBydW5OZXh0RnJhbWUgPSB0cnVlO1xuICAgICAgICB1c2VEZWZhdWx0RWxhcHNlZCA9IHRydWU7XG4gICAgICAgIGlmICghc3RhdGUuaXNQcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICBzY2hlZHVsZU5leHRCYXRjaChwcm9jZXNzQmF0Y2gpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzY2hlZHVsZSA9IHN0ZXBzT3JkZXIucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCBzdGVwID0gc3RlcHNba2V5XTtcbiAgICAgICAgYWNjW2tleV0gPSAocHJvY2Vzcywga2VlcEFsaXZlID0gZmFsc2UsIGltbWVkaWF0ZSA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJ1bk5leHRGcmFtZSlcbiAgICAgICAgICAgICAgICB3YWtlKCk7XG4gICAgICAgICAgICByZXR1cm4gc3RlcC5zY2hlZHVsZShwcm9jZXNzLCBrZWVwQWxpdmUsIGltbWVkaWF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIGNvbnN0IGNhbmNlbCA9IChwcm9jZXNzKSA9PiBzdGVwc09yZGVyLmZvckVhY2goKGtleSkgPT4gc3RlcHNba2V5XS5jYW5jZWwocHJvY2VzcykpO1xuICAgIHJldHVybiB7IHNjaGVkdWxlLCBjYW5jZWwsIHN0YXRlLCBzdGVwcyB9O1xufVxuXG5leHBvcnQgeyBjcmVhdGVSZW5kZXJCYXRjaGVyLCBzdGVwc09yZGVyIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/framer-motion/dist/es/frameloop/batcher.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/framer-motion/dist/es/frameloop/frame.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/framer-motion/dist/es/frameloop/frame.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cancelFrame: () => (/* binding */ cancelFrame),\n/* harmony export */   frame: () => (/* binding */ frame),\n/* harmony export */   frameData: () => (/* binding */ frameData),\n/* harmony export */   steps: () => (/* binding */ steps)\n/* harmony export */ });\n/* harmony import */ var _utils_noop_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/noop.mjs */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/utils/noop.mjs\");\n/* harmony import */ var _batcher_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./batcher.mjs */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/frameloop/batcher.mjs\");\n\n\n\nconst { schedule: frame, cancel: cancelFrame, state: frameData, steps, } = (0,_batcher_mjs__WEBPACK_IMPORTED_MODULE_0__.createRenderBatcher)(typeof requestAnimationFrame !== \"undefined\" ? requestAnimationFrame : _utils_noop_mjs__WEBPACK_IMPORTED_MODULE_1__.noop, true);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZnJhbWVsb29wL2ZyYW1lLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBeUM7QUFDVzs7QUFFcEQsUUFBUSxpRUFBaUUsRUFBRSxpRUFBbUIsd0VBQXdFLGlEQUFJOztBQUUxSCIsInNvdXJjZXMiOlsiL1VzZXJzL3ppYm9uL0RvY3VtZW50cy9WaWJlL0N1cnNvci9GcmFtZXIgV29ya3Nob3AvZnJhbWVyLXdvcmtzaG9wL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZnJhbWVsb29wL2ZyYW1lLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vdXRpbHMvbm9vcC5tanMnO1xuaW1wb3J0IHsgY3JlYXRlUmVuZGVyQmF0Y2hlciB9IGZyb20gJy4vYmF0Y2hlci5tanMnO1xuXG5jb25zdCB7IHNjaGVkdWxlOiBmcmFtZSwgY2FuY2VsOiBjYW5jZWxGcmFtZSwgc3RhdGU6IGZyYW1lRGF0YSwgc3RlcHMsIH0gPSBjcmVhdGVSZW5kZXJCYXRjaGVyKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09IFwidW5kZWZpbmVkXCIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBub29wLCB0cnVlKTtcblxuZXhwb3J0IHsgY2FuY2VsRnJhbWUsIGZyYW1lLCBmcmFtZURhdGEsIHN0ZXBzIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/framer-motion/dist/es/frameloop/frame.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/framer-motion/dist/es/frameloop/render-step.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/framer-motion/dist/es/frameloop/render-step.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createRenderStep: () => (/* binding */ createRenderStep)\n/* harmony export */ });\nclass Queue {\n    constructor() {\n        this.order = [];\n        this.scheduled = new Set();\n    }\n    add(process) {\n        if (!this.scheduled.has(process)) {\n            this.scheduled.add(process);\n            this.order.push(process);\n            return true;\n        }\n    }\n    remove(process) {\n        const index = this.order.indexOf(process);\n        if (index !== -1) {\n            this.order.splice(index, 1);\n            this.scheduled.delete(process);\n        }\n    }\n    clear() {\n        this.order.length = 0;\n        this.scheduled.clear();\n    }\n}\nfunction createRenderStep(runNextFrame) {\n    /**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let thisFrame = new Queue();\n    let nextFrame = new Queue();\n    let numToRun = 0;\n    /**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet();\n    const step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (queue.add(callback) && addToCurrentFrame && isProcessing) {\n                // If we're adding it to the currently running queue, update its measured size\n                numToRun = thisFrame.order.length;\n            }\n            return callback;\n        },\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */\n        cancel: (callback) => {\n            nextFrame.remove(callback);\n            toKeepAlive.delete(callback);\n        },\n        /**\n         * Execute all schedule callbacks.\n         */\n        process: (frameData) => {\n            /**\n             * If we're already processing we've probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\n            // Clear the next frame queue\n            nextFrame.clear();\n            // Execute this frame\n            numToRun = thisFrame.order.length;\n            if (numToRun) {\n                for (let i = 0; i < numToRun; i++) {\n                    const callback = thisFrame.order[i];\n                    callback(frameData);\n                    if (toKeepAlive.has(callback)) {\n                        step.schedule(callback);\n                        runNextFrame();\n                    }\n                }\n            }\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZnJhbWVsb29wL3JlbmRlci1zdGVwLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFNEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy96aWJvbi9Eb2N1bWVudHMvVmliZS9DdXJzb3IvRnJhbWVyIFdvcmtzaG9wL2ZyYW1lci13b3Jrc2hvcC9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2ZyYW1lbG9vcC9yZW5kZXItc3RlcC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgUXVldWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm9yZGVyID0gW107XG4gICAgICAgIHRoaXMuc2NoZWR1bGVkID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICBhZGQocHJvY2Vzcykge1xuICAgICAgICBpZiAoIXRoaXMuc2NoZWR1bGVkLmhhcyhwcm9jZXNzKSkge1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZWQuYWRkKHByb2Nlc3MpO1xuICAgICAgICAgICAgdGhpcy5vcmRlci5wdXNoKHByb2Nlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlKHByb2Nlc3MpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm9yZGVyLmluZGV4T2YocHJvY2Vzcyk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMub3JkZXIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVkLmRlbGV0ZShwcm9jZXNzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5vcmRlci5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnNjaGVkdWxlZC5jbGVhcigpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlclN0ZXAocnVuTmV4dEZyYW1lKSB7XG4gICAgLyoqXG4gICAgICogV2UgY3JlYXRlIGFuZCByZXVzZSB0d28gcXVldWVzLCBvbmUgdG8gcXVldWUgam9icyBmb3IgdGhlIGN1cnJlbnQgZnJhbWVcbiAgICAgKiBhbmQgb25lIGZvciB0aGUgbmV4dC4gV2UgcmV1c2UgdG8gYXZvaWQgdHJpZ2dlcmluZyBHQyBhZnRlciB4IGZyYW1lcy5cbiAgICAgKi9cbiAgICBsZXQgdGhpc0ZyYW1lID0gbmV3IFF1ZXVlKCk7XG4gICAgbGV0IG5leHRGcmFtZSA9IG5ldyBRdWV1ZSgpO1xuICAgIGxldCBudW1Ub1J1biA9IDA7XG4gICAgLyoqXG4gICAgICogVHJhY2sgd2hldGhlciB3ZSdyZSBjdXJyZW50bHkgcHJvY2Vzc2luZyBqb2JzIGluIHRoaXMgc3RlcC4gVGhpcyB3YXlcbiAgICAgKiB3ZSBjYW4gZGVjaWRlIHdoZXRoZXIgdG8gc2NoZWR1bGUgbmV3IGpvYnMgZm9yIHRoaXMgZnJhbWUgb3IgbmV4dC5cbiAgICAgKi9cbiAgICBsZXQgaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgbGV0IGZsdXNoTmV4dEZyYW1lID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQSBzZXQgb2YgcHJvY2Vzc2VzIHdoaWNoIHdlcmUgbWFya2VkIGtlZXBBbGl2ZSB3aGVuIHNjaGVkdWxlZC5cbiAgICAgKi9cbiAgICBjb25zdCB0b0tlZXBBbGl2ZSA9IG5ldyBXZWFrU2V0KCk7XG4gICAgY29uc3Qgc3RlcCA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjaGVkdWxlIGEgcHJvY2VzcyB0byBydW4gb24gdGhlIG5leHQgZnJhbWUuXG4gICAgICAgICAqL1xuICAgICAgICBzY2hlZHVsZTogKGNhbGxiYWNrLCBrZWVwQWxpdmUgPSBmYWxzZSwgaW1tZWRpYXRlID0gZmFsc2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFkZFRvQ3VycmVudEZyYW1lID0gaW1tZWRpYXRlICYmIGlzUHJvY2Vzc2luZztcbiAgICAgICAgICAgIGNvbnN0IHF1ZXVlID0gYWRkVG9DdXJyZW50RnJhbWUgPyB0aGlzRnJhbWUgOiBuZXh0RnJhbWU7XG4gICAgICAgICAgICBpZiAoa2VlcEFsaXZlKVxuICAgICAgICAgICAgICAgIHRvS2VlcEFsaXZlLmFkZChjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAocXVldWUuYWRkKGNhbGxiYWNrKSAmJiBhZGRUb0N1cnJlbnRGcmFtZSAmJiBpc1Byb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBhZGRpbmcgaXQgdG8gdGhlIGN1cnJlbnRseSBydW5uaW5nIHF1ZXVlLCB1cGRhdGUgaXRzIG1lYXN1cmVkIHNpemVcbiAgICAgICAgICAgICAgICBudW1Ub1J1biA9IHRoaXNGcmFtZS5vcmRlci5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYW5jZWwgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZyb20gcnVubmluZyBvbiB0aGUgbmV4dCBmcmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIGNhbmNlbDogKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBuZXh0RnJhbWUucmVtb3ZlKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHRvS2VlcEFsaXZlLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeGVjdXRlIGFsbCBzY2hlZHVsZSBjYWxsYmFja3MuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9jZXNzOiAoZnJhbWVEYXRhKSA9PiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlJ3JlIGFscmVhZHkgcHJvY2Vzc2luZyB3ZSd2ZSBwcm9iYWJseSBiZWVuIHRyaWdnZXJlZCBieSBhIGZsdXNoU3luY1xuICAgICAgICAgICAgICogaW5zaWRlIGFuIGV4aXN0aW5nIHByb2Nlc3MuIEluc3RlYWQgb2YgZXhlY3V0aW5nLCBtYXJrIGZsdXNoTmV4dEZyYW1lXG4gICAgICAgICAgICAgKiBhcyB0cnVlIGFuZCBlbnN1cmUgd2UgZmx1c2ggdGhlIGZvbGxvd2luZyBmcmFtZSBhdCB0aGUgZW5kIG9mIHRoaXMgb25lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaXNQcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgZmx1c2hOZXh0RnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgICAgICAgICBbdGhpc0ZyYW1lLCBuZXh0RnJhbWVdID0gW25leHRGcmFtZSwgdGhpc0ZyYW1lXTtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBuZXh0IGZyYW1lIHF1ZXVlXG4gICAgICAgICAgICBuZXh0RnJhbWUuY2xlYXIoKTtcbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhpcyBmcmFtZVxuICAgICAgICAgICAgbnVtVG9SdW4gPSB0aGlzRnJhbWUub3JkZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG51bVRvUnVuKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Ub1J1bjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpc0ZyYW1lLm9yZGVyW2ldO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhmcmFtZURhdGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9LZWVwQWxpdmUuaGFzKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcC5zY2hlZHVsZShjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5OZXh0RnJhbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGZsdXNoTmV4dEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgZmx1c2hOZXh0RnJhbWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdGVwLnByb2Nlc3MoZnJhbWVEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBzdGVwO1xufVxuXG5leHBvcnQgeyBjcmVhdGVSZW5kZXJTdGVwIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/framer-motion/dist/es/frameloop/render-step.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/framer-motion/dist/es/utils/array.mjs":
/*!************************************************************!*\
  !*** ./node_modules/framer-motion/dist/es/utils/array.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addUniqueItem: () => (/* binding */ addUniqueItem),\n/* harmony export */   moveItem: () => (/* binding */ moveItem),\n/* harmony export */   removeItem: () => (/* binding */ removeItem)\n/* harmony export */ });\nfunction addUniqueItem(arr, item) {\n    if (arr.indexOf(item) === -1)\n        arr.push(item);\n}\nfunction removeItem(arr, item) {\n    const index = arr.indexOf(item);\n    if (index > -1)\n        arr.splice(index, 1);\n}\n// Adapted from array-move\nfunction moveItem([...arr], fromIndex, toIndex) {\n    const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\n    if (startIndex >= 0 && startIndex < arr.length) {\n        const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\n        const [item] = arr.splice(fromIndex, 1);\n        arr.splice(endIndex, 0, item);\n    }\n    return arr;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvYXJyYXkubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUrQyIsInNvdXJjZXMiOlsiL1VzZXJzL3ppYm9uL0RvY3VtZW50cy9WaWJlL0N1cnNvci9GcmFtZXIgV29ya3Nob3AvZnJhbWVyLXdvcmtzaG9wL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvYXJyYXkubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGFkZFVuaXF1ZUl0ZW0oYXJyLCBpdGVtKSB7XG4gICAgaWYgKGFyci5pbmRleE9mKGl0ZW0pID09PSAtMSlcbiAgICAgICAgYXJyLnB1c2goaXRlbSk7XG59XG5mdW5jdGlvbiByZW1vdmVJdGVtKGFyciwgaXRlbSkge1xuICAgIGNvbnN0IGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xufVxuLy8gQWRhcHRlZCBmcm9tIGFycmF5LW1vdmVcbmZ1bmN0aW9uIG1vdmVJdGVtKFsuLi5hcnJdLCBmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gZnJvbUluZGV4IDwgMCA/IGFyci5sZW5ndGggKyBmcm9tSW5kZXggOiBmcm9tSW5kZXg7XG4gICAgaWYgKHN0YXJ0SW5kZXggPj0gMCAmJiBzdGFydEluZGV4IDwgYXJyLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBlbmRJbmRleCA9IHRvSW5kZXggPCAwID8gYXJyLmxlbmd0aCArIHRvSW5kZXggOiB0b0luZGV4O1xuICAgICAgICBjb25zdCBbaXRlbV0gPSBhcnIuc3BsaWNlKGZyb21JbmRleCwgMSk7XG4gICAgICAgIGFyci5zcGxpY2UoZW5kSW5kZXgsIDAsIGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuXG5leHBvcnQgeyBhZGRVbmlxdWVJdGVtLCBtb3ZlSXRlbSwgcmVtb3ZlSXRlbSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/framer-motion/dist/es/utils/array.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/framer-motion/dist/es/utils/noop.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/framer-motion/dist/es/utils/noop.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   noop: () => (/* binding */ noop)\n/* harmony export */ });\nconst noop = (any) => any;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvbm9vcC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztBQUVnQiIsInNvdXJjZXMiOlsiL1VzZXJzL3ppYm9uL0RvY3VtZW50cy9WaWJlL0N1cnNvci9GcmFtZXIgV29ya3Nob3AvZnJhbWVyLXdvcmtzaG9wL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvbm9vcC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgbm9vcCA9IChhbnkpID0+IGFueTtcblxuZXhwb3J0IHsgbm9vcCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/framer-motion/dist/es/utils/noop.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/framer-motion/dist/es/utils/subscription-manager.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/framer-motion/dist/es/utils/subscription-manager.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SubscriptionManager: () => (/* binding */ SubscriptionManager)\n/* harmony export */ });\n/* harmony import */ var _array_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.mjs */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/utils/array.mjs\");\n\n\nclass SubscriptionManager {\n    constructor() {\n        this.subscriptions = [];\n    }\n    add(handler) {\n        (0,_array_mjs__WEBPACK_IMPORTED_MODULE_0__.addUniqueItem)(this.subscriptions, handler);\n        return () => (0,_array_mjs__WEBPACK_IMPORTED_MODULE_0__.removeItem)(this.subscriptions, handler);\n    }\n    notify(a, b, c) {\n        const numSubscriptions = this.subscriptions.length;\n        if (!numSubscriptions)\n            return;\n        if (numSubscriptions === 1) {\n            /**\n             * If there's only a single handler we can just call it without invoking a loop.\n             */\n            this.subscriptions[0](a, b, c);\n        }\n        else {\n            for (let i = 0; i < numSubscriptions; i++) {\n                /**\n                 * Check whether the handler exists before firing as it's possible\n                 * the subscriptions were modified during this loop running.\n                 */\n                const handler = this.subscriptions[i];\n                handler && handler(a, b, c);\n            }\n        }\n    }\n    getSize() {\n        return this.subscriptions.length;\n    }\n    clear() {\n        this.subscriptions.length = 0;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvc3Vic2NyaXB0aW9uLW1hbmFnZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBYTtBQUNyQixxQkFBcUIsc0RBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy96aWJvbi9Eb2N1bWVudHMvVmliZS9DdXJzb3IvRnJhbWVyIFdvcmtzaG9wL2ZyYW1lci13b3Jrc2hvcC9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3N1YnNjcmlwdGlvbi1tYW5hZ2VyLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhZGRVbmlxdWVJdGVtLCByZW1vdmVJdGVtIH0gZnJvbSAnLi9hcnJheS5tanMnO1xuXG5jbGFzcyBTdWJzY3JpcHRpb25NYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgfVxuICAgIGFkZChoYW5kbGVyKSB7XG4gICAgICAgIGFkZFVuaXF1ZUl0ZW0odGhpcy5zdWJzY3JpcHRpb25zLCBoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHJlbW92ZUl0ZW0odGhpcy5zdWJzY3JpcHRpb25zLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgbm90aWZ5KGEsIGIsIGMpIHtcbiAgICAgICAgY29uc3QgbnVtU3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG4gICAgICAgIGlmICghbnVtU3Vic2NyaXB0aW9ucylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKG51bVN1YnNjcmlwdGlvbnMgPT09IDEpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhlcmUncyBvbmx5IGEgc2luZ2xlIGhhbmRsZXIgd2UgY2FuIGp1c3QgY2FsbCBpdCB3aXRob3V0IGludm9raW5nIGEgbG9vcC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zWzBdKGEsIGIsIGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1TdWJzY3JpcHRpb25zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBoYW5kbGVyIGV4aXN0cyBiZWZvcmUgZmlyaW5nIGFzIGl0J3MgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgKiB0aGUgc3Vic2NyaXB0aW9ucyB3ZXJlIG1vZGlmaWVkIGR1cmluZyB0aGlzIGxvb3AgcnVubmluZy5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5zdWJzY3JpcHRpb25zW2ldO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgJiYgaGFuZGxlcihhLCBiLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aDtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGggPSAwO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgU3Vic2NyaXB0aW9uTWFuYWdlciB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/framer-motion/dist/es/utils/subscription-manager.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/framer-motion/dist/es/utils/use-constant.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/framer-motion/dist/es/utils/use-constant.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useConstant: () => (/* binding */ useConstant)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\nfunction useConstant(init) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLWNvbnN0YW50Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2Q0FBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1QiIsInNvdXJjZXMiOlsiL1VzZXJzL3ppYm9uL0RvY3VtZW50cy9WaWJlL0N1cnNvci9GcmFtZXIgV29ya3Nob3AvZnJhbWVyLXdvcmtzaG9wL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLWNvbnN0YW50Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbnN0YW50IHZhbHVlIG92ZXIgdGhlIGxpZmVjeWNsZSBvZiBhIGNvbXBvbmVudC5cbiAqXG4gKiBFdmVuIGlmIGB1c2VNZW1vYCBpcyBwcm92aWRlZCBhbiBlbXB0eSBhcnJheSBhcyBpdHMgZmluYWwgYXJndW1lbnQsIGl0IGRvZXNuJ3Qgb2ZmZXJcbiAqIGEgZ3VhcmFudGVlIHRoYXQgaXQgd29uJ3QgcmUtcnVuIGZvciBwZXJmb3JtYW5jZSByZWFzb25zIGxhdGVyIG9uLiBCeSB1c2luZyBgdXNlQ29uc3RhbnRgXG4gKiB5b3UgY2FuIGVuc3VyZSB0aGF0IGluaXRpYWxpc2VycyBkb24ndCBleGVjdXRlIHR3aWNlIG9yIG1vcmUuXG4gKi9cbmZ1bmN0aW9uIHVzZUNvbnN0YW50KGluaXQpIHtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgaWYgKHJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gaW5pdCgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG59XG5cbmV4cG9ydCB7IHVzZUNvbnN0YW50IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/framer-motion/dist/es/utils/use-constant.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/framer-motion/dist/es/utils/velocity-per-second.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/framer-motion/dist/es/utils/velocity-per-second.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   velocityPerSecond: () => (/* binding */ velocityPerSecond)\n/* harmony export */ });\n/*\n  Convert velocity into velocity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nfunction velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdmVsb2NpdHktcGVyLXNlY29uZC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU2QiIsInNvdXJjZXMiOlsiL1VzZXJzL3ppYm9uL0RvY3VtZW50cy9WaWJlL0N1cnNvci9GcmFtZXIgV29ya3Nob3AvZnJhbWVyLXdvcmtzaG9wL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdmVsb2NpdHktcGVyLXNlY29uZC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgQ29udmVydCB2ZWxvY2l0eSBpbnRvIHZlbG9jaXR5IHBlciBzZWNvbmRcblxuICBAcGFyYW0gW251bWJlcl06IFVuaXQgcGVyIGZyYW1lXG4gIEBwYXJhbSBbbnVtYmVyXTogRnJhbWUgZHVyYXRpb24gaW4gbXNcbiovXG5mdW5jdGlvbiB2ZWxvY2l0eVBlclNlY29uZCh2ZWxvY2l0eSwgZnJhbWVEdXJhdGlvbikge1xuICAgIHJldHVybiBmcmFtZUR1cmF0aW9uID8gdmVsb2NpdHkgKiAoMTAwMCAvIGZyYW1lRHVyYXRpb24pIDogMDtcbn1cblxuZXhwb3J0IHsgdmVsb2NpdHlQZXJTZWNvbmQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/framer-motion/dist/es/utils/velocity-per-second.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/framer-motion/dist/es/utils/warn-once.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/framer-motion/dist/es/utils/warn-once.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   warnOnce: () => (/* binding */ warnOnce)\n/* harmony export */ });\nconst warned = new Set();\nfunction warnOnce(condition, message, element) {\n    if (condition || warned.has(message))\n        return;\n    console.warn(message);\n    if (element)\n        console.warn(element);\n    warned.add(message);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvd2Fybi1vbmNlLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvQiIsInNvdXJjZXMiOlsiL1VzZXJzL3ppYm9uL0RvY3VtZW50cy9WaWJlL0N1cnNvci9GcmFtZXIgV29ya3Nob3AvZnJhbWVyLXdvcmtzaG9wL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvd2Fybi1vbmNlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB3YXJuZWQgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiB3YXJuT25jZShjb25kaXRpb24sIG1lc3NhZ2UsIGVsZW1lbnQpIHtcbiAgICBpZiAoY29uZGl0aW9uIHx8IHdhcm5lZC5oYXMobWVzc2FnZSkpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgaWYgKGVsZW1lbnQpXG4gICAgICAgIGNvbnNvbGUud2FybihlbGVtZW50KTtcbiAgICB3YXJuZWQuYWRkKG1lc3NhZ2UpO1xufVxuXG5leHBvcnQgeyB3YXJuT25jZSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/framer-motion/dist/es/utils/warn-once.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/framer-motion/dist/es/value/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/framer-motion/dist/es/value/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MotionValue: () => (/* binding */ MotionValue),\n/* harmony export */   collectMotionValues: () => (/* binding */ collectMotionValues),\n/* harmony export */   motionValue: () => (/* binding */ motionValue)\n/* harmony export */ });\n/* harmony import */ var _utils_subscription_manager_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/subscription-manager.mjs */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/utils/subscription-manager.mjs\");\n/* harmony import */ var _utils_velocity_per_second_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/velocity-per-second.mjs */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/utils/velocity-per-second.mjs\");\n/* harmony import */ var _utils_warn_once_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/warn-once.mjs */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/utils/warn-once.mjs\");\n/* harmony import */ var _frameloop_frame_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../frameloop/frame.mjs */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/frameloop/frame.mjs\");\n\n\n\n\n\nconst isFloat = (value) => {\n    return !isNaN(parseFloat(value));\n};\nconst collectMotionValues = {\n    current: undefined,\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nclass MotionValue {\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     *\n     * @internal\n     */\n    constructor(init, options = {}) {\n        /**\n         * This will be replaced by the build step with the latest version number.\n         * When MotionValues are provided to motion components, warn if versions are mixed.\n         */\n        this.version = \"10.18.0\";\n        /**\n         * Duration, in milliseconds, since last updating frame.\n         *\n         * @internal\n         */\n        this.timeDelta = 0;\n        /**\n         * Timestamp of the last time this `MotionValue` was updated.\n         *\n         * @internal\n         */\n        this.lastUpdated = 0;\n        /**\n         * Tracks whether this value can output a velocity. Currently this is only true\n         * if the value is numerical, but we might be able to widen the scope here and support\n         * other value types.\n         *\n         * @internal\n         */\n        this.canTrackVelocity = false;\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */\n        this.events = {};\n        this.updateAndNotify = (v, render = true) => {\n            this.prev = this.current;\n            this.current = v;\n            // Update timestamp\n            const { delta, timestamp } = _frameloop_frame_mjs__WEBPACK_IMPORTED_MODULE_0__.frameData;\n            if (this.lastUpdated !== timestamp) {\n                this.timeDelta = delta;\n                this.lastUpdated = timestamp;\n                _frameloop_frame_mjs__WEBPACK_IMPORTED_MODULE_0__.frame.postRender(this.scheduleVelocityCheck);\n            }\n            // Update update subscribers\n            if (this.prev !== this.current && this.events.change) {\n                this.events.change.notify(this.current);\n            }\n            // Update velocity subscribers\n            if (this.events.velocityChange) {\n                this.events.velocityChange.notify(this.getVelocity());\n            }\n            // Update render subscribers\n            if (render && this.events.renderRequest) {\n                this.events.renderRequest.notify(this.current);\n            }\n        };\n        /**\n         * Schedule a velocity check for the next frame.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.scheduleVelocityCheck = () => _frameloop_frame_mjs__WEBPACK_IMPORTED_MODULE_0__.frame.postRender(this.velocityCheck);\n        /**\n         * Updates `prev` with `current` if the value hasn't been updated this frame.\n         * This ensures velocity calculations return `0`.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.velocityCheck = ({ timestamp }) => {\n            if (timestamp !== this.lastUpdated) {\n                this.prev = this.current;\n                if (this.events.velocityChange) {\n                    this.events.velocityChange.notify(this.getVelocity());\n                }\n            }\n        };\n        this.hasAnimated = false;\n        this.prev = this.current = init;\n        this.canTrackVelocity = isFloat(this.current);\n        this.owner = options.owner;\n    }\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.on(\"change\", updateOpacity)\n     *     const unsubscribeY = y.on(\"change\", updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @deprecated\n     */\n    onChange(subscription) {\n        if (true) {\n            (0,_utils_warn_once_mjs__WEBPACK_IMPORTED_MODULE_1__.warnOnce)(false, `value.onChange(callback) is deprecated. Switch to value.on(\"change\", callback).`);\n        }\n        return this.on(\"change\", subscription);\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new _utils_subscription_manager_mjs__WEBPACK_IMPORTED_MODULE_2__.SubscriptionManager();\n        }\n        const unsubscribe = this.events[eventName].add(callback);\n        if (eventName === \"change\") {\n            return () => {\n                unsubscribe();\n                /**\n                 * If we have no more change listeners by the start\n                 * of the next frame, stop active animations.\n                 */\n                _frameloop_frame_mjs__WEBPACK_IMPORTED_MODULE_0__.frame.read(() => {\n                    if (!this.events.change.getSize()) {\n                        this.stop();\n                    }\n                });\n            };\n        }\n        return unsubscribe;\n    }\n    clearListeners() {\n        for (const eventManagers in this.events) {\n            this.events[eventManagers].clear();\n        }\n    }\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     *\n     * @internal\n     */\n    attach(passiveEffect, stopPassiveEffect) {\n        this.passiveEffect = passiveEffect;\n        this.stopPassiveEffect = stopPassiveEffect;\n    }\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */\n    set(v, render = true) {\n        if (!render || !this.passiveEffect) {\n            this.updateAndNotify(v, render);\n        }\n        else {\n            this.passiveEffect(v, this.updateAndNotify);\n        }\n    }\n    setWithVelocity(prev, current, delta) {\n        this.set(current);\n        this.prev = prev;\n        this.timeDelta = delta;\n    }\n    /**\n     * Set the state of the `MotionValue`, stopping any active animations,\n     * effects, and resets velocity to `0`.\n     */\n    jump(v) {\n        this.updateAndNotify(v);\n        this.prev = v;\n        this.stop();\n        if (this.stopPassiveEffect)\n            this.stopPassiveEffect();\n    }\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */\n    get() {\n        if (collectMotionValues.current) {\n            collectMotionValues.current.push(this);\n        }\n        return this.current;\n    }\n    /**\n     * @public\n     */\n    getPrevious() {\n        return this.prev;\n    }\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */\n    getVelocity() {\n        // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n        return this.canTrackVelocity\n            ? // These casts could be avoided if parseFloat would be typed better\n                (0,_utils_velocity_per_second_mjs__WEBPACK_IMPORTED_MODULE_3__.velocityPerSecond)(parseFloat(this.current) -\n                    parseFloat(this.prev), this.timeDelta)\n            : 0;\n    }\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     *\n     * @internal\n     */\n    start(startAnimation) {\n        this.stop();\n        return new Promise((resolve) => {\n            this.hasAnimated = true;\n            this.animation = startAnimation(resolve);\n            if (this.events.animationStart) {\n                this.events.animationStart.notify();\n            }\n        }).then(() => {\n            if (this.events.animationComplete) {\n                this.events.animationComplete.notify();\n            }\n            this.clearAnimation();\n        });\n    }\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */\n    stop() {\n        if (this.animation) {\n            this.animation.stop();\n            if (this.events.animationCancel) {\n                this.events.animationCancel.notify();\n            }\n        }\n        this.clearAnimation();\n    }\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */\n    isAnimating() {\n        return !!this.animation;\n    }\n    clearAnimation() {\n        delete this.animation;\n    }\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */\n    destroy() {\n        this.clearListeners();\n        this.stop();\n        if (this.stopPassiveEffect) {\n            this.stopPassiveEffect();\n        }\n    }\n}\nfunction motionValue(init, options) {\n    return new MotionValue(init, options);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBd0U7QUFDSDtBQUNuQjtBQUNROztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUIsRUFBRSwyREFBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdURBQUs7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHFDQUFxQyxLQUFLO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQsWUFBWSw4REFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdGQUFtQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpRkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy96aWJvbi9Eb2N1bWVudHMvVmliZS9DdXJzb3IvRnJhbWVyIFdvcmtzaG9wL2ZyYW1lci13b3Jrc2hvcC9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdWJzY3JpcHRpb25NYW5hZ2VyIH0gZnJvbSAnLi4vdXRpbHMvc3Vic2NyaXB0aW9uLW1hbmFnZXIubWpzJztcbmltcG9ydCB7IHZlbG9jaXR5UGVyU2Vjb25kIH0gZnJvbSAnLi4vdXRpbHMvdmVsb2NpdHktcGVyLXNlY29uZC5tanMnO1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tICcuLi91dGlscy93YXJuLW9uY2UubWpzJztcbmltcG9ydCB7IGZyYW1lLCBmcmFtZURhdGEgfSBmcm9tICcuLi9mcmFtZWxvb3AvZnJhbWUubWpzJztcblxuY29uc3QgaXNGbG9hdCA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xufTtcbmNvbnN0IGNvbGxlY3RNb3Rpb25WYWx1ZXMgPSB7XG4gICAgY3VycmVudDogdW5kZWZpbmVkLFxufTtcbi8qKlxuICogYE1vdGlvblZhbHVlYCBpcyB1c2VkIHRvIHRyYWNrIHRoZSBzdGF0ZSBhbmQgdmVsb2NpdHkgb2YgbW90aW9uIHZhbHVlcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIE1vdGlvblZhbHVlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaW5pdCAtIFRoZSBpbml0aWF0aW5nIHZhbHVlXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgICAqXG4gICAgICogLSAgYHRyYW5zZm9ybWVyYDogQSBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gaW5jb21pbmcgdmFsdWVzIHdpdGguXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihpbml0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgYnVpbGQgc3RlcCB3aXRoIHRoZSBsYXRlc3QgdmVyc2lvbiBudW1iZXIuXG4gICAgICAgICAqIFdoZW4gTW90aW9uVmFsdWVzIGFyZSBwcm92aWRlZCB0byBtb3Rpb24gY29tcG9uZW50cywgd2FybiBpZiB2ZXJzaW9ucyBhcmUgbWl4ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBcIjEwLjE4LjBcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIER1cmF0aW9uLCBpbiBtaWxsaXNlY29uZHMsIHNpbmNlIGxhc3QgdXBkYXRpbmcgZnJhbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aW1lRGVsdGEgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGltZXN0YW1wIG9mIHRoZSBsYXN0IHRpbWUgdGhpcyBgTW90aW9uVmFsdWVgIHdhcyB1cGRhdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdFVwZGF0ZWQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJhY2tzIHdoZXRoZXIgdGhpcyB2YWx1ZSBjYW4gb3V0cHV0IGEgdmVsb2NpdHkuIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdHJ1ZVxuICAgICAgICAgKiBpZiB0aGUgdmFsdWUgaXMgbnVtZXJpY2FsLCBidXQgd2UgbWlnaHQgYmUgYWJsZSB0byB3aWRlbiB0aGUgc2NvcGUgaGVyZSBhbmQgc3VwcG9ydFxuICAgICAgICAgKiBvdGhlciB2YWx1ZSB0eXBlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhblRyYWNrVmVsb2NpdHkgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9iamVjdCBjb250YWluaW5nIGEgU3Vic2NyaXB0aW9uTWFuYWdlciBmb3IgZWFjaCBhY3RpdmUgZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgICAgICB0aGlzLnVwZGF0ZUFuZE5vdGlmeSA9ICh2LCByZW5kZXIgPSB0cnVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByZXYgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSB2O1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRpbWVzdGFtcFxuICAgICAgICAgICAgY29uc3QgeyBkZWx0YSwgdGltZXN0YW1wIH0gPSBmcmFtZURhdGE7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0VXBkYXRlZCAhPT0gdGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lRGVsdGEgPSBkZWx0YTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RVcGRhdGVkID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgICAgIGZyYW1lLnBvc3RSZW5kZXIodGhpcy5zY2hlZHVsZVZlbG9jaXR5Q2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHVwZGF0ZSBzdWJzY3JpYmVyc1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiAhPT0gdGhpcy5jdXJyZW50ICYmIHRoaXMuZXZlbnRzLmNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmNoYW5nZS5ub3RpZnkodGhpcy5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB2ZWxvY2l0eSBzdWJzY3JpYmVyc1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzLnZlbG9jaXR5Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMudmVsb2NpdHlDaGFuZ2Uubm90aWZ5KHRoaXMuZ2V0VmVsb2NpdHkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgcmVuZGVyIHN1YnNjcmliZXJzXG4gICAgICAgICAgICBpZiAocmVuZGVyICYmIHRoaXMuZXZlbnRzLnJlbmRlclJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5yZW5kZXJSZXF1ZXN0Lm5vdGlmeSh0aGlzLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2NoZWR1bGUgYSB2ZWxvY2l0eSBjaGVjayBmb3IgdGhlIG5leHQgZnJhbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgYW4gaW5zdGFuY2VkIGFuZCBib3VuZCBmdW5jdGlvbiB0byBwcmV2ZW50IGdlbmVyYXRpbmcgYSBuZXdcbiAgICAgICAgICogZnVuY3Rpb24gb25jZSBwZXIgZnJhbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY2hlZHVsZVZlbG9jaXR5Q2hlY2sgPSAoKSA9PiBmcmFtZS5wb3N0UmVuZGVyKHRoaXMudmVsb2NpdHlDaGVjayk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIGBwcmV2YCB3aXRoIGBjdXJyZW50YCBpZiB0aGUgdmFsdWUgaGFzbid0IGJlZW4gdXBkYXRlZCB0aGlzIGZyYW1lLlxuICAgICAgICAgKiBUaGlzIGVuc3VyZXMgdmVsb2NpdHkgY2FsY3VsYXRpb25zIHJldHVybiBgMGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgYW4gaW5zdGFuY2VkIGFuZCBib3VuZCBmdW5jdGlvbiB0byBwcmV2ZW50IGdlbmVyYXRpbmcgYSBuZXdcbiAgICAgICAgICogZnVuY3Rpb24gb25jZSBwZXIgZnJhbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52ZWxvY2l0eUNoZWNrID0gKHsgdGltZXN0YW1wIH0pID0+IHtcbiAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgIT09IHRoaXMubGFzdFVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXYgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzLnZlbG9jaXR5Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnZlbG9jaXR5Q2hhbmdlLm5vdGlmeSh0aGlzLmdldFZlbG9jaXR5KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYXNBbmltYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByZXYgPSB0aGlzLmN1cnJlbnQgPSBpbml0O1xuICAgICAgICB0aGlzLmNhblRyYWNrVmVsb2NpdHkgPSBpc0Zsb2F0KHRoaXMuY3VycmVudCk7XG4gICAgICAgIHRoaXMub3duZXIgPSBvcHRpb25zLm93bmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIG5vdGlmaWVkIHdoZW4gdGhlIGBNb3Rpb25WYWx1ZWAgaXMgdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEl0IHJldHVybnMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgd2lsbCBjYW5jZWwgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIFdoZW4gY2FsbGluZyBgb25DaGFuZ2VgIGluc2lkZSBhIFJlYWN0IGNvbXBvbmVudCwgaXQgc2hvdWxkIGJlIHdyYXBwZWQgd2l0aCB0aGVcbiAgICAgKiBgdXNlRWZmZWN0YCBob29rLiBBcyBpdCByZXR1cm5zIGFuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uLCB0aGlzIHNob3VsZCBiZSByZXR1cm5lZFxuICAgICAqIGZyb20gdGhlIGB1c2VFZmZlY3RgIGZ1bmN0aW9uIHRvIGVuc3VyZSB5b3UgZG9uJ3QgYWRkIGR1cGxpY2F0ZSBzdWJzY3JpYmVycy4uXG4gICAgICpcbiAgICAgKiBgYGBqc3hcbiAgICAgKiBleHBvcnQgY29uc3QgTXlDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICogICBjb25zdCB4ID0gdXNlTW90aW9uVmFsdWUoMClcbiAgICAgKiAgIGNvbnN0IHkgPSB1c2VNb3Rpb25WYWx1ZSgwKVxuICAgICAqICAgY29uc3Qgb3BhY2l0eSA9IHVzZU1vdGlvblZhbHVlKDEpXG4gICAgICpcbiAgICAgKiAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICogICAgIGZ1bmN0aW9uIHVwZGF0ZU9wYWNpdHkoKSB7XG4gICAgICogICAgICAgY29uc3QgbWF4WFkgPSBNYXRoLm1heCh4LmdldCgpLCB5LmdldCgpKVxuICAgICAqICAgICAgIGNvbnN0IG5ld09wYWNpdHkgPSB0cmFuc2Zvcm0obWF4WFksIFswLCAxMDBdLCBbMSwgMF0pXG4gICAgICogICAgICAgb3BhY2l0eS5zZXQobmV3T3BhY2l0eSlcbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICogICAgIGNvbnN0IHVuc3Vic2NyaWJlWCA9IHgub24oXCJjaGFuZ2VcIiwgdXBkYXRlT3BhY2l0eSlcbiAgICAgKiAgICAgY29uc3QgdW5zdWJzY3JpYmVZID0geS5vbihcImNoYW5nZVwiLCB1cGRhdGVPcGFjaXR5KVxuICAgICAqXG4gICAgICogICAgIHJldHVybiAoKSA9PiB7XG4gICAgICogICAgICAgdW5zdWJzY3JpYmVYKClcbiAgICAgKiAgICAgICB1bnN1YnNjcmliZVkoKVxuICAgICAqICAgICB9XG4gICAgICogICB9LCBbXSlcbiAgICAgKlxuICAgICAqICAgcmV0dXJuIDxtb3Rpb24uZGl2IHN0eWxlPXt7IHggfX0gLz5cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3Vic2NyaWJlciAtIEEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyB0aGUgbGF0ZXN0IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIHdpbGwgY2FuY2VsIHRoaXMgc3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBvbkNoYW5nZShzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgd2Fybk9uY2UoZmFsc2UsIGB2YWx1ZS5vbkNoYW5nZShjYWxsYmFjaykgaXMgZGVwcmVjYXRlZC4gU3dpdGNoIHRvIHZhbHVlLm9uKFwiY2hhbmdlXCIsIGNhbGxiYWNrKS5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5vbihcImNoYW5nZVwiLCBzdWJzY3JpcHRpb24pO1xuICAgIH1cbiAgICBvbihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5ldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXSA9IG5ldyBTdWJzY3JpcHRpb25NYW5hZ2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdLmFkZChjYWxsYmFjayk7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiY2hhbmdlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB3ZSBoYXZlIG5vIG1vcmUgY2hhbmdlIGxpc3RlbmVycyBieSB0aGUgc3RhcnRcbiAgICAgICAgICAgICAgICAgKiBvZiB0aGUgbmV4dCBmcmFtZSwgc3RvcCBhY3RpdmUgYW5pbWF0aW9ucy5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmcmFtZS5yZWFkKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZW50cy5jaGFuZ2UuZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gICAgfVxuICAgIGNsZWFyTGlzdGVuZXJzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50TWFuYWdlcnMgaW4gdGhpcy5ldmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50TWFuYWdlcnNdLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgYSBwYXNzaXZlIGVmZmVjdCB0byB0aGUgYE1vdGlvblZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGF0dGFjaChwYXNzaXZlRWZmZWN0LCBzdG9wUGFzc2l2ZUVmZmVjdCkge1xuICAgICAgICB0aGlzLnBhc3NpdmVFZmZlY3QgPSBwYXNzaXZlRWZmZWN0O1xuICAgICAgICB0aGlzLnN0b3BQYXNzaXZlRWZmZWN0ID0gc3RvcFBhc3NpdmVFZmZlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0YXRlIG9mIHRoZSBgTW90aW9uVmFsdWVgLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIGBgYGpzeFxuICAgICAqIGNvbnN0IHggPSB1c2VNb3Rpb25WYWx1ZSgwKVxuICAgICAqIHguc2V0KDEwKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGxhdGVzdCAtIExhdGVzdCB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHJlbmRlciAtIFdoZXRoZXIgdG8gbm90aWZ5IHJlbmRlciBzdWJzY3JpYmVycy4gRGVmYXVsdHMgdG8gYHRydWVgXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2V0KHYsIHJlbmRlciA9IHRydWUpIHtcbiAgICAgICAgaWYgKCFyZW5kZXIgfHwgIXRoaXMucGFzc2l2ZUVmZmVjdCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBbmROb3RpZnkodiwgcmVuZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFzc2l2ZUVmZmVjdCh2LCB0aGlzLnVwZGF0ZUFuZE5vdGlmeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0V2l0aFZlbG9jaXR5KHByZXYsIGN1cnJlbnQsIGRlbHRhKSB7XG4gICAgICAgIHRoaXMuc2V0KGN1cnJlbnQpO1xuICAgICAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgICAgICB0aGlzLnRpbWVEZWx0YSA9IGRlbHRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHN0YXRlIG9mIHRoZSBgTW90aW9uVmFsdWVgLCBzdG9wcGluZyBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsXG4gICAgICogZWZmZWN0cywgYW5kIHJlc2V0cyB2ZWxvY2l0eSB0byBgMGAuXG4gICAgICovXG4gICAganVtcCh2KSB7XG4gICAgICAgIHRoaXMudXBkYXRlQW5kTm90aWZ5KHYpO1xuICAgICAgICB0aGlzLnByZXYgPSB2O1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMuc3RvcFBhc3NpdmVFZmZlY3QpXG4gICAgICAgICAgICB0aGlzLnN0b3BQYXNzaXZlRWZmZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhdGVzdCBzdGF0ZSBvZiBgTW90aW9uVmFsdWVgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBsYXRlc3Qgc3RhdGUgb2YgYE1vdGlvblZhbHVlYFxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGdldCgpIHtcbiAgICAgICAgaWYgKGNvbGxlY3RNb3Rpb25WYWx1ZXMuY3VycmVudCkge1xuICAgICAgICAgICAgY29sbGVjdE1vdGlvblZhbHVlcy5jdXJyZW50LnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGdldFByZXZpb3VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsYXRlc3QgdmVsb2NpdHkgb2YgYE1vdGlvblZhbHVlYFxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBUaGUgbGF0ZXN0IHZlbG9jaXR5IG9mIGBNb3Rpb25WYWx1ZWAuIFJldHVybnMgYDBgIGlmIHRoZSBzdGF0ZSBpcyBub24tbnVtZXJpY2FsLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGdldFZlbG9jaXR5KCkge1xuICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIGlzRmxvYXQodGhpcy5wcmV2KSAmJiBpc0Zsb2F0KHRoaXMuY3VycmVudCksIGJ1dCB0aGF0IHdvdWxkIGJlIHdhc3RlZnVsXG4gICAgICAgIHJldHVybiB0aGlzLmNhblRyYWNrVmVsb2NpdHlcbiAgICAgICAgICAgID8gLy8gVGhlc2UgY2FzdHMgY291bGQgYmUgYXZvaWRlZCBpZiBwYXJzZUZsb2F0IHdvdWxkIGJlIHR5cGVkIGJldHRlclxuICAgICAgICAgICAgICAgIHZlbG9jaXR5UGVyU2Vjb25kKHBhcnNlRmxvYXQodGhpcy5jdXJyZW50KSAtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQodGhpcy5wcmV2KSwgdGhpcy50aW1lRGVsdGEpXG4gICAgICAgICAgICA6IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIG5ldyBhbmltYXRpb24gdG8gY29udHJvbCB0aGlzIGBNb3Rpb25WYWx1ZWAuIE9ubHkgb25lXG4gICAgICogYW5pbWF0aW9uIGNhbiBkcml2ZSBhIGBNb3Rpb25WYWx1ZWAgYXQgb25lIHRpbWUuXG4gICAgICpcbiAgICAgKiBgYGBqc3hcbiAgICAgKiB2YWx1ZS5zdGFydCgpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uIC0gQSBmdW5jdGlvbiB0aGF0IHN0YXJ0cyB0aGUgcHJvdmlkZWQgYW5pbWF0aW9uXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGFydChzdGFydEFuaW1hdGlvbikge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhc0FuaW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uID0gc3RhcnRBbmltYXRpb24ocmVzb2x2ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudHMuYW5pbWF0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5hbmltYXRpb25TdGFydC5ub3RpZnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudHMuYW5pbWF0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5hbmltYXRpb25Db21wbGV0ZS5ub3RpZnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xlYXJBbmltYXRpb24oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIGN1cnJlbnRseSBhY3RpdmUgYW5pbWF0aW9uLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24uc3RvcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmFuaW1hdGlvbkNhbmNlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmFuaW1hdGlvbkNhbmNlbC5ub3RpZnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyQW5pbWF0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgdmFsdWUgaXMgY3VycmVudGx5IGFuaW1hdGluZy5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBpc0FuaW1hdGluZygpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5hbmltYXRpb247XG4gICAgfVxuICAgIGNsZWFyQW5pbWF0aW9uKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5hbmltYXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgYW5kIGNsZWFuIHVwIHN1YnNjcmliZXJzIHRvIHRoaXMgYE1vdGlvblZhbHVlYC5cbiAgICAgKlxuICAgICAqIFRoZSBgTW90aW9uVmFsdWVgIGhvb2tzIGxpa2UgYHVzZU1vdGlvblZhbHVlYCBhbmQgYHVzZVRyYW5zZm9ybWAgYXV0b21hdGljYWxseVxuICAgICAqIGhhbmRsZSB0aGUgbGlmZWN5Y2xlIG9mIHRoZSByZXR1cm5lZCBgTW90aW9uVmFsdWVgLCBzbyB0aGlzIG1ldGhvZCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiB5b3UndmUgbWFudWFsbHlcbiAgICAgKiBjcmVhdGVkIGEgYE1vdGlvblZhbHVlYCB2aWEgdGhlIGBtb3Rpb25WYWx1ZWAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jbGVhckxpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMuc3RvcFBhc3NpdmVFZmZlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFBhc3NpdmVFZmZlY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1vdGlvblZhbHVlKGluaXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IE1vdGlvblZhbHVlKGluaXQsIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgeyBNb3Rpb25WYWx1ZSwgY29sbGVjdE1vdGlvblZhbHVlcywgbW90aW9uVmFsdWUgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/framer-motion/dist/es/value/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/framer-motion/dist/es/value/use-motion-value.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/framer-motion/dist/es/value/use-motion-value.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMotionValue: () => (/* binding */ useMotionValue)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.mjs */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/value/index.mjs\");\n/* harmony import */ var _context_MotionConfigContext_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../context/MotionConfigContext.mjs */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs\");\n/* harmony import */ var _utils_use_constant_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/use-constant.mjs */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/utils/use-constant.mjs\");\n\n\n\n\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\nfunction useMotionValue(initial) {\n    const value = (0,_utils_use_constant_mjs__WEBPACK_IMPORTED_MODULE_1__.useConstant)(() => (0,_index_mjs__WEBPACK_IMPORTED_MODULE_2__.motionValue)(initial));\n    /**\n     * If this motion value is being used in static mode, like on\n     * the Framer canvas, force components to rerender when the motion\n     * value is updated.\n     */\n    const { isStatic } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_context_MotionConfigContext_mjs__WEBPACK_IMPORTED_MODULE_3__.MotionConfigContext);\n    if (isStatic) {\n        const [, setLatest] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initial);\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => value.on(\"change\", setLatest), []);\n    }\n    return value;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdXNlLW1vdGlvbi12YWx1ZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBd0Q7QUFDZDtBQUMrQjtBQUNqQjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvRUFBVyxPQUFPLHVEQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVcsRUFBRSxpREFBVSxDQUFDLGlGQUFtQjtBQUN2RDtBQUNBLDhCQUE4QiwrQ0FBUTtBQUN0QyxRQUFRLGdEQUFTO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFMEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy96aWJvbi9Eb2N1bWVudHMvVmliZS9DdXJzb3IvRnJhbWVyIFdvcmtzaG9wL2ZyYW1lci13b3Jrc2hvcC9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3VzZS1tb3Rpb24tdmFsdWUubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBtb3Rpb25WYWx1ZSB9IGZyb20gJy4vaW5kZXgubWpzJztcbmltcG9ydCB7IE1vdGlvbkNvbmZpZ0NvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0L01vdGlvbkNvbmZpZ0NvbnRleHQubWpzJztcbmltcG9ydCB7IHVzZUNvbnN0YW50IH0gZnJvbSAnLi4vdXRpbHMvdXNlLWNvbnN0YW50Lm1qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBNb3Rpb25WYWx1ZWAgdG8gdHJhY2sgdGhlIHN0YXRlIGFuZCB2ZWxvY2l0eSBvZiBhIHZhbHVlLlxuICpcbiAqIFVzdWFsbHksIHRoZXNlIGFyZSBjcmVhdGVkIGF1dG9tYXRpY2FsbHkuIEZvciBhZHZhbmNlZCB1c2UtY2FzZXMsIGxpa2UgdXNlIHdpdGggYHVzZVRyYW5zZm9ybWAsIHlvdSBjYW4gY3JlYXRlIGBNb3Rpb25WYWx1ZWBzIGV4dGVybmFsbHkgYW5kIHBhc3MgdGhlbSBpbnRvIHRoZSBhbmltYXRlZCBjb21wb25lbnQgdmlhIHRoZSBgc3R5bGVgIHByb3AuXG4gKlxuICogYGBganN4XG4gKiBleHBvcnQgY29uc3QgTXlDb21wb25lbnQgPSAoKSA9PiB7XG4gKiAgIGNvbnN0IHNjYWxlID0gdXNlTW90aW9uVmFsdWUoMSlcbiAqXG4gKiAgIHJldHVybiA8bW90aW9uLmRpdiBzdHlsZT17eyBzY2FsZSB9fSAvPlxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGluaXRpYWwgLSBUaGUgaW5pdGlhbCBzdGF0ZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZU1vdGlvblZhbHVlKGluaXRpYWwpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHVzZUNvbnN0YW50KCgpID0+IG1vdGlvblZhbHVlKGluaXRpYWwpKTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIG1vdGlvbiB2YWx1ZSBpcyBiZWluZyB1c2VkIGluIHN0YXRpYyBtb2RlLCBsaWtlIG9uXG4gICAgICogdGhlIEZyYW1lciBjYW52YXMsIGZvcmNlIGNvbXBvbmVudHMgdG8gcmVyZW5kZXIgd2hlbiB0aGUgbW90aW9uXG4gICAgICogdmFsdWUgaXMgdXBkYXRlZC5cbiAgICAgKi9cbiAgICBjb25zdCB7IGlzU3RhdGljIH0gPSB1c2VDb250ZXh0KE1vdGlvbkNvbmZpZ0NvbnRleHQpO1xuICAgIGlmIChpc1N0YXRpYykge1xuICAgICAgICBjb25zdCBbLCBzZXRMYXRlc3RdID0gdXNlU3RhdGUoaW5pdGlhbCk7XG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB2YWx1ZS5vbihcImNoYW5nZVwiLCBzZXRMYXRlc3QpLCBbXSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IHsgdXNlTW90aW9uVmFsdWUgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/framer-motion/dist/es/value/use-motion-value.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/framer/build/esm/framer.debug.js":
/*!*******************************************************!*\
  !*** ./node_modules/framer/build/esm/framer.debug.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animatable: () => (/* binding */ Animatable),\n/* harmony export */   AnimatePresence: () => (/* binding */ AnimatePresence),\n/* harmony export */   AnimateSharedLayout: () => (/* binding */ AnimateSharedLayout),\n/* harmony export */   AnyInterpolation: () => (/* binding */ AnyInterpolation),\n/* harmony export */   AutomaticLayoutIds: () => (/* binding */ AutomaticLayoutIds),\n/* harmony export */   BackgroundImage: () => (/* binding */ BackgroundImage),\n/* harmony export */   BezierAnimator: () => (/* binding */ BezierAnimator),\n/* harmony export */   BoxShadow: () => (/* binding */ BoxShadow),\n/* harmony export */   CanvasStore: () => (/* binding */ CanvasStore),\n/* harmony export */   Color: () => (/* binding */ Color),\n/* harmony export */   ColorFormat: () => (/* binding */ ColorFormat),\n/* harmony export */   ColorMixModelType: () => (/* binding */ ColorMixModelType),\n/* harmony export */   ComponentContainerContext: () => (/* binding */ ComponentContainerContext),\n/* harmony export */   ConstraintMask: () => (/* binding */ ConstraintMask),\n/* harmony export */   ConstraintValues: () => (/* binding */ ConstraintValues),\n/* harmony export */   Container: () => (/* binding */ Container),\n/* harmony export */   ControlType: () => (/* binding */ ControlType),\n/* harmony export */   ConvertColor: () => (/* binding */ ConvertColor),\n/* harmony export */   CustomProperties: () => (/* binding */ CustomProperties),\n/* harmony export */   CustomPropertiesContext: () => (/* binding */ CustomPropertiesContext),\n/* harmony export */   CycleVariantState: () => (/* binding */ CycleVariantState),\n/* harmony export */   DOM: () => (/* binding */ DOM),\n/* harmony export */   Data: () => (/* binding */ Data),\n/* harmony export */   DataContext: () => (/* binding */ DataContext),\n/* harmony export */   DataObserver: () => (/* binding */ DataObserver),\n/* harmony export */   DataObserverContext: () => (/* binding */ DataObserverContext),\n/* harmony export */   DeprecatedComponentContainer: () => (/* binding */ DeprecatedComponentContainer),\n/* harmony export */   DeprecatedFrameWithEvents: () => (/* binding */ DeprecatedFrameWithEvents),\n/* harmony export */   DimensionType: () => (/* binding */ DimensionType),\n/* harmony export */   DragControls: () => (/* binding */ DragControls),\n/* harmony export */   Draggable: () => (/* binding */ Draggable),\n/* harmony export */   EmptyState: () => (/* binding */ EmptyState),\n/* harmony export */   FlatTree: () => (/* binding */ FlatTree),\n/* harmony export */   Frame: () => (/* binding */ Frame),\n/* harmony export */   FrameWithMotion: () => (/* binding */ FrameWithMotion),\n/* harmony export */   FramerAnimation: () => (/* binding */ FramerAnimation),\n/* harmony export */   FramerEvent: () => (/* binding */ FramerEvent),\n/* harmony export */   FramerEventListener: () => (/* binding */ FramerEventListener),\n/* harmony export */   FramerEventSession: () => (/* binding */ FramerEventSession),\n/* harmony export */   FramerTreeLayoutContext: () => (/* binding */ FramerTreeLayoutContext),\n/* harmony export */   GamepadContext: () => (/* binding */ GamepadContext),\n/* harmony export */   Image: () => (/* binding */ Image2),\n/* harmony export */   InternalID: () => (/* binding */ InternalID),\n/* harmony export */   Layer: () => (/* binding */ Layer),\n/* harmony export */   LayoutGroup: () => (/* binding */ LayoutGroup),\n/* harmony export */   LayoutGroupContext: () => (/* binding */ LayoutGroupContext),\n/* harmony export */   LayoutIdContext: () => (/* binding */ LayoutIdContext),\n/* harmony export */   LazyMotion: () => (/* binding */ LazyMotion),\n/* harmony export */   Line: () => (/* binding */ Line),\n/* harmony export */   LinearGradient: () => (/* binding */ LinearGradient),\n/* harmony export */   MainLoop: () => (/* binding */ MainLoop),\n/* harmony export */   MotionConfig: () => (/* binding */ MotionConfig),\n/* harmony export */   MotionConfigContext: () => (/* binding */ MotionConfigContext),\n/* harmony export */   MotionSetup: () => (/* binding */ MotionSetup),\n/* harmony export */   MotionValue: () => (/* binding */ MotionValue),\n/* harmony export */   NavigateTo: () => (/* binding */ NavigateTo),\n/* harmony export */   Navigation: () => (/* binding */ Navigation),\n/* harmony export */   NavigationCallbackProvider: () => (/* binding */ NavigationCallbackProvider),\n/* harmony export */   NavigationConsumer: () => (/* binding */ NavigationConsumer),\n/* harmony export */   NavigationTransitionType: () => (/* binding */ NavigationTransitionType),\n/* harmony export */   ObservableObject: () => (/* binding */ ObservableObject),\n/* harmony export */   Page: () => (/* binding */ Page),\n/* harmony export */   ParentSizeState: () => (/* binding */ ParentSizeState),\n/* harmony export */   PathSegment: () => (/* binding */ PathSegment),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   PresenceContext: () => (/* binding */ PresenceContext),\n/* harmony export */   PropertyStore: () => (/* binding */ PropertyStore),\n/* harmony export */   ProvideParentSize: () => (/* binding */ ProvideParentSize),\n/* harmony export */   RadialGradient: () => (/* binding */ RadialGradient),\n/* harmony export */   Rect: () => (/* binding */ Rect),\n/* harmony export */   RenderNodeProvider: () => (/* binding */ RenderNodeProvider),\n/* harmony export */   RenderTarget: () => (/* binding */ RenderTarget),\n/* harmony export */   SVG: () => (/* binding */ SVG),\n/* harmony export */   Scroll: () => (/* binding */ Scroll),\n/* harmony export */   Shadow: () => (/* binding */ Shadow),\n/* harmony export */   SharedLayoutContext: () => (/* binding */ SharedLayoutContext),\n/* harmony export */   Size: () => (/* binding */ Size),\n/* harmony export */   SpringAnimator: () => (/* binding */ SpringAnimator),\n/* harmony export */   Stack: () => (/* binding */ Stack),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   TypefaceSourceNames: () => (/* binding */ TypefaceSourceNames),\n/* harmony export */   ValueInterpolation: () => (/* binding */ ValueInterpolation),\n/* harmony export */   VariantSelector: () => (/* binding */ VariantSelector),\n/* harmony export */   Vector: () => (/* binding */ Vector),\n/* harmony export */   VectorGroup: () => (/* binding */ VectorGroup),\n/* harmony export */   VisibilityAction: () => (/* binding */ VisibilityAction),\n/* harmony export */   WithNavigator: () => (/* binding */ WithNavigator),\n/* harmony export */   WithOverride: () => (/* binding */ WithOverride),\n/* harmony export */   _getCSSTextColorFromStyle: () => (/* binding */ _getCSSTextColorFromStyle),\n/* harmony export */   _injectRuntime: () => (/* binding */ _injectRuntime),\n/* harmony export */   addActionControls: () => (/* binding */ addActionControls),\n/* harmony export */   addFonts: () => (/* binding */ addFonts),\n/* harmony export */   addPropertyControls: () => (/* binding */ addPropertyControls),\n/* harmony export */   addScaleCorrection: () => (/* binding */ addScaleCorrection),\n/* harmony export */   animate: () => (/* binding */ animate3),\n/* harmony export */   animateVisualElement: () => (/* binding */ animateVisualElement),\n/* harmony export */   animationControls: () => (/* binding */ animationControls),\n/* harmony export */   annotateTypeOnStringify: () => (/* binding */ annotateTypeOnStringify),\n/* harmony export */   backgroundImageFromProps: () => (/* binding */ backgroundImageFromProps),\n/* harmony export */   calculateRect: () => (/* binding */ calculateRect),\n/* harmony export */   callEach: () => (/* binding */ callEach),\n/* harmony export */   collectVisualStyleFromProps: () => (/* binding */ collectVisualStyleFromProps),\n/* harmony export */   constraintsEnabled: () => (/* binding */ constraintsEnabled),\n/* harmony export */   convertPresentationTree: () => (/* binding */ convertPresentationTree),\n/* harmony export */   createBatcher: () => (/* binding */ createBatcher),\n/* harmony export */   createCrossfader: () => (/* binding */ createCrossfader),\n/* harmony export */   createData: () => (/* binding */ createData),\n/* harmony export */   createDesignComponent: () => (/* binding */ createDesignComponent),\n/* harmony export */   createDomMotionComponent: () => (/* binding */ createDomMotionComponent),\n/* harmony export */   createMotionComponent: () => (/* binding */ createMotionComponent),\n/* harmony export */   cssBackgroundSize: () => (/* binding */ cssBackgroundSize),\n/* harmony export */   cx: () => (/* binding */ cx),\n/* harmony export */   debounce: () => (/* binding */ debounce),\n/* harmony export */   dispatchKeyDownEvent: () => (/* binding */ dispatchKeyDownEvent),\n/* harmony export */   domAnimation: () => (/* binding */ domAnimation),\n/* harmony export */   domMax: () => (/* binding */ domMax),\n/* harmony export */   environment: () => (/* binding */ environment),\n/* harmony export */   executeInRenderEnvironment: () => (/* binding */ executeInRenderEnvironment),\n/* harmony export */   finiteNumber: () => (/* binding */ finiteNumber),\n/* harmony export */   fontStore: () => (/* binding */ fontStore),\n/* harmony export */   forceLayerBackingWithCSSProperties: () => (/* binding */ forceLayerBackingWithCSSProperties),\n/* harmony export */   fraction: () => (/* binding */ fraction),\n/* harmony export */   frameFromElement: () => (/* binding */ frameFromElement),\n/* harmony export */   frameFromElements: () => (/* binding */ frameFromElements),\n/* harmony export */   getConfigFromPreviewURL: () => (/* binding */ getConfigFromPreviewURL),\n/* harmony export */   getConfigFromURL: () => (/* binding */ getConfigFromPreviewURL),\n/* harmony export */   getConfigFromVekterURL: () => (/* binding */ getConfigFromVekterURL),\n/* harmony export */   getFonts: () => (/* binding */ getFonts),\n/* harmony export */   getMeasurableCodeComponentChildren: () => (/* binding */ getMeasurableCodeComponentChildren),\n/* harmony export */   getMergedConstraintsProps: () => (/* binding */ getMergedConstraintsProps),\n/* harmony export */   getPropertyControls: () => (/* binding */ getPropertyControls),\n/* harmony export */   gradientForShape: () => (/* binding */ gradientForShape),\n/* harmony export */   imagePatternPropsForFill: () => (/* binding */ imagePatternPropsForFill),\n/* harmony export */   imageUrlForAsset: () => (/* binding */ imageUrlForAsset),\n/* harmony export */   isAnimatable: () => (/* binding */ isAnimatable2),\n/* harmony export */   isDesignDefinition: () => (/* binding */ isDesignDefinition),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   isFiniteNumber: () => (/* binding */ isFiniteNumber),\n/* harmony export */   isFractionDimension: () => (/* binding */ isFractionDimension),\n/* harmony export */   isFramerGamepadKeydownData: () => (/* binding */ isFramerGamepadKeydownData),\n/* harmony export */   isGapEnabled: () => (/* binding */ isGapEnabled),\n/* harmony export */   isMotionValue: () => (/* binding */ isMotionValue2),\n/* harmony export */   isOfAnnotatedType: () => (/* binding */ isOfAnnotatedType),\n/* harmony export */   isOverride: () => (/* binding */ isOverride),\n/* harmony export */   isReactDefinition: () => (/* binding */ isReactDefinition),\n/* harmony export */   isShallowEqualArray: () => (/* binding */ isShallowEqualArray),\n/* harmony export */   isStraightCurve: () => (/* binding */ isStraightCurve),\n/* harmony export */   isValidMotionProp: () => (/* binding */ isValidMotionProp),\n/* harmony export */   lazy: () => (/* binding */ lazy2),\n/* harmony export */   loadFont: () => (/* binding */ loadFont),\n/* harmony export */   loadJSON: () => (/* binding */ loadJSON),\n/* harmony export */   localPackageFallbackIdentifier: () => (/* binding */ localPackageFallbackIdentifier),\n/* harmony export */   localShadowFrame: () => (/* binding */ localShadowFrame),\n/* harmony export */   m: () => (/* binding */ m),\n/* harmony export */   makePaddingString: () => (/* binding */ makePaddingString),\n/* harmony export */   memoize: () => (/* binding */ memoize),\n/* harmony export */   motion: () => (/* binding */ motion),\n/* harmony export */   motionValue: () => (/* binding */ motionValue),\n/* harmony export */   paddingFromProps: () => (/* binding */ paddingFromProps),\n/* harmony export */   parseVariant: () => (/* binding */ parseVariant),\n/* harmony export */   pathDefaults: () => (/* binding */ pathDefaults),\n/* harmony export */   print: () => (/* binding */ print),\n/* harmony export */   resolveMotionValue: () => (/* binding */ resolveMotionValue),\n/* harmony export */   roundWithOffset: () => (/* binding */ roundWithOffset),\n/* harmony export */   roundedNumber: () => (/* binding */ roundedNumber),\n/* harmony export */   roundedNumberString: () => (/* binding */ roundedNumberString),\n/* harmony export */   serverURL: () => (/* binding */ serverURL),\n/* harmony export */   setGlobalRenderEnvironment: () => (/* binding */ setGlobalRenderEnvironment),\n/* harmony export */   snapshotViewportBox: () => (/* binding */ snapshotViewportBox),\n/* harmony export */   startAnimation: () => (/* binding */ startAnimation2),\n/* harmony export */   systemTypefaceName: () => (/* binding */ systemTypefaceName),\n/* harmony export */   throttle: () => (/* binding */ throttle),\n/* harmony export */   toFlexDirection: () => (/* binding */ toFlexDirection),\n/* harmony export */   toJustifyOrAlignment: () => (/* binding */ toJustifyOrAlignment),\n/* harmony export */   toSVGPath: () => (/* binding */ toSVGPath),\n/* harmony export */   transform: () => (/* binding */ transform),\n/* harmony export */   transformString: () => (/* binding */ transformString),\n/* harmony export */   transformTemplate: () => (/* binding */ transformTemplate),\n/* harmony export */   useActiveTargetCallback: () => (/* binding */ useActiveTargetCallback),\n/* harmony export */   useActiveVariantCallback: () => (/* binding */ useActiveVariantCallback),\n/* harmony export */   useAddVariantProps: () => (/* binding */ useAddVariantProps),\n/* harmony export */   useAnimatedState: () => (/* binding */ useAnimatedState),\n/* harmony export */   useAnimation: () => (/* binding */ useAnimation),\n/* harmony export */   useCycle: () => (/* binding */ useCycle),\n/* harmony export */   useDeprecatedAnimatedState: () => (/* binding */ useAnimatedState),\n/* harmony export */   useDeprecatedInvertedScale: () => (/* binding */ useInvertedScale),\n/* harmony export */   useDomEvent: () => (/* binding */ useDomEvent),\n/* harmony export */   useDragControls: () => (/* binding */ useDragControls),\n/* harmony export */   useElementScroll: () => (/* binding */ useElementScroll),\n/* harmony export */   useGamepad: () => (/* binding */ useGamepad),\n/* harmony export */   useHotkey: () => (/* binding */ useHotkey),\n/* harmony export */   useInvertedScale: () => (/* binding */ useInvertedScale),\n/* harmony export */   useIsInCurrentNavigationTarget: () => (/* binding */ useIsInCurrentNavigationTarget),\n/* harmony export */   useIsOnFramerCanvas: () => (/* binding */ useIsOnFramerCanvas),\n/* harmony export */   useIsPresent: () => (/* binding */ useIsPresent),\n/* harmony export */   useMeasureLayout: () => (/* binding */ useMeasureLayout),\n/* harmony export */   useMotionTemplate: () => (/* binding */ useMotionTemplate),\n/* harmony export */   useMotionValue: () => (/* binding */ useMotionValue),\n/* harmony export */   useNavigate: () => (/* binding */ useNavigate),\n/* harmony export */   useNavigation: () => (/* binding */ useNavigation),\n/* harmony export */   useObserveData: () => (/* binding */ useObserveData),\n/* harmony export */   useOnAppear: () => (/* binding */ useOnAppear),\n/* harmony export */   useOnCurrentTargetChange: () => (/* binding */ useOnCurrentTargetChange),\n/* harmony export */   useOnVariantChange: () => (/* binding */ useOnVariantChange),\n/* harmony export */   usePresence: () => (/* binding */ usePresence),\n/* harmony export */   useReducedMotion: () => (/* binding */ useReducedMotion),\n/* harmony export */   useRenderEnvironment: () => (/* binding */ useRenderEnvironment),\n/* harmony export */   useSpring: () => (/* binding */ useSpring),\n/* harmony export */   useTransform: () => (/* binding */ useTransform),\n/* harmony export */   useVariantState: () => (/* binding */ useVariantState),\n/* harmony export */   useVelocity: () => (/* binding */ useVelocity),\n/* harmony export */   useViewportScroll: () => (/* binding */ useViewportScroll),\n/* harmony export */   valueToDimensionType: () => (/* binding */ valueToDimensionType),\n/* harmony export */   version: () => (/* binding */ version),\n/* harmony export */   visualElement: () => (/* binding */ visualElement),\n/* harmony export */   withCSS: () => (/* binding */ withCSS),\n/* harmony export */   withGeneratedLayoutId: () => (/* binding */ withGeneratedLayoutId),\n/* harmony export */   withMeasuredSize: () => (/* binding */ withMeasuredSize),\n/* harmony export */   withOpacity: () => (/* binding */ withOpacity),\n/* harmony export */   withPath: () => (/* binding */ withPath),\n/* harmony export */   withShape: () => (/* binding */ withShape)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __commonJS = (cb2, mod) => function __require() {\n  return mod || (0, cb2[Object.keys(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module, desc) => {\n  if (module && typeof module === \"object\" || typeof module === \"function\") {\n    for (let key6 of __getOwnPropNames(module))\n      if (!__hasOwnProp.call(target, key6) && key6 !== \"default\")\n        __defProp(target, key6, { get: () => module[key6], enumerable: !(desc = __getOwnPropDesc(module, key6)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module) => {\n  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, \"default\", module && module.__esModule && \"default\" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);\n};\nvar __accessCheck = (obj, member, msg2) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg2);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\n\n// ../../node_modules/tslib/tslib.js\nvar require_tslib = __commonJS({\n  \"../../node_modules/tslib/tslib.js\"(exports, module) {\n    var __extends2;\n    var __assign2;\n    var __rest2;\n    var __decorate2;\n    var __param2;\n    var __metadata2;\n    var __awaiter2;\n    var __generator2;\n    var __exportStar2;\n    var __values2;\n    var __read2;\n    var __spread2;\n    var __spreadArrays2;\n    var __spreadArray2;\n    var __await2;\n    var __asyncGenerator2;\n    var __asyncDelegator2;\n    var __asyncValues2;\n    var __makeTemplateObject2;\n    var __importStar2;\n    var __importDefault2;\n    var __classPrivateFieldGet2;\n    var __classPrivateFieldSet2;\n    var __createBinding2;\n    (function(factory) {\n      var root = typeof window === \"object\" ? window : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\n      if (typeof define === \"function\" && __webpack_require__.amdO) {\n        define(\"tslib\", [\"exports\"], function(exports2) {\n          factory(createExporter(root, createExporter(exports2)));\n        });\n      } else if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        factory(createExporter(root, createExporter(module.exports)));\n      } else {\n        factory(createExporter(root));\n      }\n      function createExporter(exports2, previous) {\n        if (exports2 !== root) {\n          if (typeof Object.create === \"function\") {\n            Object.defineProperty(exports2, \"__esModule\", { value: true });\n          } else {\n            exports2.__esModule = true;\n          }\n        }\n        return function(id, v) {\n          return exports2[id] = previous ? previous(id, v) : v;\n        };\n      }\n    })(function(exporter) {\n      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b2) {\n        d.__proto__ = b2;\n      } || function(d, b2) {\n        for (var p in b2)\n          if (Object.prototype.hasOwnProperty.call(b2, p))\n            d[p] = b2[p];\n      };\n      __extends2 = function(d, b2) {\n        if (typeof b2 !== \"function\" && b2 !== null)\n          throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n        extendStatics(d, b2);\n        function __() {\n          this.constructor = d;\n        }\n        d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n      };\n      __assign2 = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n              t[p] = s[p];\n        }\n        return t;\n      };\n      __rest2 = function(s, e) {\n        var t = {};\n        for (var p in s)\n          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n            t[p] = s[p];\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n          }\n        return t;\n      };\n      __decorate2 = function(decorators, target, key6, desc) {\n        var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key6) : desc, d;\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n          r = Reflect.decorate(decorators, target, key6, desc);\n        else\n          for (var i = decorators.length - 1; i >= 0; i--)\n            if (d = decorators[i])\n              r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key6, r) : d(target, key6)) || r;\n        return c2 > 3 && r && Object.defineProperty(target, key6, r), r;\n      };\n      __param2 = function(paramIndex, decorator) {\n        return function(target, key6) {\n          decorator(target, key6, paramIndex);\n        };\n      };\n      __metadata2 = function(metadataKey, metadataValue) {\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\")\n          return Reflect.metadata(metadataKey, metadataValue);\n      };\n      __awaiter2 = function(thisArg, _arguments, P, generator) {\n        function adopt(value) {\n          return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n          });\n        }\n        return new (P || (P = Promise))(function(resolve, reject) {\n          function fulfilled(value) {\n            try {\n              step(generator.next(value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function rejected(value) {\n            try {\n              step(generator[\"throw\"](value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n          }\n          step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n      };\n      __generator2 = function(thisArg, body) {\n        var _ = { label: 0, sent: function() {\n          if (t[0] & 1)\n            throw t[1];\n          return t[1];\n        }, trys: [], ops: [] }, f, y, t, g;\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n          return this;\n        }), g;\n        function verb(n) {\n          return function(v) {\n            return step([n, v]);\n          };\n        }\n        function step(op) {\n          if (f)\n            throw new TypeError(\"Generator is already executing.\");\n          while (_)\n            try {\n              if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                return t;\n              if (y = 0, t)\n                op = [op[0] & 2, t.value];\n              switch (op[0]) {\n                case 0:\n                case 1:\n                  t = op;\n                  break;\n                case 4:\n                  _.label++;\n                  return { value: op[1], done: false };\n                case 5:\n                  _.label++;\n                  y = op[1];\n                  op = [0];\n                  continue;\n                case 7:\n                  op = _.ops.pop();\n                  _.trys.pop();\n                  continue;\n                default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                    _ = 0;\n                    continue;\n                  }\n                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                    _.label = op[1];\n                    break;\n                  }\n                  if (op[0] === 6 && _.label < t[1]) {\n                    _.label = t[1];\n                    t = op;\n                    break;\n                  }\n                  if (t && _.label < t[2]) {\n                    _.label = t[2];\n                    _.ops.push(op);\n                    break;\n                  }\n                  if (t[2])\n                    _.ops.pop();\n                  _.trys.pop();\n                  continue;\n              }\n              op = body.call(thisArg, _);\n            } catch (e) {\n              op = [6, e];\n              y = 0;\n            } finally {\n              f = t = 0;\n            }\n          if (op[0] & 5)\n            throw op[1];\n          return { value: op[0] ? op[1] : void 0, done: true };\n        }\n      };\n      __exportStar2 = function(m2, o) {\n        for (var p in m2)\n          if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p))\n            __createBinding2(o, m2, p);\n      };\n      __createBinding2 = Object.create ? function(o, m2, k, k2) {\n        if (k2 === void 0)\n          k2 = k;\n        Object.defineProperty(o, k2, { enumerable: true, get: function() {\n          return m2[k];\n        } });\n      } : function(o, m2, k, k2) {\n        if (k2 === void 0)\n          k2 = k;\n        o[k2] = m2[k];\n      };\n      __values2 = function(o) {\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m2 = s && o[s], i = 0;\n        if (m2)\n          return m2.call(o);\n        if (o && typeof o.length === \"number\")\n          return {\n            next: function() {\n              if (o && i >= o.length)\n                o = void 0;\n              return { value: o && o[i++], done: !o };\n            }\n          };\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n      };\n      __read2 = function(o, n) {\n        var m2 = typeof Symbol === \"function\" && o[Symbol.iterator];\n        if (!m2)\n          return o;\n        var i = m2.call(o), r, ar = [], e;\n        try {\n          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n            ar.push(r.value);\n        } catch (error) {\n          e = { error };\n        } finally {\n          try {\n            if (r && !r.done && (m2 = i[\"return\"]))\n              m2.call(i);\n          } finally {\n            if (e)\n              throw e.error;\n          }\n        }\n        return ar;\n      };\n      __spread2 = function() {\n        for (var ar = [], i = 0; i < arguments.length; i++)\n          ar = ar.concat(__read2(arguments[i]));\n        return ar;\n      };\n      __spreadArrays2 = function() {\n        for (var s = 0, i = 0, il = arguments.length; i < il; i++)\n          s += arguments[i].length;\n        for (var r = Array(s), k = 0, i = 0; i < il; i++)\n          for (var a2 = arguments[i], j = 0, jl = a2.length; j < jl; j++, k++)\n            r[k] = a2[j];\n        return r;\n      };\n      __spreadArray2 = function(to, from) {\n        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n          to[j] = from[i];\n        return to;\n      };\n      __await2 = function(v) {\n        return this instanceof __await2 ? (this.v = v, this) : new __await2(v);\n      };\n      __asyncGenerator2 = function(thisArg, _arguments, generator) {\n        if (!Symbol.asyncIterator)\n          throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n          return this;\n        }, i;\n        function verb(n) {\n          if (g[n])\n            i[n] = function(v) {\n              return new Promise(function(a2, b2) {\n                q.push([n, v, a2, b2]) > 1 || resume(n, v);\n              });\n            };\n        }\n        function resume(n, v) {\n          try {\n            step(g[n](v));\n          } catch (e) {\n            settle(q[0][3], e);\n          }\n        }\n        function step(r) {\n          r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n        }\n        function fulfill(value) {\n          resume(\"next\", value);\n        }\n        function reject(value) {\n          resume(\"throw\", value);\n        }\n        function settle(f, v) {\n          if (f(v), q.shift(), q.length)\n            resume(q[0][0], q[0][1]);\n        }\n      };\n      __asyncDelegator2 = function(o) {\n        var i, p;\n        return i = {}, verb(\"next\"), verb(\"throw\", function(e) {\n          throw e;\n        }), verb(\"return\"), i[Symbol.iterator] = function() {\n          return this;\n        }, i;\n        function verb(n, f) {\n          i[n] = o[n] ? function(v) {\n            return (p = !p) ? { value: __await2(o[n](v)), done: n === \"return\" } : f ? f(v) : v;\n          } : f;\n        }\n      };\n      __asyncValues2 = function(o) {\n        if (!Symbol.asyncIterator)\n          throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var m2 = o[Symbol.asyncIterator], i;\n        return m2 ? m2.call(o) : (o = typeof __values2 === \"function\" ? __values2(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n          return this;\n        }, i);\n        function verb(n) {\n          i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n              v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n          };\n        }\n        function settle(resolve, reject, d, v) {\n          Promise.resolve(v).then(function(v2) {\n            resolve({ value: v2, done: d });\n          }, reject);\n        }\n      };\n      __makeTemplateObject2 = function(cooked, raw) {\n        if (Object.defineProperty) {\n          Object.defineProperty(cooked, \"raw\", { value: raw });\n        } else {\n          cooked.raw = raw;\n        }\n        return cooked;\n      };\n      var __setModuleDefault = Object.create ? function(o, v) {\n        Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n      } : function(o, v) {\n        o[\"default\"] = v;\n      };\n      __importStar2 = function(mod) {\n        if (mod && mod.__esModule)\n          return mod;\n        var result = {};\n        if (mod != null) {\n          for (var k in mod)\n            if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k))\n              __createBinding2(result, mod, k);\n        }\n        __setModuleDefault(result, mod);\n        return result;\n      };\n      __importDefault2 = function(mod) {\n        return mod && mod.__esModule ? mod : { \"default\": mod };\n      };\n      __classPrivateFieldGet2 = function(receiver, state, kind, f) {\n        if (kind === \"a\" && !f)\n          throw new TypeError(\"Private accessor was defined without a getter\");\n        if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver))\n          throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n        return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n      };\n      __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {\n        if (kind === \"m\")\n          throw new TypeError(\"Private method is not writable\");\n        if (kind === \"a\" && !f)\n          throw new TypeError(\"Private accessor was defined without a setter\");\n        if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver))\n          throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n        return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n      };\n      exporter(\"__extends\", __extends2);\n      exporter(\"__assign\", __assign2);\n      exporter(\"__rest\", __rest2);\n      exporter(\"__decorate\", __decorate2);\n      exporter(\"__param\", __param2);\n      exporter(\"__metadata\", __metadata2);\n      exporter(\"__awaiter\", __awaiter2);\n      exporter(\"__generator\", __generator2);\n      exporter(\"__exportStar\", __exportStar2);\n      exporter(\"__createBinding\", __createBinding2);\n      exporter(\"__values\", __values2);\n      exporter(\"__read\", __read2);\n      exporter(\"__spread\", __spread2);\n      exporter(\"__spreadArrays\", __spreadArrays2);\n      exporter(\"__spreadArray\", __spreadArray2);\n      exporter(\"__await\", __await2);\n      exporter(\"__asyncGenerator\", __asyncGenerator2);\n      exporter(\"__asyncDelegator\", __asyncDelegator2);\n      exporter(\"__asyncValues\", __asyncValues2);\n      exporter(\"__makeTemplateObject\", __makeTemplateObject2);\n      exporter(\"__importStar\", __importStar2);\n      exporter(\"__importDefault\", __importDefault2);\n      exporter(\"__classPrivateFieldGet\", __classPrivateFieldGet2);\n      exporter(\"__classPrivateFieldSet\", __classPrivateFieldSet2);\n    });\n  }\n});\n\n// ../../node_modules/@emotion/memoize/dist/memoize.browser.cjs.js\nvar require_memoize_browser_cjs = __commonJS({\n  \"../../node_modules/@emotion/memoize/dist/memoize.browser.cjs.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function memoize2(fn) {\n      var cache4 = {};\n      return function(arg) {\n        if (cache4[arg] === void 0)\n          cache4[arg] = fn(arg);\n        return cache4[arg];\n      };\n    }\n    exports.default = memoize2;\n  }\n});\n\n// ../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.cjs.js\nvar require_is_prop_valid_browser_cjs = __commonJS({\n  \"../../node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.cjs.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function _interopDefault(ex) {\n      return ex && typeof ex === \"object\" && \"default\" in ex ? ex[\"default\"] : ex;\n    }\n    var memoize2 = _interopDefault(require_memoize_browser_cjs());\n    var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;\n    var index = memoize2(function(prop) {\n      return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;\n    });\n    exports.default = index;\n  }\n});\n\n// ../../node_modules/hsluv/hsluv.js\nvar require_hsluv = __commonJS({\n  \"../../node_modules/hsluv/hsluv.js\"(exports, module) {\n    var hsluv = hsluv || {};\n    hsluv.Geometry = function() {\n    };\n    hsluv.Geometry.intersectLineLine = function(a2, b2) {\n      var x = (a2.intercept - b2.intercept) / (b2.slope - a2.slope);\n      var y = a2.slope * x + a2.intercept;\n      return { x, y };\n    };\n    hsluv.Geometry.distanceFromOrigin = function(point) {\n      return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));\n    };\n    hsluv.Geometry.distanceLineFromOrigin = function(line) {\n      return Math.abs(line.intercept) / Math.sqrt(Math.pow(line.slope, 2) + 1);\n    };\n    hsluv.Geometry.perpendicularThroughPoint = function(line, point) {\n      var slope = -1 / line.slope;\n      var intercept = point.y - slope * point.x;\n      return { slope, intercept };\n    };\n    hsluv.Geometry.angleFromOrigin = function(point) {\n      return Math.atan2(point.y, point.x);\n    };\n    hsluv.Geometry.normalizeAngle = function(angle) {\n      var m2 = 2 * Math.PI;\n      return (angle % m2 + m2) % m2;\n    };\n    hsluv.Geometry.lengthOfRayUntilIntersect = function(theta, line) {\n      return line.intercept / (Math.sin(theta) - line.slope * Math.cos(theta));\n    };\n    hsluv.Hsluv = function() {\n    };\n    hsluv.Hsluv.getBounds = function(L) {\n      var result = [];\n      var sub1 = Math.pow(L + 16, 3) / 1560896;\n      var sub2 = sub1 > hsluv.Hsluv.epsilon ? sub1 : L / hsluv.Hsluv.kappa;\n      var _g = 0;\n      while (_g < 3) {\n        var c2 = _g++;\n        var m1 = hsluv.Hsluv.m[c2][0];\n        var m2 = hsluv.Hsluv.m[c2][1];\n        var m3 = hsluv.Hsluv.m[c2][2];\n        var _g1 = 0;\n        while (_g1 < 2) {\n          var t = _g1++;\n          var top1 = (284517 * m1 - 94839 * m3) * sub2;\n          var top2 = (838422 * m3 + 769860 * m2 + 731718 * m1) * L * sub2 - 769860 * t * L;\n          var bottom = (632260 * m3 - 126452 * m2) * sub2 + 126452 * t;\n          result.push({ slope: top1 / bottom, intercept: top2 / bottom });\n        }\n      }\n      return result;\n    };\n    hsluv.Hsluv.maxSafeChromaForL = function(L) {\n      var bounds = hsluv.Hsluv.getBounds(L);\n      var min = Infinity;\n      var _g = 0;\n      while (_g < bounds.length) {\n        var bound = bounds[_g];\n        ++_g;\n        var length = hsluv.Geometry.distanceLineFromOrigin(bound);\n        min = Math.min(min, length);\n      }\n      return min;\n    };\n    hsluv.Hsluv.maxChromaForLH = function(L, H) {\n      var hrad = H / 360 * Math.PI * 2;\n      var bounds = hsluv.Hsluv.getBounds(L);\n      var min = Infinity;\n      var _g = 0;\n      while (_g < bounds.length) {\n        var bound = bounds[_g];\n        ++_g;\n        var length = hsluv.Geometry.lengthOfRayUntilIntersect(hrad, bound);\n        if (length >= 0) {\n          min = Math.min(min, length);\n        }\n      }\n      return min;\n    };\n    hsluv.Hsluv.dotProduct = function(a2, b2) {\n      var sum = 0;\n      var _g1 = 0;\n      var _g = a2.length;\n      while (_g1 < _g) {\n        var i = _g1++;\n        sum += a2[i] * b2[i];\n      }\n      return sum;\n    };\n    hsluv.Hsluv.fromLinear = function(c2) {\n      if (c2 <= 31308e-7) {\n        return 12.92 * c2;\n      } else {\n        return 1.055 * Math.pow(c2, 0.4166666666666667) - 0.055;\n      }\n    };\n    hsluv.Hsluv.toLinear = function(c2) {\n      if (c2 > 0.04045) {\n        return Math.pow((c2 + 0.055) / 1.055, 2.4);\n      } else {\n        return c2 / 12.92;\n      }\n    };\n    hsluv.Hsluv.xyzToRgb = function(tuple) {\n      return [hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[0], tuple)), hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[1], tuple)), hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[2], tuple))];\n    };\n    hsluv.Hsluv.rgbToXyz = function(tuple) {\n      var rgbl = [hsluv.Hsluv.toLinear(tuple[0]), hsluv.Hsluv.toLinear(tuple[1]), hsluv.Hsluv.toLinear(tuple[2])];\n      return [hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[0], rgbl), hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[1], rgbl), hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[2], rgbl)];\n    };\n    hsluv.Hsluv.yToL = function(Y) {\n      if (Y <= hsluv.Hsluv.epsilon) {\n        return Y / hsluv.Hsluv.refY * hsluv.Hsluv.kappa;\n      } else {\n        return 116 * Math.pow(Y / hsluv.Hsluv.refY, 0.3333333333333333) - 16;\n      }\n    };\n    hsluv.Hsluv.lToY = function(L) {\n      if (L <= 8) {\n        return hsluv.Hsluv.refY * L / hsluv.Hsluv.kappa;\n      } else {\n        return hsluv.Hsluv.refY * Math.pow((L + 16) / 116, 3);\n      }\n    };\n    hsluv.Hsluv.xyzToLuv = function(tuple) {\n      var X = tuple[0];\n      var Y = tuple[1];\n      var Z = tuple[2];\n      var divider = X + 15 * Y + 3 * Z;\n      var varU = 4 * X;\n      var varV = 9 * Y;\n      if (divider != 0) {\n        varU /= divider;\n        varV /= divider;\n      } else {\n        varU = NaN;\n        varV = NaN;\n      }\n      var L = hsluv.Hsluv.yToL(Y);\n      if (L == 0) {\n        return [0, 0, 0];\n      }\n      var U = 13 * L * (varU - hsluv.Hsluv.refU);\n      var V = 13 * L * (varV - hsluv.Hsluv.refV);\n      return [L, U, V];\n    };\n    hsluv.Hsluv.luvToXyz = function(tuple) {\n      var L = tuple[0];\n      var U = tuple[1];\n      var V = tuple[2];\n      if (L == 0) {\n        return [0, 0, 0];\n      }\n      var varU = U / (13 * L) + hsluv.Hsluv.refU;\n      var varV = V / (13 * L) + hsluv.Hsluv.refV;\n      var Y = hsluv.Hsluv.lToY(L);\n      var X = 0 - 9 * Y * varU / ((varU - 4) * varV - varU * varV);\n      var Z = (9 * Y - 15 * varV * Y - varV * X) / (3 * varV);\n      return [X, Y, Z];\n    };\n    hsluv.Hsluv.luvToLch = function(tuple) {\n      var L = tuple[0];\n      var U = tuple[1];\n      var V = tuple[2];\n      var C = Math.sqrt(U * U + V * V);\n      var H;\n      if (C < 1e-8) {\n        H = 0;\n      } else {\n        var Hrad = Math.atan2(V, U);\n        H = Hrad * 180 / Math.PI;\n        if (H < 0) {\n          H = 360 + H;\n        }\n      }\n      return [L, C, H];\n    };\n    hsluv.Hsluv.lchToLuv = function(tuple) {\n      var L = tuple[0];\n      var C = tuple[1];\n      var H = tuple[2];\n      var Hrad = H / 360 * 2 * Math.PI;\n      var U = Math.cos(Hrad) * C;\n      var V = Math.sin(Hrad) * C;\n      return [L, U, V];\n    };\n    hsluv.Hsluv.hsluvToLch = function(tuple) {\n      var H = tuple[0];\n      var S = tuple[1];\n      var L = tuple[2];\n      if (L > 99.9999999) {\n        return [100, 0, H];\n      }\n      if (L < 1e-8) {\n        return [0, 0, H];\n      }\n      var max = hsluv.Hsluv.maxChromaForLH(L, H);\n      var C = max / 100 * S;\n      return [L, C, H];\n    };\n    hsluv.Hsluv.lchToHsluv = function(tuple) {\n      var L = tuple[0];\n      var C = tuple[1];\n      var H = tuple[2];\n      if (L > 99.9999999) {\n        return [H, 0, 100];\n      }\n      if (L < 1e-8) {\n        return [H, 0, 0];\n      }\n      var max = hsluv.Hsluv.maxChromaForLH(L, H);\n      var S = C / max * 100;\n      return [H, S, L];\n    };\n    hsluv.Hsluv.hpluvToLch = function(tuple) {\n      var H = tuple[0];\n      var S = tuple[1];\n      var L = tuple[2];\n      if (L > 99.9999999) {\n        return [100, 0, H];\n      }\n      if (L < 1e-8) {\n        return [0, 0, H];\n      }\n      var max = hsluv.Hsluv.maxSafeChromaForL(L);\n      var C = max / 100 * S;\n      return [L, C, H];\n    };\n    hsluv.Hsluv.lchToHpluv = function(tuple) {\n      var L = tuple[0];\n      var C = tuple[1];\n      var H = tuple[2];\n      if (L > 99.9999999) {\n        return [H, 0, 100];\n      }\n      if (L < 1e-8) {\n        return [H, 0, 0];\n      }\n      var max = hsluv.Hsluv.maxSafeChromaForL(L);\n      var S = C / max * 100;\n      return [H, S, L];\n    };\n    hsluv.Hsluv.rgbToHex = function(tuple) {\n      var h = \"#\";\n      var _g = 0;\n      while (_g < 3) {\n        var i = _g++;\n        var chan = tuple[i];\n        var c2 = Math.round(chan * 255);\n        var digit2 = c2 % 16;\n        var digit1 = (c2 - digit2) / 16 | 0;\n        h += hsluv.Hsluv.hexChars.charAt(digit1) + hsluv.Hsluv.hexChars.charAt(digit2);\n      }\n      return h;\n    };\n    hsluv.Hsluv.hexToRgb = function(hex2) {\n      hex2 = hex2.toLowerCase();\n      var ret = [];\n      var _g = 0;\n      while (_g < 3) {\n        var i = _g++;\n        var digit1 = hsluv.Hsluv.hexChars.indexOf(hex2.charAt(i * 2 + 1));\n        var digit2 = hsluv.Hsluv.hexChars.indexOf(hex2.charAt(i * 2 + 2));\n        var n = digit1 * 16 + digit2;\n        ret.push(n / 255);\n      }\n      return ret;\n    };\n    hsluv.Hsluv.lchToRgb = function(tuple) {\n      return hsluv.Hsluv.xyzToRgb(hsluv.Hsluv.luvToXyz(hsluv.Hsluv.lchToLuv(tuple)));\n    };\n    hsluv.Hsluv.rgbToLch = function(tuple) {\n      return hsluv.Hsluv.luvToLch(hsluv.Hsluv.xyzToLuv(hsluv.Hsluv.rgbToXyz(tuple)));\n    };\n    hsluv.Hsluv.hsluvToRgb = function(tuple) {\n      return hsluv.Hsluv.lchToRgb(hsluv.Hsluv.hsluvToLch(tuple));\n    };\n    hsluv.Hsluv.rgbToHsluv = function(tuple) {\n      return hsluv.Hsluv.lchToHsluv(hsluv.Hsluv.rgbToLch(tuple));\n    };\n    hsluv.Hsluv.hpluvToRgb = function(tuple) {\n      return hsluv.Hsluv.lchToRgb(hsluv.Hsluv.hpluvToLch(tuple));\n    };\n    hsluv.Hsluv.rgbToHpluv = function(tuple) {\n      return hsluv.Hsluv.lchToHpluv(hsluv.Hsluv.rgbToLch(tuple));\n    };\n    hsluv.Hsluv.hsluvToHex = function(tuple) {\n      return hsluv.Hsluv.rgbToHex(hsluv.Hsluv.hsluvToRgb(tuple));\n    };\n    hsluv.Hsluv.hpluvToHex = function(tuple) {\n      return hsluv.Hsluv.rgbToHex(hsluv.Hsluv.hpluvToRgb(tuple));\n    };\n    hsluv.Hsluv.hexToHsluv = function(s) {\n      return hsluv.Hsluv.rgbToHsluv(hsluv.Hsluv.hexToRgb(s));\n    };\n    hsluv.Hsluv.hexToHpluv = function(s) {\n      return hsluv.Hsluv.rgbToHpluv(hsluv.Hsluv.hexToRgb(s));\n    };\n    hsluv.Hsluv.m = [[3.240969941904521, -1.537383177570093, -0.498610760293], [-0.96924363628087, 1.87596750150772, 0.041555057407175], [0.055630079696993, -0.20397695888897, 1.056971514242878]];\n    hsluv.Hsluv.minv = [[0.41239079926595, 0.35758433938387, 0.18048078840183], [0.21263900587151, 0.71516867876775, 0.072192315360733], [0.019330818715591, 0.11919477979462, 0.95053215224966]];\n    hsluv.Hsluv.refY = 1;\n    hsluv.Hsluv.refU = 0.19783000664283;\n    hsluv.Hsluv.refV = 0.46831999493879;\n    hsluv.Hsluv.kappa = 903.2962962;\n    hsluv.Hsluv.epsilon = 0.0088564516;\n    hsluv.Hsluv.hexChars = \"0123456789abcdef\";\n    var root = {\n      \"hsluvToRgb\": hsluv.Hsluv.hsluvToRgb,\n      \"rgbToHsluv\": hsluv.Hsluv.rgbToHsluv,\n      \"hpluvToRgb\": hsluv.Hsluv.hpluvToRgb,\n      \"rgbToHpluv\": hsluv.Hsluv.rgbToHpluv,\n      \"hsluvToHex\": hsluv.Hsluv.hsluvToHex,\n      \"hexToHsluv\": hsluv.Hsluv.hexToHsluv,\n      \"hpluvToHex\": hsluv.Hsluv.hpluvToHex,\n      \"hexToHpluv\": hsluv.Hsluv.hexToHpluv,\n      \"lchToHpluv\": hsluv.Hsluv.lchToHpluv,\n      \"hpluvToLch\": hsluv.Hsluv.hpluvToLch,\n      \"lchToHsluv\": hsluv.Hsluv.lchToHsluv,\n      \"hsluvToLch\": hsluv.Hsluv.hsluvToLch,\n      \"lchToLuv\": hsluv.Hsluv.lchToLuv,\n      \"luvToLch\": hsluv.Hsluv.luvToLch,\n      \"xyzToLuv\": hsluv.Hsluv.xyzToLuv,\n      \"luvToXyz\": hsluv.Hsluv.luvToXyz,\n      \"xyzToRgb\": hsluv.Hsluv.xyzToRgb,\n      \"rgbToXyz\": hsluv.Hsluv.rgbToXyz,\n      \"lchToRgb\": hsluv.Hsluv.lchToRgb,\n      \"rgbToLch\": hsluv.Hsluv.rgbToLch\n    };\n    module.exports = root;\n  }\n});\n\n// ../../node_modules/eventemitter3/index.js\nvar require_eventemitter3 = __commonJS({\n  \"../../node_modules/eventemitter3/index.js\"(exports, module) {\n    \"use strict\";\n    var has = Object.prototype.hasOwnProperty;\n    var prefix = \"~\";\n    function Events() {\n    }\n    if (Object.create) {\n      Events.prototype = Object.create(null);\n      if (!new Events().__proto__)\n        prefix = false;\n    }\n    function EE(fn, context, once) {\n      this.fn = fn;\n      this.context = context;\n      this.once = once || false;\n    }\n    function addListener(emitter, event, fn, context, once) {\n      if (typeof fn !== \"function\") {\n        throw new TypeError(\"The listener must be a function\");\n      }\n      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;\n      if (!emitter._events[evt])\n        emitter._events[evt] = listener, emitter._eventsCount++;\n      else if (!emitter._events[evt].fn)\n        emitter._events[evt].push(listener);\n      else\n        emitter._events[evt] = [emitter._events[evt], listener];\n      return emitter;\n    }\n    function clearEvent(emitter, evt) {\n      if (--emitter._eventsCount === 0)\n        emitter._events = new Events();\n      else\n        delete emitter._events[evt];\n    }\n    function EventEmitter2() {\n      this._events = new Events();\n      this._eventsCount = 0;\n    }\n    EventEmitter2.prototype.eventNames = function eventNames() {\n      var names2 = [], events2, name;\n      if (this._eventsCount === 0)\n        return names2;\n      for (name in events2 = this._events) {\n        if (has.call(events2, name))\n          names2.push(prefix ? name.slice(1) : name);\n      }\n      if (Object.getOwnPropertySymbols) {\n        return names2.concat(Object.getOwnPropertySymbols(events2));\n      }\n      return names2;\n    };\n    EventEmitter2.prototype.listeners = function listeners(event) {\n      var evt = prefix ? prefix + event : event, handlers = this._events[evt];\n      if (!handlers)\n        return [];\n      if (handlers.fn)\n        return [handlers.fn];\n      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n        ee[i] = handlers[i].fn;\n      }\n      return ee;\n    };\n    EventEmitter2.prototype.listenerCount = function listenerCount(event) {\n      var evt = prefix ? prefix + event : event, listeners = this._events[evt];\n      if (!listeners)\n        return 0;\n      if (listeners.fn)\n        return 1;\n      return listeners.length;\n    };\n    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n      var evt = prefix ? prefix + event : event;\n      if (!this._events[evt])\n        return false;\n      var listeners = this._events[evt], len = arguments.length, args, i;\n      if (listeners.fn) {\n        if (listeners.once)\n          this.removeListener(event, listeners.fn, void 0, true);\n        switch (len) {\n          case 1:\n            return listeners.fn.call(listeners.context), true;\n          case 2:\n            return listeners.fn.call(listeners.context, a1), true;\n          case 3:\n            return listeners.fn.call(listeners.context, a1, a2), true;\n          case 4:\n            return listeners.fn.call(listeners.context, a1, a2, a3), true;\n          case 5:\n            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n          case 6:\n            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n        }\n        for (i = 1, args = new Array(len - 1); i < len; i++) {\n          args[i - 1] = arguments[i];\n        }\n        listeners.fn.apply(listeners.context, args);\n      } else {\n        var length = listeners.length, j;\n        for (i = 0; i < length; i++) {\n          if (listeners[i].once)\n            this.removeListener(event, listeners[i].fn, void 0, true);\n          switch (len) {\n            case 1:\n              listeners[i].fn.call(listeners[i].context);\n              break;\n            case 2:\n              listeners[i].fn.call(listeners[i].context, a1);\n              break;\n            case 3:\n              listeners[i].fn.call(listeners[i].context, a1, a2);\n              break;\n            case 4:\n              listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n              break;\n            default:\n              if (!args)\n                for (j = 1, args = new Array(len - 1); j < len; j++) {\n                  args[j - 1] = arguments[j];\n                }\n              listeners[i].fn.apply(listeners[i].context, args);\n          }\n        }\n      }\n      return true;\n    };\n    EventEmitter2.prototype.on = function on(event, fn, context) {\n      return addListener(this, event, fn, context, false);\n    };\n    EventEmitter2.prototype.once = function once(event, fn, context) {\n      return addListener(this, event, fn, context, true);\n    };\n    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {\n      var evt = prefix ? prefix + event : event;\n      if (!this._events[evt])\n        return this;\n      if (!fn) {\n        clearEvent(this, evt);\n        return this;\n      }\n      var listeners = this._events[evt];\n      if (listeners.fn) {\n        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n          clearEvent(this, evt);\n        }\n      } else {\n        for (var i = 0, events2 = [], length = listeners.length; i < length; i++) {\n          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n            events2.push(listeners[i]);\n          }\n        }\n        if (events2.length)\n          this._events[evt] = events2.length === 1 ? events2[0] : events2;\n        else\n          clearEvent(this, evt);\n      }\n      return this;\n    };\n    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {\n      var evt;\n      if (event) {\n        evt = prefix ? prefix + event : event;\n        if (this._events[evt])\n          clearEvent(this, evt);\n      } else {\n        this._events = new Events();\n        this._eventsCount = 0;\n      }\n      return this;\n    };\n    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;\n    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;\n    EventEmitter2.prefixed = prefix;\n    EventEmitter2.EventEmitter = EventEmitter2;\n    if (typeof module !== \"undefined\") {\n      module.exports = EventEmitter2;\n    }\n  }\n});\n\n// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\nvar require_hoist_non_react_statics_cjs = __commonJS({\n  \"node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\"(exports, module) {\n    \"use strict\";\n    var REACT_STATICS = {\n      childContextTypes: true,\n      contextTypes: true,\n      defaultProps: true,\n      displayName: true,\n      getDefaultProps: true,\n      getDerivedStateFromProps: true,\n      mixins: true,\n      propTypes: true,\n      type: true\n    };\n    var KNOWN_STATICS = {\n      name: true,\n      length: true,\n      prototype: true,\n      caller: true,\n      callee: true,\n      arguments: true,\n      arity: true\n    };\n    var defineProperty = Object.defineProperty;\n    var getOwnPropertyNames = Object.getOwnPropertyNames;\n    var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    var getPrototypeOf = Object.getPrototypeOf;\n    var objectPrototype = getPrototypeOf && getPrototypeOf(Object);\n    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n      if (typeof sourceComponent !== \"string\") {\n        if (objectPrototype) {\n          var inheritedComponent = getPrototypeOf(sourceComponent);\n          if (inheritedComponent && inheritedComponent !== objectPrototype) {\n            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n          }\n        }\n        var keys2 = getOwnPropertyNames(sourceComponent);\n        if (getOwnPropertySymbols) {\n          keys2 = keys2.concat(getOwnPropertySymbols(sourceComponent));\n        }\n        for (var i = 0; i < keys2.length; ++i) {\n          var key6 = keys2[i];\n          if (!REACT_STATICS[key6] && !KNOWN_STATICS[key6] && (!blacklist || !blacklist[key6])) {\n            var descriptor = getOwnPropertyDescriptor(sourceComponent, key6);\n            try {\n              defineProperty(targetComponent, key6, descriptor);\n            } catch (e) {\n            }\n          }\n        }\n        return targetComponent;\n      }\n      return targetComponent;\n    }\n    module.exports = hoistNonReactStatics;\n  }\n});\n\n// ../../node_modules/fontfaceobserver/fontfaceobserver.standalone.js\nvar require_fontfaceobserver_standalone = __commonJS({\n  \"../../node_modules/fontfaceobserver/fontfaceobserver.standalone.js\"(exports, module) {\n    (function() {\n      function l(a2, b2) {\n        document.addEventListener ? a2.addEventListener(\"scroll\", b2, false) : a2.attachEvent(\"scroll\", b2);\n      }\n      function m2(a2) {\n        document.body ? a2() : document.addEventListener ? document.addEventListener(\"DOMContentLoaded\", function c2() {\n          document.removeEventListener(\"DOMContentLoaded\", c2);\n          a2();\n        }) : document.attachEvent(\"onreadystatechange\", function k() {\n          if (document.readyState == \"interactive\" || document.readyState == \"complete\")\n            document.detachEvent(\"onreadystatechange\", k), a2();\n        });\n      }\n      ;\n      function t(a2) {\n        this.a = document.createElement(\"div\");\n        this.a.setAttribute(\"aria-hidden\", \"true\");\n        this.a.appendChild(document.createTextNode(a2));\n        this.b = document.createElement(\"span\");\n        this.c = document.createElement(\"span\");\n        this.h = document.createElement(\"span\");\n        this.f = document.createElement(\"span\");\n        this.g = -1;\n        this.b.style.cssText = \"max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;\";\n        this.c.style.cssText = \"max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;\";\n        this.f.style.cssText = \"max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;\";\n        this.h.style.cssText = \"display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;\";\n        this.b.appendChild(this.h);\n        this.c.appendChild(this.f);\n        this.a.appendChild(this.b);\n        this.a.appendChild(this.c);\n      }\n      function u(a2, b2) {\n        a2.a.style.cssText = \"max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:\" + b2 + \";\";\n      }\n      function z(a2) {\n        var b2 = a2.a.offsetWidth, c2 = b2 + 100;\n        a2.f.style.width = c2 + \"px\";\n        a2.c.scrollLeft = c2;\n        a2.b.scrollLeft = a2.b.scrollWidth + 100;\n        return a2.g !== b2 ? (a2.g = b2, true) : false;\n      }\n      function A(a2, b2) {\n        function c2() {\n          var a3 = k;\n          z(a3) && a3.a.parentNode && b2(a3.g);\n        }\n        var k = a2;\n        l(a2.b, c2);\n        l(a2.c, c2);\n        z(a2);\n      }\n      ;\n      function B(a2, b2) {\n        var c2 = b2 || {};\n        this.family = a2;\n        this.style = c2.style || \"normal\";\n        this.weight = c2.weight || \"normal\";\n        this.stretch = c2.stretch || \"normal\";\n      }\n      var C = null, D = null, E = null, F = null;\n      function G() {\n        if (D === null)\n          if (J() && /Apple/.test(window.navigator.vendor)) {\n            var a2 = /AppleWebKit\\/([0-9]+)(?:\\.([0-9]+))(?:\\.([0-9]+))/.exec(window.navigator.userAgent);\n            D = !!a2 && 603 > parseInt(a2[1], 10);\n          } else\n            D = false;\n        return D;\n      }\n      function J() {\n        F === null && (F = !!document.fonts);\n        return F;\n      }\n      function K() {\n        if (E === null) {\n          var a2 = document.createElement(\"div\");\n          try {\n            a2.style.font = \"condensed 100px sans-serif\";\n          } catch (b2) {\n          }\n          E = a2.style.font !== \"\";\n        }\n        return E;\n      }\n      function L(a2, b2) {\n        return [a2.style, a2.weight, K() ? a2.stretch : \"\", \"100px\", b2].join(\" \");\n      }\n      B.prototype.load = function(a2, b2) {\n        var c2 = this, k = a2 || \"BESbswy\", r = 0, n = b2 || 3e3, H = new Date().getTime();\n        return new Promise(function(a3, b3) {\n          if (J() && !G()) {\n            var M = new Promise(function(a4, b4) {\n              function e() {\n                new Date().getTime() - H >= n ? b4(Error(\"\" + n + \"ms timeout exceeded\")) : document.fonts.load(L(c2, '\"' + c2.family + '\"'), k).then(function(c3) {\n                  1 <= c3.length ? a4() : setTimeout(e, 25);\n                }, b4);\n              }\n              e();\n            }), N = new Promise(function(a4, c3) {\n              r = setTimeout(function() {\n                c3(Error(\"\" + n + \"ms timeout exceeded\"));\n              }, n);\n            });\n            Promise.race([N, M]).then(function() {\n              clearTimeout(r);\n              a3(c2);\n            }, b3);\n          } else\n            m2(function() {\n              function v() {\n                var b4;\n                if (b4 = f != -1 && g != -1 || f != -1 && h != -1 || g != -1 && h != -1)\n                  (b4 = f != g && f != h && g != h) || (C === null && (b4 = /AppleWebKit\\/([0-9]+)(?:\\.([0-9]+))/.exec(window.navigator.userAgent), C = !!b4 && (536 > parseInt(b4[1], 10) || parseInt(b4[1], 10) === 536 && 11 >= parseInt(b4[2], 10))), b4 = C && (f == w && g == w && h == w || f == x && g == x && h == x || f == y && g == y && h == y)), b4 = !b4;\n                b4 && (d.parentNode && d.parentNode.removeChild(d), clearTimeout(r), a3(c2));\n              }\n              function I() {\n                if (new Date().getTime() - H >= n)\n                  d.parentNode && d.parentNode.removeChild(d), b3(Error(\"\" + n + \"ms timeout exceeded\"));\n                else {\n                  var a4 = document.hidden;\n                  if (a4 === true || a4 === void 0)\n                    f = e.a.offsetWidth, g = p.a.offsetWidth, h = q.a.offsetWidth, v();\n                  r = setTimeout(I, 50);\n                }\n              }\n              var e = new t(k), p = new t(k), q = new t(k), f = -1, g = -1, h = -1, w = -1, x = -1, y = -1, d = document.createElement(\"div\");\n              d.dir = \"ltr\";\n              u(e, L(c2, \"sans-serif\"));\n              u(p, L(c2, \"serif\"));\n              u(q, L(c2, \"monospace\"));\n              d.appendChild(e.a);\n              d.appendChild(p.a);\n              d.appendChild(q.a);\n              document.body.appendChild(d);\n              w = e.a.offsetWidth;\n              x = p.a.offsetWidth;\n              y = q.a.offsetWidth;\n              I();\n              A(e, function(a4) {\n                f = a4;\n                v();\n              });\n              u(e, L(c2, '\"' + c2.family + '\",sans-serif'));\n              A(p, function(a4) {\n                g = a4;\n                v();\n              });\n              u(p, L(c2, '\"' + c2.family + '\",serif'));\n              A(q, function(a4) {\n                h = a4;\n                v();\n              });\n              u(q, L(c2, '\"' + c2.family + '\",monospace'));\n            });\n        });\n      };\n      typeof module === \"object\" ? module.exports = B : (window.FontFaceObserver = B, window.FontFaceObserver.prototype.load = B.prototype.load);\n    })();\n  }\n});\n\n// ../../node_modules/tslib/modules/index.js\nvar import_tslib = __toModule(require_tslib());\nvar {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __exportStar,\n  __createBinding,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet\n} = import_tslib.default;\n\n// ../../node_modules/framer-motion/dist/es/motion/index.js\n\n\n\n// ../../node_modules/framer-motion/dist/es/motion/features/use-features.js\n\n\n\n// ../../node_modules/framer-motion/dist/es/motion/features/definitions.js\nvar createDefinition = function(propNames) {\n  return {\n    isEnabled: function(props) {\n      return propNames.some(function(name) {\n        return !!props[name];\n      });\n    }\n  };\n};\nvar featureDefinitions = {\n  measureLayout: createDefinition([\n    \"layout\",\n    \"layoutId\",\n    \"drag\",\n    \"_layoutResetTransform\"\n  ]),\n  animation: createDefinition([\n    \"animate\",\n    \"exit\",\n    \"variants\",\n    \"whileHover\",\n    \"whileTap\",\n    \"whileFocus\",\n    \"whileDrag\"\n  ]),\n  exit: createDefinition([\"exit\"]),\n  drag: createDefinition([\"drag\", \"dragControls\"]),\n  focus: createDefinition([\"whileFocus\"]),\n  hover: createDefinition([\"whileHover\", \"onHoverStart\", \"onHoverEnd\"]),\n  tap: createDefinition([\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"]),\n  pan: createDefinition([\n    \"onPan\",\n    \"onPanStart\",\n    \"onPanSessionStart\",\n    \"onPanEnd\"\n  ]),\n  layoutAnimation: createDefinition([\"layout\", \"layoutId\"])\n};\nfunction loadFeatures(features) {\n  for (var key6 in features) {\n    var Component19 = features[key6];\n    if (Component19 !== null)\n      featureDefinitions[key6].Component = Component19;\n  }\n}\n\n// ../../node_modules/hey-listen/dist/hey-listen.es.js\nvar warning = function() {\n};\nvar invariant = function() {\n};\nif (true) {\n  warning = function(check, message) {\n    if (!check && typeof console !== \"undefined\") {\n      console.warn(message);\n    }\n  };\n  invariant = function(check, message) {\n    if (!check) {\n      throw new Error(message);\n    }\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/context/LazyContext.js\n\nvar LazyContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({ strict: false });\n\n// ../../node_modules/framer-motion/dist/es/motion/features/use-features.js\nvar featureNames = Object.keys(featureDefinitions);\nvar numFeatures = featureNames.length;\nfunction useFeatures(props, visualElement2, preloadedFeatures) {\n  var features = [];\n  var lazyContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LazyContext);\n  if (!visualElement2)\n    return null;\n  if (preloadedFeatures && lazyContext.strict) {\n    invariant(false, \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\");\n  }\n  for (var i = 0; i < numFeatures; i++) {\n    var name_1 = featureNames[i];\n    var _a = featureDefinitions[name_1], isEnabled = _a.isEnabled, Component19 = _a.Component;\n    if (isEnabled(props) && Component19) {\n      features.push((0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Component19, __assign({ key: name_1 }, props, { visualElement: visualElement2 })));\n    }\n  }\n  return features;\n}\n\n// ../../node_modules/framer-motion/dist/es/context/MotionConfigContext.js\n\nvar MotionConfigContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  transformPagePoint: function(p) {\n    return p;\n  },\n  isStatic: false\n});\n\n// ../../node_modules/framer-motion/dist/es/context/MotionContext/index.js\n\nvar MotionContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nfunction useVisualElementContext() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MotionContext).visualElement;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-element.js\n\n\n// ../../node_modules/framer-motion/dist/es/context/PresenceContext.js\n\nvar PresenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\n\n// ../../node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.js\n\n\n// ../../node_modules/framer-motion/dist/es/utils/use-constant.js\n\nfunction useConstant(init) {\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  if (ref.current === null) {\n    ref.current = init();\n  }\n  return ref.current;\n}\n\n// ../../node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.js\nfunction usePresence() {\n  var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PresenceContext);\n  if (context === null)\n    return [true, null];\n  var isPresent2 = context.isPresent, onExitComplete = context.onExitComplete, register = context.register;\n  var id = useUniqueId();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    return register(id);\n  }, []);\n  var safeToRemove = function() {\n    return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id);\n  };\n  return !isPresent2 && onExitComplete ? [false, safeToRemove] : [true];\n}\nfunction useIsPresent() {\n  return isPresent((0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PresenceContext));\n}\nfunction isPresent(context) {\n  return context === null ? true : context.isPresent;\n}\nvar counter = 0;\nvar incrementId = function() {\n  return counter++;\n};\nvar useUniqueId = function() {\n  return useConstant(incrementId);\n};\n\n// ../../node_modules/framer-motion/dist/es/context/LayoutGroupContext.js\n\nvar LayoutGroupContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\n\n// ../../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.js\n\n\n// ../../node_modules/framer-motion/dist/es/utils/is-browser.js\nvar isBrowser = typeof window !== \"undefined\";\n\n// ../../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.js\nvar useIsomorphicLayoutEffect = isBrowser ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-element.js\nfunction useLayoutId(_a) {\n  var layoutId = _a.layoutId;\n  var layoutGroupId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LayoutGroupContext);\n  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + \"-\" + layoutId : layoutId;\n}\nfunction useVisualElement(Component19, visualState, props, createVisualElement) {\n  var config = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MotionConfigContext);\n  var lazyContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LazyContext);\n  var parent = useVisualElementContext();\n  var presenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PresenceContext);\n  var layoutId = useLayoutId(props);\n  var visualElementRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);\n  if (!createVisualElement)\n    createVisualElement = lazyContext.renderer;\n  if (!visualElementRef.current && createVisualElement) {\n    visualElementRef.current = createVisualElement(Component19, {\n      visualState,\n      parent,\n      props: __assign(__assign({}, props), { layoutId }),\n      presenceId: presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id,\n      blockInitialAnimation: (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false\n    });\n  }\n  var visualElement2 = visualElementRef.current;\n  useIsomorphicLayoutEffect(function() {\n    if (!visualElement2)\n      return;\n    visualElement2.setProps(__assign(__assign(__assign({}, config), props), { layoutId }));\n    visualElement2.isPresent = isPresent(presenceContext);\n    visualElement2.isPresenceRoot = !parent || parent.presenceId !== (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id);\n    visualElement2.syncRender();\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    var _a;\n    if (!visualElement2)\n      return;\n    (_a = visualElement2.animationState) === null || _a === void 0 ? void 0 : _a.animateChanges();\n  });\n  useIsomorphicLayoutEffect(function() {\n    return function() {\n      return visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.notifyUnmount();\n    };\n  }, []);\n  return visualElement2;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.js\n\n\n// ../../node_modules/framer-motion/dist/es/utils/is-ref-object.js\nfunction isRefObject(ref) {\n  return typeof ref === \"object\" && Object.prototype.hasOwnProperty.call(ref, \"current\");\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.js\nfunction useMotionRef(visualState, visualElement2, externalRef) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(instance) {\n    var _a;\n    instance && ((_a = visualState.mount) === null || _a === void 0 ? void 0 : _a.call(visualState, instance));\n    if (visualElement2) {\n      instance ? visualElement2.mount(instance) : visualElement2.unmount();\n    }\n    if (externalRef) {\n      if (typeof externalRef === \"function\") {\n        externalRef(instance);\n      } else if (isRefObject(externalRef)) {\n        externalRef.current = instance;\n      }\n    }\n  }, [visualElement2]);\n}\n\n// ../../node_modules/framer-motion/dist/es/context/MotionContext/create.js\n\n\n// ../../node_modules/framer-motion/dist/es/render/utils/variants.js\nfunction isVariantLabels(v) {\n  return Array.isArray(v);\n}\nfunction isVariantLabel(v) {\n  return typeof v === \"string\" || isVariantLabels(v);\n}\nfunction getCurrent(visualElement2) {\n  var current = {};\n  visualElement2.forEachValue(function(value, key6) {\n    return current[key6] = value.get();\n  });\n  return current;\n}\nfunction getVelocity(visualElement2) {\n  var velocity = {};\n  visualElement2.forEachValue(function(value, key6) {\n    return velocity[key6] = value.getVelocity();\n  });\n  return velocity;\n}\nfunction resolveVariantFromProps(props, definition, custom, currentValues, currentVelocity) {\n  var _a;\n  if (currentValues === void 0) {\n    currentValues = {};\n  }\n  if (currentVelocity === void 0) {\n    currentVelocity = {};\n  }\n  if (typeof definition === \"string\") {\n    definition = (_a = props.variants) === null || _a === void 0 ? void 0 : _a[definition];\n  }\n  return typeof definition === \"function\" ? definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity) : definition;\n}\nfunction resolveVariant(visualElement2, definition, custom) {\n  var props = visualElement2.getProps();\n  return resolveVariantFromProps(props, definition, custom !== null && custom !== void 0 ? custom : props.custom, getCurrent(visualElement2), getVelocity(visualElement2));\n}\nfunction checkIfControllingVariants(props) {\n  var _a;\n  return typeof ((_a = props.animate) === null || _a === void 0 ? void 0 : _a.start) === \"function\" || isVariantLabel(props.initial) || isVariantLabel(props.animate) || isVariantLabel(props.whileHover) || isVariantLabel(props.whileDrag) || isVariantLabel(props.whileTap) || isVariantLabel(props.whileFocus) || isVariantLabel(props.exit);\n}\nfunction checkIfVariantNode(props) {\n  return Boolean(checkIfControllingVariants(props) || props.variants);\n}\n\n// ../../node_modules/framer-motion/dist/es/context/MotionContext/utils.js\nfunction getCurrentTreeVariants(props, context) {\n  if (checkIfControllingVariants(props)) {\n    var initial = props.initial, animate4 = props.animate;\n    return {\n      initial: initial === false || isVariantLabel(initial) ? initial : void 0,\n      animate: isVariantLabel(animate4) ? animate4 : void 0\n    };\n  }\n  return props.inherit !== false ? context : {};\n}\n\n// ../../node_modules/framer-motion/dist/es/context/MotionContext/create.js\nfunction useCreateMotionContext(props, isStatic) {\n  var _a = getCurrentTreeVariants(props, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MotionContext)), initial = _a.initial, animate4 = _a.animate;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function() {\n    return { initial, animate: animate4 };\n  }, isStatic ? [\n    variantLabelsAsDependency(initial),\n    variantLabelsAsDependency(animate4)\n  ] : []);\n}\nfunction variantLabelsAsDependency(prop) {\n  return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/index.js\nfunction createMotionComponent(_a) {\n  var preloadedFeatures = _a.preloadedFeatures, createVisualElement = _a.createVisualElement, useRender = _a.useRender, useVisualState2 = _a.useVisualState, Component19 = _a.Component;\n  preloadedFeatures && loadFeatures(preloadedFeatures);\n  function MotionComponent(props, externalRef) {\n    var isStatic = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MotionConfigContext).isStatic;\n    var features = null;\n    var context = useCreateMotionContext(props, isStatic);\n    var visualState = useVisualState2(props, isStatic);\n    if (!isStatic && isBrowser) {\n      context.visualElement = useVisualElement(Component19, visualState, props, createVisualElement);\n      features = useFeatures(props, context.visualElement, preloadedFeatures);\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(MotionContext.Provider, { value: context }, useRender(Component19, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic)), features);\n  }\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(MotionComponent);\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/motion-proxy.js\nfunction createMotionProxy(createConfig) {\n  function custom(Component19, customMotionComponentConfig) {\n    if (customMotionComponentConfig === void 0) {\n      customMotionComponentConfig = {};\n    }\n    return createMotionComponent(createConfig(Component19, customMotionComponentConfig));\n  }\n  var componentCache = new Map();\n  return new Proxy(custom, {\n    get: function(_target, key6) {\n      if (!componentCache.has(key6)) {\n        componentCache.set(key6, custom(key6));\n      }\n      return componentCache.get(key6);\n    }\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/lowercase-elements.js\nvar lowercaseSVGElements = [\n  \"animate\",\n  \"circle\",\n  \"defs\",\n  \"desc\",\n  \"ellipse\",\n  \"g\",\n  \"image\",\n  \"line\",\n  \"filter\",\n  \"marker\",\n  \"mask\",\n  \"metadata\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"rect\",\n  \"stop\",\n  \"svg\",\n  \"switch\",\n  \"symbol\",\n  \"text\",\n  \"tspan\",\n  \"use\",\n  \"view\"\n];\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.js\nfunction isSVGComponent(Component19) {\n  if (typeof Component19 !== \"string\" || Component19.includes(\"-\")) {\n    return false;\n  } else if (lowercaseSVGElements.indexOf(Component19) > -1 || /[A-Z]/.test(Component19)) {\n    return true;\n  }\n  return false;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/use-render.js\n\n\n// ../../node_modules/framer-motion/dist/es/render/html/use-props.js\n\n\n// ../../node_modules/framer-motion/dist/es/render/dom/projection/scale-correction.js\nvar valueScaleCorrection = {};\nfunction addScaleCorrection(correctors) {\n  for (var key6 in correctors) {\n    valueScaleCorrection[key6] = correctors[key6];\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/transform.js\nvar transformAxes = [\"\", \"X\", \"Y\", \"Z\"];\nvar order = [\"translate\", \"scale\", \"rotate\", \"skew\"];\nvar transformProps = [\"transformPerspective\", \"x\", \"y\", \"z\"];\norder.forEach(function(operationKey) {\n  return transformAxes.forEach(function(axesKey) {\n    return transformProps.push(operationKey + axesKey);\n  });\n});\nfunction sortTransformProps(a2, b2) {\n  return transformProps.indexOf(a2) - transformProps.indexOf(b2);\n}\nvar transformPropSet = new Set(transformProps);\nfunction isTransformProp(key6) {\n  return transformPropSet.has(key6);\n}\nvar transformOriginProps = new Set([\"originX\", \"originY\", \"originZ\"]);\nfunction isTransformOriginProp(key6) {\n  return transformOriginProps.has(key6);\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.js\nfunction isForcedMotionValue(key6, _a) {\n  var layout = _a.layout, layoutId = _a.layoutId;\n  return isTransformProp(key6) || isTransformOriginProp(key6) || (layout || layoutId !== void 0) && (!!valueScaleCorrection[key6] || key6 === \"opacity\");\n}\n\n// ../../node_modules/framer-motion/dist/es/value/utils/is-motion-value.js\nvar isMotionValue = function(value) {\n  return value !== null && typeof value === \"object\" && value.getVelocity;\n};\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/build-transform.js\nvar translateAlias = {\n  x: \"translateX\",\n  y: \"translateY\",\n  z: \"translateZ\",\n  transformPerspective: \"perspective\"\n};\nfunction buildTransform(_a, _b, transformIsDefault, transformTemplate2) {\n  var transform2 = _a.transform, transformKeys2 = _a.transformKeys;\n  var _c = _b.enableHardwareAcceleration, enableHardwareAcceleration = _c === void 0 ? true : _c, _d = _b.allowTransformNone, allowTransformNone = _d === void 0 ? true : _d;\n  var transformString2 = \"\";\n  transformKeys2.sort(sortTransformProps);\n  var transformHasZ = false;\n  var numTransformKeys = transformKeys2.length;\n  for (var i = 0; i < numTransformKeys; i++) {\n    var key6 = transformKeys2[i];\n    transformString2 += (translateAlias[key6] || key6) + \"(\" + transform2[key6] + \") \";\n    if (key6 === \"z\")\n      transformHasZ = true;\n  }\n  if (!transformHasZ && enableHardwareAcceleration) {\n    transformString2 += \"translateZ(0)\";\n  } else {\n    transformString2 = transformString2.trim();\n  }\n  if (transformTemplate2) {\n    transformString2 = transformTemplate2(transform2, transformIsDefault ? \"\" : transformString2);\n  } else if (allowTransformNone && transformIsDefault) {\n    transformString2 = \"none\";\n  }\n  return transformString2;\n}\nfunction buildTransformOrigin(_a) {\n  var _b = _a.originX, originX = _b === void 0 ? \"50%\" : _b, _c = _a.originY, originY = _c === void 0 ? \"50%\" : _c, _d = _a.originZ, originZ = _d === void 0 ? 0 : _d;\n  return originX + \" \" + originY + \" \" + originZ;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.js\nfunction isCSSVariable(key6) {\n  return key6.startsWith(\"--\");\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.js\nvar getValueAsType = function(value, type) {\n  return type && typeof value === \"number\" ? type.transform(value) : value;\n};\n\n// ../../node_modules/style-value-types/dist/es/utils.js\nvar clamp = function(min, max) {\n  return function(v) {\n    return Math.max(Math.min(v, max), min);\n  };\n};\nvar sanitize = function(v) {\n  return v % 1 ? Number(v.toFixed(5)) : v;\n};\nvar floatRegex = /(-)?([\\d]*\\.?[\\d])+/g;\nvar colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2,3}\\s*\\/*\\s*[\\d\\.]+%?\\))/gi;\nvar singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2,3}\\s*\\/*\\s*[\\d\\.]+%?\\))$/i;\nfunction isString(v) {\n  return typeof v === \"string\";\n}\n\n// ../../node_modules/style-value-types/dist/es/numbers/index.js\nvar number = {\n  test: function(v) {\n    return typeof v === \"number\";\n  },\n  parse: parseFloat,\n  transform: function(v) {\n    return v;\n  }\n};\nvar alpha = __assign(__assign({}, number), { transform: clamp(0, 1) });\nvar scale = __assign(__assign({}, number), { default: 1 });\n\n// ../../node_modules/style-value-types/dist/es/numbers/units.js\nvar createUnitType = function(unit) {\n  return {\n    test: function(v) {\n      return isString(v) && v.endsWith(unit) && v.split(\" \").length === 1;\n    },\n    parse: parseFloat,\n    transform: function(v) {\n      return \"\" + v + unit;\n    }\n  };\n};\nvar degrees = createUnitType(\"deg\");\nvar percent = createUnitType(\"%\");\nvar px = createUnitType(\"px\");\nvar vh = createUnitType(\"vh\");\nvar vw = createUnitType(\"vw\");\nvar progressPercentage = __assign(__assign({}, percent), { parse: function(v) {\n  return percent.parse(v) / 100;\n}, transform: function(v) {\n  return percent.transform(v * 100);\n} });\n\n// ../../node_modules/style-value-types/dist/es/color/utils.js\nvar isColorString = function(type, testProp) {\n  return function(v) {\n    return Boolean(isString(v) && singleColorRegex.test(v) && v.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v, testProp));\n  };\n};\nvar splitColor = function(aName, bName, cName) {\n  return function(v) {\n    var _a;\n    if (!isString(v))\n      return v;\n    var _b = v.match(floatRegex), a2 = _b[0], b2 = _b[1], c2 = _b[2], alpha2 = _b[3];\n    return _a = {}, _a[aName] = parseFloat(a2), _a[bName] = parseFloat(b2), _a[cName] = parseFloat(c2), _a.alpha = alpha2 !== void 0 ? parseFloat(alpha2) : 1, _a;\n  };\n};\n\n// ../../node_modules/style-value-types/dist/es/color/hsla.js\nvar hsla = {\n  test: isColorString(\"hsl\", \"hue\"),\n  parse: splitColor(\"hue\", \"saturation\", \"lightness\"),\n  transform: function(_a) {\n    var hue = _a.hue, saturation = _a.saturation, lightness = _a.lightness, _b = _a.alpha, alpha$1 = _b === void 0 ? 1 : _b;\n    return \"hsla(\" + Math.round(hue) + \", \" + percent.transform(sanitize(saturation)) + \", \" + percent.transform(sanitize(lightness)) + \", \" + sanitize(alpha.transform(alpha$1)) + \")\";\n  }\n};\n\n// ../../node_modules/style-value-types/dist/es/color/rgba.js\nvar clampRgbUnit = clamp(0, 255);\nvar rgbUnit = __assign(__assign({}, number), { transform: function(v) {\n  return Math.round(clampRgbUnit(v));\n} });\nvar rgba = {\n  test: isColorString(\"rgb\", \"red\"),\n  parse: splitColor(\"red\", \"green\", \"blue\"),\n  transform: function(_a) {\n    var red = _a.red, green = _a.green, blue = _a.blue, _b = _a.alpha, alpha$1 = _b === void 0 ? 1 : _b;\n    return \"rgba(\" + rgbUnit.transform(red) + \", \" + rgbUnit.transform(green) + \", \" + rgbUnit.transform(blue) + \", \" + sanitize(alpha.transform(alpha$1)) + \")\";\n  }\n};\n\n// ../../node_modules/style-value-types/dist/es/color/hex.js\nfunction parseHex(v) {\n  var r = \"\";\n  var g = \"\";\n  var b2 = \"\";\n  var a2 = \"\";\n  if (v.length > 5) {\n    r = v.substr(1, 2);\n    g = v.substr(3, 2);\n    b2 = v.substr(5, 2);\n    a2 = v.substr(7, 2);\n  } else {\n    r = v.substr(1, 1);\n    g = v.substr(2, 1);\n    b2 = v.substr(3, 1);\n    a2 = v.substr(4, 1);\n    r += r;\n    g += g;\n    b2 += b2;\n    a2 += a2;\n  }\n  return {\n    red: parseInt(r, 16),\n    green: parseInt(g, 16),\n    blue: parseInt(b2, 16),\n    alpha: a2 ? parseInt(a2, 16) / 255 : 1\n  };\n}\nvar hex = {\n  test: isColorString(\"#\"),\n  parse: parseHex,\n  transform: rgba.transform\n};\n\n// ../../node_modules/style-value-types/dist/es/color/index.js\nvar color = {\n  test: function(v) {\n    return rgba.test(v) || hex.test(v) || hsla.test(v);\n  },\n  parse: function(v) {\n    if (rgba.test(v)) {\n      return rgba.parse(v);\n    } else if (hsla.test(v)) {\n      return hsla.parse(v);\n    } else {\n      return hex.parse(v);\n    }\n  },\n  transform: function(v) {\n    return isString(v) ? v : v.hasOwnProperty(\"red\") ? rgba.transform(v) : hsla.transform(v);\n  }\n};\n\n// ../../node_modules/style-value-types/dist/es/complex/index.js\nvar colorToken = \"${c}\";\nvar numberToken = \"${n}\";\nfunction test(v) {\n  var _a, _b, _c, _d;\n  return isNaN(v) && isString(v) && ((_b = (_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = v.match(colorRegex)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0;\n}\nfunction analyse(v) {\n  var values = [];\n  var numColors = 0;\n  var colors = v.match(colorRegex);\n  if (colors) {\n    numColors = colors.length;\n    v = v.replace(colorRegex, colorToken);\n    values.push.apply(values, colors.map(color.parse));\n  }\n  var numbers = v.match(floatRegex);\n  if (numbers) {\n    v = v.replace(floatRegex, numberToken);\n    values.push.apply(values, numbers.map(number.parse));\n  }\n  return { values, numColors, tokenised: v };\n}\nfunction parse(v) {\n  return analyse(v).values;\n}\nfunction createTransformer(v) {\n  var _a = analyse(v), values = _a.values, numColors = _a.numColors, tokenised = _a.tokenised;\n  var numValues = values.length;\n  return function(v2) {\n    var output = tokenised;\n    for (var i = 0; i < numValues; i++) {\n      output = output.replace(i < numColors ? colorToken : numberToken, i < numColors ? color.transform(v2[i]) : sanitize(v2[i]));\n    }\n    return output;\n  };\n}\nvar convertNumbersToZero = function(v) {\n  return typeof v === \"number\" ? 0 : v;\n};\nfunction getAnimatableNone(v) {\n  var parsed = parse(v);\n  var transformer = createTransformer(v);\n  return transformer(parsed.map(convertNumbersToZero));\n}\nvar complex = { test, parse, createTransformer, getAnimatableNone };\n\n// ../../node_modules/style-value-types/dist/es/complex/filter.js\nvar maxDefaults = new Set([\"brightness\", \"contrast\", \"saturate\", \"opacity\"]);\nfunction applyDefaultFilter(v) {\n  var _a = v.slice(0, -1).split(\"(\"), name = _a[0], value = _a[1];\n  if (name === \"drop-shadow\")\n    return v;\n  var number2 = (value.match(floatRegex) || [])[0];\n  if (!number2)\n    return v;\n  var unit = value.replace(number2, \"\");\n  var defaultValue = maxDefaults.has(name) ? 1 : 0;\n  if (number2 !== value)\n    defaultValue *= 100;\n  return name + \"(\" + defaultValue + unit + \")\";\n}\nvar functionRegex = /([a-z-]*)\\(.*?\\)/g;\nvar filter = __assign(__assign({}, complex), { getAnimatableNone: function(v) {\n  var functions = v.match(functionRegex);\n  return functions ? functions.map(applyDefaultFilter).join(\" \") : v;\n} });\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/type-int.js\nvar int = __assign(__assign({}, number), { transform: Math.round });\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/number.js\nvar numberValueTypes = {\n  borderWidth: px,\n  borderTopWidth: px,\n  borderRightWidth: px,\n  borderBottomWidth: px,\n  borderLeftWidth: px,\n  borderRadius: px,\n  radius: px,\n  borderTopLeftRadius: px,\n  borderTopRightRadius: px,\n  borderBottomRightRadius: px,\n  borderBottomLeftRadius: px,\n  width: px,\n  maxWidth: px,\n  height: px,\n  maxHeight: px,\n  size: px,\n  top: px,\n  right: px,\n  bottom: px,\n  left: px,\n  padding: px,\n  paddingTop: px,\n  paddingRight: px,\n  paddingBottom: px,\n  paddingLeft: px,\n  margin: px,\n  marginTop: px,\n  marginRight: px,\n  marginBottom: px,\n  marginLeft: px,\n  rotate: degrees,\n  rotateX: degrees,\n  rotateY: degrees,\n  rotateZ: degrees,\n  scale,\n  scaleX: scale,\n  scaleY: scale,\n  scaleZ: scale,\n  skew: degrees,\n  skewX: degrees,\n  skewY: degrees,\n  distance: px,\n  translateX: px,\n  translateY: px,\n  translateZ: px,\n  x: px,\n  y: px,\n  z: px,\n  perspective: px,\n  transformPerspective: px,\n  opacity: __assign(__assign({}, alpha), { default: 1 }),\n  originX: progressPercentage,\n  originY: progressPercentage,\n  originZ: px,\n  zIndex: int,\n  fillOpacity: alpha,\n  strokeOpacity: alpha,\n  numOctaves: int\n};\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/build-styles.js\nfunction buildHTMLStyles(state, latestValues, projection, layoutState, options, transformTemplate2, buildProjectionTransform, buildProjectionTransformOrigin) {\n  var _a;\n  var style = state.style, vars = state.vars, transform2 = state.transform, transformKeys2 = state.transformKeys, transformOrigin = state.transformOrigin;\n  transformKeys2.length = 0;\n  var hasTransform = false;\n  var hasTransformOrigin = false;\n  var transformIsNone = true;\n  for (var key6 in latestValues) {\n    var value = latestValues[key6];\n    if (isCSSVariable(key6)) {\n      vars[key6] = value;\n      continue;\n    }\n    var valueType = numberValueTypes[key6];\n    var valueAsType = getValueAsType(value, valueType);\n    if (isTransformProp(key6)) {\n      hasTransform = true;\n      transform2[key6] = valueAsType;\n      transformKeys2.push(key6);\n      if (!transformIsNone)\n        continue;\n      if (value !== ((_a = valueType.default) !== null && _a !== void 0 ? _a : 0))\n        transformIsNone = false;\n    } else if (isTransformOriginProp(key6)) {\n      transformOrigin[key6] = valueAsType;\n      hasTransformOrigin = true;\n    } else {\n      if (layoutState && projection && layoutState.isHydrated && valueScaleCorrection[key6]) {\n        var correctedValue = valueScaleCorrection[key6].process(value, layoutState, projection);\n        var applyTo = valueScaleCorrection[key6].applyTo;\n        if (applyTo) {\n          var num = applyTo.length;\n          for (var i = 0; i < num; i++) {\n            style[applyTo[i]] = correctedValue;\n          }\n        } else {\n          style[key6] = correctedValue;\n        }\n      } else {\n        style[key6] = valueAsType;\n      }\n    }\n  }\n  if (layoutState && projection && buildProjectionTransform && buildProjectionTransformOrigin) {\n    style.transform = buildProjectionTransform(layoutState.deltaFinal, layoutState.treeScale, hasTransform ? transform2 : void 0);\n    if (transformTemplate2) {\n      style.transform = transformTemplate2(transform2, style.transform);\n    }\n    style.transformOrigin = buildProjectionTransformOrigin(layoutState);\n  } else {\n    if (hasTransform) {\n      style.transform = buildTransform(state, options, transformIsNone, transformTemplate2);\n    }\n    if (hasTransformOrigin) {\n      style.transformOrigin = buildTransformOrigin(transformOrigin);\n    }\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/create-render-state.js\nvar createHtmlRenderState = function() {\n  return {\n    style: {},\n    transform: {},\n    transformKeys: [],\n    transformOrigin: {},\n    vars: {}\n  };\n};\n\n// ../../node_modules/framer-motion/dist/es/render/html/use-props.js\nfunction copyRawValuesOnly(target, source, props) {\n  for (var key6 in source) {\n    if (!isMotionValue(source[key6]) && !isForcedMotionValue(key6, props)) {\n      target[key6] = source[key6];\n    }\n  }\n}\nfunction useInitialMotionValues(_a, visualState, isStatic) {\n  var transformTemplate2 = _a.transformTemplate;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function() {\n    var state = createHtmlRenderState();\n    buildHTMLStyles(state, visualState, void 0, void 0, { enableHardwareAcceleration: !isStatic }, transformTemplate2);\n    var vars = state.vars, style = state.style;\n    return __assign(__assign({}, vars), style);\n  }, [visualState]);\n}\nfunction useStyle(props, visualState, isStatic) {\n  var styleProp = props.style || {};\n  var style = {};\n  copyRawValuesOnly(style, styleProp, props);\n  Object.assign(style, useInitialMotionValues(props, visualState, isStatic));\n  if (props.transformValues) {\n    style = props.transformValues(style);\n  }\n  return style;\n}\nfunction useHTMLProps(props, visualState, isStatic) {\n  var htmlProps = {};\n  var style = useStyle(props, visualState, isStatic);\n  if (Boolean(props.drag)) {\n    htmlProps.draggable = false;\n    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = \"none\";\n    style.touchAction = props.drag === true ? \"none\" : \"pan-\" + (props.drag === \"x\" ? \"y\" : \"x\");\n  }\n  htmlProps.style = style;\n  return htmlProps;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/valid-prop.js\nvar validMotionProps = new Set([\n  \"initial\",\n  \"animate\",\n  \"exit\",\n  \"style\",\n  \"variants\",\n  \"transition\",\n  \"transformTemplate\",\n  \"transformValues\",\n  \"custom\",\n  \"inherit\",\n  \"layout\",\n  \"layoutId\",\n  \"_layoutResetTransform\",\n  \"onLayoutAnimationComplete\",\n  \"onViewportBoxUpdate\",\n  \"onLayoutMeasure\",\n  \"onBeforeLayoutMeasure\",\n  \"onAnimationStart\",\n  \"onAnimationComplete\",\n  \"onUpdate\",\n  \"onDragStart\",\n  \"onDrag\",\n  \"onDragEnd\",\n  \"onMeasureDragConstraints\",\n  \"onDirectionLock\",\n  \"onDragTransitionEnd\",\n  \"drag\",\n  \"dragControls\",\n  \"dragListener\",\n  \"dragConstraints\",\n  \"dragDirectionLock\",\n  \"_dragX\",\n  \"_dragY\",\n  \"dragElastic\",\n  \"dragMomentum\",\n  \"dragPropagation\",\n  \"dragTransition\",\n  \"whileDrag\",\n  \"onPan\",\n  \"onPanStart\",\n  \"onPanEnd\",\n  \"onPanSessionStart\",\n  \"onTap\",\n  \"onTapStart\",\n  \"onTapCancel\",\n  \"onHoverStart\",\n  \"onHoverEnd\",\n  \"whileFocus\",\n  \"whileTap\",\n  \"whileHover\"\n]);\nfunction isValidMotionProp(key6) {\n  return validMotionProps.has(key6);\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/filter-props.js\nvar shouldForward = function(key6) {\n  return !isValidMotionProp(key6);\n};\ntry {\n  emotionIsPropValid_1 = require_is_prop_valid_browser_cjs().default;\n  shouldForward = function(key6) {\n    if (key6.startsWith(\"on\")) {\n      return !isValidMotionProp(key6);\n    } else {\n      return emotionIsPropValid_1(key6);\n    }\n  };\n} catch (_a) {\n}\nvar emotionIsPropValid_1;\nfunction filterProps(props, isDom, forwardMotionProps) {\n  var filteredProps2 = {};\n  for (var key6 in props) {\n    if (shouldForward(key6) || forwardMotionProps === true && isValidMotionProp(key6) || !isDom && !isValidMotionProp(key6)) {\n      filteredProps2[key6] = props[key6];\n    }\n  }\n  return filteredProps2;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/use-props.js\n\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.js\nfunction calcOrigin(origin, offset, size2) {\n  return typeof origin === \"string\" ? origin : px.transform(offset + size2 * origin);\n}\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n  var pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);\n  var pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);\n  return pxOriginX + \" \" + pxOriginY;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/path.js\nvar progressToPixels = function(progress2, length) {\n  return px.transform(progress2 * length);\n};\nvar dashKeys = {\n  offset: \"stroke-dashoffset\",\n  array: \"stroke-dasharray\"\n};\nvar camelKeys = {\n  offset: \"strokeDashoffset\",\n  array: \"strokeDasharray\"\n};\nfunction buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {\n  if (spacing === void 0) {\n    spacing = 1;\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  if (useDashCase === void 0) {\n    useDashCase = true;\n  }\n  var keys2 = useDashCase ? dashKeys : camelKeys;\n  attrs[keys2.offset] = progressToPixels(-offset, totalLength);\n  var pathLength = progressToPixels(length, totalLength);\n  var pathSpacing = progressToPixels(spacing, totalLength);\n  attrs[keys2.array] = pathLength + \" \" + pathSpacing;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.js\nfunction buildSVGAttrs(state, _a, projection, layoutState, options, transformTemplate2, buildProjectionTransform, buildProjectionTransformOrigin) {\n  var attrX = _a.attrX, attrY = _a.attrY, originX = _a.originX, originY = _a.originY, pathLength = _a.pathLength, _b = _a.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a.pathOffset, pathOffset = _c === void 0 ? 0 : _c, latest = __rest(_a, [\"attrX\", \"attrY\", \"originX\", \"originY\", \"pathLength\", \"pathSpacing\", \"pathOffset\"]);\n  buildHTMLStyles(state, latest, projection, layoutState, options, transformTemplate2, buildProjectionTransform, buildProjectionTransformOrigin);\n  state.attrs = state.style;\n  state.style = {};\n  var attrs = state.attrs, style = state.style, dimensions = state.dimensions, totalPathLength = state.totalPathLength;\n  if (attrs.transform) {\n    if (dimensions)\n      style.transform = attrs.transform;\n    delete attrs.transform;\n  }\n  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {\n    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);\n  }\n  if (attrX !== void 0)\n    attrs.x = attrX;\n  if (attrY !== void 0)\n    attrs.y = attrY;\n  if (totalPathLength !== void 0 && pathLength !== void 0) {\n    buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.js\nvar createSvgRenderState = function() {\n  return __assign(__assign({}, createHtmlRenderState()), { attrs: {} });\n};\n\n// ../../node_modules/framer-motion/dist/es/render/svg/use-props.js\nfunction useSVGProps(props, visualState) {\n  var visualProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function() {\n    var state = createSvgRenderState();\n    buildSVGAttrs(state, visualState, void 0, void 0, { enableHardwareAcceleration: false }, props.transformTemplate);\n    return __assign(__assign({}, state.attrs), { style: __assign({}, state.style) });\n  }, [visualState]);\n  if (props.style) {\n    var rawStyles = {};\n    copyRawValuesOnly(rawStyles, props.style, props);\n    visualProps.style = __assign(__assign({}, rawStyles), visualProps.style);\n  }\n  return visualProps;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/use-render.js\nfunction createUseRender(forwardMotionProps) {\n  if (forwardMotionProps === void 0) {\n    forwardMotionProps = false;\n  }\n  var useRender = function(Component19, props, ref, _a, isStatic) {\n    var latestValues = _a.latestValues;\n    var useVisualProps = isSVGComponent(Component19) ? useSVGProps : useHTMLProps;\n    var visualProps = useVisualProps(props, latestValues, isStatic);\n    var filteredProps2 = filterProps(props, typeof Component19 === \"string\", forwardMotionProps);\n    var elementProps = __assign(__assign(__assign({}, filteredProps2), visualProps), { ref });\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Component19, elementProps);\n  };\n  return useRender;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.js\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\nvar REPLACE_TEMPLATE = \"$1-$2\";\nvar camelToDash = function(str) {\n  return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\n};\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/render.js\nfunction renderHTML(element, _a) {\n  var style = _a.style, vars = _a.vars;\n  Object.assign(element.style, style);\n  for (var key6 in vars) {\n    element.style.setProperty(key6, vars[key6]);\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.js\nvar camelCaseAttributes = new Set([\n  \"baseFrequency\",\n  \"diffuseConstant\",\n  \"kernelMatrix\",\n  \"kernelUnitLength\",\n  \"keySplines\",\n  \"keyTimes\",\n  \"limitingConeAngle\",\n  \"markerHeight\",\n  \"markerWidth\",\n  \"numOctaves\",\n  \"targetX\",\n  \"targetY\",\n  \"surfaceScale\",\n  \"specularConstant\",\n  \"specularExponent\",\n  \"stdDeviation\",\n  \"tableValues\",\n  \"viewBox\"\n]);\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/render.js\nfunction renderSVG(element, renderState) {\n  renderHTML(element, renderState);\n  for (var key6 in renderState.attrs) {\n    element.setAttribute(!camelCaseAttributes.has(key6) ? camelToDash(key6) : key6, renderState.attrs[key6]);\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.js\nfunction scrapeMotionValuesFromProps(props) {\n  var style = props.style;\n  var newValues = {};\n  for (var key6 in style) {\n    if (isMotionValue(style[key6]) || isForcedMotionValue(key6, props)) {\n      newValues[key6] = style[key6];\n    }\n  }\n  return newValues;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.js\nfunction scrapeMotionValuesFromProps2(props) {\n  var newValues = scrapeMotionValuesFromProps(props);\n  for (var key6 in props) {\n    if (isMotionValue(props[key6])) {\n      var targetKey = key6 === \"x\" || key6 === \"y\" ? \"attr\" + key6.toUpperCase() : key6;\n      newValues[targetKey] = props[key6];\n    }\n  }\n  return newValues;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-state.js\n\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.js\nfunction isAnimationControls(v) {\n  return typeof v === \"object\" && typeof v.start === \"function\";\n}\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.js\nvar isKeyframesTarget = function(v) {\n  return Array.isArray(v);\n};\n\n// ../../node_modules/framer-motion/dist/es/utils/resolve-value.js\nvar isCustomValue = function(v) {\n  return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nvar resolveFinalValueInKeyframes = function(v) {\n  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n\n// ../../node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.js\nfunction resolveMotionValue(value) {\n  var unwrappedValue = isMotionValue(value) ? value.get() : value;\n  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/use-visual-state.js\nfunction makeState(_a, props, context, presenceContext) {\n  var scrapeMotionValuesFromProps3 = _a.scrapeMotionValuesFromProps, createRenderState = _a.createRenderState, onMount = _a.onMount;\n  var state = {\n    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),\n    renderState: createRenderState()\n  };\n  if (onMount) {\n    state.mount = function(instance) {\n      return onMount(props, instance, state);\n    };\n  }\n  return state;\n}\nvar makeUseVisualState = function(config) {\n  return function(props, isStatic) {\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MotionContext);\n    var presenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PresenceContext);\n    return isStatic ? makeState(config, props, context, presenceContext) : useConstant(function() {\n      return makeState(config, props, context, presenceContext);\n    });\n  };\n};\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n  var values = {};\n  var blockInitialAnimation = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false;\n  var motionValues = scrapeMotionValues(props);\n  for (var key6 in motionValues) {\n    values[key6] = resolveMotionValue(motionValues[key6]);\n  }\n  var initial = props.initial, animate4 = props.animate;\n  var isControllingVariants = checkIfControllingVariants(props);\n  var isVariantNode = checkIfVariantNode(props);\n  if (context && isVariantNode && !isControllingVariants && props.inherit !== false) {\n    initial !== null && initial !== void 0 ? initial : initial = context.initial;\n    animate4 !== null && animate4 !== void 0 ? animate4 : animate4 = context.animate;\n  }\n  var variantToSet = blockInitialAnimation || initial === false ? animate4 : initial;\n  if (variantToSet && typeof variantToSet !== \"boolean\" && !isAnimationControls(variantToSet)) {\n    var list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n    list.forEach(function(definition) {\n      var resolved = resolveVariantFromProps(props, definition);\n      if (!resolved)\n        return;\n      var transitionEnd = resolved.transitionEnd;\n      resolved.transition;\n      var target = __rest(resolved, [\"transitionEnd\", \"transition\"]);\n      for (var key7 in target)\n        values[key7] = target[key7];\n      for (var key7 in transitionEnd)\n        values[key7] = transitionEnd[key7];\n    });\n  }\n  return values;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/svg/config-motion.js\nvar svgMotionConfig = {\n  useVisualState: makeUseVisualState({\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,\n    createRenderState: createSvgRenderState,\n    onMount: function(props, instance, _a) {\n      var renderState = _a.renderState, latestValues = _a.latestValues;\n      try {\n        renderState.dimensions = typeof instance.getBBox === \"function\" ? instance.getBBox() : instance.getBoundingClientRect();\n      } catch (e) {\n        renderState.dimensions = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n      if (isPath(instance)) {\n        renderState.totalPathLength = instance.getTotalLength();\n      }\n      buildSVGAttrs(renderState, latestValues, void 0, void 0, { enableHardwareAcceleration: false }, props.transformTemplate);\n      renderSVG(instance, renderState);\n    }\n  })\n};\nfunction isPath(element) {\n  return element.tagName === \"path\";\n}\n\n// ../../node_modules/framer-motion/dist/es/render/html/config-motion.js\nvar htmlMotionConfig = {\n  useVisualState: makeUseVisualState({\n    scrapeMotionValuesFromProps,\n    createRenderState: createHtmlRenderState\n  })\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/create-config.js\nfunction createDomMotionConfig(Component19, _a, preloadedFeatures, createVisualElement) {\n  var _b = _a.forwardMotionProps, forwardMotionProps = _b === void 0 ? false : _b;\n  var baseConfig = isSVGComponent(Component19) ? svgMotionConfig : htmlMotionConfig;\n  return __assign(__assign({}, baseConfig), {\n    preloadedFeatures,\n    useRender: createUseRender(forwardMotionProps),\n    createVisualElement,\n    Component: Component19\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/types.js\nvar AnimationType;\n(function(AnimationType2) {\n  AnimationType2[\"Animate\"] = \"animate\";\n  AnimationType2[\"Hover\"] = \"whileHover\";\n  AnimationType2[\"Tap\"] = \"whileTap\";\n  AnimationType2[\"Drag\"] = \"whileDrag\";\n  AnimationType2[\"Focus\"] = \"whileFocus\";\n  AnimationType2[\"Exit\"] = \"exit\";\n})(AnimationType || (AnimationType = {}));\n\n// ../../node_modules/framer-motion/dist/es/events/use-dom-event.js\n\nfunction addDomEvent(target, eventName, handler, options) {\n  target.addEventListener(eventName, handler, options);\n  return function() {\n    return target.removeEventListener(eventName, handler, options);\n  };\n}\nfunction useDomEvent(ref, eventName, handler, options) {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    var element = ref.current;\n    if (handler && element) {\n      return addDomEvent(element, eventName, handler, options);\n    }\n  }, [ref, eventName, handler, options]);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-focus-gesture.js\nfunction useFocusGesture(_a) {\n  var whileFocus = _a.whileFocus, visualElement2 = _a.visualElement;\n  var onFocus = function() {\n    var _a2;\n    (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Focus, true);\n  };\n  var onBlur = function() {\n    var _a2;\n    (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Focus, false);\n  };\n  useDomEvent(visualElement2, \"focus\", whileFocus ? onFocus : void 0);\n  useDomEvent(visualElement2, \"blur\", whileFocus ? onBlur : void 0);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/utils/event-type.js\nfunction isMouseEvent(event) {\n  if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n    return !!(event.pointerType === \"mouse\");\n  }\n  return event instanceof MouseEvent;\n}\nfunction isTouchEvent(event) {\n  var hasTouches = !!event.touches;\n  return hasTouches;\n}\n\n// ../../node_modules/framer-motion/dist/es/events/event-info.js\nfunction filterPrimaryPointer(eventHandler) {\n  return function(event) {\n    var isMouseEvent2 = event instanceof MouseEvent;\n    var isPrimaryPointer = !isMouseEvent2 || isMouseEvent2 && event.button === 0;\n    if (isPrimaryPointer) {\n      eventHandler(event);\n    }\n  };\n}\nvar defaultPagePoint = { pageX: 0, pageY: 0 };\nfunction pointFromTouch(e, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n  var primaryTouch = e.touches[0] || e.changedTouches[0];\n  var point = primaryTouch || defaultPagePoint;\n  return {\n    x: point[pointType + \"X\"],\n    y: point[pointType + \"Y\"]\n  };\n}\nfunction pointFromMouse(point, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n  return {\n    x: point[pointType + \"X\"],\n    y: point[pointType + \"Y\"]\n  };\n}\nfunction extractEventInfo(event, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n  return {\n    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)\n  };\n}\nfunction getViewportPointFromEvent(event) {\n  return extractEventInfo(event, \"client\");\n}\nvar wrapHandler = function(handler, shouldFilterPrimaryPointer) {\n  if (shouldFilterPrimaryPointer === void 0) {\n    shouldFilterPrimaryPointer = false;\n  }\n  var listener = function(event) {\n    return handler(event, extractEventInfo(event));\n  };\n  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;\n};\n\n// ../../node_modules/framer-motion/dist/es/events/utils.js\nvar supportsPointerEvents = function() {\n  return isBrowser && window.onpointerdown === null;\n};\nvar supportsTouchEvents = function() {\n  return isBrowser && window.ontouchstart === null;\n};\nvar supportsMouseEvents = function() {\n  return isBrowser && window.onmousedown === null;\n};\n\n// ../../node_modules/framer-motion/dist/es/events/use-pointer-event.js\nvar mouseEventNames = {\n  pointerdown: \"mousedown\",\n  pointermove: \"mousemove\",\n  pointerup: \"mouseup\",\n  pointercancel: \"mousecancel\",\n  pointerover: \"mouseover\",\n  pointerout: \"mouseout\",\n  pointerenter: \"mouseenter\",\n  pointerleave: \"mouseleave\"\n};\nvar touchEventNames = {\n  pointerdown: \"touchstart\",\n  pointermove: \"touchmove\",\n  pointerup: \"touchend\",\n  pointercancel: \"touchcancel\"\n};\nfunction getPointerEventName(name) {\n  if (supportsPointerEvents()) {\n    return name;\n  } else if (supportsTouchEvents()) {\n    return touchEventNames[name];\n  } else if (supportsMouseEvents()) {\n    return mouseEventNames[name];\n  }\n  return name;\n}\nfunction addPointerEvent(target, eventName, handler, options) {\n  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\nfunction usePointerEvent(ref, eventName, handler, options) {\n  return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/utils/lock.js\nfunction createLock(name) {\n  var lock = null;\n  return function() {\n    var openLock = function() {\n      lock = null;\n    };\n    if (lock === null) {\n      lock = name;\n      return openLock;\n    }\n    return false;\n  };\n}\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\nfunction getGlobalLock(drag2) {\n  var lock = false;\n  if (drag2 === \"y\") {\n    lock = globalVerticalLock();\n  } else if (drag2 === \"x\") {\n    lock = globalHorizontalLock();\n  } else {\n    var openHorizontal_1 = globalHorizontalLock();\n    var openVertical_1 = globalVerticalLock();\n    if (openHorizontal_1 && openVertical_1) {\n      lock = function() {\n        openHorizontal_1();\n        openVertical_1();\n      };\n    } else {\n      if (openHorizontal_1)\n        openHorizontal_1();\n      if (openVertical_1)\n        openVertical_1();\n    }\n  }\n  return lock;\n}\nfunction isDragActive() {\n  var openGestureLock = getGlobalLock(true);\n  if (!openGestureLock)\n    return true;\n  openGestureLock();\n  return false;\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-hover-gesture.js\nfunction createHoverEvent(visualElement2, isActive, callback) {\n  return function(event, info) {\n    var _a;\n    if (!isMouseEvent(event) || !visualElement2.isHoverEventsEnabled || isDragActive()) {\n      return;\n    }\n    callback === null || callback === void 0 ? void 0 : callback(event, info);\n    (_a = visualElement2.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Hover, isActive);\n  };\n}\nfunction useHoverGesture(_a) {\n  var onHoverStart = _a.onHoverStart, onHoverEnd = _a.onHoverEnd, whileHover = _a.whileHover, visualElement2 = _a.visualElement;\n  usePointerEvent(visualElement2, \"pointerenter\", onHoverStart || whileHover ? createHoverEvent(visualElement2, true, onHoverStart) : void 0);\n  usePointerEvent(visualElement2, \"pointerleave\", onHoverEnd || whileHover ? createHoverEvent(visualElement2, false, onHoverEnd) : void 0);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-tap-gesture.js\n\n\n// ../../node_modules/framer-motion/dist/es/gestures/utils/is-node-or-child.js\nvar isNodeOrChild = function(parent, child) {\n  if (!child) {\n    return false;\n  } else if (parent === child) {\n    return true;\n  } else {\n    return isNodeOrChild(parent, child.parentElement);\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/utils/use-unmount-effect.js\n\nfunction useUnmountEffect(callback) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    return function() {\n      return callback();\n    };\n  }, []);\n}\n\n// ../../node_modules/popmotion/dist/es/utils/clamp.js\nvar clamp2 = function(min, max, v) {\n  return Math.min(Math.max(v, min), max);\n};\n\n// ../../node_modules/popmotion/dist/es/animations/utils/find-spring.js\nvar safeMin = 1e-3;\nvar minDuration = 0.01;\nvar maxDuration = 10;\nvar minDamping = 0.05;\nvar maxDamping = 1;\nfunction findSpring(_a) {\n  var _b = _a.duration, duration = _b === void 0 ? 800 : _b, _c = _a.bounce, bounce = _c === void 0 ? 0.25 : _c, _d = _a.velocity, velocity = _d === void 0 ? 0 : _d, _e = _a.mass, mass = _e === void 0 ? 1 : _e;\n  var envelope;\n  var derivative;\n  warning(duration <= maxDuration * 1e3, \"Spring duration must be 10 seconds or less\");\n  var dampingRatio = 1 - bounce;\n  dampingRatio = clamp2(minDamping, maxDamping, dampingRatio);\n  duration = clamp2(minDuration, maxDuration, duration / 1e3);\n  if (dampingRatio < 1) {\n    envelope = function(undampedFreq2) {\n      var exponentialDecay = undampedFreq2 * dampingRatio;\n      var delta2 = exponentialDecay * duration;\n      var a2 = exponentialDecay - velocity;\n      var b2 = calcAngularFreq(undampedFreq2, dampingRatio);\n      var c2 = Math.exp(-delta2);\n      return safeMin - a2 / b2 * c2;\n    };\n    derivative = function(undampedFreq2) {\n      var exponentialDecay = undampedFreq2 * dampingRatio;\n      var delta2 = exponentialDecay * duration;\n      var d = delta2 * velocity + velocity;\n      var e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;\n      var f = Math.exp(-delta2);\n      var g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);\n      var factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;\n      return factor * ((d - e) * f) / g;\n    };\n  } else {\n    envelope = function(undampedFreq2) {\n      var a2 = Math.exp(-undampedFreq2 * duration);\n      var b2 = (undampedFreq2 - velocity) * duration + 1;\n      return -safeMin + a2 * b2;\n    };\n    derivative = function(undampedFreq2) {\n      var a2 = Math.exp(-undampedFreq2 * duration);\n      var b2 = (velocity - undampedFreq2) * (duration * duration);\n      return a2 * b2;\n    };\n  }\n  var initialGuess = 5 / duration;\n  var undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n  duration = duration * 1e3;\n  if (isNaN(undampedFreq)) {\n    return {\n      stiffness: 100,\n      damping: 10,\n      duration\n    };\n  } else {\n    var stiffness = Math.pow(undampedFreq, 2) * mass;\n    return {\n      stiffness,\n      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n      duration\n    };\n  }\n}\nvar rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n  var result = initialGuess;\n  for (var i = 1; i < rootIterations; i++) {\n    result = result - envelope(result) / derivative(result);\n  }\n  return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\n// ../../node_modules/popmotion/dist/es/animations/generators/spring.js\nvar durationKeys = [\"duration\", \"bounce\"];\nvar physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys2) {\n  return keys2.some(function(key6) {\n    return options[key6] !== void 0;\n  });\n}\nfunction getSpringOptions(options) {\n  var springOptions = __assign({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false }, options);\n  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n    var derived = findSpring(options);\n    springOptions = __assign(__assign(__assign({}, springOptions), derived), { velocity: 0, mass: 1 });\n    springOptions.isResolvedFromDuration = true;\n  }\n  return springOptions;\n}\nfunction spring(_a) {\n  var _b = _a.from, from = _b === void 0 ? 0 : _b, _c = _a.to, to = _c === void 0 ? 1 : _c, _d = _a.restSpeed, restSpeed = _d === void 0 ? 2 : _d, restDelta = _a.restDelta, options = __rest(_a, [\"from\", \"to\", \"restSpeed\", \"restDelta\"]);\n  var state = { done: false, value: from };\n  var _e = getSpringOptions(options), stiffness = _e.stiffness, damping = _e.damping, mass = _e.mass, velocity = _e.velocity, duration = _e.duration, isResolvedFromDuration = _e.isResolvedFromDuration;\n  var resolveSpring = zero;\n  var resolveVelocity = zero;\n  function createSpring() {\n    var initialVelocity = velocity ? -(velocity / 1e3) : 0;\n    var initialDelta = to - from;\n    var dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    var undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;\n    restDelta !== null && restDelta !== void 0 ? restDelta : restDelta = Math.abs(to - from) <= 1 ? 0.01 : 0.4;\n    if (dampingRatio < 1) {\n      var angularFreq_1 = calcAngularFreq(undampedAngularFreq, dampingRatio);\n      resolveSpring = function(t) {\n        var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq_1 * Math.sin(angularFreq_1 * t) + initialDelta * Math.cos(angularFreq_1 * t));\n      };\n      resolveVelocity = function(t) {\n        var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq_1 * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq_1 + initialDelta * Math.cos(angularFreq_1 * t)) - envelope * (Math.cos(angularFreq_1 * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq_1 * initialDelta * Math.sin(angularFreq_1 * t));\n      };\n    } else if (dampingRatio === 1) {\n      resolveSpring = function(t) {\n        return to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n      };\n    } else {\n      var dampedAngularFreq_1 = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n      resolveSpring = function(t) {\n        var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        var freqForT = Math.min(dampedAngularFreq_1 * t, 300);\n        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq_1 * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq_1;\n      };\n    }\n  }\n  createSpring();\n  return {\n    next: function(t) {\n      var current = resolveSpring(t);\n      if (!isResolvedFromDuration) {\n        var currentVelocity = resolveVelocity(t) * 1e3;\n        var isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        var isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n      } else {\n        state.done = t >= duration;\n      }\n      state.value = state.done ? to : current;\n      return state;\n    },\n    flipTarget: function() {\n      var _a2;\n      velocity = -velocity;\n      _a2 = [to, from], from = _a2[0], to = _a2[1];\n      createSpring();\n    }\n  };\n}\nspring.needsInterpolation = function(a2, b2) {\n  return typeof a2 === \"string\" || typeof b2 === \"string\";\n};\nvar zero = function(_t) {\n  return 0;\n};\n\n// ../../node_modules/popmotion/dist/es/utils/progress.js\nvar progress = function(from, to, value) {\n  var toFromDifference = to - from;\n  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\n// ../../node_modules/popmotion/dist/es/utils/mix.js\nvar mix = function(from, to, progress2) {\n  return -progress2 * from + progress2 * to + from;\n};\n\n// ../../node_modules/popmotion/dist/es/utils/mix-color.js\nvar mixLinearColor = function(from, to, v) {\n  var fromExpo = from * from;\n  var toExpo = to * to;\n  return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));\n};\nvar colorTypes = [hex, rgba, hsla];\nvar getColorType = function(v) {\n  return colorTypes.find(function(type) {\n    return type.test(v);\n  });\n};\nvar notAnimatable = function(color2) {\n  return \"'\" + color2 + \"' is not an animatable color. Use the equivalent color code instead.\";\n};\nvar mixColor = function(from, to) {\n  var fromColorType = getColorType(from);\n  var toColorType = getColorType(to);\n  invariant(!!fromColorType, notAnimatable(from));\n  invariant(!!toColorType, notAnimatable(to));\n  invariant(fromColorType.transform === toColorType.transform, \"Both colors must be hex/RGBA, OR both must be HSLA.\");\n  var fromColor = fromColorType.parse(from);\n  var toColor = toColorType.parse(to);\n  var blended = __assign({}, fromColor);\n  var mixFunc = fromColorType === hsla ? mix : mixLinearColor;\n  return function(v) {\n    for (var key6 in blended) {\n      if (key6 !== \"alpha\") {\n        blended[key6] = mixFunc(fromColor[key6], toColor[key6], v);\n      }\n    }\n    blended.alpha = mix(fromColor.alpha, toColor.alpha, v);\n    return fromColorType.transform(blended);\n  };\n};\n\n// ../../node_modules/popmotion/dist/es/utils/inc.js\nvar isNum = function(v) {\n  return typeof v === \"number\";\n};\n\n// ../../node_modules/popmotion/dist/es/utils/pipe.js\nvar combineFunctions = function(a2, b2) {\n  return function(v) {\n    return b2(a2(v));\n  };\n};\nvar pipe = function() {\n  var transformers = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    transformers[_i] = arguments[_i];\n  }\n  return transformers.reduce(combineFunctions);\n};\n\n// ../../node_modules/popmotion/dist/es/utils/mix-complex.js\nfunction getMixer(origin, target) {\n  if (isNum(origin)) {\n    return function(v) {\n      return mix(origin, target, v);\n    };\n  } else if (color.test(origin)) {\n    return mixColor(origin, target);\n  } else {\n    return mixComplex(origin, target);\n  }\n}\nvar mixArray = function(from, to) {\n  var output = __spreadArray([], from);\n  var numValues = output.length;\n  var blendValue = from.map(function(fromThis, i) {\n    return getMixer(fromThis, to[i]);\n  });\n  return function(v) {\n    for (var i = 0; i < numValues; i++) {\n      output[i] = blendValue[i](v);\n    }\n    return output;\n  };\n};\nvar mixObject = function(origin, target) {\n  var output = __assign(__assign({}, origin), target);\n  var blendValue = {};\n  for (var key6 in output) {\n    if (origin[key6] !== void 0 && target[key6] !== void 0) {\n      blendValue[key6] = getMixer(origin[key6], target[key6]);\n    }\n  }\n  return function(v) {\n    for (var key7 in blendValue) {\n      output[key7] = blendValue[key7](v);\n    }\n    return output;\n  };\n};\nfunction analyse2(value) {\n  var parsed = complex.parse(value);\n  var numValues = parsed.length;\n  var numNumbers = 0;\n  var numRGB = 0;\n  var numHSL = 0;\n  for (var i = 0; i < numValues; i++) {\n    if (numNumbers || typeof parsed[i] === \"number\") {\n      numNumbers++;\n    } else {\n      if (parsed[i].hue !== void 0) {\n        numHSL++;\n      } else {\n        numRGB++;\n      }\n    }\n  }\n  return { parsed, numNumbers, numRGB, numHSL };\n}\nvar mixComplex = function(origin, target) {\n  var template = complex.createTransformer(target);\n  var originStats = analyse2(origin);\n  var targetStats = analyse2(target);\n  invariant(originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers, \"Complex values '\" + origin + \"' and '\" + target + \"' too different to mix. Ensure all colors are of the same type.\");\n  return pipe(mixArray(originStats.parsed, targetStats.parsed), template);\n};\n\n// ../../node_modules/popmotion/dist/es/utils/interpolate.js\nvar mixNumber = function(from, to) {\n  return function(p) {\n    return mix(from, to, p);\n  };\n};\nfunction detectMixerFactory(v) {\n  if (typeof v === \"number\") {\n    return mixNumber;\n  } else if (typeof v === \"string\") {\n    if (color.test(v)) {\n      return mixColor;\n    } else {\n      return mixComplex;\n    }\n  } else if (Array.isArray(v)) {\n    return mixArray;\n  } else if (typeof v === \"object\") {\n    return mixObject;\n  }\n}\nfunction createMixers(output, ease, customMixer) {\n  var mixers = [];\n  var mixerFactory = customMixer || detectMixerFactory(output[0]);\n  var numMixers = output.length - 1;\n  for (var i = 0; i < numMixers; i++) {\n    var mixer = mixerFactory(output[i], output[i + 1]);\n    if (ease) {\n      var easingFunction = Array.isArray(ease) ? ease[i] : ease;\n      mixer = pipe(easingFunction, mixer);\n    }\n    mixers.push(mixer);\n  }\n  return mixers;\n}\nfunction fastInterpolate(_a, _b) {\n  var from = _a[0], to = _a[1];\n  var mixer = _b[0];\n  return function(v) {\n    return mixer(progress(from, to, v));\n  };\n}\nfunction slowInterpolate(input, mixers) {\n  var inputLength = input.length;\n  var lastInputIndex = inputLength - 1;\n  return function(v) {\n    var mixerIndex = 0;\n    var foundMixerIndex = false;\n    if (v <= input[0]) {\n      foundMixerIndex = true;\n    } else if (v >= input[lastInputIndex]) {\n      mixerIndex = lastInputIndex - 1;\n      foundMixerIndex = true;\n    }\n    if (!foundMixerIndex) {\n      var i = 1;\n      for (; i < inputLength; i++) {\n        if (input[i] > v || i === lastInputIndex) {\n          break;\n        }\n      }\n      mixerIndex = i - 1;\n    }\n    var progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);\n    return mixers[mixerIndex](progressInRange);\n  };\n}\nfunction interpolate(input, output, _a) {\n  var _b = _a === void 0 ? {} : _a, _c = _b.clamp, isClamp = _c === void 0 ? true : _c, ease = _b.ease, mixer = _b.mixer;\n  var inputLength = input.length;\n  invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n  invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, \"Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.\");\n  if (input[0] > input[inputLength - 1]) {\n    input = [].concat(input);\n    output = [].concat(output);\n    input.reverse();\n    output.reverse();\n  }\n  var mixers = createMixers(output, ease, mixer);\n  var interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);\n  return isClamp ? function(v) {\n    return interpolator(clamp2(input[0], input[inputLength - 1], v));\n  } : interpolator;\n}\n\n// ../../node_modules/popmotion/dist/es/easing/utils.js\nvar reverseEasing = function(easing) {\n  return function(p) {\n    return 1 - easing(1 - p);\n  };\n};\nvar mirrorEasing = function(easing) {\n  return function(p) {\n    return p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n  };\n};\nvar createExpoIn = function(power) {\n  return function(p) {\n    return Math.pow(p, power);\n  };\n};\nvar createBackIn = function(power) {\n  return function(p) {\n    return p * p * ((power + 1) * p - power);\n  };\n};\nvar createAnticipate = function(power) {\n  var backEasing = createBackIn(power);\n  return function(p) {\n    return (p *= 2) < 1 ? 0.5 * backEasing(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n  };\n};\n\n// ../../node_modules/popmotion/dist/es/easing/index.js\nvar DEFAULT_OVERSHOOT_STRENGTH = 1.525;\nvar BOUNCE_FIRST_THRESHOLD = 4 / 11;\nvar BOUNCE_SECOND_THRESHOLD = 8 / 11;\nvar BOUNCE_THIRD_THRESHOLD = 9 / 10;\nvar linear = function(p) {\n  return p;\n};\nvar easeIn = createExpoIn(2);\nvar easeOut = reverseEasing(easeIn);\nvar easeInOut = mirrorEasing(easeIn);\nvar circIn = function(p) {\n  return 1 - Math.sin(Math.acos(p));\n};\nvar circOut = reverseEasing(circIn);\nvar circInOut = mirrorEasing(circOut);\nvar backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);\nvar backOut = reverseEasing(backIn);\nvar backInOut = mirrorEasing(backIn);\nvar anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);\nvar ca = 4356 / 361;\nvar cb = 35442 / 1805;\nvar cc = 16061 / 1805;\nvar bounceOut = function(p) {\n  if (p === 1 || p === 0)\n    return p;\n  var p2 = p * p;\n  return p < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p2 : p < BOUNCE_SECOND_THRESHOLD ? 9.075 * p2 - 9.9 * p + 3.4 : p < BOUNCE_THIRD_THRESHOLD ? ca * p2 - cb * p + cc : 10.8 * p * p - 20.52 * p + 10.72;\n};\nvar bounceIn = reverseEasing(bounceOut);\nvar bounceInOut = function(p) {\n  return p < 0.5 ? 0.5 * (1 - bounceOut(1 - p * 2)) : 0.5 * bounceOut(p * 2 - 1) + 0.5;\n};\n\n// ../../node_modules/popmotion/dist/es/animations/generators/keyframes.js\nfunction defaultEasing(values, easing) {\n  return values.map(function() {\n    return easing || easeInOut;\n  }).splice(0, values.length - 1);\n}\nfunction defaultOffset(values) {\n  var numValues = values.length;\n  return values.map(function(_value, i) {\n    return i !== 0 ? i / (numValues - 1) : 0;\n  });\n}\nfunction convertOffsetToTimes(offset, duration) {\n  return offset.map(function(o) {\n    return o * duration;\n  });\n}\nfunction keyframes(_a) {\n  var _b = _a.from, from = _b === void 0 ? 0 : _b, _c = _a.to, to = _c === void 0 ? 1 : _c, ease = _a.ease, offset = _a.offset, _d = _a.duration, duration = _d === void 0 ? 300 : _d;\n  var state = { done: false, value: from };\n  var values = Array.isArray(to) ? to : [from, to];\n  var times = convertOffsetToTimes(offset && offset.length === values.length ? offset : defaultOffset(values), duration);\n  function createInterpolator() {\n    return interpolate(times, values, {\n      ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)\n    });\n  }\n  var interpolator = createInterpolator();\n  return {\n    next: function(t) {\n      state.value = interpolator(t);\n      state.done = t >= duration;\n      return state;\n    },\n    flipTarget: function() {\n      values.reverse();\n      interpolator = createInterpolator();\n    }\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/animations/generators/decay.js\nfunction decay(_a) {\n  var _b = _a.velocity, velocity = _b === void 0 ? 0 : _b, _c = _a.from, from = _c === void 0 ? 0 : _c, _d = _a.power, power = _d === void 0 ? 0.8 : _d, _e = _a.timeConstant, timeConstant2 = _e === void 0 ? 350 : _e, _f = _a.restDelta, restDelta = _f === void 0 ? 0.5 : _f, modifyTarget = _a.modifyTarget;\n  var state = { done: false, value: from };\n  var amplitude = power * velocity;\n  var ideal = from + amplitude;\n  var target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);\n  if (target !== ideal)\n    amplitude = target - from;\n  return {\n    next: function(t) {\n      var delta2 = -amplitude * Math.exp(-t / timeConstant2);\n      state.done = !(delta2 > restDelta || delta2 < -restDelta);\n      state.value = state.done ? target : target + delta2;\n      return state;\n    },\n    flipTarget: function() {\n    }\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/animations/utils/detect-animation-from-options.js\nvar types = { keyframes, spring, decay };\nfunction detectAnimationFromOptions(config) {\n  if (Array.isArray(config.to)) {\n    return keyframes;\n  } else if (types[config.type]) {\n    return types[config.type];\n  }\n  var keys2 = new Set(Object.keys(config));\n  if (keys2.has(\"ease\") || keys2.has(\"duration\") && !keys2.has(\"dampingRatio\")) {\n    return keyframes;\n  } else if (keys2.has(\"dampingRatio\") || keys2.has(\"stiffness\") || keys2.has(\"mass\") || keys2.has(\"damping\") || keys2.has(\"restSpeed\") || keys2.has(\"restDelta\")) {\n    return spring;\n  }\n  return keyframes;\n}\n\n// ../../node_modules/framesync/dist/es/on-next-frame.js\nvar defaultTimestep = 1 / 60 * 1e3;\nvar getCurrentTime = typeof performance !== \"undefined\" ? function() {\n  return performance.now();\n} : function() {\n  return Date.now();\n};\nvar onNextFrame = typeof window !== \"undefined\" ? function(callback) {\n  return window.requestAnimationFrame(callback);\n} : function(callback) {\n  return setTimeout(function() {\n    return callback(getCurrentTime());\n  }, defaultTimestep);\n};\n\n// ../../node_modules/framesync/dist/es/create-render-step.js\nfunction createRenderStep(runNextFrame2) {\n  var toRun = [];\n  var toRunNextFrame = [];\n  var numToRun = 0;\n  var isProcessing2 = false;\n  var toKeepAlive = new WeakSet();\n  var step = {\n    schedule: function(callback, keepAlive, immediate) {\n      if (keepAlive === void 0) {\n        keepAlive = false;\n      }\n      if (immediate === void 0) {\n        immediate = false;\n      }\n      var addToCurrentFrame = immediate && isProcessing2;\n      var buffer = addToCurrentFrame ? toRun : toRunNextFrame;\n      if (keepAlive)\n        toKeepAlive.add(callback);\n      if (buffer.indexOf(callback) === -1) {\n        buffer.push(callback);\n        if (addToCurrentFrame && isProcessing2)\n          numToRun = toRun.length;\n      }\n      return callback;\n    },\n    cancel: function(callback) {\n      var index = toRunNextFrame.indexOf(callback);\n      if (index !== -1)\n        toRunNextFrame.splice(index, 1);\n      toKeepAlive.delete(callback);\n    },\n    process: function(frameData) {\n      var _a;\n      isProcessing2 = true;\n      _a = [toRunNextFrame, toRun], toRun = _a[0], toRunNextFrame = _a[1];\n      toRunNextFrame.length = 0;\n      numToRun = toRun.length;\n      if (numToRun) {\n        for (var i = 0; i < numToRun; i++) {\n          var callback = toRun[i];\n          callback(frameData);\n          if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame2();\n          }\n        }\n      }\n      isProcessing2 = false;\n    }\n  };\n  return step;\n}\n\n// ../../node_modules/framesync/dist/es/index.js\nvar maxElapsed = 40;\nvar useDefaultElapsed = true;\nvar runNextFrame = false;\nvar isProcessing = false;\nvar frame = {\n  delta: 0,\n  timestamp: 0\n};\nvar stepsOrder = [\"read\", \"update\", \"preRender\", \"render\", \"postRender\"];\nvar steps = /* @__PURE__ */ stepsOrder.reduce(function(acc, key6) {\n  acc[key6] = createRenderStep(function() {\n    return runNextFrame = true;\n  });\n  return acc;\n}, {});\nvar sync = /* @__PURE__ */ stepsOrder.reduce(function(acc, key6) {\n  var step = steps[key6];\n  acc[key6] = function(process3, keepAlive, immediate) {\n    if (keepAlive === void 0) {\n      keepAlive = false;\n    }\n    if (immediate === void 0) {\n      immediate = false;\n    }\n    if (!runNextFrame)\n      startLoop();\n    return step.schedule(process3, keepAlive, immediate);\n  };\n  return acc;\n}, {});\nvar cancelSync = /* @__PURE__ */ stepsOrder.reduce(function(acc, key6) {\n  acc[key6] = steps[key6].cancel;\n  return acc;\n}, {});\nvar flushSync = /* @__PURE__ */ stepsOrder.reduce(function(acc, key6) {\n  acc[key6] = function() {\n    return steps[key6].process(frame);\n  };\n  return acc;\n}, {});\nvar processStep = function(stepId) {\n  return steps[stepId].process(frame);\n};\nvar processFrame = function(timestamp) {\n  runNextFrame = false;\n  frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);\n  frame.timestamp = timestamp;\n  isProcessing = true;\n  stepsOrder.forEach(processStep);\n  isProcessing = false;\n  if (runNextFrame) {\n    useDefaultElapsed = false;\n    onNextFrame(processFrame);\n  }\n};\nvar startLoop = function() {\n  runNextFrame = true;\n  useDefaultElapsed = true;\n  if (!isProcessing)\n    onNextFrame(processFrame);\n};\nvar getFrameData = function() {\n  return frame;\n};\nvar es_default = sync;\n\n// ../../node_modules/popmotion/dist/es/animations/utils/elapsed.js\nfunction loopElapsed(elapsed, duration, delay) {\n  if (delay === void 0) {\n    delay = 0;\n  }\n  return elapsed - duration - delay;\n}\nfunction reverseElapsed(elapsed, duration, delay, isForwardPlayback) {\n  if (delay === void 0) {\n    delay = 0;\n  }\n  if (isForwardPlayback === void 0) {\n    isForwardPlayback = true;\n  }\n  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay) : duration - (elapsed - duration) + delay;\n}\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\n  return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\n}\n\n// ../../node_modules/popmotion/dist/es/animations/index.js\nvar framesync = function(update) {\n  var passTimestamp = function(_a) {\n    var delta2 = _a.delta;\n    return update(delta2);\n  };\n  return {\n    start: function() {\n      return es_default.update(passTimestamp, true);\n    },\n    stop: function() {\n      return cancelSync.update(passTimestamp);\n    }\n  };\n};\nfunction animate(_a) {\n  var _b, _c;\n  var from = _a.from, _d = _a.autoplay, autoplay = _d === void 0 ? true : _d, _e = _a.driver, driver = _e === void 0 ? framesync : _e, _f = _a.elapsed, elapsed = _f === void 0 ? 0 : _f, _g = _a.repeat, repeatMax = _g === void 0 ? 0 : _g, _h = _a.repeatType, repeatType = _h === void 0 ? \"loop\" : _h, _j = _a.repeatDelay, repeatDelay = _j === void 0 ? 0 : _j, onPlay = _a.onPlay, onStop = _a.onStop, onComplete = _a.onComplete, onRepeat = _a.onRepeat, onUpdate = _a.onUpdate, options = __rest(_a, [\"from\", \"autoplay\", \"driver\", \"elapsed\", \"repeat\", \"repeatType\", \"repeatDelay\", \"onPlay\", \"onStop\", \"onComplete\", \"onRepeat\", \"onUpdate\"]);\n  var to = options.to;\n  var driverControls;\n  var repeatCount = 0;\n  var computedDuration = options.duration;\n  var latest;\n  var isComplete = false;\n  var isForwardPlayback = true;\n  var interpolateFromNumber;\n  var animator = detectAnimationFromOptions(options);\n  if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {\n    interpolateFromNumber = interpolate([0, 100], [from, to], {\n      clamp: false\n    });\n    from = 0;\n    to = 100;\n  }\n  var animation = animator(__assign(__assign({}, options), { from, to }));\n  function repeat() {\n    repeatCount++;\n    if (repeatType === \"reverse\") {\n      isForwardPlayback = repeatCount % 2 === 0;\n      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n    } else {\n      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n      if (repeatType === \"mirror\")\n        animation.flipTarget();\n    }\n    isComplete = false;\n    onRepeat && onRepeat();\n  }\n  function complete() {\n    driverControls.stop();\n    onComplete && onComplete();\n  }\n  function update(delta2) {\n    if (!isForwardPlayback)\n      delta2 = -delta2;\n    elapsed += delta2;\n    if (!isComplete) {\n      var state = animation.next(Math.max(0, elapsed));\n      latest = state.value;\n      if (interpolateFromNumber)\n        latest = interpolateFromNumber(latest);\n      isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n    }\n    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);\n    if (isComplete) {\n      if (repeatCount === 0)\n        computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;\n      if (repeatCount < repeatMax) {\n        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n      } else {\n        complete();\n      }\n    }\n  }\n  function play() {\n    onPlay === null || onPlay === void 0 ? void 0 : onPlay();\n    driverControls = driver(update);\n    driverControls.start();\n  }\n  autoplay && play();\n  return {\n    stop: function() {\n      onStop === null || onStop === void 0 ? void 0 : onStop();\n      driverControls.stop();\n    }\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/utils/velocity-per-second.js\nfunction velocityPerSecond(velocity, frameDuration) {\n  return frameDuration ? velocity * (1e3 / frameDuration) : 0;\n}\n\n// ../../node_modules/popmotion/dist/es/animations/inertia.js\nfunction inertia(_a) {\n  var _b = _a.from, from = _b === void 0 ? 0 : _b, _c = _a.velocity, velocity = _c === void 0 ? 0 : _c, min = _a.min, max = _a.max, _d = _a.power, power = _d === void 0 ? 0.8 : _d, _e = _a.timeConstant, timeConstant2 = _e === void 0 ? 750 : _e, _f = _a.bounceStiffness, bounceStiffness = _f === void 0 ? 500 : _f, _g = _a.bounceDamping, bounceDamping = _g === void 0 ? 10 : _g, _h = _a.restDelta, restDelta = _h === void 0 ? 1 : _h, modifyTarget = _a.modifyTarget, driver = _a.driver, onUpdate = _a.onUpdate, onComplete = _a.onComplete, onStop = _a.onStop;\n  var currentAnimation;\n  function isOutOfBounds(v) {\n    return min !== void 0 && v < min || max !== void 0 && v > max;\n  }\n  function boundaryNearest(v) {\n    if (min === void 0)\n      return max;\n    if (max === void 0)\n      return min;\n    return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n  }\n  function startAnimation3(options) {\n    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();\n    currentAnimation = animate(__assign(__assign({}, options), {\n      driver,\n      onUpdate: function(v) {\n        var _a2;\n        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);\n        (_a2 = options.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(options, v);\n      },\n      onComplete,\n      onStop\n    }));\n  }\n  function startSpring(options) {\n    startAnimation3(__assign({ type: \"spring\", stiffness: bounceStiffness, damping: bounceDamping, restDelta }, options));\n  }\n  if (isOutOfBounds(from)) {\n    startSpring({ from, velocity, to: boundaryNearest(from) });\n  } else {\n    var target = power * velocity + from;\n    if (typeof modifyTarget !== \"undefined\")\n      target = modifyTarget(target);\n    var boundary_1 = boundaryNearest(target);\n    var heading_1 = boundary_1 === min ? -1 : 1;\n    var prev_1;\n    var current_1;\n    var checkBoundary = function(v) {\n      prev_1 = current_1;\n      current_1 = v;\n      velocity = velocityPerSecond(v - prev_1, getFrameData().delta);\n      if (heading_1 === 1 && v > boundary_1 || heading_1 === -1 && v < boundary_1) {\n        startSpring({ from: v, to: boundary_1, velocity });\n      }\n    };\n    startAnimation3({\n      type: \"decay\",\n      from,\n      velocity,\n      timeConstant: timeConstant2,\n      power,\n      restDelta,\n      modifyTarget,\n      onUpdate: isOutOfBounds(target) ? checkBoundary : void 0\n    });\n  }\n  return {\n    stop: function() {\n      return currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();\n    }\n  };\n}\n\n// ../../node_modules/popmotion/dist/es/utils/is-point.js\nvar isPoint = function(point) {\n  return point.hasOwnProperty(\"x\") && point.hasOwnProperty(\"y\");\n};\n\n// ../../node_modules/popmotion/dist/es/utils/is-point-3d.js\nvar isPoint3D = function(point) {\n  return isPoint(point) && point.hasOwnProperty(\"z\");\n};\n\n// ../../node_modules/popmotion/dist/es/utils/distance.js\nvar distance1D = function(a2, b2) {\n  return Math.abs(a2 - b2);\n};\nfunction distance(a2, b2) {\n  if (isNum(a2) && isNum(b2)) {\n    return distance1D(a2, b2);\n  } else if (isPoint(a2) && isPoint(b2)) {\n    var xDelta = distance1D(a2.x, b2.x);\n    var yDelta = distance1D(a2.y, b2.y);\n    var zDelta = isPoint3D(a2) && isPoint3D(b2) ? distance1D(a2.z, b2.z) : 0;\n    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));\n  }\n}\n\n// ../../node_modules/popmotion/dist/es/utils/wrap.js\nvar wrap = function(min, max, v) {\n  var rangeSize = max - min;\n  return ((v - min) % rangeSize + rangeSize) % rangeSize + min;\n};\n\n// ../../node_modules/popmotion/dist/es/easing/cubic-bezier.js\nvar a = function(a1, a2) {\n  return 1 - 3 * a2 + 3 * a1;\n};\nvar b = function(a1, a2) {\n  return 3 * a2 - 6 * a1;\n};\nvar c = function(a1) {\n  return 3 * a1;\n};\nvar calcBezier = function(t, a1, a2) {\n  return ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n};\nvar getSlope = function(t, a1, a2) {\n  return 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);\n};\nvar subdivisionPrecision = 1e-7;\nvar subdivisionMaxIterations = 10;\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  var currentX;\n  var currentT;\n  var i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);\n  return currentT;\n}\nvar newtonIterations = 8;\nvar newtonMinSlope = 1e-3;\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (var i = 0; i < newtonIterations; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0) {\n      return aGuessT;\n    }\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n  return aGuessT;\n}\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1 / (kSplineTableSize - 1);\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n  if (mX1 === mY1 && mX2 === mY2)\n    return linear;\n  var sampleValues = new Float32Array(kSplineTableSize);\n  for (var i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n  function getTForX(aX) {\n    var intervalStart = 0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= newtonMinSlope) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n  return function(t) {\n    return t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-tap-gesture.js\nfunction useTapGesture(_a) {\n  var onTap = _a.onTap, onTapStart = _a.onTapStart, onTapCancel = _a.onTapCancel, whileTap = _a.whileTap, visualElement2 = _a.visualElement;\n  var hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n  var isPressing = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  var cancelPointerEndListeners = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  function removePointerEndListener() {\n    var _a2;\n    (_a2 = cancelPointerEndListeners.current) === null || _a2 === void 0 ? void 0 : _a2.call(cancelPointerEndListeners);\n    cancelPointerEndListeners.current = null;\n  }\n  function checkPointerEnd() {\n    var _a2;\n    removePointerEndListener();\n    isPressing.current = false;\n    (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Tap, false);\n    return !isDragActive();\n  }\n  function onPointerUp(event, info) {\n    if (!checkPointerEnd())\n      return;\n    !isNodeOrChild(visualElement2.getInstance(), event.target) ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info) : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);\n  }\n  function onPointerCancel(event, info) {\n    if (!checkPointerEnd())\n      return;\n    onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);\n  }\n  function onPointerDown(event, info) {\n    var _a2;\n    removePointerEndListener();\n    if (isPressing.current)\n      return;\n    isPressing.current = true;\n    cancelPointerEndListeners.current = pipe(addPointerEvent(window, \"pointerup\", onPointerUp), addPointerEvent(window, \"pointercancel\", onPointerCancel));\n    onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);\n    (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Tap, true);\n  }\n  usePointerEvent(visualElement2, \"pointerdown\", hasPressListeners ? onPointerDown : void 0);\n  useUnmountEffect(removePointerEndListener);\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/utils/make-renderless-component.js\nvar makeRenderlessComponent = function(hook) {\n  return function(props) {\n    hook(props);\n    return null;\n  };\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/gestures.js\nvar gestureAnimations = {\n  tap: makeRenderlessComponent(useTapGesture),\n  focus: makeRenderlessComponent(useFocusGesture),\n  hover: makeRenderlessComponent(useHoverGesture)\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/animations.js\n\n\n// ../../node_modules/framer-motion/dist/es/utils/shallow-compare.js\nfunction shallowCompare(next, prev) {\n  if (!Array.isArray(prev))\n    return false;\n  var prevLength = prev.length;\n  if (prevLength !== next.length)\n    return false;\n  for (var i = 0; i < prevLength; i++) {\n    if (prev[i] !== next[i])\n      return false;\n  }\n  return true;\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/time-conversion.js\nvar secondsToMilliseconds = function(seconds) {\n  return seconds * 1e3;\n};\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/easing.js\nvar easingLookup = {\n  linear,\n  easeIn,\n  easeInOut,\n  easeOut,\n  circIn,\n  circInOut,\n  circOut,\n  backIn,\n  backInOut,\n  backOut,\n  anticipate,\n  bounceIn,\n  bounceInOut,\n  bounceOut\n};\nvar easingDefinitionToFunction = function(definition) {\n  if (Array.isArray(definition)) {\n    invariant(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\n    var _a = __read(definition, 4), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];\n    return cubicBezier(x1, y1, x2, y2);\n  } else if (typeof definition === \"string\") {\n    invariant(easingLookup[definition] !== void 0, \"Invalid easing type '\" + definition + \"'\");\n    return easingLookup[definition];\n  }\n  return definition;\n};\nvar isEasingArray = function(ease) {\n  return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/is-animatable.js\nvar isAnimatable = function(key6, value) {\n  if (key6 === \"zIndex\")\n    return false;\n  if (typeof value === \"number\" || Array.isArray(value))\n    return true;\n  if (typeof value === \"string\" && complex.test(value) && !value.startsWith(\"url(\")) {\n    return true;\n  }\n  return false;\n};\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/default-transitions.js\nvar underDampedSpring = function() {\n  return {\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restDelta: 0.5,\n    restSpeed: 10\n  };\n};\nvar criticallyDampedSpring = function(to) {\n  return {\n    type: \"spring\",\n    stiffness: 550,\n    damping: to === 0 ? 2 * Math.sqrt(550) : 30,\n    restDelta: 0.01,\n    restSpeed: 10\n  };\n};\nvar linearTween = function() {\n  return {\n    type: \"keyframes\",\n    ease: \"linear\",\n    duration: 0.3\n  };\n};\nvar keyframes2 = function(values) {\n  return {\n    type: \"keyframes\",\n    duration: 0.8,\n    values\n  };\n};\nvar defaultTransitions = {\n  x: underDampedSpring,\n  y: underDampedSpring,\n  z: underDampedSpring,\n  rotate: underDampedSpring,\n  rotateX: underDampedSpring,\n  rotateY: underDampedSpring,\n  rotateZ: underDampedSpring,\n  scaleX: criticallyDampedSpring,\n  scaleY: criticallyDampedSpring,\n  scale: criticallyDampedSpring,\n  opacity: linearTween,\n  backgroundColor: linearTween,\n  color: linearTween,\n  default: criticallyDampedSpring\n};\nvar getDefaultTransition = function(valueKey, to) {\n  var transitionFactory;\n  if (isKeyframesTarget(to)) {\n    transitionFactory = keyframes2;\n  } else {\n    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;\n  }\n  return __assign({ to }, transitionFactory(to));\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/defaults.js\nvar defaultValueTypes = __assign(__assign({}, numberValueTypes), {\n  color,\n  backgroundColor: color,\n  outlineColor: color,\n  fill: color,\n  stroke: color,\n  borderColor: color,\n  borderTopColor: color,\n  borderRightColor: color,\n  borderBottomColor: color,\n  borderLeftColor: color,\n  filter,\n  WebkitFilter: filter\n});\nvar getDefaultValueType = function(key6) {\n  return defaultValueTypes[key6];\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.js\nfunction getAnimatableNone2(key6, value) {\n  var _a;\n  var defaultValueType = getDefaultValueType(key6);\n  if (defaultValueType !== filter)\n    defaultValueType = complex;\n  return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);\n}\n\n// ../../node_modules/framer-motion/dist/es/animation/utils/transitions.js\nfunction isTransitionDefined(_a) {\n  _a.when;\n  _a.delay;\n  _a.delayChildren;\n  _a.staggerChildren;\n  _a.staggerDirection;\n  _a.repeat;\n  _a.repeatType;\n  _a.repeatDelay;\n  _a.from;\n  var transition = __rest(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\", \"repeat\", \"repeatType\", \"repeatDelay\", \"from\"]);\n  return !!Object.keys(transition).length;\n}\nvar legacyRepeatWarning = false;\nfunction convertTransitionToAnimationOptions(_a) {\n  var ease = _a.ease, times = _a.times, yoyo = _a.yoyo, flip = _a.flip, loop = _a.loop, transition = __rest(_a, [\"ease\", \"times\", \"yoyo\", \"flip\", \"loop\"]);\n  var options = __assign({}, transition);\n  if (times)\n    options[\"offset\"] = times;\n  if (transition.duration)\n    options[\"duration\"] = secondsToMilliseconds(transition.duration);\n  if (transition.repeatDelay)\n    options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\n  if (ease) {\n    options[\"ease\"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);\n  }\n  if (transition.type === \"tween\")\n    options.type = \"keyframes\";\n  if (yoyo || loop || flip) {\n    warning(!legacyRepeatWarning, \"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\");\n    legacyRepeatWarning = true;\n    if (yoyo) {\n      options.repeatType = \"reverse\";\n    } else if (loop) {\n      options.repeatType = \"loop\";\n    } else if (flip) {\n      options.repeatType = \"mirror\";\n    }\n    options.repeat = loop || yoyo || flip || transition.repeat;\n  }\n  if (transition.type !== \"spring\")\n    options.type = \"keyframes\";\n  return options;\n}\nfunction getDelayFromTransition(transition, key6) {\n  var _a;\n  var valueTransition = getValueTransition(transition, key6) || {};\n  return (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : 0;\n}\nfunction hydrateKeyframes(options) {\n  if (Array.isArray(options.to) && options.to[0] === null) {\n    options.to = __spreadArray([], __read(options.to));\n    options.to[0] = options.from;\n  }\n  return options;\n}\nfunction getPopmotionAnimationOptions(transition, options, key6) {\n  var _a;\n  if (Array.isArray(options.to)) {\n    (_a = transition.duration) !== null && _a !== void 0 ? _a : transition.duration = 0.8;\n  }\n  hydrateKeyframes(options);\n  if (!isTransitionDefined(transition)) {\n    transition = __assign(__assign({}, transition), getDefaultTransition(key6, options.to));\n  }\n  return __assign(__assign({}, options), convertTransitionToAnimationOptions(transition));\n}\nfunction getAnimation(key6, value, target, transition, onComplete) {\n  var _a;\n  var valueTransition = getValueTransition(transition, key6);\n  var origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();\n  var isTargetAnimatable = isAnimatable(key6, target);\n  if (origin === \"none\" && isTargetAnimatable && typeof target === \"string\") {\n    origin = getAnimatableNone2(key6, target);\n  } else if (isZero(origin) && typeof target === \"string\") {\n    origin = getZeroUnit(target);\n  } else if (!Array.isArray(target) && isZero(target) && typeof origin === \"string\") {\n    target = getZeroUnit(origin);\n  }\n  var isOriginAnimatable = isAnimatable(key6, origin);\n  warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \" + key6 + ' from \"' + origin + '\" to \"' + target + '\". ' + origin + \" is not an animatable value - to enable this animation set \" + origin + \" to a value animatable to \" + target + \" via the `style` property.\");\n  function start() {\n    var options = {\n      from: origin,\n      to: target,\n      velocity: value.getVelocity(),\n      onComplete,\n      onUpdate: function(v) {\n        return value.set(v);\n      }\n    };\n    return valueTransition.type === \"inertia\" || valueTransition.type === \"decay\" ? inertia(__assign(__assign({}, options), valueTransition)) : animate(__assign(__assign({}, getPopmotionAnimationOptions(valueTransition, options, key6)), { onUpdate: function(v) {\n      var _a2;\n      options.onUpdate(v);\n      (_a2 = valueTransition.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(valueTransition, v);\n    }, onComplete: function() {\n      var _a2;\n      options.onComplete();\n      (_a2 = valueTransition.onComplete) === null || _a2 === void 0 ? void 0 : _a2.call(valueTransition);\n    } }));\n  }\n  function set() {\n    var _a2;\n    value.set(target);\n    onComplete();\n    (_a2 = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _a2 === void 0 ? void 0 : _a2.call(valueTransition);\n    return { stop: function() {\n    } };\n  }\n  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start;\n}\nfunction isZero(value) {\n  return value === 0 || typeof value === \"string\" && parseFloat(value) === 0 && value.indexOf(\" \") === -1;\n}\nfunction getZeroUnit(potentialUnitType) {\n  return typeof potentialUnitType === \"number\" ? 0 : getAnimatableNone2(\"\", potentialUnitType);\n}\nfunction getValueTransition(transition, key6) {\n  return transition[key6] || transition[\"default\"] || transition;\n}\nfunction startAnimation(key6, value, target, transition) {\n  if (transition === void 0) {\n    transition = {};\n  }\n  return value.start(function(onComplete) {\n    var delayTimer;\n    var controls;\n    var animation = getAnimation(key6, value, target, transition, onComplete);\n    var delay = getDelayFromTransition(transition, key6);\n    var start = function() {\n      return controls = animation();\n    };\n    if (delay) {\n      delayTimer = setTimeout(start, secondsToMilliseconds(delay));\n    } else {\n      start();\n    }\n    return function() {\n      clearTimeout(delayTimer);\n      controls === null || controls === void 0 ? void 0 : controls.stop();\n    };\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/is-numerical-string.js\nvar isNumericalString = function(v) {\n  return /^\\-?\\d*\\.?\\d+$/.test(v);\n};\n\n// ../../node_modules/framer-motion/dist/es/utils/array.js\nfunction addUniqueItem(arr, item) {\n  arr.indexOf(item) === -1 && arr.push(item);\n}\nfunction removeItem(arr, item) {\n  var index = arr.indexOf(item);\n  index > -1 && arr.splice(index, 1);\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/subscription-manager.js\nvar SubscriptionManager = function() {\n  function SubscriptionManager2() {\n    this.subscriptions = [];\n  }\n  SubscriptionManager2.prototype.add = function(handler) {\n    var _this = this;\n    addUniqueItem(this.subscriptions, handler);\n    return function() {\n      return removeItem(_this.subscriptions, handler);\n    };\n  };\n  SubscriptionManager2.prototype.notify = function(a2, b2, c2) {\n    var numSubscriptions = this.subscriptions.length;\n    if (!numSubscriptions)\n      return;\n    if (numSubscriptions === 1) {\n      this.subscriptions[0](a2, b2, c2);\n    } else {\n      for (var i = 0; i < numSubscriptions; i++) {\n        var handler = this.subscriptions[i];\n        handler && handler(a2, b2, c2);\n      }\n    }\n  };\n  SubscriptionManager2.prototype.getSize = function() {\n    return this.subscriptions.length;\n  };\n  SubscriptionManager2.prototype.clear = function() {\n    this.subscriptions.length = 0;\n  };\n  return SubscriptionManager2;\n}();\n\n// ../../node_modules/framer-motion/dist/es/value/index.js\nvar isFloat = function(value) {\n  return !isNaN(parseFloat(value));\n};\nvar MotionValue = function() {\n  function MotionValue10(init) {\n    var _this = this;\n    this.timeDelta = 0;\n    this.lastUpdated = 0;\n    this.updateSubscribers = new SubscriptionManager();\n    this.velocityUpdateSubscribers = new SubscriptionManager();\n    this.renderSubscribers = new SubscriptionManager();\n    this.canTrackVelocity = false;\n    this.updateAndNotify = function(v, render) {\n      if (render === void 0) {\n        render = true;\n      }\n      _this.prev = _this.current;\n      _this.current = v;\n      var _a = getFrameData(), delta2 = _a.delta, timestamp = _a.timestamp;\n      if (_this.lastUpdated !== timestamp) {\n        _this.timeDelta = delta2;\n        _this.lastUpdated = timestamp;\n        es_default.postRender(_this.scheduleVelocityCheck);\n      }\n      if (_this.prev !== _this.current) {\n        _this.updateSubscribers.notify(_this.current);\n      }\n      if (_this.velocityUpdateSubscribers.getSize()) {\n        _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n      }\n      if (render) {\n        _this.renderSubscribers.notify(_this.current);\n      }\n    };\n    this.scheduleVelocityCheck = function() {\n      return es_default.postRender(_this.velocityCheck);\n    };\n    this.velocityCheck = function(_a) {\n      var timestamp = _a.timestamp;\n      if (timestamp !== _this.lastUpdated) {\n        _this.prev = _this.current;\n        _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n      }\n    };\n    this.hasAnimated = false;\n    this.prev = this.current = init;\n    this.canTrackVelocity = isFloat(this.current);\n  }\n  MotionValue10.prototype.onChange = function(subscription) {\n    return this.updateSubscribers.add(subscription);\n  };\n  MotionValue10.prototype.clearListeners = function() {\n    this.updateSubscribers.clear();\n  };\n  MotionValue10.prototype.onRenderRequest = function(subscription) {\n    subscription(this.get());\n    return this.renderSubscribers.add(subscription);\n  };\n  MotionValue10.prototype.attach = function(passiveEffect) {\n    this.passiveEffect = passiveEffect;\n  };\n  MotionValue10.prototype.set = function(v, render) {\n    if (render === void 0) {\n      render = true;\n    }\n    if (!render || !this.passiveEffect) {\n      this.updateAndNotify(v, render);\n    } else {\n      this.passiveEffect(v, this.updateAndNotify);\n    }\n  };\n  MotionValue10.prototype.get = function() {\n    return this.current;\n  };\n  MotionValue10.prototype.getPrevious = function() {\n    return this.prev;\n  };\n  MotionValue10.prototype.getVelocity = function() {\n    return this.canTrackVelocity ? velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;\n  };\n  MotionValue10.prototype.start = function(animation) {\n    var _this = this;\n    this.stop();\n    return new Promise(function(resolve) {\n      _this.hasAnimated = true;\n      _this.stopAnimation = animation(resolve);\n    }).then(function() {\n      return _this.clearAnimation();\n    });\n  };\n  MotionValue10.prototype.stop = function() {\n    if (this.stopAnimation)\n      this.stopAnimation();\n    this.clearAnimation();\n  };\n  MotionValue10.prototype.isAnimating = function() {\n    return !!this.stopAnimation;\n  };\n  MotionValue10.prototype.clearAnimation = function() {\n    this.stopAnimation = null;\n  };\n  MotionValue10.prototype.destroy = function() {\n    this.updateSubscribers.clear();\n    this.renderSubscribers.clear();\n    this.stop();\n  };\n  return MotionValue10;\n}();\nfunction motionValue(init) {\n  return new MotionValue(init);\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/test.js\nvar testValueType = function(v) {\n  return function(type) {\n    return type.test(v);\n  };\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.js\nvar auto = {\n  test: function(v) {\n    return v === \"auto\";\n  },\n  parse: function(v) {\n    return v;\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.js\nvar dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\nvar findDimensionValueType = function(v) {\n  return dimensionValueTypes.find(testValueType(v));\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/value-types/find.js\nvar valueTypes = __spreadArray(__spreadArray([], __read(dimensionValueTypes)), [color, complex]);\nvar findValueType = function(v) {\n  return valueTypes.find(testValueType(v));\n};\n\n// ../../node_modules/framer-motion/dist/es/render/utils/setters.js\nfunction setMotionValue(visualElement2, key6, value) {\n  if (visualElement2.hasValue(key6)) {\n    visualElement2.getValue(key6).set(value);\n  } else {\n    visualElement2.addValue(key6, motionValue(value));\n  }\n}\nfunction setTarget(visualElement2, definition) {\n  var resolved = resolveVariant(visualElement2, definition);\n  var _a = resolved ? visualElement2.makeTargetAnimatable(resolved, false) : {}, _b = _a.transitionEnd, transitionEnd = _b === void 0 ? {} : _b;\n  _a.transition;\n  var target = __rest(_a, [\"transitionEnd\", \"transition\"]);\n  target = __assign(__assign({}, target), transitionEnd);\n  for (var key6 in target) {\n    var value = resolveFinalValueInKeyframes(target[key6]);\n    setMotionValue(visualElement2, key6, value);\n  }\n}\nfunction setVariants(visualElement2, variantLabels) {\n  var reversedLabels = __spreadArray([], __read(variantLabels)).reverse();\n  reversedLabels.forEach(function(key6) {\n    var _a;\n    var variant = visualElement2.getVariant(key6);\n    variant && setTarget(visualElement2, variant);\n    (_a = visualElement2.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function(child) {\n      setVariants(child, variantLabels);\n    });\n  });\n}\nfunction setValues(visualElement2, definition) {\n  if (Array.isArray(definition)) {\n    return setVariants(visualElement2, definition);\n  } else if (typeof definition === \"string\") {\n    return setVariants(visualElement2, [definition]);\n  } else {\n    setTarget(visualElement2, definition);\n  }\n}\nfunction checkTargetForNewValues(visualElement2, target, origin) {\n  var _a, _b, _c;\n  var _d;\n  var newValueKeys = Object.keys(target).filter(function(key7) {\n    return !visualElement2.hasValue(key7);\n  });\n  var numNewValues = newValueKeys.length;\n  if (!numNewValues)\n    return;\n  for (var i = 0; i < numNewValues; i++) {\n    var key6 = newValueKeys[i];\n    var targetValue = target[key6];\n    var value = null;\n    if (Array.isArray(targetValue)) {\n      value = targetValue[0];\n    }\n    if (value === null) {\n      value = (_b = (_a = origin[key6]) !== null && _a !== void 0 ? _a : visualElement2.readValue(key6)) !== null && _b !== void 0 ? _b : target[key6];\n    }\n    if (value === void 0 || value === null)\n      continue;\n    if (typeof value === \"string\" && (isNumericalString(value) || value.startsWith(\"0\"))) {\n      value = parseFloat(value);\n    } else if (!findValueType(value) && complex.test(targetValue)) {\n      value = getAnimatableNone2(key6, targetValue);\n    }\n    visualElement2.addValue(key6, motionValue(value));\n    (_c = (_d = origin)[key6]) !== null && _c !== void 0 ? _c : _d[key6] = value;\n    visualElement2.setBaseTarget(key6, value);\n  }\n}\nfunction getOriginFromTransition(key6, transition) {\n  if (!transition)\n    return;\n  var valueTransition = transition[key6] || transition[\"default\"] || transition;\n  return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement2) {\n  var _a, _b;\n  var origin = {};\n  for (var key6 in target) {\n    origin[key6] = (_a = getOriginFromTransition(key6, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement2.getValue(key6)) === null || _b === void 0 ? void 0 : _b.get();\n  }\n  return origin;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/animation.js\nfunction animateVisualElement(visualElement2, definition, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  visualElement2.notifyAnimationStart();\n  var animation;\n  if (Array.isArray(definition)) {\n    var animations2 = definition.map(function(variant) {\n      return animateVariant(visualElement2, variant, options);\n    });\n    animation = Promise.all(animations2);\n  } else if (typeof definition === \"string\") {\n    animation = animateVariant(visualElement2, definition, options);\n  } else {\n    var resolvedDefinition = typeof definition === \"function\" ? resolveVariant(visualElement2, definition, options.custom) : definition;\n    animation = animateTarget(visualElement2, resolvedDefinition, options);\n  }\n  return animation.then(function() {\n    return visualElement2.notifyAnimationComplete(definition);\n  });\n}\nfunction animateVariant(visualElement2, variant, options) {\n  var _a;\n  if (options === void 0) {\n    options = {};\n  }\n  var resolved = resolveVariant(visualElement2, variant, options.custom);\n  var _b = (resolved || {}).transition, transition = _b === void 0 ? visualElement2.getDefaultTransition() || {} : _b;\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  var getAnimation2 = resolved ? function() {\n    return animateTarget(visualElement2, resolved, options);\n  } : function() {\n    return Promise.resolve();\n  };\n  var getChildAnimations = ((_a = visualElement2.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? function(forwardDelay) {\n    if (forwardDelay === void 0) {\n      forwardDelay = 0;\n    }\n    var _a2 = transition.delayChildren, delayChildren = _a2 === void 0 ? 0 : _a2, staggerChildren = transition.staggerChildren, staggerDirection = transition.staggerDirection;\n    return animateChildren(visualElement2, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n  } : function() {\n    return Promise.resolve();\n  };\n  var when = transition.when;\n  if (when) {\n    var _c = __read(when === \"beforeChildren\" ? [getAnimation2, getChildAnimations] : [getChildAnimations, getAnimation2], 2), first = _c[0], last = _c[1];\n    return first().then(last);\n  } else {\n    return Promise.all([getAnimation2(), getChildAnimations(options.delay)]);\n  }\n}\nfunction animateTarget(visualElement2, definition, _a) {\n  var _b;\n  var _c = _a === void 0 ? {} : _a, _d = _c.delay, delay = _d === void 0 ? 0 : _d, transitionOverride = _c.transitionOverride, type = _c.type;\n  var _e = visualElement2.makeTargetAnimatable(definition), _f = _e.transition, transition = _f === void 0 ? visualElement2.getDefaultTransition() : _f, transitionEnd = _e.transitionEnd, target = __rest(_e, [\"transition\", \"transitionEnd\"]);\n  if (transitionOverride)\n    transition = transitionOverride;\n  var animations2 = [];\n  var animationTypeState = type && ((_b = visualElement2.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);\n  for (var key6 in target) {\n    var value = visualElement2.getValue(key6);\n    var valueTarget = target[key6];\n    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key6)) {\n      continue;\n    }\n    var animation = startAnimation(key6, value, valueTarget, __assign({ delay }, transition));\n    animations2.push(animation);\n  }\n  return Promise.all(animations2).then(function() {\n    transitionEnd && setTarget(visualElement2, transitionEnd);\n  });\n}\nfunction animateChildren(visualElement2, variant, delayChildren, staggerChildren, staggerDirection, options) {\n  if (delayChildren === void 0) {\n    delayChildren = 0;\n  }\n  if (staggerChildren === void 0) {\n    staggerChildren = 0;\n  }\n  if (staggerDirection === void 0) {\n    staggerDirection = 1;\n  }\n  var animations2 = [];\n  var maxStaggerDuration = (visualElement2.variantChildren.size - 1) * staggerChildren;\n  var generateStaggerDuration = staggerDirection === 1 ? function(i) {\n    if (i === void 0) {\n      i = 0;\n    }\n    return i * staggerChildren;\n  } : function(i) {\n    if (i === void 0) {\n      i = 0;\n    }\n    return maxStaggerDuration - i * staggerChildren;\n  };\n  Array.from(visualElement2.variantChildren).sort(sortByTreeOrder).forEach(function(child, i) {\n    animations2.push(animateVariant(child, variant, __assign(__assign({}, options), { delay: delayChildren + generateStaggerDuration(i) })).then(function() {\n      return child.notifyAnimationComplete(variant);\n    }));\n  });\n  return Promise.all(animations2);\n}\nfunction stopAnimation(visualElement2) {\n  visualElement2.forEachValue(function(value) {\n    return value.stop();\n  });\n}\nfunction sortByTreeOrder(a2, b2) {\n  return a2.sortNodePosition(b2);\n}\nfunction shouldBlockAnimation(_a, key6) {\n  var protectedKeys = _a.protectedKeys, needsAnimating = _a.needsAnimating;\n  var shouldBlock = protectedKeys.hasOwnProperty(key6) && needsAnimating[key6] !== true;\n  needsAnimating[key6] = false;\n  return shouldBlock;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/animation-state.js\nvar variantPriorityOrder = [\n  AnimationType.Animate,\n  AnimationType.Hover,\n  AnimationType.Tap,\n  AnimationType.Drag,\n  AnimationType.Focus,\n  AnimationType.Exit\n];\nvar reversePriorityOrder = __spreadArray([], __read(variantPriorityOrder)).reverse();\nvar numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement2) {\n  return function(animations2) {\n    return Promise.all(animations2.map(function(_a) {\n      var animation = _a.animation, options = _a.options;\n      return animateVisualElement(visualElement2, animation, options);\n    }));\n  };\n}\nfunction createAnimationState(visualElement2) {\n  var animate4 = animateList(visualElement2);\n  var state = createState();\n  var allAnimatedKeys = {};\n  var isInitialRender = true;\n  var buildResolvedTypeValues = function(acc, definition) {\n    var resolved = resolveVariant(visualElement2, definition);\n    if (resolved) {\n      resolved.transition;\n      var transitionEnd = resolved.transitionEnd, target = __rest(resolved, [\"transition\", \"transitionEnd\"]);\n      acc = __assign(__assign(__assign({}, acc), target), transitionEnd);\n    }\n    return acc;\n  };\n  function isAnimated(key6) {\n    return allAnimatedKeys[key6] !== void 0;\n  }\n  function setAnimateFunction(makeAnimator) {\n    animate4 = makeAnimator(visualElement2);\n  }\n  function animateChanges(options, changedActiveType) {\n    var _a;\n    var props = visualElement2.getProps();\n    var context = visualElement2.getVariantContext(true) || {};\n    var animations2 = [];\n    var removedKeys = new Set();\n    var encounteredKeys = {};\n    var removedVariantIndex = Infinity;\n    var _loop_1 = function(i2) {\n      var type = reversePriorityOrder[i2];\n      var typeState = state[type];\n      var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n      var propIsVariant = isVariantLabel(prop);\n      var activeDelta = type === changedActiveType ? typeState.isActive : null;\n      if (activeDelta === false)\n        removedVariantIndex = i2;\n      var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n      if (isInherited && isInitialRender && visualElement2.manuallyAnimateOnMount) {\n        isInherited = false;\n      }\n      typeState.protectedKeys = __assign({}, encounteredKeys);\n      if (!typeState.isActive && activeDelta === null || !prop && !typeState.prevProp || isAnimationControls(prop) || typeof prop === \"boolean\") {\n        return \"continue\";\n      }\n      var shouldAnimateType = variantsHaveChanged(typeState.prevProp, prop) || type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || i2 > removedVariantIndex && propIsVariant;\n      var definitionList = Array.isArray(prop) ? prop : [prop];\n      var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n      if (activeDelta === false)\n        resolvedValues = {};\n      var _b = typeState.prevResolvedValues, prevResolvedValues = _b === void 0 ? {} : _b;\n      var allKeys = __assign(__assign({}, prevResolvedValues), resolvedValues);\n      var markToAnimate = function(key7) {\n        shouldAnimateType = true;\n        removedKeys.delete(key7);\n        typeState.needsAnimating[key7] = true;\n      };\n      for (var key6 in allKeys) {\n        var next = resolvedValues[key6];\n        var prev = prevResolvedValues[key6];\n        if (encounteredKeys.hasOwnProperty(key6))\n          continue;\n        if (next !== prev) {\n          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n            if (!shallowCompare(next, prev)) {\n              markToAnimate(key6);\n            } else {\n              typeState.protectedKeys[key6] = true;\n            }\n          } else if (next !== void 0) {\n            markToAnimate(key6);\n          } else {\n            removedKeys.add(key6);\n          }\n        } else if (next !== void 0 && removedKeys.has(key6)) {\n          markToAnimate(key6);\n        } else {\n          typeState.protectedKeys[key6] = true;\n        }\n      }\n      typeState.prevProp = prop;\n      typeState.prevResolvedValues = resolvedValues;\n      if (typeState.isActive) {\n        encounteredKeys = __assign(__assign({}, encounteredKeys), resolvedValues);\n      }\n      if (isInitialRender && visualElement2.blockInitialAnimation) {\n        shouldAnimateType = false;\n      }\n      if (shouldAnimateType && !isInherited) {\n        animations2.push.apply(animations2, __spreadArray([], __read(definitionList.map(function(animation) {\n          return {\n            animation,\n            options: __assign({ type }, options)\n          };\n        }))));\n      }\n    };\n    for (var i = 0; i < numAnimationTypes; i++) {\n      _loop_1(i);\n    }\n    allAnimatedKeys = __assign({}, encounteredKeys);\n    if (removedKeys.size) {\n      var fallbackAnimation_1 = {};\n      removedKeys.forEach(function(key6) {\n        var fallbackTarget = visualElement2.getBaseTarget(key6);\n        if (fallbackTarget !== void 0) {\n          fallbackAnimation_1[key6] = fallbackTarget;\n        }\n      });\n      animations2.push({ animation: fallbackAnimation_1 });\n    }\n    var shouldAnimate = Boolean(animations2.length);\n    if (isInitialRender && props.initial === false && !visualElement2.manuallyAnimateOnMount) {\n      shouldAnimate = false;\n    }\n    isInitialRender = false;\n    return shouldAnimate ? animate4(animations2) : Promise.resolve();\n  }\n  function setActive(type, isActive, options) {\n    var _a;\n    if (state[type].isActive === isActive)\n      return Promise.resolve();\n    (_a = visualElement2.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function(child) {\n      var _a2;\n      return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);\n    });\n    state[type].isActive = isActive;\n    return animateChanges(options, type);\n  }\n  return {\n    isAnimated,\n    animateChanges,\n    setActive,\n    setAnimateFunction,\n    getState: function() {\n      return state;\n    }\n  };\n}\nfunction variantsHaveChanged(prev, next) {\n  if (typeof next === \"string\") {\n    return next !== prev;\n  } else if (isVariantLabels(next)) {\n    return !shallowCompare(next, prev);\n  }\n  return false;\n}\nfunction createTypeState(isActive) {\n  if (isActive === void 0) {\n    isActive = false;\n  }\n  return {\n    isActive,\n    protectedKeys: {},\n    needsAnimating: {},\n    prevResolvedValues: {}\n  };\n}\nfunction createState() {\n  var _a;\n  return _a = {}, _a[AnimationType.Animate] = createTypeState(true), _a[AnimationType.Hover] = createTypeState(), _a[AnimationType.Tap] = createTypeState(), _a[AnimationType.Drag] = createTypeState(), _a[AnimationType.Focus] = createTypeState(), _a[AnimationType.Exit] = createTypeState(), _a;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/animations.js\nvar animations = {\n  animation: makeRenderlessComponent(function(_a) {\n    var visualElement2 = _a.visualElement, animate4 = _a.animate;\n    visualElement2.animationState || (visualElement2.animationState = createAnimationState(visualElement2));\n    if (isAnimationControls(animate4)) {\n      (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        return animate4.subscribe(visualElement2);\n      }, [animate4]);\n    }\n  }),\n  exit: makeRenderlessComponent(function(props) {\n    var custom = props.custom, visualElement2 = props.visualElement;\n    var _a = __read(usePresence(), 2), isPresent2 = _a[0], onExitComplete = _a[1];\n    var presenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PresenceContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n      var _a2, _b;\n      var animation = (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Exit, !isPresent2, { custom: (_b = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== null && _b !== void 0 ? _b : custom });\n      !isPresent2 && (animation === null || animation === void 0 ? void 0 : animation.then(onExitComplete));\n    }, [isPresent2]);\n  })\n};\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/use-drag.js\n\n\n// ../../node_modules/framer-motion/dist/es/gestures/PanSession.js\nvar PanSession = function() {\n  function PanSession2(event, handlers, _a) {\n    var _this = this;\n    var _b = _a === void 0 ? {} : _a, transformPagePoint = _b.transformPagePoint;\n    this.startEvent = null;\n    this.lastMoveEvent = null;\n    this.lastMoveEventInfo = null;\n    this.handlers = {};\n    this.updatePoint = function() {\n      if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))\n        return;\n      var info2 = getPanInfo(_this.lastMoveEventInfo, _this.history);\n      var isPanStarted = _this.startEvent !== null;\n      var isDistancePastThreshold = distance(info2.offset, { x: 0, y: 0 }) >= 3;\n      if (!isPanStarted && !isDistancePastThreshold)\n        return;\n      var point2 = info2.point;\n      var timestamp2 = getFrameData().timestamp;\n      _this.history.push(__assign(__assign({}, point2), { timestamp: timestamp2 }));\n      var _a2 = _this.handlers, onStart = _a2.onStart, onMove = _a2.onMove;\n      if (!isPanStarted) {\n        onStart && onStart(_this.lastMoveEvent, info2);\n        _this.startEvent = _this.lastMoveEvent;\n      }\n      onMove && onMove(_this.lastMoveEvent, info2);\n    };\n    this.handlePointerMove = function(event2, info2) {\n      _this.lastMoveEvent = event2;\n      _this.lastMoveEventInfo = transformPoint(info2, _this.transformPagePoint);\n      if (isMouseEvent(event2) && event2.buttons === 0) {\n        _this.handlePointerUp(event2, info2);\n        return;\n      }\n      es_default.update(_this.updatePoint, true);\n    };\n    this.handlePointerUp = function(event2, info2) {\n      _this.end();\n      var onEnd = _this.handlers.onEnd;\n      if (!onEnd || !_this.startEvent)\n        return;\n      var panInfo = getPanInfo(transformPoint(info2, _this.transformPagePoint), _this.history);\n      onEnd && onEnd(event2, panInfo);\n    };\n    if (isTouchEvent(event) && event.touches.length > 1)\n      return;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    var info = extractEventInfo(event);\n    var initialInfo = transformPoint(info, this.transformPagePoint);\n    var point = initialInfo.point;\n    var timestamp = getFrameData().timestamp;\n    this.history = [__assign(__assign({}, point), { timestamp })];\n    var onSessionStart = handlers.onSessionStart;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    this.removeListeners = pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n  }\n  PanSession2.prototype.updateHandlers = function(handlers) {\n    this.handlers = handlers;\n  };\n  PanSession2.prototype.end = function() {\n    this.removeListeners && this.removeListeners();\n    cancelSync.update(this.updatePoint);\n  };\n  return PanSession2;\n}();\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a2, b2) {\n  return { x: a2.x - b2.x, y: a2.y - b2.y };\n}\nfunction getPanInfo(_a, history) {\n  var point = _a.point;\n  return {\n    point,\n    delta: subtractPoint(point, lastDevicePoint(history)),\n    offset: subtractPoint(point, startDevicePoint(history)),\n    velocity: getVelocity2(history, 0.1)\n  };\n}\nfunction startDevicePoint(history) {\n  return history[0];\n}\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\nfunction getVelocity2(history, timeDelta2) {\n  if (history.length < 2) {\n    return { x: 0, y: 0 };\n  }\n  var i = history.length - 1;\n  var timestampedPoint = null;\n  var lastPoint = lastDevicePoint(history);\n  while (i >= 0) {\n    timestampedPoint = history[i];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta2)) {\n      break;\n    }\n    i--;\n  }\n  if (!timestampedPoint) {\n    return { x: 0, y: 0 };\n  }\n  var time3 = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;\n  if (time3 === 0) {\n    return { x: 0, y: 0 };\n  }\n  var currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time3,\n    y: (lastPoint.y - timestampedPoint.y) / time3\n  };\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n  return currentVelocity;\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/noop.js\nfunction noop(any) {\n  return any;\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/geometry/index.js\nfunction convertBoundingBoxToAxisBox(_a) {\n  var top = _a.top, left = _a.left, right = _a.right, bottom = _a.bottom;\n  return {\n    x: { min: left, max: right },\n    y: { min: top, max: bottom }\n  };\n}\nfunction convertAxisBoxToBoundingBox(_a) {\n  var x = _a.x, y = _a.y;\n  return {\n    top: y.min,\n    bottom: y.max,\n    left: x.min,\n    right: x.max\n  };\n}\nfunction transformBoundingBox(_a, transformPoint2) {\n  var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\n  if (transformPoint2 === void 0) {\n    transformPoint2 = noop;\n  }\n  var topLeft = transformPoint2({ x: left, y: top });\n  var bottomRight = transformPoint2({ x: right, y: bottom });\n  return {\n    top: topLeft.y,\n    left: topLeft.x,\n    bottom: bottomRight.y,\n    right: bottomRight.x\n  };\n}\nfunction axisBox() {\n  return { x: { min: 0, max: 1 }, y: { min: 0, max: 1 } };\n}\nfunction copyAxisBox(box) {\n  return {\n    x: __assign({}, box.x),\n    y: __assign({}, box.y)\n  };\n}\nvar zeroDelta = {\n  translate: 0,\n  scale: 1,\n  origin: 0,\n  originPoint: 0\n};\nfunction delta() {\n  return {\n    x: __assign({}, zeroDelta),\n    y: __assign({}, zeroDelta)\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/each-axis.js\nfunction eachAxis(handler) {\n  return [handler(\"x\"), handler(\"y\")];\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.js\nfunction applyConstraints(point, _a, elastic) {\n  var min = _a.min, max = _a.max;\n  if (min !== void 0 && point < min) {\n    point = elastic ? mix(min, point, elastic.min) : Math.max(point, min);\n  } else if (max !== void 0 && point > max) {\n    point = elastic ? mix(max, point, elastic.max) : Math.min(point, max);\n  }\n  return point;\n}\nfunction calcConstrainedMinPoint(point, length, progress2, constraints, elastic) {\n  var min = point - length * progress2;\n  return constraints ? applyConstraints(min, constraints, elastic) : min;\n}\nfunction calcRelativeAxisConstraints(axis, min, max) {\n  return {\n    min: min !== void 0 ? axis.min + min : void 0,\n    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0\n  };\n}\nfunction calcRelativeConstraints(layoutBox, _a) {\n  var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\n  return {\n    x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)\n  };\n}\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n  var _a;\n  var min = constraintsAxis.min - layoutAxis.min;\n  var max = constraintsAxis.max - layoutAxis.max;\n  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {\n    _a = __read([max, min], 2), min = _a[0], max = _a[1];\n  }\n  return {\n    min: layoutAxis.min + min,\n    max: layoutAxis.min + max\n  };\n}\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n  return {\n    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)\n  };\n}\nfunction calcPositionFromProgress(axis, constraints, progress2) {\n  var axisLength = axis.max - axis.min;\n  var min = mix(constraints.min, constraints.max - axisLength, progress2);\n  return { min, max: min + axisLength };\n}\nfunction rebaseAxisConstraints(layout, constraints) {\n  var relativeConstraints = {};\n  if (constraints.min !== void 0) {\n    relativeConstraints.min = constraints.min - layout.min;\n  }\n  if (constraints.max !== void 0) {\n    relativeConstraints.max = constraints.max - layout.min;\n  }\n  return relativeConstraints;\n}\nvar defaultElastic = 0.35;\nfunction resolveDragElastic(dragElastic) {\n  if (dragElastic === false) {\n    dragElastic = 0;\n  } else if (dragElastic === true) {\n    dragElastic = defaultElastic;\n  }\n  return {\n    x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n    y: resolveAxisElastic(dragElastic, \"top\", \"bottom\")\n  };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n  return {\n    min: resolvePointElastic(dragElastic, minLabel),\n    max: resolvePointElastic(dragElastic, maxLabel)\n  };\n}\nfunction resolvePointElastic(dragElastic, label) {\n  var _a;\n  return typeof dragElastic === \"number\" ? dragElastic : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/projection/measure.js\nfunction getBoundingBox(element, transformPagePoint) {\n  var box = element.getBoundingClientRect();\n  return convertBoundingBoxToAxisBox(transformBoundingBox(box, transformPagePoint));\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/geometry/delta-calc.js\nvar clampProgress = function(v) {\n  return clamp2(0, 1, v);\n};\nfunction isNear(value, target, maxDistance) {\n  if (target === void 0) {\n    target = 0;\n  }\n  if (maxDistance === void 0) {\n    maxDistance = 0.01;\n  }\n  return distance(value, target) < maxDistance;\n}\nfunction calcLength(axis) {\n  return axis.max - axis.min;\n}\nfunction calcOrigin2(source, target) {\n  var origin = 0.5;\n  var sourceLength = calcLength(source);\n  var targetLength = calcLength(target);\n  if (targetLength > sourceLength) {\n    origin = progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = progress(source.min, source.max - targetLength, target.min);\n  }\n  return clampProgress(origin);\n}\nfunction updateAxisDelta(delta2, source, target, origin) {\n  if (origin === void 0) {\n    origin = 0.5;\n  }\n  delta2.origin = origin;\n  delta2.originPoint = mix(source.min, source.max, delta2.origin);\n  delta2.scale = calcLength(target) / calcLength(source);\n  if (isNear(delta2.scale, 1, 1e-4))\n    delta2.scale = 1;\n  delta2.translate = mix(target.min, target.max, delta2.origin) - delta2.originPoint;\n  if (isNear(delta2.translate))\n    delta2.translate = 0;\n}\nfunction updateBoxDelta(delta2, source, target, origin) {\n  updateAxisDelta(delta2.x, source.x, target.x, defaultOrigin(origin.originX));\n  updateAxisDelta(delta2.y, source.y, target.y, defaultOrigin(origin.originY));\n}\nfunction defaultOrigin(origin) {\n  return typeof origin === \"number\" ? origin : 0.5;\n}\nfunction calcRelativeAxis(target, relative, parent) {\n  target.min = parent.min + relative.min;\n  target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(projection, parentProjection) {\n  calcRelativeAxis(projection.target.x, projection.relativeTarget.x, parentProjection.target.x);\n  calcRelativeAxis(projection.target.y, projection.relativeTarget.y, parentProjection.target.y);\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/compare-by-depth.js\nvar compareByDepth = function(a2, b2) {\n  return a2.depth - b2.depth;\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/projection/utils.js\nfunction updateTreeLayoutMeasurements(visualElement2, isRelativeDrag) {\n  withoutTreeTransform(visualElement2, function() {\n    var allChildren = collectProjectingChildren(visualElement2);\n    batchResetAndMeasure(allChildren);\n    updateLayoutMeasurement(visualElement2);\n  });\n  !isRelativeDrag && visualElement2.rebaseProjectionTarget(true, visualElement2.measureViewportBox(false));\n}\nfunction collectProjectingChildren(visualElement2) {\n  var children = [];\n  var addChild = function(child) {\n    if (child.projection.isEnabled || child.shouldResetTransform()) {\n      children.push(child);\n    }\n    child.children.forEach(addChild);\n  };\n  visualElement2.children.forEach(addChild);\n  return children.sort(compareByDepth);\n}\nfunction withoutTreeTransform(visualElement2, callback) {\n  var parent = visualElement2.parent;\n  var isEnabled = visualElement2.projection.isEnabled;\n  var shouldReset = isEnabled || visualElement2.shouldResetTransform();\n  shouldReset && visualElement2.resetTransform();\n  parent ? withoutTreeTransform(parent, callback) : callback();\n  shouldReset && visualElement2.restoreTransform();\n}\nfunction updateLayoutMeasurement(visualElement2) {\n  if (visualElement2.shouldResetTransform())\n    return;\n  var layoutState = visualElement2.getLayoutState();\n  visualElement2.notifyBeforeLayoutMeasure(layoutState.layout);\n  layoutState.isHydrated = true;\n  layoutState.layout = visualElement2.measureViewportBox();\n  layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\n  visualElement2.notifyLayoutMeasure(layoutState.layout, visualElement2.prevViewportBox || layoutState.layout);\n  es_default.update(function() {\n    return visualElement2.rebaseProjectionTarget();\n  });\n}\nfunction snapshotViewportBox(visualElement2) {\n  if (visualElement2.shouldResetTransform())\n    return;\n  visualElement2.prevViewportBox = visualElement2.measureViewportBox(false);\n  visualElement2.rebaseProjectionTarget(false, visualElement2.prevViewportBox);\n}\nfunction batchResetAndMeasure(order2) {\n  order2.forEach(function(child) {\n    return child.resetTransform();\n  });\n  order2.forEach(updateLayoutMeasurement);\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/layout/utils.js\nfunction tweenAxis(target, prev, next, p) {\n  target.min = mix(prev.min, next.min, p);\n  target.max = mix(prev.max, next.max, p);\n}\nfunction calcRelativeOffsetAxis(parent, child) {\n  return {\n    min: child.min - parent.min,\n    max: child.max - parent.min\n  };\n}\nfunction calcRelativeOffset(parent, child) {\n  return {\n    x: calcRelativeOffsetAxis(parent.x, child.x),\n    y: calcRelativeOffsetAxis(parent.y, child.y)\n  };\n}\nfunction checkIfParentHasChanged(prev, next) {\n  var prevId = prev.getLayoutId();\n  var nextId = next.getLayoutId();\n  return prevId !== nextId || nextId === void 0 && prev !== next;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/is-draggable.js\nfunction isDraggable(visualElement2) {\n  var _a = visualElement2.getProps(), drag2 = _a.drag, _dragX = _a._dragX;\n  return drag2 && !_dragX;\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/geometry/delta-apply.js\nfunction resetAxis(axis, originAxis) {\n  axis.min = originAxis.min;\n  axis.max = originAxis.max;\n}\nfunction resetBox(box, originBox) {\n  resetAxis(box.x, originBox.x);\n  resetAxis(box.y, originBox.y);\n}\nfunction scalePoint(point, scale2, originPoint) {\n  var distanceFromOrigin = point - originPoint;\n  var scaled = scale2 * distanceFromOrigin;\n  return originPoint + scaled;\n}\nfunction applyPointDelta(point, translate, scale2, originPoint, boxScale) {\n  if (boxScale !== void 0) {\n    point = scalePoint(point, boxScale, originPoint);\n  }\n  return scalePoint(point, scale2, originPoint) + translate;\n}\nfunction applyAxisDelta(axis, translate, scale2, originPoint, boxScale) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n  if (scale2 === void 0) {\n    scale2 = 1;\n  }\n  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);\n}\nfunction applyBoxDelta(box, _a) {\n  var x = _a.x, y = _a.y;\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\nfunction applyAxisTransforms(final, axis, transforms, _a) {\n  var _b = __read(_a, 3), key6 = _b[0], scaleKey = _b[1], originKey = _b[2];\n  final.min = axis.min;\n  final.max = axis.max;\n  var axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;\n  var originPoint = mix(axis.min, axis.max, axisOrigin);\n  applyAxisDelta(final, transforms[key6], transforms[scaleKey], originPoint, transforms.scale);\n}\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\nfunction applyBoxTransforms(finalBox, box, transforms) {\n  applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);\n  applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);\n}\nfunction removePointDelta(point, translate, scale2, originPoint, boxScale) {\n  point -= translate;\n  point = scalePoint(point, 1 / scale2, originPoint);\n  if (boxScale !== void 0) {\n    point = scalePoint(point, 1 / boxScale, originPoint);\n  }\n  return point;\n}\nfunction removeAxisDelta(axis, translate, scale2, origin, boxScale) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n  if (scale2 === void 0) {\n    scale2 = 1;\n  }\n  if (origin === void 0) {\n    origin = 0.5;\n  }\n  var originPoint = mix(axis.min, axis.max, origin) - translate;\n  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);\n  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);\n}\nfunction removeAxisTransforms(axis, transforms, _a) {\n  var _b = __read(_a, 3), key6 = _b[0], scaleKey = _b[1], originKey = _b[2];\n  removeAxisDelta(axis, transforms[key6], transforms[scaleKey], transforms[originKey], transforms.scale);\n}\nfunction removeBoxTransforms(box, transforms) {\n  removeAxisTransforms(box.x, transforms, xKeys);\n  removeAxisTransforms(box.y, transforms, yKeys);\n}\nfunction applyTreeDeltas(box, treeScale, treePath) {\n  var treeLength = treePath.length;\n  if (!treeLength)\n    return;\n  treeScale.x = treeScale.y = 1;\n  var node;\n  var delta2;\n  for (var i = 0; i < treeLength; i++) {\n    node = treePath[i];\n    delta2 = node.getLayoutState().delta;\n    treeScale.x *= delta2.x.scale;\n    treeScale.y *= delta2.y.scale;\n    applyBoxDelta(box, delta2);\n    if (isDraggable(node)) {\n      applyBoxTransforms(box, box, node.getLatestValues());\n    }\n  }\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/projection/convert-to-relative.js\nfunction convertToRelativeProjection(visualElement2, isLayoutDrag) {\n  if (isLayoutDrag === void 0) {\n    isLayoutDrag = true;\n  }\n  var projectionParent = visualElement2.getProjectionParent();\n  if (!projectionParent)\n    return false;\n  var offset;\n  if (isLayoutDrag) {\n    offset = calcRelativeOffset(projectionParent.projection.target, visualElement2.projection.target);\n    removeBoxTransforms(offset, projectionParent.getLatestValues());\n  } else {\n    offset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement2.getLayoutState().layout);\n  }\n  eachAxis(function(axis) {\n    return visualElement2.setProjectionTargetAxis(axis, offset[axis].min, offset[axis].max, true);\n  });\n  return true;\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.js\nvar elementDragControls = new WeakMap();\nvar lastPointerEvent;\nvar VisualElementDragControls = function() {\n  function VisualElementDragControls2(_a) {\n    var visualElement2 = _a.visualElement;\n    this.isDragging = false;\n    this.currentDirection = null;\n    this.constraints = false;\n    this.elastic = axisBox();\n    this.props = {};\n    this.hasMutatedConstraints = false;\n    this.cursorProgress = {\n      x: 0.5,\n      y: 0.5\n    };\n    this.originPoint = {};\n    this.openGlobalLock = null;\n    this.panSession = null;\n    this.visualElement = visualElement2;\n    this.visualElement.enableLayoutProjection();\n    elementDragControls.set(visualElement2, this);\n  }\n  VisualElementDragControls2.prototype.start = function(originEvent, _a) {\n    var _this = this;\n    var _b = _a === void 0 ? {} : _a, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c, cursorProgress = _b.cursorProgress;\n    var onSessionStart = function(event) {\n      _this.stopMotion();\n      _this.updateLayoutMeasurements();\n      snapToCursor && _this.snapToCursor(originEvent);\n      _this.isLayoutDrag() && _this.visualElement.lockProjectionTarget();\n      var point = getViewportPointFromEvent(event).point;\n      eachAxis(function(axis) {\n        var _a2 = _this.visualElement.projection.target[axis], min = _a2.min, max = _a2.max;\n        _this.cursorProgress[axis] = cursorProgress ? cursorProgress[axis] : progress(min, max, point[axis]);\n        var axisValue = _this.getAxisMotionValue(axis);\n        if (axisValue) {\n          _this.originPoint[axis] = axisValue.get();\n        }\n      });\n    };\n    var onStart = function(event, info) {\n      var _a2, _b2, _c2;\n      var _d = _this.props, drag2 = _d.drag, dragPropagation = _d.dragPropagation;\n      if (drag2 && !dragPropagation) {\n        if (_this.openGlobalLock)\n          _this.openGlobalLock();\n        _this.openGlobalLock = getGlobalLock(drag2);\n        if (!_this.openGlobalLock)\n          return;\n      }\n      _this.resolveDragConstraints();\n      _this.isDragging = true;\n      _this.currentDirection = null;\n      (_b2 = (_a2 = _this.props).onDragStart) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, event, info);\n      (_c2 = _this.visualElement.animationState) === null || _c2 === void 0 ? void 0 : _c2.setActive(AnimationType.Drag, true);\n    };\n    var onMove = function(event, info) {\n      var _a2, _b2, _c2, _d;\n      var _e = _this.props, dragPropagation = _e.dragPropagation, dragDirectionLock = _e.dragDirectionLock;\n      if (!dragPropagation && !_this.openGlobalLock)\n        return;\n      var offset = info.offset;\n      if (dragDirectionLock && _this.currentDirection === null) {\n        _this.currentDirection = getCurrentDirection(offset);\n        if (_this.currentDirection !== null) {\n          (_b2 = (_a2 = _this.props).onDirectionLock) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, _this.currentDirection);\n        }\n        return;\n      }\n      _this.updateAxis(\"x\", event, offset);\n      _this.updateAxis(\"y\", event, offset);\n      (_d = (_c2 = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c2, event, info);\n      lastPointerEvent = event;\n    };\n    var onEnd = function(event, info) {\n      return _this.stop(event, info);\n    };\n    var transformPagePoint = this.props.transformPagePoint;\n    this.panSession = new PanSession(originEvent, {\n      onSessionStart,\n      onStart,\n      onMove,\n      onEnd\n    }, { transformPagePoint });\n  };\n  VisualElementDragControls2.prototype.updateLayoutMeasurements = function() {\n    updateTreeLayoutMeasurements(this.visualElement, Boolean(this.getAxisMotionValue(\"x\") && !this.isExternalDrag()));\n  };\n  VisualElementDragControls2.prototype.resolveDragConstraints = function() {\n    var _this = this;\n    var _a = this.props, dragConstraints = _a.dragConstraints, dragElastic = _a.dragElastic;\n    this.visualElement.updateLayoutProjection();\n    var layout = this.visualElement.getLayoutState().layoutCorrected;\n    if (dragConstraints) {\n      this.constraints = isRefObject(dragConstraints) ? this.resolveRefConstraints(layout, dragConstraints) : calcRelativeConstraints(layout, dragConstraints);\n    } else {\n      this.constraints = false;\n    }\n    this.elastic = resolveDragElastic(dragElastic);\n    if (this.constraints && !this.hasMutatedConstraints) {\n      eachAxis(function(axis) {\n        if (_this.getAxisMotionValue(axis)) {\n          _this.constraints[axis] = rebaseAxisConstraints(layout[axis], _this.constraints[axis]);\n        }\n      });\n    }\n  };\n  VisualElementDragControls2.prototype.resolveRefConstraints = function(layoutBox, constraints) {\n    var _a = this.props, onMeasureDragConstraints = _a.onMeasureDragConstraints, transformPagePoint = _a.transformPagePoint;\n    var constraintsElement = constraints.current;\n    invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n    this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);\n    var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);\n    if (onMeasureDragConstraints) {\n      var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));\n      this.hasMutatedConstraints = !!userConstraints;\n      if (userConstraints) {\n        measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);\n      }\n    }\n    return measuredConstraints;\n  };\n  VisualElementDragControls2.prototype.cancelDrag = function() {\n    var _a;\n    this.isDragging = false;\n    this.panSession && this.panSession.end();\n    this.panSession = null;\n    if (!this.props.dragPropagation && this.openGlobalLock) {\n      this.openGlobalLock();\n      this.openGlobalLock = null;\n    }\n    (_a = this.visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Drag, false);\n  };\n  VisualElementDragControls2.prototype.stop = function(event, info) {\n    var _a, _b, _c;\n    this.visualElement.unlockProjectionTarget();\n    (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n    this.panSession = null;\n    var isDragging = this.isDragging;\n    this.cancelDrag();\n    if (!isDragging)\n      return;\n    var velocity = info.velocity;\n    this.animateDragEnd(velocity);\n    (_c = (_b = this.props).onDragEnd) === null || _c === void 0 ? void 0 : _c.call(_b, event, info);\n  };\n  VisualElementDragControls2.prototype.snapToCursor = function(event) {\n    var _this = this;\n    eachAxis(function(axis) {\n      var drag2 = _this.props.drag;\n      if (!shouldDrag(axis, drag2, _this.currentDirection))\n        return;\n      var axisValue = _this.getAxisMotionValue(axis);\n      if (axisValue) {\n        var point = getViewportPointFromEvent(event).point;\n        var box = _this.visualElement.getLayoutState().layout;\n        var length_1 = box[axis].max - box[axis].min;\n        var center = box[axis].min + length_1 / 2;\n        var offset = point[axis] - center;\n        _this.originPoint[axis] = point[axis];\n        axisValue.set(offset);\n      } else {\n        _this.cursorProgress[axis] = 0.5;\n        _this.updateVisualElementAxis(axis, event);\n      }\n    });\n  };\n  VisualElementDragControls2.prototype.updateAxis = function(axis, event, offset) {\n    var drag2 = this.props.drag;\n    if (!shouldDrag(axis, drag2, this.currentDirection))\n      return;\n    return this.getAxisMotionValue(axis) ? this.updateAxisMotionValue(axis, offset) : this.updateVisualElementAxis(axis, event);\n  };\n  VisualElementDragControls2.prototype.updateAxisMotionValue = function(axis, offset) {\n    var axisValue = this.getAxisMotionValue(axis);\n    if (!offset || !axisValue)\n      return;\n    var nextValue = this.originPoint[axis] + offset[axis];\n    var update = this.constraints ? applyConstraints(nextValue, this.constraints[axis], this.elastic[axis]) : nextValue;\n    axisValue.set(update);\n  };\n  VisualElementDragControls2.prototype.updateVisualElementAxis = function(axis, event) {\n    var _a;\n    var axisLayout = this.visualElement.getLayoutState().layout[axis];\n    var axisLength = axisLayout.max - axisLayout.min;\n    var axisProgress = this.cursorProgress[axis];\n    var point = getViewportPointFromEvent(event).point;\n    var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], this.elastic[axis]);\n    this.visualElement.setProjectionTargetAxis(axis, min, min + axisLength);\n  };\n  VisualElementDragControls2.prototype.setProps = function(_a) {\n    var _b = _a.drag, drag2 = _b === void 0 ? false : _b, _c = _a.dragDirectionLock, dragDirectionLock = _c === void 0 ? false : _c, _d = _a.dragPropagation, dragPropagation = _d === void 0 ? false : _d, _e = _a.dragConstraints, dragConstraints = _e === void 0 ? false : _e, _f = _a.dragElastic, dragElastic = _f === void 0 ? defaultElastic : _f, _g = _a.dragMomentum, dragMomentum = _g === void 0 ? true : _g, remainingProps = __rest(_a, [\"drag\", \"dragDirectionLock\", \"dragPropagation\", \"dragConstraints\", \"dragElastic\", \"dragMomentum\"]);\n    this.props = __assign({\n      drag: drag2,\n      dragDirectionLock,\n      dragPropagation,\n      dragConstraints,\n      dragElastic,\n      dragMomentum\n    }, remainingProps);\n  };\n  VisualElementDragControls2.prototype.getAxisMotionValue = function(axis) {\n    var _a = this.props, layout = _a.layout, layoutId = _a.layoutId;\n    var dragKey = \"_drag\" + axis.toUpperCase();\n    if (this.props[dragKey]) {\n      return this.props[dragKey];\n    } else if (!layout && layoutId === void 0) {\n      return this.visualElement.getValue(axis, 0);\n    }\n  };\n  VisualElementDragControls2.prototype.isLayoutDrag = function() {\n    return !this.getAxisMotionValue(\"x\");\n  };\n  VisualElementDragControls2.prototype.isExternalDrag = function() {\n    var _a = this.props, _dragX = _a._dragX, _dragY = _a._dragY;\n    return _dragX || _dragY;\n  };\n  VisualElementDragControls2.prototype.animateDragEnd = function(velocity) {\n    var _this = this;\n    var _a = this.props, drag2 = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition;\n    var isRelative = convertToRelativeProjection(this.visualElement, this.isLayoutDrag() && !this.isExternalDrag());\n    var constraints = this.constraints || {};\n    if (isRelative && Object.keys(constraints).length && this.isLayoutDrag()) {\n      var projectionParent = this.visualElement.getProjectionParent();\n      if (projectionParent) {\n        var relativeConstraints_1 = calcRelativeOffset(projectionParent.projection.targetFinal, constraints);\n        eachAxis(function(axis) {\n          var _a2 = relativeConstraints_1[axis], min = _a2.min, max = _a2.max;\n          constraints[axis] = {\n            min: isNaN(min) ? void 0 : min,\n            max: isNaN(max) ? void 0 : max\n          };\n        });\n      }\n    }\n    var momentumAnimations = eachAxis(function(axis) {\n      var _a2;\n      if (!shouldDrag(axis, drag2, _this.currentDirection)) {\n        return;\n      }\n      var transition = (_a2 = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a2 !== void 0 ? _a2 : {};\n      var bounceStiffness = dragElastic ? 200 : 1e6;\n      var bounceDamping = dragElastic ? 40 : 1e7;\n      var inertia2 = __assign(__assign({\n        type: \"inertia\",\n        velocity: dragMomentum ? velocity[axis] : 0,\n        bounceStiffness,\n        bounceDamping,\n        timeConstant: 750,\n        restDelta: 1,\n        restSpeed: 10\n      }, dragTransition), transition);\n      return _this.getAxisMotionValue(axis) ? _this.startAxisValueAnimation(axis, inertia2) : _this.visualElement.startLayoutAnimation(axis, inertia2, isRelative);\n    });\n    return Promise.all(momentumAnimations).then(function() {\n      var _a2, _b;\n      (_b = (_a2 = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a2);\n    });\n  };\n  VisualElementDragControls2.prototype.stopMotion = function() {\n    var _this = this;\n    eachAxis(function(axis) {\n      var axisValue = _this.getAxisMotionValue(axis);\n      axisValue ? axisValue.stop() : _this.visualElement.stopLayoutAnimation();\n    });\n  };\n  VisualElementDragControls2.prototype.startAxisValueAnimation = function(axis, transition) {\n    var axisValue = this.getAxisMotionValue(axis);\n    if (!axisValue)\n      return;\n    var currentValue = axisValue.get();\n    axisValue.set(currentValue);\n    axisValue.set(currentValue);\n    return startAnimation(axis, axisValue, 0, transition);\n  };\n  VisualElementDragControls2.prototype.scalePoint = function() {\n    var _this = this;\n    var _a = this.props, drag2 = _a.drag, dragConstraints = _a.dragConstraints;\n    if (!isRefObject(dragConstraints) || !this.constraintsBox)\n      return;\n    this.stopMotion();\n    var boxProgress = { x: 0, y: 0 };\n    eachAxis(function(axis) {\n      boxProgress[axis] = calcOrigin2(_this.visualElement.projection.target[axis], _this.constraintsBox[axis]);\n    });\n    this.updateLayoutMeasurements();\n    this.resolveDragConstraints();\n    eachAxis(function(axis) {\n      if (!shouldDrag(axis, drag2, null))\n        return;\n      var _a2 = calcPositionFromProgress(_this.visualElement.projection.target[axis], _this.constraintsBox[axis], boxProgress[axis]), min = _a2.min, max = _a2.max;\n      _this.visualElement.setProjectionTargetAxis(axis, min, max);\n    });\n  };\n  VisualElementDragControls2.prototype.mount = function(visualElement2) {\n    var _this = this;\n    var element = visualElement2.getInstance();\n    var stopPointerListener = addPointerEvent(element, \"pointerdown\", function(event) {\n      var _a = _this.props, drag2 = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;\n      drag2 && dragListener && _this.start(event);\n    });\n    var stopResizeListener = addDomEvent(window, \"resize\", function() {\n      _this.scalePoint();\n    });\n    var stopLayoutUpdateListener = visualElement2.onLayoutUpdate(function() {\n      if (_this.isDragging)\n        _this.resolveDragConstraints();\n    });\n    var prevDragCursor = visualElement2.prevDragCursor;\n    if (prevDragCursor) {\n      this.start(lastPointerEvent, { cursorProgress: prevDragCursor });\n    }\n    return function() {\n      stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();\n      stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();\n      stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();\n      _this.cancelDrag();\n    };\n  };\n  return VisualElementDragControls2;\n}();\nfunction shouldDrag(direction, drag2, currentDirection) {\n  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);\n}\nfunction getCurrentDirection(offset, lockThreshold) {\n  if (lockThreshold === void 0) {\n    lockThreshold = 10;\n  }\n  var direction = null;\n  if (Math.abs(offset.y) > lockThreshold) {\n    direction = \"y\";\n  } else if (Math.abs(offset.x) > lockThreshold) {\n    direction = \"x\";\n  }\n  return direction;\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/use-drag.js\nfunction useDrag(props) {\n  var groupDragControls = props.dragControls, visualElement2 = props.visualElement;\n  var transformPagePoint = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MotionConfigContext).transformPagePoint;\n  var dragControls = useConstant(function() {\n    return new VisualElementDragControls({\n      visualElement: visualElement2\n    });\n  });\n  dragControls.setProps(__assign(__assign({}, props), { transformPagePoint }));\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    return groupDragControls && groupDragControls.subscribe(dragControls);\n  }, [dragControls]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    return dragControls.mount(visualElement2);\n  }, []);\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/use-pan-gesture.js\n\nfunction usePanGesture(_a) {\n  var onPan = _a.onPan, onPanStart = _a.onPanStart, onPanEnd = _a.onPanEnd, onPanSessionStart = _a.onPanSessionStart, visualElement2 = _a.visualElement;\n  var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n  var panSession = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var transformPagePoint = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MotionConfigContext).transformPagePoint;\n  var handlers = {\n    onSessionStart: onPanSessionStart,\n    onStart: onPanStart,\n    onMove: onPan,\n    onEnd: function(event, info) {\n      panSession.current = null;\n      onPanEnd && onPanEnd(event, info);\n    }\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    if (panSession.current !== null) {\n      panSession.current.updateHandlers(handlers);\n    }\n  });\n  function onPointerDown(event) {\n    panSession.current = new PanSession(event, handlers, {\n      transformPagePoint\n    });\n  }\n  usePointerEvent(visualElement2, \"pointerdown\", hasPanEvents && onPointerDown);\n  useUnmountEffect(function() {\n    return panSession.current && panSession.current.end();\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/drag.js\nvar drag = {\n  pan: makeRenderlessComponent(usePanGesture),\n  drag: makeRenderlessComponent(useDrag)\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/layout/Animate.js\n\n\n// ../../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/types.js\nvar Presence;\n(function(Presence2) {\n  Presence2[Presence2[\"Entering\"] = 0] = \"Entering\";\n  Presence2[Presence2[\"Present\"] = 1] = \"Present\";\n  Presence2[Presence2[\"Exiting\"] = 2] = \"Exiting\";\n})(Presence || (Presence = {}));\nvar VisibilityAction;\n(function(VisibilityAction2) {\n  VisibilityAction2[VisibilityAction2[\"Hide\"] = 0] = \"Hide\";\n  VisibilityAction2[VisibilityAction2[\"Show\"] = 1] = \"Show\";\n})(VisibilityAction || (VisibilityAction = {}));\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.js\nfunction isCSSVariable2(value) {\n  return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n  var match = cssVariableRegex.exec(current);\n  if (!match)\n    return [,];\n  var _a = __read(match, 3), token = _a[1], fallback = _a[2];\n  return [token, fallback];\n}\nvar maxDepth = 4;\nfunction getVariableValue(current, element, depth) {\n  if (depth === void 0) {\n    depth = 1;\n  }\n  invariant(depth <= maxDepth, 'Max CSS variable fallback depth detected in property \"' + current + '\". This may indicate a circular fallback dependency.');\n  var _a = __read(parseCSSVariable(current), 2), token = _a[0], fallback = _a[1];\n  if (!token)\n    return;\n  var resolved = window.getComputedStyle(element).getPropertyValue(token);\n  if (resolved) {\n    return resolved.trim();\n  } else if (isCSSVariable2(fallback)) {\n    return getVariableValue(fallback, element, depth + 1);\n  } else {\n    return fallback;\n  }\n}\nfunction resolveCSSVariables(visualElement2, _a, transitionEnd) {\n  var _b;\n  var target = __rest(_a, []);\n  var element = visualElement2.getInstance();\n  if (!(element instanceof HTMLElement))\n    return { target, transitionEnd };\n  if (transitionEnd) {\n    transitionEnd = __assign({}, transitionEnd);\n  }\n  visualElement2.forEachValue(function(value) {\n    var current2 = value.get();\n    if (!isCSSVariable2(current2))\n      return;\n    var resolved2 = getVariableValue(current2, element);\n    if (resolved2)\n      value.set(resolved2);\n  });\n  for (var key6 in target) {\n    var current = target[key6];\n    if (!isCSSVariable2(current))\n      continue;\n    var resolved = getVariableValue(current, element);\n    if (!resolved)\n      continue;\n    target[key6] = resolved;\n    if (transitionEnd)\n      (_b = transitionEnd[key6]) !== null && _b !== void 0 ? _b : transitionEnd[key6] = current;\n  }\n  return { target, transitionEnd };\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/projection/default-scale-correctors.js\nfunction pixelsToPercent(pixels, axis) {\n  return pixels / (axis.max - axis.min) * 100;\n}\nfunction correctBorderRadius(latest, _layoutState, _a) {\n  var target = _a.target;\n  if (typeof latest === \"string\") {\n    if (px.test(latest)) {\n      latest = parseFloat(latest);\n    } else {\n      return latest;\n    }\n  }\n  var x = pixelsToPercent(latest, target.x);\n  var y = pixelsToPercent(latest, target.y);\n  return x + \"% \" + y + \"%\";\n}\nvar varToken = \"_$css\";\nfunction correctBoxShadow(latest, _a) {\n  var delta2 = _a.delta, treeScale = _a.treeScale;\n  var original = latest;\n  var containsCSSVariables = latest.includes(\"var(\");\n  var cssVariables = [];\n  if (containsCSSVariables) {\n    latest = latest.replace(cssVariableRegex, function(match) {\n      cssVariables.push(match);\n      return varToken;\n    });\n  }\n  var shadow = complex.parse(latest);\n  if (shadow.length > 5)\n    return original;\n  var template = complex.createTransformer(latest);\n  var offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n  var xScale = delta2.x.scale * treeScale.x;\n  var yScale = delta2.y.scale * treeScale.y;\n  shadow[0 + offset] /= xScale;\n  shadow[1 + offset] /= yScale;\n  var averageScale = mix(xScale, yScale, 0.5);\n  if (typeof shadow[2 + offset] === \"number\")\n    shadow[2 + offset] /= averageScale;\n  if (typeof shadow[3 + offset] === \"number\")\n    shadow[3 + offset] /= averageScale;\n  var output = template(shadow);\n  if (containsCSSVariables) {\n    var i_1 = 0;\n    output = output.replace(varToken, function() {\n      var cssVariable = cssVariables[i_1];\n      i_1++;\n      return cssVariable;\n    });\n  }\n  return output;\n}\nvar borderCorrectionDefinition = {\n  process: correctBorderRadius\n};\nvar defaultScaleCorrectors = {\n  borderRadius: __assign(__assign({}, borderCorrectionDefinition), { applyTo: [\n    \"borderTopLeftRadius\",\n    \"borderTopRightRadius\",\n    \"borderBottomLeftRadius\",\n    \"borderBottomRightRadius\"\n  ] }),\n  borderTopLeftRadius: borderCorrectionDefinition,\n  borderTopRightRadius: borderCorrectionDefinition,\n  borderBottomLeftRadius: borderCorrectionDefinition,\n  borderBottomRightRadius: borderCorrectionDefinition,\n  boxShadow: {\n    process: correctBoxShadow\n  }\n};\n\n// ../../node_modules/framer-motion/dist/es/motion/features/layout/Animate.js\nvar progressTarget = 1e3;\nvar Animate = function(_super) {\n  __extends(Animate2, _super);\n  function Animate2() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.frameTarget = axisBox();\n    _this.currentAnimationTarget = axisBox();\n    _this.isAnimating = {\n      x: false,\n      y: false\n    };\n    _this.stopAxisAnimation = {\n      x: void 0,\n      y: void 0\n    };\n    _this.isAnimatingTree = false;\n    _this.animate = function(target, origin, _a) {\n      if (_a === void 0) {\n        _a = {};\n      }\n      var originBox = _a.originBox, targetBox = _a.targetBox, visibilityAction = _a.visibilityAction, shouldStackAnimate = _a.shouldStackAnimate, onComplete = _a.onComplete, prevParent = _a.prevParent, config = __rest(_a, [\"originBox\", \"targetBox\", \"visibilityAction\", \"shouldStackAnimate\", \"onComplete\", \"prevParent\"]);\n      var _b = _this.props, visualElement2 = _b.visualElement, layout = _b.layout;\n      if (shouldStackAnimate === false) {\n        _this.isAnimatingTree = false;\n        return _this.safeToRemove();\n      }\n      if (_this.isAnimatingTree && shouldStackAnimate !== true) {\n        return;\n      } else if (shouldStackAnimate) {\n        _this.isAnimatingTree = true;\n      }\n      origin = originBox || origin;\n      target = targetBox || target;\n      var isRelative = false;\n      var projectionParent = visualElement2.getProjectionParent();\n      if (projectionParent) {\n        var prevParentViewportBox = projectionParent.prevViewportBox;\n        var parentLayout = projectionParent.getLayoutState().layout;\n        if (prevParent) {\n          if (targetBox) {\n            parentLayout = prevParent.getLayoutState().layout;\n          }\n          if (originBox && !checkIfParentHasChanged(prevParent, projectionParent) && prevParent.prevViewportBox) {\n            prevParentViewportBox = prevParent.prevViewportBox;\n          }\n        }\n        if (prevParentViewportBox && isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox)) {\n          isRelative = true;\n          origin = calcRelativeOffset(prevParentViewportBox, origin);\n          target = calcRelativeOffset(parentLayout, target);\n        }\n      }\n      var boxHasMoved = hasMoved(origin, target);\n      var animations2 = eachAxis(function(axis) {\n        var _a2, _b2;\n        if (layout === \"position\") {\n          var targetLength = target[axis].max - target[axis].min;\n          origin[axis].max = origin[axis].min + targetLength;\n        }\n        if (visualElement2.projection.isTargetLocked) {\n          return;\n        } else if (visibilityAction !== void 0) {\n          visualElement2.setVisibility(visibilityAction === VisibilityAction.Show);\n        } else if (boxHasMoved) {\n          return _this.animateAxis(axis, target[axis], origin[axis], __assign(__assign({}, config), { isRelative }));\n        } else {\n          (_b2 = (_a2 = _this.stopAxisAnimation)[axis]) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);\n          return visualElement2.setProjectionTargetAxis(axis, target[axis].min, target[axis].max, isRelative);\n        }\n      });\n      visualElement2.syncRender();\n      return Promise.all(animations2).then(function() {\n        _this.isAnimatingTree = false;\n        onComplete && onComplete();\n        visualElement2.notifyLayoutAnimationComplete();\n      });\n    };\n    return _this;\n  }\n  Animate2.prototype.componentDidMount = function() {\n    var _this = this;\n    var visualElement2 = this.props.visualElement;\n    visualElement2.animateMotionValue = startAnimation;\n    visualElement2.enableLayoutProjection();\n    this.unsubLayoutReady = visualElement2.onLayoutUpdate(this.animate);\n    visualElement2.layoutSafeToRemove = function() {\n      return _this.safeToRemove();\n    };\n    addScaleCorrection(defaultScaleCorrectors);\n  };\n  Animate2.prototype.componentWillUnmount = function() {\n    var _this = this;\n    this.unsubLayoutReady();\n    eachAxis(function(axis) {\n      var _a, _b;\n      return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a);\n    });\n  };\n  Animate2.prototype.animateAxis = function(axis, target, origin, _a) {\n    var _this = this;\n    var _b, _c;\n    var _d = _a === void 0 ? {} : _a, transition = _d.transition, isRelative = _d.isRelative;\n    if (this.isAnimating[axis] && axisIsEqual(target, this.currentAnimationTarget[axis])) {\n      return;\n    }\n    (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\n    this.isAnimating[axis] = true;\n    var visualElement2 = this.props.visualElement;\n    var frameTarget = this.frameTarget[axis];\n    var layoutProgress = visualElement2.getProjectionAnimationProgress()[axis];\n    layoutProgress.clearListeners();\n    layoutProgress.set(0);\n    layoutProgress.set(0);\n    var frame2 = function() {\n      var p = layoutProgress.get() / progressTarget;\n      tweenAxis(frameTarget, origin, target, p);\n      visualElement2.setProjectionTargetAxis(axis, frameTarget.min, frameTarget.max, isRelative);\n    };\n    frame2();\n    var unsubscribeProgress = layoutProgress.onChange(frame2);\n    this.stopAxisAnimation[axis] = function() {\n      _this.isAnimating[axis] = false;\n      layoutProgress.stop();\n      unsubscribeProgress();\n    };\n    this.currentAnimationTarget[axis] = target;\n    var layoutTransition = transition || visualElement2.getDefaultTransition() || defaultLayoutTransition;\n    var animation = startAnimation(axis === \"x\" ? \"layoutX\" : \"layoutY\", layoutProgress, progressTarget, layoutTransition && getValueTransition(layoutTransition, \"layout\")).then(this.stopAxisAnimation[axis]);\n    return animation;\n  };\n  Animate2.prototype.safeToRemove = function() {\n    var _a, _b;\n    (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\n  };\n  Animate2.prototype.render = function() {\n    return null;\n  };\n  return Animate2;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\nfunction AnimateLayoutContextProvider(props) {\n  var _a = __read(usePresence(), 2), safeToRemove = _a[1];\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Animate, __assign({}, props, { safeToRemove }));\n}\nfunction hasMoved(a2, b2) {\n  return !isZeroBox(a2) && !isZeroBox(b2) && (!axisIsEqual(a2.x, b2.x) || !axisIsEqual(a2.y, b2.y));\n}\nvar zeroAxis = { min: 0, max: 0 };\nfunction isZeroBox(a2) {\n  return axisIsEqual(a2.x, zeroAxis) && axisIsEqual(a2.y, zeroAxis);\n}\nfunction axisIsEqual(a2, b2) {\n  return a2.min === b2.min && a2.max === b2.max;\n}\nvar defaultLayoutTransition = {\n  duration: 0.45,\n  ease: [0.4, 0, 0.1, 1]\n};\nfunction isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox) {\n  return prevParent || !prevParent && !(originBox || targetBox);\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/layout/Measure.js\n\n\n// ../../node_modules/framer-motion/dist/es/context/SharedLayoutContext.js\n\n\n// ../../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/batcher.js\nvar defaultHandler = {\n  layoutReady: function(child) {\n    return child.notifyLayoutReady();\n  }\n};\nfunction createBatcher() {\n  var queue = new Set();\n  return {\n    add: function(child) {\n      return queue.add(child);\n    },\n    flush: function(_a) {\n      var _b = _a === void 0 ? defaultHandler : _a, layoutReady = _b.layoutReady, parent = _b.parent;\n      var order2 = Array.from(queue).sort(compareByDepth);\n      if (parent) {\n        withoutTreeTransform(parent, function() {\n          batchResetAndMeasure(order2);\n        });\n      } else {\n        batchResetAndMeasure(order2);\n      }\n      order2.forEach(layoutReady);\n      order2.forEach(function(child) {\n        if (child.isPresent)\n          child.presence = Presence.Present;\n      });\n      flushSync.preRender();\n      flushSync.render();\n      es_default.postRender(function() {\n        return order2.forEach(assignProjectionToSnapshot);\n      });\n      queue.clear();\n    }\n  };\n}\nfunction assignProjectionToSnapshot(child) {\n  child.prevViewportBox = child.projection.target;\n}\n\n// ../../node_modules/framer-motion/dist/es/context/SharedLayoutContext.js\nvar SharedLayoutContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(createBatcher());\nvar FramerTreeLayoutContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(createBatcher());\nfunction isSharedLayout(context) {\n  return !!context.forceUpdate;\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/layout/Measure.js\nvar Measure = function(_super) {\n  __extends(Measure2, _super);\n  function Measure2() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Measure2.prototype.componentDidMount = function() {\n    var _a = this.props, syncLayout = _a.syncLayout, framerSyncLayout = _a.framerSyncLayout, visualElement2 = _a.visualElement;\n    isSharedLayout(syncLayout) && syncLayout.register(visualElement2);\n    isSharedLayout(framerSyncLayout) && framerSyncLayout.register(visualElement2);\n    visualElement2.onUnmount(function() {\n      if (isSharedLayout(syncLayout)) {\n        syncLayout.remove(visualElement2);\n      }\n      if (isSharedLayout(framerSyncLayout)) {\n        framerSyncLayout.remove(visualElement2);\n      }\n    });\n  };\n  Measure2.prototype.getSnapshotBeforeUpdate = function() {\n    var _a = this.props, syncLayout = _a.syncLayout, visualElement2 = _a.visualElement;\n    if (isSharedLayout(syncLayout)) {\n      syncLayout.syncUpdate();\n    } else {\n      snapshotViewportBox(visualElement2);\n      syncLayout.add(visualElement2);\n    }\n    return null;\n  };\n  Measure2.prototype.componentDidUpdate = function() {\n    var syncLayout = this.props.syncLayout;\n    if (!isSharedLayout(syncLayout))\n      syncLayout.flush();\n  };\n  Measure2.prototype.render = function() {\n    return null;\n  };\n  return Measure2;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().Component));\nfunction MeasureContextProvider(props) {\n  var syncLayout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedLayoutContext);\n  var framerSyncLayout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FramerTreeLayoutContext);\n  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Measure, __assign({}, props, { syncLayout, framerSyncLayout }));\n}\n\n// ../../node_modules/framer-motion/dist/es/motion/features/layout/index.js\nvar layoutAnimations = {\n  measureLayout: MeasureContextProvider,\n  layoutAnimation: AnimateLayoutContextProvider\n};\n\n// ../../node_modules/framer-motion/dist/es/render/utils/state.js\nvar createProjectionState = function() {\n  return {\n    isEnabled: false,\n    isTargetLocked: false,\n    target: axisBox(),\n    targetFinal: axisBox()\n  };\n};\nfunction createLayoutState() {\n  return {\n    isHydrated: false,\n    layout: axisBox(),\n    layoutCorrected: axisBox(),\n    treeScale: { x: 1, y: 1 },\n    delta: delta(),\n    deltaFinal: delta(),\n    deltaTransform: \"\"\n  };\n}\nvar zeroLayout = createLayoutState();\n\n// ../../node_modules/framer-motion/dist/es/render/html/utils/build-projection-transform.js\nfunction buildLayoutProjectionTransform(_a, treeScale, latestTransform) {\n  var x = _a.x, y = _a.y;\n  var xTranslate = x.translate / treeScale.x;\n  var yTranslate = y.translate / treeScale.y;\n  var transform2 = \"translate3d(\" + xTranslate + \"px, \" + yTranslate + \"px, 0) \";\n  if (latestTransform) {\n    var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;\n    if (rotate)\n      transform2 += \"rotate(\" + rotate + \") \";\n    if (rotateX)\n      transform2 += \"rotateX(\" + rotateX + \") \";\n    if (rotateY)\n      transform2 += \"rotateY(\" + rotateY + \") \";\n  }\n  transform2 += \"scale(\" + x.scale + \", \" + y.scale + \")\";\n  return !latestTransform && transform2 === identityProjection ? \"\" : transform2;\n}\nfunction buildLayoutProjectionTransformOrigin(_a) {\n  var deltaFinal = _a.deltaFinal;\n  return deltaFinal.x.origin * 100 + \"% \" + deltaFinal.y.origin * 100 + \"% 0\";\n}\nvar identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, { x: 1, y: 1 });\n\n// ../../node_modules/framer-motion/dist/es/render/utils/lifecycles.js\nvar names = [\n  \"LayoutMeasure\",\n  \"BeforeLayoutMeasure\",\n  \"LayoutUpdate\",\n  \"ViewportBoxUpdate\",\n  \"Update\",\n  \"Render\",\n  \"AnimationComplete\",\n  \"LayoutAnimationComplete\",\n  \"AnimationStart\",\n  \"SetAxisTarget\",\n  \"Unmount\"\n];\nfunction createLifecycles() {\n  var managers = names.map(function() {\n    return new SubscriptionManager();\n  });\n  var propSubscriptions = {};\n  var lifecycles = {\n    clearAllListeners: function() {\n      return managers.forEach(function(manager) {\n        return manager.clear();\n      });\n    },\n    updatePropListeners: function(props) {\n      return names.forEach(function(name) {\n        var _a;\n        (_a = propSubscriptions[name]) === null || _a === void 0 ? void 0 : _a.call(propSubscriptions);\n        var on = \"on\" + name;\n        var propListener = props[on];\n        if (propListener) {\n          propSubscriptions[name] = lifecycles[on](propListener);\n        }\n      });\n    }\n  };\n  managers.forEach(function(manager, i) {\n    lifecycles[\"on\" + names[i]] = function(handler) {\n      return manager.add(handler);\n    };\n    lifecycles[\"notify\" + names[i]] = function() {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      return manager.notify.apply(manager, __spreadArray([], __read(args)));\n    };\n  });\n  return lifecycles;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/motion-values.js\nfunction updateMotionValuesFromProps(element, next, prev) {\n  var _a;\n  for (var key6 in next) {\n    var nextValue = next[key6];\n    var prevValue = prev[key6];\n    if (isMotionValue(nextValue)) {\n      element.addValue(key6, nextValue);\n    } else if (isMotionValue(prevValue)) {\n      element.addValue(key6, motionValue(nextValue));\n    } else if (prevValue !== nextValue) {\n      if (element.hasValue(key6)) {\n        var existingValue = element.getValue(key6);\n        !existingValue.hasAnimated && existingValue.set(nextValue);\n      } else {\n        element.addValue(key6, motionValue((_a = element.getStaticValue(key6)) !== null && _a !== void 0 ? _a : nextValue));\n      }\n    }\n  }\n  for (var key6 in prev) {\n    if (next[key6] === void 0)\n      element.removeValue(key6);\n  }\n  return next;\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/projection.js\nfunction updateLayoutDeltas(_a, _b, treePath, transformOrigin) {\n  var delta2 = _a.delta, layout = _a.layout, layoutCorrected = _a.layoutCorrected, treeScale = _a.treeScale;\n  var target = _b.target;\n  resetBox(layoutCorrected, layout);\n  applyTreeDeltas(layoutCorrected, treeScale, treePath);\n  updateBoxDelta(delta2, layoutCorrected, target, transformOrigin);\n}\n\n// ../../node_modules/framer-motion/dist/es/render/utils/flat-tree.js\nvar FlatTree = function() {\n  function FlatTree2() {\n    this.children = [];\n    this.isDirty = false;\n  }\n  FlatTree2.prototype.add = function(child) {\n    addUniqueItem(this.children, child);\n    this.isDirty = true;\n  };\n  FlatTree2.prototype.remove = function(child) {\n    removeItem(this.children, child);\n    this.isDirty = true;\n  };\n  FlatTree2.prototype.forEach = function(callback) {\n    this.isDirty && this.children.sort(compareByDepth);\n    this.isDirty = false;\n    this.children.forEach(callback);\n  };\n  return FlatTree2;\n}();\n\n// ../../node_modules/framer-motion/dist/es/render/dom/projection/relative-set.js\nfunction setCurrentViewportBox(visualElement2) {\n  var projectionParent = visualElement2.getProjectionParent();\n  if (!projectionParent) {\n    visualElement2.rebaseProjectionTarget();\n    return;\n  }\n  var relativeOffset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement2.getLayoutState().layout);\n  eachAxis(function(axis) {\n    visualElement2.setProjectionTargetAxis(axis, relativeOffset[axis].min, relativeOffset[axis].max, true);\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/render/index.js\nvar visualElement = function(_a) {\n  var _b = _a.treeType, treeType = _b === void 0 ? \"\" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, resetTransform = _a.resetTransform, restoreTransform = _a.restoreTransform, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps3 = _a.scrapeMotionValuesFromProps;\n  return function(_a2, options) {\n    var parent = _a2.parent, props = _a2.props, presenceId2 = _a2.presenceId, blockInitialAnimation = _a2.blockInitialAnimation, visualState = _a2.visualState;\n    if (options === void 0) {\n      options = {};\n    }\n    var latestValues = visualState.latestValues, renderState = visualState.renderState;\n    var instance;\n    var lifecycles = createLifecycles();\n    var projection = createProjectionState();\n    var projectionParent;\n    var leadProjection = projection;\n    var leadLatestValues = latestValues;\n    var unsubscribeFromLeadVisualElement;\n    var layoutState = createLayoutState();\n    var crossfader;\n    var hasViewportBoxUpdated = false;\n    var values = new Map();\n    var valueSubscriptions = new Map();\n    var prevMotionValues = {};\n    var projectionTargetProgress;\n    var baseTarget = __assign({}, latestValues);\n    var removeFromVariantTree;\n    function render() {\n      if (!instance)\n        return;\n      if (element.isProjectionReady()) {\n        applyBoxTransforms(leadProjection.targetFinal, leadProjection.target, leadLatestValues);\n        updateBoxDelta(layoutState.deltaFinal, layoutState.layoutCorrected, leadProjection.targetFinal, latestValues);\n      }\n      triggerBuild();\n      renderInstance(instance, renderState);\n    }\n    function triggerBuild() {\n      var valuesToRender = latestValues;\n      if (crossfader && crossfader.isActive()) {\n        var crossfadedValues = crossfader.getCrossfadeState(element);\n        if (crossfadedValues)\n          valuesToRender = crossfadedValues;\n      }\n      build(element, renderState, valuesToRender, leadProjection, layoutState, options, props);\n    }\n    function update() {\n      lifecycles.notifyUpdate(latestValues);\n    }\n    function updateLayoutProjection() {\n      var delta2 = layoutState.delta, treeScale = layoutState.treeScale;\n      var prevTreeScaleX = treeScale.x;\n      var prevTreeScaleY = treeScale.x;\n      var prevDeltaTransform = layoutState.deltaTransform;\n      updateLayoutDeltas(layoutState, leadProjection, element.path, latestValues);\n      hasViewportBoxUpdated && element.notifyViewportBoxUpdate(leadProjection.target, delta2);\n      hasViewportBoxUpdated = false;\n      var deltaTransform = buildLayoutProjectionTransform(delta2, treeScale);\n      if (deltaTransform !== prevDeltaTransform || prevTreeScaleX !== treeScale.x || prevTreeScaleY !== treeScale.y) {\n        element.scheduleRender();\n      }\n      layoutState.deltaTransform = deltaTransform;\n    }\n    function updateTreeLayoutProjection() {\n      element.layoutTree.forEach(fireUpdateLayoutProjection);\n    }\n    function bindToMotionValue(key7, value2) {\n      var removeOnChange = value2.onChange(function(latestValue) {\n        latestValues[key7] = latestValue;\n        props.onUpdate && es_default.update(update, false, true);\n      });\n      var removeOnRenderRequest = value2.onRenderRequest(element.scheduleRender);\n      valueSubscriptions.set(key7, function() {\n        removeOnChange();\n        removeOnRenderRequest();\n      });\n    }\n    var initialMotionValues = scrapeMotionValuesFromProps3(props);\n    for (var key6 in initialMotionValues) {\n      var value = initialMotionValues[key6];\n      if (latestValues[key6] !== void 0 && isMotionValue(value)) {\n        value.set(latestValues[key6], false);\n      }\n    }\n    var isControllingVariants = checkIfControllingVariants(props);\n    var isVariantNode = checkIfVariantNode(props);\n    var element = __assign(__assign({\n      treeType,\n      current: null,\n      depth: parent ? parent.depth + 1 : 0,\n      parent,\n      children: new Set(),\n      path: parent ? __spreadArray(__spreadArray([], __read(parent.path)), [parent]) : [],\n      layoutTree: parent ? parent.layoutTree : new FlatTree(),\n      presenceId: presenceId2,\n      projection,\n      variantChildren: isVariantNode ? new Set() : void 0,\n      isVisible: void 0,\n      manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),\n      blockInitialAnimation,\n      isHoverEventsEnabled: true,\n      isMounted: function() {\n        return Boolean(instance);\n      },\n      mount: function(newInstance) {\n        instance = element.current = newInstance;\n        element.pointTo(element);\n        if (isVariantNode && parent && !isControllingVariants) {\n          removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\n        }\n        parent === null || parent === void 0 ? void 0 : parent.children.add(element);\n      },\n      unmount: function() {\n        cancelSync.update(update);\n        cancelSync.render(render);\n        cancelSync.preRender(element.updateLayoutProjection);\n        valueSubscriptions.forEach(function(remove2) {\n          return remove2();\n        });\n        element.stopLayoutAnimation();\n        element.layoutTree.remove(element);\n        removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\n        parent === null || parent === void 0 ? void 0 : parent.children.delete(element);\n        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n        lifecycles.clearAllListeners();\n      },\n      addVariantChild: function(child) {\n        var _a3;\n        var closestVariantNode = element.getClosestVariantNode();\n        if (closestVariantNode) {\n          (_a3 = closestVariantNode.variantChildren) === null || _a3 === void 0 ? void 0 : _a3.add(child);\n          return function() {\n            return closestVariantNode.variantChildren.delete(child);\n          };\n        }\n      },\n      sortNodePosition: function(other) {\n        if (!sortNodePosition || treeType !== other.treeType)\n          return 0;\n        return sortNodePosition(element.getInstance(), other.getInstance());\n      },\n      getClosestVariantNode: function() {\n        return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\n      },\n      scheduleUpdateLayoutProjection: parent ? parent.scheduleUpdateLayoutProjection : function() {\n        return es_default.preRender(element.updateTreeLayoutProjection, false, true);\n      },\n      getLayoutId: function() {\n        return props.layoutId;\n      },\n      getInstance: function() {\n        return instance;\n      },\n      getStaticValue: function(key7) {\n        return latestValues[key7];\n      },\n      setStaticValue: function(key7, value2) {\n        return latestValues[key7] = value2;\n      },\n      getLatestValues: function() {\n        return latestValues;\n      },\n      setVisibility: function(visibility) {\n        if (element.isVisible === visibility)\n          return;\n        element.isVisible = visibility;\n        element.scheduleRender();\n      },\n      makeTargetAnimatable: function(target, canMutate) {\n        if (canMutate === void 0) {\n          canMutate = true;\n        }\n        return makeTargetAnimatable(element, target, props, canMutate);\n      },\n      suspendHoverEvents: function() {\n        element.isHoverEventsEnabled = false;\n        es_default.postRender(function() {\n          return setTimeout(function() {\n            return element.isHoverEventsEnabled = true;\n          }, 10);\n        });\n      },\n      addValue: function(key7, value2) {\n        if (element.hasValue(key7))\n          element.removeValue(key7);\n        values.set(key7, value2);\n        latestValues[key7] = value2.get();\n        bindToMotionValue(key7, value2);\n      },\n      removeValue: function(key7) {\n        var _a3;\n        values.delete(key7);\n        (_a3 = valueSubscriptions.get(key7)) === null || _a3 === void 0 ? void 0 : _a3();\n        valueSubscriptions.delete(key7);\n        delete latestValues[key7];\n        removeValueFromRenderState(key7, renderState);\n      },\n      hasValue: function(key7) {\n        return values.has(key7);\n      },\n      getValue: function(key7, defaultValue) {\n        var value2 = values.get(key7);\n        if (value2 === void 0 && defaultValue !== void 0) {\n          value2 = motionValue(defaultValue);\n          element.addValue(key7, value2);\n        }\n        return value2;\n      },\n      forEachValue: function(callback) {\n        return values.forEach(callback);\n      },\n      readValue: function(key7) {\n        var _a3;\n        return (_a3 = latestValues[key7]) !== null && _a3 !== void 0 ? _a3 : readValueFromInstance(instance, key7, options);\n      },\n      setBaseTarget: function(key7, value2) {\n        baseTarget[key7] = value2;\n      },\n      getBaseTarget: function(key7) {\n        if (getBaseTarget) {\n          var target = getBaseTarget(props, key7);\n          if (target !== void 0 && !isMotionValue(target))\n            return target;\n        }\n        return baseTarget[key7];\n      }\n    }, lifecycles), {\n      build: function() {\n        triggerBuild();\n        return renderState;\n      },\n      scheduleRender: function() {\n        es_default.render(render, false, true);\n      },\n      syncRender: render,\n      setProps: function(newProps) {\n        props = newProps;\n        lifecycles.updatePropListeners(newProps);\n        prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps3(props), prevMotionValues);\n      },\n      getProps: function() {\n        return props;\n      },\n      getVariant: function(name) {\n        var _a3;\n        return (_a3 = props.variants) === null || _a3 === void 0 ? void 0 : _a3[name];\n      },\n      getDefaultTransition: function() {\n        return props.transition;\n      },\n      getVariantContext: function(startAtParent) {\n        if (startAtParent === void 0) {\n          startAtParent = false;\n        }\n        if (startAtParent)\n          return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\n        if (!isControllingVariants) {\n          var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\n          if (props.initial !== void 0) {\n            context_1.initial = props.initial;\n          }\n          return context_1;\n        }\n        var context = {};\n        for (var i = 0; i < numVariantProps; i++) {\n          var name_1 = variantProps[i];\n          var prop = props[name_1];\n          if (isVariantLabel(prop) || prop === false) {\n            context[name_1] = prop;\n          }\n        }\n        return context;\n      },\n      enableLayoutProjection: function() {\n        projection.isEnabled = true;\n        element.layoutTree.add(element);\n      },\n      lockProjectionTarget: function() {\n        projection.isTargetLocked = true;\n      },\n      unlockProjectionTarget: function() {\n        element.stopLayoutAnimation();\n        projection.isTargetLocked = false;\n      },\n      getLayoutState: function() {\n        return layoutState;\n      },\n      setCrossfader: function(newCrossfader) {\n        crossfader = newCrossfader;\n      },\n      isProjectionReady: function() {\n        return projection.isEnabled && layoutState.isHydrated;\n      },\n      startLayoutAnimation: function(axis, transition, isRelative) {\n        if (isRelative === void 0) {\n          isRelative = false;\n        }\n        var progress2 = element.getProjectionAnimationProgress()[axis];\n        var _a3 = isRelative ? projection.relativeTarget[axis] : projection.target[axis], min = _a3.min, max = _a3.max;\n        var length = max - min;\n        progress2.clearListeners();\n        progress2.set(min);\n        progress2.set(min);\n        progress2.onChange(function(v) {\n          element.setProjectionTargetAxis(axis, v, v + length, isRelative);\n        });\n        return element.animateMotionValue(axis, progress2, 0, transition);\n      },\n      stopLayoutAnimation: function() {\n        eachAxis(function(axis) {\n          return element.getProjectionAnimationProgress()[axis].stop();\n        });\n      },\n      measureViewportBox: function(withTransform) {\n        if (withTransform === void 0) {\n          withTransform = true;\n        }\n        var viewportBox = measureViewportBox(instance, options);\n        if (!withTransform)\n          removeBoxTransforms(viewportBox, latestValues);\n        return viewportBox;\n      },\n      getProjectionAnimationProgress: function() {\n        projectionTargetProgress || (projectionTargetProgress = {\n          x: motionValue(0),\n          y: motionValue(0)\n        });\n        return projectionTargetProgress;\n      },\n      setProjectionTargetAxis: function(axis, min, max, isRelative) {\n        if (isRelative === void 0) {\n          isRelative = false;\n        }\n        var target;\n        if (isRelative) {\n          if (!projection.relativeTarget) {\n            projection.relativeTarget = axisBox();\n          }\n          target = projection.relativeTarget[axis];\n        } else {\n          projection.relativeTarget = void 0;\n          target = projection.target[axis];\n        }\n        target.min = min;\n        target.max = max;\n        hasViewportBoxUpdated = true;\n        lifecycles.notifySetAxisTarget();\n      },\n      rebaseProjectionTarget: function(force, box) {\n        if (box === void 0) {\n          box = layoutState.layout;\n        }\n        var _a3 = element.getProjectionAnimationProgress(), x = _a3.x, y = _a3.y;\n        var shouldRebase = !projection.relativeTarget && !projection.isTargetLocked && !x.isAnimating() && !y.isAnimating();\n        if (force || shouldRebase) {\n          eachAxis(function(axis) {\n            var _a4 = box[axis], min = _a4.min, max = _a4.max;\n            element.setProjectionTargetAxis(axis, min, max);\n          });\n        }\n      },\n      notifyLayoutReady: function(config) {\n        setCurrentViewportBox(element);\n        element.notifyLayoutUpdate(layoutState.layout, element.prevViewportBox || layoutState.layout, config);\n      },\n      resetTransform: function() {\n        return resetTransform(element, instance, props);\n      },\n      restoreTransform: function() {\n        return restoreTransform(instance, renderState);\n      },\n      updateLayoutProjection,\n      updateTreeLayoutProjection: function() {\n        element.layoutTree.forEach(fireResolveRelativeTargetBox);\n        es_default.preRender(updateTreeLayoutProjection, false, true);\n      },\n      getProjectionParent: function() {\n        if (projectionParent === void 0) {\n          var foundParent = false;\n          for (var i = element.path.length - 1; i >= 0; i--) {\n            var ancestor = element.path[i];\n            if (ancestor.projection.isEnabled) {\n              foundParent = ancestor;\n              break;\n            }\n          }\n          projectionParent = foundParent;\n        }\n        return projectionParent;\n      },\n      resolveRelativeTargetBox: function() {\n        var relativeParent = element.getProjectionParent();\n        if (!projection.relativeTarget || !relativeParent)\n          return;\n        calcRelativeBox(projection, relativeParent.projection);\n        if (isDraggable(relativeParent)) {\n          var target = projection.target;\n          applyBoxTransforms(target, target, relativeParent.getLatestValues());\n        }\n      },\n      shouldResetTransform: function() {\n        return Boolean(props._layoutResetTransform);\n      },\n      pointTo: function(newLead) {\n        leadProjection = newLead.projection;\n        leadLatestValues = newLead.getLatestValues();\n        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n        unsubscribeFromLeadVisualElement = pipe(newLead.onSetAxisTarget(element.scheduleUpdateLayoutProjection), newLead.onLayoutAnimationComplete(function() {\n          var _a3;\n          if (element.isPresent) {\n            element.presence = Presence.Present;\n          } else {\n            (_a3 = element.layoutSafeToRemove) === null || _a3 === void 0 ? void 0 : _a3.call(element);\n          }\n        }));\n      },\n      isPresent: true,\n      presence: Presence.Entering\n    });\n    return element;\n  };\n};\nfunction fireResolveRelativeTargetBox(child) {\n  child.resolveRelativeTargetBox();\n}\nfunction fireUpdateLayoutProjection(child) {\n  child.updateLayoutProjection();\n}\nvar variantProps = __spreadArray([\"initial\"], __read(variantPriorityOrder));\nvar numVariantProps = variantProps.length;\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.js\nvar positionalKeys = new Set([\n  \"width\",\n  \"height\",\n  \"top\",\n  \"left\",\n  \"right\",\n  \"bottom\",\n  \"x\",\n  \"y\"\n]);\nvar isPositionalKey = function(key6) {\n  return positionalKeys.has(key6);\n};\nvar hasPositionalKey = function(target) {\n  return Object.keys(target).some(isPositionalKey);\n};\nvar setAndResetVelocity = function(value, to) {\n  value.set(to, false);\n  value.set(to);\n};\nvar isNumOrPxType = function(v) {\n  return v === number || v === px;\n};\nvar BoundingBoxDimension;\n(function(BoundingBoxDimension2) {\n  BoundingBoxDimension2[\"width\"] = \"width\";\n  BoundingBoxDimension2[\"height\"] = \"height\";\n  BoundingBoxDimension2[\"left\"] = \"left\";\n  BoundingBoxDimension2[\"right\"] = \"right\";\n  BoundingBoxDimension2[\"top\"] = \"top\";\n  BoundingBoxDimension2[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\nvar getPosFromMatrix = function(matrix, pos) {\n  return parseFloat(matrix.split(\", \")[pos]);\n};\nvar getTranslateFromMatrix = function(pos2, pos3) {\n  return function(_bbox, _a) {\n    var transform2 = _a.transform;\n    if (transform2 === \"none\" || !transform2)\n      return 0;\n    var matrix3d = transform2.match(/^matrix3d\\((.+)\\)$/);\n    if (matrix3d) {\n      return getPosFromMatrix(matrix3d[1], pos3);\n    } else {\n      var matrix = transform2.match(/^matrix\\((.+)\\)$/);\n      if (matrix) {\n        return getPosFromMatrix(matrix[1], pos2);\n      } else {\n        return 0;\n      }\n    }\n  };\n};\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformProps.filter(function(key6) {\n  return !transformKeys.has(key6);\n});\nfunction removeNonTranslationalTransform(visualElement2) {\n  var removedTransforms = [];\n  nonTranslationalTransformKeys.forEach(function(key6) {\n    var value = visualElement2.getValue(key6);\n    if (value !== void 0) {\n      removedTransforms.push([key6, value.get()]);\n      value.set(key6.startsWith(\"scale\") ? 1 : 0);\n    }\n  });\n  if (removedTransforms.length)\n    visualElement2.syncRender();\n  return removedTransforms;\n}\nvar positionalValues = {\n  width: function(_a) {\n    var x = _a.x;\n    return x.max - x.min;\n  },\n  height: function(_a) {\n    var y = _a.y;\n    return y.max - y.min;\n  },\n  top: function(_bbox, _a) {\n    var top = _a.top;\n    return parseFloat(top);\n  },\n  left: function(_bbox, _a) {\n    var left = _a.left;\n    return parseFloat(left);\n  },\n  bottom: function(_a, _b) {\n    var y = _a.y;\n    var top = _b.top;\n    return parseFloat(top) + (y.max - y.min);\n  },\n  right: function(_a, _b) {\n    var x = _a.x;\n    var left = _b.left;\n    return parseFloat(left) + (x.max - x.min);\n  },\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\nvar convertChangedValueTypes = function(target, visualElement2, changedKeys) {\n  var originBbox = visualElement2.measureViewportBox();\n  var element = visualElement2.getInstance();\n  var elementComputedStyle = getComputedStyle(element);\n  var display = elementComputedStyle.display, top = elementComputedStyle.top, left = elementComputedStyle.left, bottom = elementComputedStyle.bottom, right = elementComputedStyle.right, transform2 = elementComputedStyle.transform;\n  var originComputedStyle = { top, left, bottom, right, transform: transform2 };\n  if (display === \"none\") {\n    visualElement2.setStaticValue(\"display\", target.display || \"block\");\n  }\n  visualElement2.syncRender();\n  var targetBbox = visualElement2.measureViewportBox();\n  changedKeys.forEach(function(key6) {\n    var value = visualElement2.getValue(key6);\n    setAndResetVelocity(value, positionalValues[key6](originBbox, originComputedStyle));\n    target[key6] = positionalValues[key6](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\nvar checkAndConvertChangedValueTypes = function(visualElement2, target, origin, transitionEnd) {\n  if (origin === void 0) {\n    origin = {};\n  }\n  if (transitionEnd === void 0) {\n    transitionEnd = {};\n  }\n  target = __assign({}, target);\n  transitionEnd = __assign({}, transitionEnd);\n  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n  var removedTransformValues = [];\n  var hasAttemptedToRemoveTransformValues = false;\n  var changedValueTypeKeys = [];\n  targetPositionalKeys.forEach(function(key6) {\n    var value = visualElement2.getValue(key6);\n    if (!visualElement2.hasValue(key6))\n      return;\n    var from = origin[key6];\n    var to = target[key6];\n    var fromType = findDimensionValueType(from);\n    var toType;\n    if (isKeyframesTarget(to)) {\n      var numKeyframes = to.length;\n      for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\n        if (!toType) {\n          toType = findDimensionValueType(to[i]);\n          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n    if (fromType !== toType) {\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        var current = value.get();\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n        if (typeof to === \"string\") {\n          target[key6] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === px) {\n          target[key6] = to.map(parseFloat);\n        }\n      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {\n        if (from === 0) {\n          value.set(toType.transform(from));\n        } else {\n          target[key6] = fromType.transform(to);\n        }\n      } else {\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement2);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n        changedValueTypeKeys.push(key6);\n        transitionEnd[key6] = transitionEnd[key6] !== void 0 ? transitionEnd[key6] : target[key6];\n        setAndResetVelocity(value, to);\n      }\n    }\n  });\n  if (changedValueTypeKeys.length) {\n    var convertedTarget = convertChangedValueTypes(target, visualElement2, changedValueTypeKeys);\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(function(_a) {\n        var _b = __read(_a, 2), key6 = _b[0], value = _b[1];\n        visualElement2.getValue(key6).set(value);\n      });\n    }\n    visualElement2.syncRender();\n    return { target: convertedTarget, transitionEnd };\n  } else {\n    return { target, transitionEnd };\n  }\n};\nfunction unitConversion(visualElement2, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement2, target, origin, transitionEnd) : { target, transitionEnd };\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/utils/parse-dom-variant.js\nvar parseDomVariant = function(visualElement2, target, origin, transitionEnd) {\n  var resolved = resolveCSSVariables(visualElement2, target, transitionEnd);\n  target = resolved.target;\n  transitionEnd = resolved.transitionEnd;\n  return unitConversion(visualElement2, target, origin, transitionEnd);\n};\n\n// ../../node_modules/framer-motion/dist/es/render/html/visual-element.js\nfunction getComputedStyle2(element) {\n  return window.getComputedStyle(element);\n}\nvar htmlConfig = {\n  treeType: \"dom\",\n  readValueFromInstance: function(domElement, key6) {\n    var _a;\n    if (isTransformProp(key6)) {\n      var defaultType = getDefaultValueType(key6);\n      return (_a = defaultType === null || defaultType === void 0 ? void 0 : defaultType.default) !== null && _a !== void 0 ? _a : 0;\n    } else {\n      var computedStyle = getComputedStyle2(domElement);\n      return (isCSSVariable(key6) ? computedStyle.getPropertyValue(key6) : computedStyle[key6]) || 0;\n    }\n  },\n  sortNodePosition: function(a2, b2) {\n    return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;\n  },\n  getBaseTarget: function(props, key6) {\n    var _a, _b;\n    var defaultType = getDefaultValueType(key6);\n    return (_b = (_a = props.style) === null || _a === void 0 ? void 0 : _a[key6]) !== null && _b !== void 0 ? _b : defaultType === null || defaultType === void 0 ? void 0 : defaultType.default;\n  },\n  measureViewportBox: function(element, _a) {\n    var transformPagePoint = _a.transformPagePoint;\n    return getBoundingBox(element, transformPagePoint);\n  },\n  resetTransform: function(element, domElement, props) {\n    element.suspendHoverEvents();\n    var transformTemplate2 = props.transformTemplate;\n    domElement.style.transform = transformTemplate2 ? transformTemplate2({}, \"\") : \"none\";\n    element.scheduleRender();\n  },\n  restoreTransform: function(instance, mutableState) {\n    instance.style.transform = mutableState.style.transform;\n  },\n  removeValueFromRenderState: function(key6, _a) {\n    var vars = _a.vars, style = _a.style;\n    delete vars[key6];\n    delete style[key6];\n  },\n  makeTargetAnimatable: function(element, _a, _b, isMounted) {\n    var transformValues3 = _b.transformValues;\n    if (isMounted === void 0) {\n      isMounted = true;\n    }\n    var transition = _a.transition, transitionEnd = _a.transitionEnd, target = __rest(_a, [\"transition\", \"transitionEnd\"]);\n    var origin = getOrigin(target, transition || {}, element);\n    if (transformValues3) {\n      if (transitionEnd)\n        transitionEnd = transformValues3(transitionEnd);\n      if (target)\n        target = transformValues3(target);\n      if (origin)\n        origin = transformValues3(origin);\n    }\n    if (isMounted) {\n      checkTargetForNewValues(element, target, origin);\n      var parsed = parseDomVariant(element, target, origin, transitionEnd);\n      transitionEnd = parsed.transitionEnd;\n      target = parsed.target;\n    }\n    return __assign({\n      transition,\n      transitionEnd\n    }, target);\n  },\n  scrapeMotionValuesFromProps,\n  build: function(element, renderState, latestValues, projection, layoutState, options, props) {\n    if (element.isVisible !== void 0) {\n      renderState.style.visibility = element.isVisible ? \"visible\" : \"hidden\";\n    }\n    var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;\n    buildHTMLStyles(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : void 0, isProjectionTranform ? buildLayoutProjectionTransformOrigin : void 0);\n  },\n  render: renderHTML\n};\nvar htmlVisualElement = visualElement(htmlConfig);\n\n// ../../node_modules/framer-motion/dist/es/render/svg/visual-element.js\nvar svgVisualElement = visualElement(__assign(__assign({}, htmlConfig), {\n  getBaseTarget: function(props, key6) {\n    return props[key6];\n  },\n  readValueFromInstance: function(domElement, key6) {\n    var _a;\n    if (isTransformProp(key6)) {\n      return ((_a = getDefaultValueType(key6)) === null || _a === void 0 ? void 0 : _a.default) || 0;\n    }\n    key6 = !camelCaseAttributes.has(key6) ? camelToDash(key6) : key6;\n    return domElement.getAttribute(key6);\n  },\n  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,\n  build: function(_element, renderState, latestValues, projection, layoutState, options, props) {\n    var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;\n    buildSVGAttrs(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : void 0, isProjectionTranform ? buildLayoutProjectionTransformOrigin : void 0);\n  },\n  render: renderSVG\n}));\n\n// ../../node_modules/framer-motion/dist/es/render/dom/create-visual-element.js\nvar createDomVisualElement = function(Component19, options) {\n  return isSVGComponent(Component19) ? svgVisualElement(options, { enableHardwareAcceleration: false }) : htmlVisualElement(options, { enableHardwareAcceleration: true });\n};\n\n// ../../node_modules/framer-motion/dist/es/render/dom/motion.js\nvar featureBundle = __assign(__assign(__assign(__assign({}, animations), gestureAnimations), drag), layoutAnimations);\nvar motion = /* @__PURE__ */ createMotionProxy(function(Component19, config) {\n  return createDomMotionConfig(Component19, config, featureBundle, createDomVisualElement);\n});\nfunction createDomMotionComponent(key6) {\n  return createMotionComponent(createDomMotionConfig(key6, { forwardMotionProps: false }, featureBundle, createDomVisualElement));\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/motion-minimal.js\nvar m = createMotionProxy(createDomMotionConfig);\n\n// ../../node_modules/framer-motion/dist/es/components/AnimatePresence/index.js\n\n\n\n// ../../node_modules/framer-motion/dist/es/utils/use-force-update.js\n\nfunction useForceUpdate() {\n  var unloadingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  var _a = __read((0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), 2), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];\n  useUnmountEffect(function() {\n    return unloadingRef.current = true;\n  });\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n    !unloadingRef.current && setForcedRenderCount(forcedRenderCount + 1);\n  }, [forcedRenderCount]);\n}\n\n// ../../node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.js\n\n\nvar presenceId = 0;\nfunction getPresenceId() {\n  var id = presenceId;\n  presenceId++;\n  return id;\n}\nvar PresenceChild = function(_a) {\n  var children = _a.children, initial = _a.initial, isPresent2 = _a.isPresent, onExitComplete = _a.onExitComplete, custom = _a.custom, presenceAffectsLayout = _a.presenceAffectsLayout;\n  var presenceChildren = useConstant(newChildrenMap);\n  var id = useConstant(getPresenceId);\n  var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function() {\n    return {\n      id,\n      initial,\n      isPresent: isPresent2,\n      custom,\n      onExitComplete: function(childId) {\n        presenceChildren.set(childId, true);\n        var allComplete = true;\n        presenceChildren.forEach(function(isComplete) {\n          if (!isComplete)\n            allComplete = false;\n        });\n        allComplete && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n      },\n      register: function(childId) {\n        presenceChildren.set(childId, false);\n        return function() {\n          return presenceChildren.delete(childId);\n        };\n      }\n    };\n  }, presenceAffectsLayout ? void 0 : [isPresent2]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function() {\n    presenceChildren.forEach(function(_, key6) {\n      return presenceChildren.set(key6, false);\n    });\n  }, [isPresent2]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    !isPresent2 && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n  }, [isPresent2]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(PresenceContext.Provider, { value: context }, children);\n};\nfunction newChildrenMap() {\n  return new Map();\n}\n\n// ../../node_modules/framer-motion/dist/es/components/AnimatePresence/index.js\nfunction getChildKey(child) {\n  return child.key || \"\";\n}\nfunction updateChildLookup(children, allChildren) {\n  var seenChildren =  true ? new Set() : 0;\n  children.forEach(function(child) {\n    var key6 = getChildKey(child);\n    if (seenChildren) {\n      if (seenChildren.has(key6)) {\n        console.warn('Children of AnimatePresence require unique keys. \"' + key6 + '\" is a duplicate.');\n      }\n      seenChildren.add(key6);\n    }\n    allChildren.set(key6, child);\n  });\n}\nfunction onlyElements(children) {\n  var filtered = [];\n  react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(children, function(child) {\n    if ((0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(child))\n      filtered.push(child);\n  });\n  return filtered;\n}\nvar AnimatePresence = function(_a) {\n  var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter, _c = _a.presenceAffectsLayout, presenceAffectsLayout = _c === void 0 ? true : _c;\n  var forceRender = useForceUpdate();\n  var layoutContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedLayoutContext);\n  if (isSharedLayout(layoutContext)) {\n    forceRender = layoutContext.forceUpdate;\n  }\n  var isInitialRender = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n  var filteredChildren = onlyElements(children);\n  var presentChildren = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(filteredChildren);\n  var allChildren = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map()).current;\n  var exiting = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Set()).current;\n  updateChildLookup(filteredChildren, allChildren);\n  if (isInitialRender.current) {\n    isInitialRender.current = false;\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, filteredChildren.map(function(child) {\n      return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? void 0 : false, presenceAffectsLayout }, child);\n    }));\n  }\n  var childrenToRender = __spreadArray([], __read(filteredChildren));\n  var presentKeys = presentChildren.current.map(getChildKey);\n  var targetKeys = filteredChildren.map(getChildKey);\n  var numPresent = presentKeys.length;\n  for (var i = 0; i < numPresent; i++) {\n    var key6 = presentKeys[i];\n    if (targetKeys.indexOf(key6) === -1) {\n      exiting.add(key6);\n    } else {\n      exiting.delete(key6);\n    }\n  }\n  if (exitBeforeEnter && exiting.size) {\n    childrenToRender = [];\n  }\n  exiting.forEach(function(key7) {\n    if (targetKeys.indexOf(key7) !== -1)\n      return;\n    var child = allChildren.get(key7);\n    if (!child)\n      return;\n    var insertionIndex = presentKeys.indexOf(key7);\n    var onExit = function() {\n      allChildren.delete(key7);\n      exiting.delete(key7);\n      var removeIndex = presentChildren.current.findIndex(function(presentChild) {\n        return presentChild.key === key7;\n      });\n      presentChildren.current.splice(removeIndex, 1);\n      if (!exiting.size) {\n        presentChildren.current = filteredChildren;\n        forceRender();\n        onExitComplete && onExitComplete();\n      }\n    };\n    childrenToRender.splice(insertionIndex, 0, (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom, presenceAffectsLayout }, child));\n  });\n  childrenToRender = childrenToRender.map(function(child) {\n    var key7 = child.key;\n    return exiting.has(key7) ? child : (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout }, child);\n  });\n  presentChildren.current = childrenToRender;\n  if (exitBeforeEnter && childrenToRender.length > 1) {\n    console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n  }\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(function(child) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(child);\n  }));\n};\n\n// ../../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/index.js\n\n\n// ../../node_modules/framer-motion/dist/es/animation/animate.js\nfunction animate2(from, to, transition) {\n  if (transition === void 0) {\n    transition = {};\n  }\n  var value = isMotionValue(from) ? from : motionValue(from);\n  startAnimation(\"\", value, to, transition);\n  return {\n    stop: function() {\n      return value.stop();\n    }\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/crossfader.js\nfunction createCrossfader() {\n  var progress2 = motionValue(1);\n  var options = {\n    lead: void 0,\n    follow: void 0,\n    crossfadeOpacity: false,\n    preserveFollowOpacity: false\n  };\n  var prevOptions = __assign({}, options);\n  var leadState = {};\n  var followState = {};\n  var isActive = false;\n  var finalCrossfadeFrame = null;\n  var prevUpdate = 0;\n  function startCrossfadeAnimation(target, transition) {\n    var lead = options.lead, follow = options.follow;\n    isActive = true;\n    finalCrossfadeFrame = null;\n    var hasUpdated = false;\n    var onUpdate = function() {\n      hasUpdated = true;\n      lead && lead.scheduleRender();\n      follow && follow.scheduleRender();\n    };\n    var onComplete = function() {\n      isActive = false;\n      finalCrossfadeFrame = getFrameData().timestamp;\n    };\n    transition = transition && getValueTransition(transition, \"crossfade\");\n    return animate2(progress2, target, __assign(__assign({}, transition), { onUpdate, onComplete: function() {\n      if (!hasUpdated) {\n        progress2.set(target);\n        es_default.read(onComplete);\n      } else {\n        onComplete();\n      }\n      onUpdate();\n    } }));\n  }\n  function updateCrossfade() {\n    var _a, _b;\n    var timestamp = getFrameData().timestamp;\n    var lead = options.lead, follow = options.follow;\n    if (timestamp === prevUpdate || !lead)\n      return;\n    prevUpdate = timestamp;\n    var latestLeadValues = lead.getLatestValues();\n    Object.assign(leadState, latestLeadValues);\n    var latestFollowValues = follow ? follow.getLatestValues() : options.prevValues;\n    Object.assign(followState, latestFollowValues);\n    var p = progress2.get();\n    var leadTargetOpacity = (_a = latestLeadValues.opacity) !== null && _a !== void 0 ? _a : 1;\n    var followTargetOpacity = (_b = latestFollowValues === null || latestFollowValues === void 0 ? void 0 : latestFollowValues.opacity) !== null && _b !== void 0 ? _b : 1;\n    if (options.crossfadeOpacity && follow) {\n      leadState.opacity = mix(follow.isVisible !== false ? 0 : followTargetOpacity, leadTargetOpacity, easeCrossfadeIn(p));\n      followState.opacity = options.preserveFollowOpacity ? followTargetOpacity : mix(followTargetOpacity, 0, easeCrossfadeOut(p));\n    } else if (!follow) {\n      leadState.opacity = mix(followTargetOpacity, leadTargetOpacity, p);\n    }\n    mixValues(leadState, followState, latestLeadValues, latestFollowValues || {}, Boolean(follow), p);\n  }\n  return {\n    isActive: function() {\n      return leadState && (isActive || getFrameData().timestamp === finalCrossfadeFrame);\n    },\n    fromLead: function(transition) {\n      return startCrossfadeAnimation(0, transition);\n    },\n    toLead: function(transition) {\n      var initialProgress = 0;\n      if (!options.prevValues && !options.follow) {\n        initialProgress = 1;\n      } else if (prevOptions.lead === options.follow && prevOptions.follow === options.lead) {\n        initialProgress = 1 - progress2.get();\n      }\n      progress2.set(initialProgress);\n      return startCrossfadeAnimation(1, transition);\n    },\n    reset: function() {\n      return progress2.set(1);\n    },\n    stop: function() {\n      return progress2.stop();\n    },\n    getCrossfadeState: function(element) {\n      updateCrossfade();\n      if (element === options.lead) {\n        return leadState;\n      } else if (element === options.follow) {\n        return followState;\n      }\n    },\n    setOptions: function(newOptions) {\n      prevOptions = options;\n      options = newOptions;\n      leadState = {};\n      followState = {};\n    },\n    getLatestValues: function() {\n      return leadState;\n    }\n  };\n}\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear);\nfunction compress(min, max, easing) {\n  return function(p) {\n    if (p < min)\n      return 0;\n    if (p > max)\n      return 1;\n    return easing(progress(min, max, p));\n  };\n}\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\nfunction mixValues(leadState, followState, latestLeadValues, latestFollowValues, hasFollowElement, p) {\n  for (var i = 0; i < numBorders; i++) {\n    var borderLabel = \"border\" + borders[i] + \"Radius\";\n    var followRadius = getRadius(latestFollowValues, borderLabel);\n    var leadRadius = getRadius(latestLeadValues, borderLabel);\n    if (followRadius === void 0 && leadRadius === void 0)\n      continue;\n    followRadius || (followRadius = 0);\n    leadRadius || (leadRadius = 0);\n    if (typeof followRadius === \"number\" && typeof leadRadius === \"number\") {\n      var radius = Math.max(mix(followRadius, leadRadius, p), 0);\n      leadState[borderLabel] = followState[borderLabel] = radius;\n    }\n  }\n  if (latestFollowValues.rotate || latestLeadValues.rotate) {\n    var rotate = mix(latestFollowValues.rotate || 0, latestLeadValues.rotate || 0, p);\n    leadState.rotate = followState.rotate = rotate;\n  }\n  if (!hasFollowElement && latestLeadValues.backgroundColor && latestFollowValues.backgroundColor) {\n    leadState.backgroundColor = followState.backgroundColor = mixColor(latestFollowValues.backgroundColor, latestLeadValues.backgroundColor)(p);\n  }\n}\nfunction getRadius(values, radiusName) {\n  var _a;\n  return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\n\n// ../../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/stack.js\nfunction layoutStack() {\n  var stack = new Set();\n  var state = { leadIsExiting: false };\n  var prevState = __assign({}, state);\n  var prevValues;\n  var prevViewportBox;\n  var prevDragCursor;\n  var crossfader = createCrossfader();\n  var needsCrossfadeAnimation = false;\n  function getFollowViewportBox() {\n    return state.follow ? state.follow.prevViewportBox : prevViewportBox;\n  }\n  function getFollowLayout() {\n    var _a;\n    return (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getLayoutState().layout;\n  }\n  return {\n    add: function(element) {\n      element.setCrossfader(crossfader);\n      stack.add(element);\n      if (prevDragCursor)\n        element.prevDragCursor = prevDragCursor;\n      if (!state.lead)\n        state.lead = element;\n    },\n    remove: function(element) {\n      stack.delete(element);\n    },\n    getLead: function() {\n      return state.lead;\n    },\n    updateSnapshot: function() {\n      if (!state.lead)\n        return;\n      prevValues = crossfader.isActive() ? crossfader.getLatestValues() : state.lead.getLatestValues();\n      prevViewportBox = state.lead.prevViewportBox;\n      var dragControls = elementDragControls.get(state.lead);\n      if (dragControls && dragControls.isDragging) {\n        prevDragCursor = dragControls.cursorProgress;\n      }\n    },\n    clearSnapshot: function() {\n      prevDragCursor = prevViewportBox = void 0;\n    },\n    updateLeadAndFollow: function() {\n      var _a;\n      prevState = __assign({}, state);\n      var lead;\n      var follow;\n      var order2 = Array.from(stack);\n      for (var i = order2.length; i--; i >= 0) {\n        var element = order2[i];\n        if (lead)\n          follow !== null && follow !== void 0 ? follow : follow = element;\n        lead !== null && lead !== void 0 ? lead : lead = element;\n        if (lead && follow)\n          break;\n      }\n      state.lead = lead;\n      state.follow = follow;\n      state.leadIsExiting = ((_a = state.lead) === null || _a === void 0 ? void 0 : _a.presence) === Presence.Exiting;\n      crossfader.setOptions({\n        lead,\n        follow,\n        prevValues,\n        crossfadeOpacity: (follow === null || follow === void 0 ? void 0 : follow.isPresenceRoot) || (lead === null || lead === void 0 ? void 0 : lead.isPresenceRoot)\n      });\n      if (state.lead !== prevState.follow && (prevState.lead !== state.lead || prevState.leadIsExiting !== state.leadIsExiting)) {\n        needsCrossfadeAnimation = true;\n      }\n    },\n    animate: function(child, shouldCrossfade) {\n      var _a;\n      if (shouldCrossfade === void 0) {\n        shouldCrossfade = false;\n      }\n      if (child === state.lead) {\n        if (shouldCrossfade) {\n          child.pointTo(state.lead);\n        } else {\n          child.setVisibility(true);\n        }\n        var config = {};\n        var prevParent = (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getProjectionParent();\n        if (prevParent) {\n          config.prevParent = prevParent;\n        }\n        if (child.presence === Presence.Entering) {\n          config.originBox = getFollowViewportBox();\n        } else if (child.presence === Presence.Exiting) {\n          config.targetBox = getFollowLayout();\n        }\n        if (needsCrossfadeAnimation) {\n          needsCrossfadeAnimation = false;\n          var transition = child.getDefaultTransition();\n          child.presence === Presence.Entering ? crossfader.toLead(transition) : crossfader.fromLead(transition);\n        }\n        child.notifyLayoutReady(config);\n      } else {\n        if (shouldCrossfade) {\n          state.lead && child.pointTo(state.lead);\n        } else {\n          child.setVisibility(false);\n        }\n      }\n    }\n  };\n}\n\n// ../../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/rotate.js\nfunction resetRotate(child) {\n  var hasRotate = false;\n  var resetValues = {};\n  for (var i = 0; i < transformAxes.length; i++) {\n    var axis = transformAxes[i];\n    var key6 = \"rotate\" + axis;\n    if (!child.hasValue(key6) || child.getStaticValue(key6) === 0)\n      continue;\n    hasRotate = true;\n    resetValues[key6] = child.getStaticValue(key6);\n    child.setStaticValue(key6, 0);\n  }\n  if (!hasRotate)\n    return;\n  child.syncRender();\n  for (var key6 in resetValues) {\n    child.setStaticValue(key6, resetValues[key6]);\n  }\n  child.scheduleRender();\n}\n\n// ../../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/index.js\nvar AnimateSharedLayout = function(_super) {\n  __extends(AnimateSharedLayout2, _super);\n  function AnimateSharedLayout2() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.children = new Set();\n    _this.stacks = new Map();\n    _this.hasMounted = false;\n    _this.updateScheduled = false;\n    _this.renderScheduled = false;\n    _this.syncContext = __assign(__assign({}, createBatcher()), { syncUpdate: function(force) {\n      return _this.scheduleUpdate(force);\n    }, forceUpdate: function() {\n      _this.syncContext = __assign({}, _this.syncContext);\n      _this.scheduleUpdate(true);\n    }, register: function(child) {\n      return _this.addChild(child);\n    }, remove: function(child) {\n      return _this.removeChild(child);\n    } });\n    return _this;\n  }\n  AnimateSharedLayout2.prototype.componentDidMount = function() {\n    this.hasMounted = true;\n  };\n  AnimateSharedLayout2.prototype.componentDidUpdate = function() {\n    this.startLayoutAnimation();\n  };\n  AnimateSharedLayout2.prototype.shouldComponentUpdate = function() {\n    this.renderScheduled = true;\n    return true;\n  };\n  AnimateSharedLayout2.prototype.startLayoutAnimation = function() {\n    var _this = this;\n    this.renderScheduled = this.updateScheduled = false;\n    var type = this.props.type;\n    this.children.forEach(function(child) {\n      if (!child.isPresent) {\n        child.presence = Presence.Exiting;\n      } else if (child.presence !== Presence.Entering) {\n        child.presence = child.presence === Presence.Exiting ? Presence.Entering : Presence.Present;\n      }\n    });\n    this.updateStacks();\n    var handler = {\n      layoutReady: function(child) {\n        if (child.getLayoutId() !== void 0) {\n          var stack = _this.getStack(child);\n          stack.animate(child, type === \"crossfade\");\n        } else {\n          child.notifyLayoutReady();\n        }\n      },\n      parent: this.context.visualElement\n    };\n    this.children.forEach(function(child) {\n      return _this.syncContext.add(child);\n    });\n    this.syncContext.flush(handler);\n    this.stacks.forEach(function(stack) {\n      return stack.clearSnapshot();\n    });\n  };\n  AnimateSharedLayout2.prototype.updateStacks = function() {\n    this.stacks.forEach(function(stack) {\n      return stack.updateLeadAndFollow();\n    });\n  };\n  AnimateSharedLayout2.prototype.scheduleUpdate = function(force) {\n    if (force === void 0) {\n      force = false;\n    }\n    if (!(force || !this.updateScheduled))\n      return;\n    this.updateScheduled = true;\n    this.children.forEach(function(child) {\n      resetRotate(child);\n      if (child.shouldResetTransform())\n        child.resetTransform();\n    });\n    this.children.forEach(snapshotViewportBox);\n    this.stacks.forEach(function(stack) {\n      return stack.updateSnapshot();\n    });\n    if (force || !this.renderScheduled) {\n      this.renderScheduled = true;\n      this.forceUpdate();\n    }\n  };\n  AnimateSharedLayout2.prototype.addChild = function(child) {\n    this.children.add(child);\n    this.addToStack(child);\n    child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n  };\n  AnimateSharedLayout2.prototype.removeChild = function(child) {\n    this.scheduleUpdate();\n    this.children.delete(child);\n    this.removeFromStack(child);\n  };\n  AnimateSharedLayout2.prototype.addToStack = function(child) {\n    var stack = this.getStack(child);\n    stack === null || stack === void 0 ? void 0 : stack.add(child);\n  };\n  AnimateSharedLayout2.prototype.removeFromStack = function(child) {\n    var stack = this.getStack(child);\n    stack === null || stack === void 0 ? void 0 : stack.remove(child);\n  };\n  AnimateSharedLayout2.prototype.getStack = function(child) {\n    var id = child.getLayoutId();\n    if (id === void 0)\n      return;\n    !this.stacks.has(id) && this.stacks.set(id, layoutStack());\n    return this.stacks.get(id);\n  };\n  AnimateSharedLayout2.prototype.render = function() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(SharedLayoutContext.Provider, { value: this.syncContext }, this.props.children);\n  };\n  AnimateSharedLayout2.contextType = MotionContext;\n  return AnimateSharedLayout2;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n\n// ../../node_modules/framer-motion/dist/es/components/MotionConfig/index.js\n\n\nfunction MotionConfig(_a) {\n  var children = _a.children, config = __rest(_a, [\"children\"]);\n  config = __assign(__assign({}, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MotionConfigContext)), config);\n  config.isStatic = useConstant(function() {\n    return config.isStatic;\n  });\n  var transitionDependency = typeof config.transition === \"object\" ? config.transition.toString() : \"\";\n  var context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function() {\n    return config;\n  }, [\n    transitionDependency,\n    config.transformPagePoint\n  ]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(MotionConfigContext.Provider, { value: context }, children);\n}\n\n// ../../node_modules/framer-motion/dist/es/components/LazyMotion/index.js\n\n\nfunction LazyMotion(_a) {\n  var children = _a.children, features = _a.features, _b = _a.strict, strict = _b === void 0 ? false : _b;\n  var _c = __read((0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!isLazyBundle(features)), 2), setIsLoaded = _c[1];\n  var loadedRenderer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(void 0);\n  if (!isLazyBundle(features)) {\n    var renderer = features.renderer, loadedFeatures = __rest(features, [\"renderer\"]);\n    loadedRenderer.current = renderer;\n    loadFeatures(loadedFeatures);\n  }\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    if (isLazyBundle(features)) {\n      features().then(function(_a2) {\n        var renderer2 = _a2.renderer, loadedFeatures2 = __rest(_a2, [\"renderer\"]);\n        loadFeatures(loadedFeatures2);\n        loadedRenderer.current = renderer2;\n        setIsLoaded(true);\n      });\n    }\n  }, []);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict } }, children);\n}\nfunction isLazyBundle(features) {\n  return typeof features === \"function\";\n}\n\n// ../../node_modules/framer-motion/dist/es/render/dom/features-animation.js\nvar domAnimation = __assign(__assign({ renderer: createDomVisualElement }, animations), gestureAnimations);\n\n// ../../node_modules/framer-motion/dist/es/render/dom/features-max.js\nvar domMax = __assign(__assign(__assign({}, domAnimation), drag), layoutAnimations);\n\n// ../../node_modules/framer-motion/dist/es/value/use-motion-value.js\n\nfunction useMotionValue(initial) {\n  var value = useConstant(function() {\n    return motionValue(initial);\n  });\n  var isStatic = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MotionConfigContext).isStatic;\n  if (isStatic) {\n    var _a = __read((0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initial), 2), setLatest_1 = _a[1];\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n      return value.onChange(setLatest_1);\n    }, []);\n  }\n  return value;\n}\n\n// ../../node_modules/framer-motion/dist/es/value/use-on-change.js\n\nfunction useOnChange(value, callback) {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    if (isMotionValue(value))\n      return value.onChange(callback);\n  }, [callback]);\n}\nfunction useMultiOnChange(values, handler) {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    var subscriptions = values.map(function(value) {\n      return value.onChange(handler);\n    });\n    return function() {\n      return subscriptions.forEach(function(unsubscribe) {\n        return unsubscribe();\n      });\n    };\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/value/use-combine-values.js\nfunction useCombineMotionValues(values, combineValues) {\n  var value = useMotionValue(combineValues());\n  var updateValue = function() {\n    return value.set(combineValues());\n  };\n  updateValue();\n  useMultiOnChange(values, function() {\n    return es_default.update(updateValue, false, true);\n  });\n  return value;\n}\n\n// ../../node_modules/framer-motion/dist/es/value/use-motion-template.js\nfunction useMotionTemplate(fragments) {\n  var values = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    values[_i - 1] = arguments[_i];\n  }\n  var numFragments = fragments.length;\n  function buildValue() {\n    var output = \"\";\n    for (var i = 0; i < numFragments; i++) {\n      output += fragments[i];\n      var value = values[i];\n      if (value)\n        output += values[i].get();\n    }\n    return output;\n  }\n  return useCombineMotionValues(values, buildValue);\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/transform.js\nvar isCustomValueType = function(v) {\n  return typeof v === \"object\" && v.mix;\n};\nvar getMixer2 = function(v) {\n  return isCustomValueType(v) ? v.mix : void 0;\n};\nfunction transform() {\n  var args = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n  var useImmediate = !Array.isArray(args[0]);\n  var argOffset = useImmediate ? 0 : -1;\n  var inputValue = args[0 + argOffset];\n  var inputRange = args[1 + argOffset];\n  var outputRange = args[2 + argOffset];\n  var options = args[3 + argOffset];\n  var interpolator = interpolate(inputRange, outputRange, __assign({ mixer: getMixer2(outputRange[0]) }, options));\n  return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\n// ../../node_modules/framer-motion/dist/es/value/use-transform.js\nfunction useTransform(input, inputRangeOrTransformer, outputRange, options) {\n  var transformer = typeof inputRangeOrTransformer === \"function\" ? inputRangeOrTransformer : transform(inputRangeOrTransformer, outputRange, options);\n  return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([input], function(_a) {\n    var _b = __read(_a, 1), latest = _b[0];\n    return transformer(latest);\n  });\n}\nfunction useListTransform(values, transformer) {\n  var latest = useConstant(function() {\n    return [];\n  });\n  return useCombineMotionValues(values, function() {\n    latest.length = 0;\n    var numValues = values.length;\n    for (var i = 0; i < numValues; i++) {\n      latest[i] = values[i].get();\n    }\n    return transformer(latest);\n  });\n}\n\n// ../../node_modules/framer-motion/dist/es/value/use-spring.js\n\nfunction useSpring(source, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  var isStatic = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MotionConfigContext).isStatic;\n  var activeSpringAnimation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  var value = useMotionValue(isMotionValue(source) ? source.get() : source);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function() {\n    return value.attach(function(v, set) {\n      if (isStatic)\n        return set(v);\n      if (activeSpringAnimation.current) {\n        activeSpringAnimation.current.stop();\n      }\n      activeSpringAnimation.current = animate(__assign(__assign({ from: value.get(), to: v, velocity: value.getVelocity() }, config), { onUpdate: set }));\n      return value.get();\n    });\n  }, Object.values(config));\n  useOnChange(source, function(v) {\n    return value.set(parseFloat(v));\n  });\n  return value;\n}\n\n// ../../node_modules/framer-motion/dist/es/value/use-velocity.js\n\nfunction useVelocity(value) {\n  var velocity = useMotionValue(value.getVelocity());\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    return value.velocityUpdateSubscribers.add(function(newVelocity) {\n      velocity.set(newVelocity);\n    });\n  }, [value]);\n  return velocity;\n}\n\n// ../../node_modules/framer-motion/dist/es/value/scroll/utils.js\nfunction createScrollMotionValues() {\n  return {\n    scrollX: motionValue(0),\n    scrollY: motionValue(0),\n    scrollXProgress: motionValue(0),\n    scrollYProgress: motionValue(0)\n  };\n}\nfunction setProgress(offset, maxOffset, value) {\n  value.set(!offset || !maxOffset ? 0 : offset / maxOffset);\n}\nfunction createScrollUpdater(values, getOffsets) {\n  var update = function() {\n    var _a = getOffsets(), xOffset = _a.xOffset, yOffset = _a.yOffset, xMaxOffset = _a.xMaxOffset, yMaxOffset = _a.yMaxOffset;\n    values.scrollX.set(xOffset);\n    values.scrollY.set(yOffset);\n    setProgress(xOffset, xMaxOffset, values.scrollXProgress);\n    setProgress(yOffset, yMaxOffset, values.scrollYProgress);\n  };\n  update();\n  return update;\n}\n\n// ../../node_modules/framer-motion/dist/es/value/scroll/use-element-scroll.js\nvar getElementScrollOffsets = function(element) {\n  return function() {\n    return {\n      xOffset: element.scrollLeft,\n      yOffset: element.scrollTop,\n      xMaxOffset: element.scrollWidth - element.offsetWidth,\n      yMaxOffset: element.scrollHeight - element.offsetHeight\n    };\n  };\n};\nfunction useElementScroll(ref) {\n  var values = useConstant(createScrollMotionValues);\n  useIsomorphicLayoutEffect(function() {\n    var element = ref.current;\n    invariant(!!element, \"ref provided to useScroll must be passed into a HTML element.\");\n    if (!element)\n      return;\n    var updateScrollValues = createScrollUpdater(values, getElementScrollOffsets(element));\n    var scrollListener = addDomEvent(element, \"scroll\", updateScrollValues, { passive: true });\n    var resizeListener = addDomEvent(element, \"resize\", updateScrollValues);\n    return function() {\n      scrollListener && scrollListener();\n      resizeListener && resizeListener();\n    };\n  }, []);\n  return values;\n}\n\n// ../../node_modules/framer-motion/dist/es/value/scroll/use-viewport-scroll.js\nvar viewportScrollValues;\nfunction getViewportScrollOffsets() {\n  return {\n    xOffset: window.pageXOffset,\n    yOffset: window.pageYOffset,\n    xMaxOffset: document.body.clientWidth - window.innerWidth,\n    yMaxOffset: document.body.clientHeight - window.innerHeight\n  };\n}\nvar hasListeners = false;\nfunction addEventListeners() {\n  hasListeners = true;\n  if (typeof window === \"undefined\")\n    return;\n  var updateScrollValues = createScrollUpdater(viewportScrollValues, getViewportScrollOffsets);\n  addDomEvent(window, \"scroll\", updateScrollValues, { passive: true });\n  addDomEvent(window, \"resize\", updateScrollValues);\n}\nfunction useViewportScroll() {\n  if (!viewportScrollValues) {\n    viewportScrollValues = createScrollMotionValues();\n  }\n  useIsomorphicLayoutEffect(function() {\n    !hasListeners && addEventListeners();\n  }, []);\n  return viewportScrollValues;\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/use-reduced-motion.js\n\nvar prefersReducedMotion;\nfunction initPrefersReducedMotion() {\n  prefersReducedMotion = motionValue(null);\n  if (typeof window === \"undefined\")\n    return;\n  if (window.matchMedia) {\n    var motionMediaQuery_1 = window.matchMedia(\"(prefers-reduced-motion)\");\n    var setReducedMotionPreferences = function() {\n      return prefersReducedMotion.set(motionMediaQuery_1.matches);\n    };\n    motionMediaQuery_1.addListener(setReducedMotionPreferences);\n    setReducedMotionPreferences();\n  } else {\n    prefersReducedMotion.set(false);\n  }\n}\nfunction useReducedMotion() {\n  !prefersReducedMotion && initPrefersReducedMotion();\n  var _a = __read((0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(prefersReducedMotion.get()), 2), shouldReduceMotion = _a[0], setShouldReduceMotion = _a[1];\n  useOnChange(prefersReducedMotion, setShouldReduceMotion);\n  return shouldReduceMotion;\n}\n\n// ../../node_modules/framer-motion/dist/es/animation/animation-controls.js\nfunction animationControls() {\n  var hasMounted = false;\n  var pendingAnimations = [];\n  var subscribers = new Set();\n  var controls = {\n    subscribe: function(visualElement2) {\n      subscribers.add(visualElement2);\n      return function() {\n        return void subscribers.delete(visualElement2);\n      };\n    },\n    start: function(definition, transitionOverride) {\n      if (hasMounted) {\n        var animations_1 = [];\n        subscribers.forEach(function(visualElement2) {\n          animations_1.push(animateVisualElement(visualElement2, definition, {\n            transitionOverride\n          }));\n        });\n        return Promise.all(animations_1);\n      } else {\n        return new Promise(function(resolve) {\n          pendingAnimations.push({\n            animation: [definition, transitionOverride],\n            resolve\n          });\n        });\n      }\n    },\n    set: function(definition) {\n      invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n      return subscribers.forEach(function(visualElement2) {\n        setValues(visualElement2, definition);\n      });\n    },\n    stop: function() {\n      subscribers.forEach(function(visualElement2) {\n        stopAnimation(visualElement2);\n      });\n    },\n    mount: function() {\n      hasMounted = true;\n      pendingAnimations.forEach(function(_a) {\n        var animation = _a.animation, resolve = _a.resolve;\n        controls.start.apply(controls, __spreadArray([], __read(animation))).then(resolve);\n      });\n      return function() {\n        hasMounted = false;\n        controls.stop();\n      };\n    }\n  };\n  return controls;\n}\n\n// ../../node_modules/framer-motion/dist/es/animation/use-animation.js\n\nfunction useAnimation() {\n  var controls = useConstant(animationControls);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(controls.mount, []);\n  return controls;\n}\n\n// ../../node_modules/framer-motion/dist/es/utils/use-cycle.js\n\nfunction useCycle() {\n  var items = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    items[_i] = arguments[_i];\n  }\n  var index = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n  var _a = __read((0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(items[index.current]), 2), item = _a[0], setItem = _a[1];\n  return [\n    item,\n    function(next) {\n      index.current = typeof next !== \"number\" ? wrap(0, items.length, index.current + 1) : next;\n      setItem(items[index.current]);\n    }\n  ];\n}\n\n// ../../node_modules/framer-motion/dist/es/gestures/drag/use-drag-controls.js\nvar DragControls = function() {\n  function DragControls2() {\n    this.componentControls = new Set();\n  }\n  DragControls2.prototype.subscribe = function(controls) {\n    var _this = this;\n    this.componentControls.add(controls);\n    return function() {\n      return _this.componentControls.delete(controls);\n    };\n  };\n  DragControls2.prototype.start = function(event, options) {\n    this.componentControls.forEach(function(controls) {\n      controls.start(event.nativeEvent || event, options);\n    });\n  };\n  DragControls2.prototype.updateConstraints = function() {\n    this.componentControls.forEach(function(controls) {\n      controls.updateLayoutMeasurements();\n      controls.resolveDragConstraints();\n    });\n  };\n  return DragControls2;\n}();\nvar createDragControls = function() {\n  return new DragControls();\n};\nfunction useDragControls() {\n  return useConstant(createDragControls);\n}\n\n// ../../node_modules/framer-motion/dist/es/animation/use-animated-state.js\n\nvar createObject = function() {\n  return {};\n};\nvar stateVisualElement = visualElement({\n  build: function() {\n  },\n  measureViewportBox: axisBox,\n  resetTransform: function() {\n  },\n  restoreTransform: function() {\n  },\n  removeValueFromRenderState: function() {\n  },\n  render: function() {\n  },\n  scrapeMotionValuesFromProps: createObject,\n  readValueFromInstance: function(_state, key6, options) {\n    return options.initialState[key6] || 0;\n  },\n  makeTargetAnimatable: function(element, _a) {\n    var transition = _a.transition, transitionEnd = _a.transitionEnd, target = __rest(_a, [\"transition\", \"transitionEnd\"]);\n    var origin = getOrigin(target, transition || {}, element);\n    checkTargetForNewValues(element, target, origin);\n    return __assign({ transition, transitionEnd }, target);\n  }\n});\nvar useVisualState = makeUseVisualState({\n  scrapeMotionValuesFromProps: createObject,\n  createRenderState: createObject\n});\nfunction useAnimatedState(initialState2) {\n  var _a = __read((0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialState2), 2), animationState = _a[0], setAnimationState = _a[1];\n  var visualState = useVisualState({}, false);\n  var element = useConstant(function() {\n    return stateVisualElement({ props: {}, visualState }, { initialState: initialState2 });\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    element.mount({});\n    return element.unmount();\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n    element.setProps({\n      onUpdate: function(v) {\n        return setAnimationState(__assign({}, v));\n      }\n    });\n  });\n  var startAnimation3 = useConstant(function() {\n    return function(animationDefinition) {\n      return animateVisualElement(element, animationDefinition);\n    };\n  });\n  return [animationState, startAnimation3];\n}\n\n// ../../node_modules/framer-motion/dist/es/value/use-inverted-scale.js\nvar maxScale = 1e5;\nvar invertScale = function(scale2) {\n  return scale2 > 1e-3 ? 1 / scale2 : maxScale;\n};\nvar hasWarned = false;\nfunction useInvertedScale(scale2) {\n  var parentScaleX = useMotionValue(1);\n  var parentScaleY = useMotionValue(1);\n  var visualElement2 = useVisualElementContext();\n  invariant(!!(scale2 || visualElement2), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\n  warning(hasWarned, \"useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.\");\n  hasWarned = true;\n  if (scale2) {\n    parentScaleX = scale2.scaleX || parentScaleX;\n    parentScaleY = scale2.scaleY || parentScaleY;\n  } else if (visualElement2) {\n    parentScaleX = visualElement2.getValue(\"scaleX\", 1);\n    parentScaleY = visualElement2.getValue(\"scaleY\", 1);\n  }\n  var scaleX = useTransform(parentScaleX, invertScale);\n  var scaleY = useTransform(parentScaleY, invertScale);\n  return { scaleX, scaleY };\n}\n\n// src/animation/Motion/addChildHack.ts\nMotionValue.prototype.addChild = function({ transformer = (v) => v }) {\n  const child = new MotionValue(transformer(this.get()));\n  this.onChange((v) => child.set(transformer(v)));\n  return child;\n};\n\n// src/components/Scroll/Scroll.tsx\n\n\n// src/render/types/PropertyControls.ts\nvar ControlType;\n(function(ControlType2) {\n  ControlType2[\"Boolean\"] = \"boolean\";\n  ControlType2[\"Number\"] = \"number\";\n  ControlType2[\"String\"] = \"string\";\n  ControlType2[\"FusedNumber\"] = \"fusednumber\";\n  ControlType2[\"Enum\"] = \"enum\";\n  ControlType2[\"SegmentedEnum\"] = \"segmentedenum\";\n  ControlType2[\"Color\"] = \"color\";\n  ControlType2[\"Image\"] = \"image\";\n  ControlType2[\"File\"] = \"file\";\n  ControlType2[\"ComponentInstance\"] = \"componentinstance\";\n  ControlType2[\"Array\"] = \"array\";\n  ControlType2[\"EventHandler\"] = \"eventhandler\";\n  ControlType2[\"Transition\"] = \"transition\";\n  ControlType2[\"Object\"] = \"object\";\n})(ControlType || (ControlType = {}));\n\n// src/utils/addPropertyControls.ts\nfunction addPropertyControls(component, propertyControls) {\n  Object.assign(component, { propertyControls });\n}\nfunction getPropertyControls(component) {\n  return component.propertyControls;\n}\n\n// src/components/Scroll/EmulatedScroll.tsx\n\n\n\n// src/render/presentation/Frame/FrameWithMotion.tsx\nvar import_is_prop_valid = __toModule(require_is_prop_valid_browser_cjs());\n\n\n\n// src/utils/safeWindow.ts\nvar mockWindow = {\n  addEventListener: () => {\n  },\n  removeEventListener: () => {\n  },\n  dispatchEvent: () => false,\n  onpointerdown: false,\n  onpointermove: false,\n  onpointerup: false,\n  ontouchstart: false,\n  ontouchmove: false,\n  ontouchend: false,\n  onmousedown: false,\n  onmousemove: false,\n  onmouseup: false,\n  devicePixelRatio: 1,\n  scrollX: 0,\n  scrollY: 0,\n  location: {\n    href: \"\"\n  },\n  setTimeout: () => 0,\n  clearTimeout: () => {\n  },\n  setInterval: () => 0,\n  clearInterval: () => {\n  },\n  webkitConvertPointFromPageToNode: (_, pt) => pt\n};\nvar safeWindow = typeof window === \"undefined\" ? mockWindow : window;\n\n// src/render/style/BorderComponent.tsx\n\nfunction collectBorderStyleForProps(props, style, collapseEqualBorders = true) {\n  const { borderWidth, borderStyle, borderColor } = props;\n  if (!borderWidth) {\n    return;\n  }\n  let borderTop;\n  let borderBottom;\n  let borderLeft;\n  let borderRight;\n  if (typeof borderWidth === \"number\") {\n    borderTop = borderBottom = borderLeft = borderRight = borderWidth;\n  } else {\n    borderTop = borderWidth.top || 0;\n    borderBottom = borderWidth.bottom || 0;\n    borderLeft = borderWidth.left || 0;\n    borderRight = borderWidth.right || 0;\n  }\n  if (borderTop === 0 && borderBottom === 0 && borderLeft === 0 && borderRight === 0) {\n    return;\n  }\n  if (collapseEqualBorders && borderTop === borderBottom && borderTop === borderLeft && borderTop === borderRight) {\n    style.border = `${borderTop}px ${borderStyle} ${borderColor}`;\n    return;\n  }\n  style.borderStyle = props.borderStyle;\n  style.borderColor = props.borderColor;\n  style.borderTopWidth = `${borderTop}px`;\n  style.borderBottomWidth = `${borderBottom}px`;\n  style.borderLeftWidth = `${borderLeft}px`;\n  style.borderRightWidth = `${borderRight}px`;\n}\nfunction Border(props) {\n  const layoutId = props.layoutId ? `${props.layoutId}-border` : void 0;\n  if (!props.borderWidth) {\n    return null;\n  }\n  const style = {\n    position: \"absolute\",\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0,\n    borderRadius: \"inherit\",\n    pointerEvents: \"none\"\n  };\n  if (props.border) {\n    ;\n    style.border = props.border;\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(motion.div, {\n      style\n    });\n  }\n  collectBorderStyleForProps(props, style, false);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(motion.div, {\n    \"data-frame-border\": true,\n    style,\n    layoutId\n  });\n}\n\n// src/render/types/BackgroundImage.ts\nvar key = \"src\";\nvar BackgroundImage;\n(function(BackgroundImage2) {\n  BackgroundImage2.isImageObject = function(image) {\n    if (!image || typeof image === \"string\")\n      return false;\n    return key in image;\n  };\n})(BackgroundImage || (BackgroundImage = {}));\n\n// src/animation/Animatable/Observers.ts\nvar Observers = class {\n  constructor() {\n    this.observers = new Set();\n    this.transactions = {};\n  }\n  add(observer) {\n    this.observers.add(observer);\n    let isCalled = false;\n    return () => {\n      if (isCalled) {\n        return;\n      }\n      isCalled = true;\n      this.remove(observer);\n    };\n  }\n  remove(observer) {\n    this.observers.delete(observer);\n  }\n  notify(change, transaction) {\n    if (transaction) {\n      const accumulatedChange = this.transactions[transaction] || change;\n      accumulatedChange.value = change.value;\n      this.transactions[transaction] = accumulatedChange;\n    } else {\n      this.callObservers(change);\n    }\n  }\n  finishTransaction(transaction) {\n    const accumulatedChange = this.transactions[transaction];\n    delete this.transactions[transaction];\n    return this.callObservers(accumulatedChange, transaction);\n  }\n  callObservers(change, transaction) {\n    const finishObservers = [];\n    new Set(this.observers).forEach((observer) => {\n      if (typeof observer === \"function\") {\n        observer(change, transaction);\n      } else {\n        observer.update(change, transaction);\n        finishObservers.push(observer.finish);\n      }\n    });\n    return finishObservers;\n  }\n};\n\n// ../shared/src/assert.ts\nfunction assert(condition, ...msg2) {\n  if (condition)\n    return;\n  const e = Error(\"Assertion Error\" + (msg2.length > 0 ? \": \" + msg2.join(\" \") : \"\"));\n  if (e.stack) {\n    try {\n      const lines = e.stack.split(\"\\n\");\n      if (lines[1].includes(\"assert\")) {\n        lines.splice(1, 1);\n        e.stack = lines.join(\"\\n\");\n      } else if (lines[0].includes(\"assert\")) {\n        lines.splice(0, 1);\n        e.stack = lines.join(\"\\n\");\n      }\n    } catch {\n    }\n  }\n  throw e;\n}\n\n// ../shared/src/warnOnce.ts\nvar warningMessages = new Set();\nfunction warnOnce(keyMessage, ...rest) {\n  if (warningMessages.has(keyMessage))\n    return;\n  warningMessages.add(keyMessage);\n  console.warn(keyMessage, ...rest);\n}\n\n// ../shared/src/deprecation.ts\nfunction deprecationWarning(removedItem, removalVersion, replacement) {\n  const replacementText = replacement ? `, use ${replacement} instead` : \"\";\n  const warningText = `Deprecation warning: ${removedItem} will be removed in version ${removalVersion}${replacementText}.`;\n  warnOnce(warningText);\n}\n\n// ../shared/src/errors.ts\nvar errorReporter;\nfunction reportError({\n  error: maybeError,\n  tags,\n  extras,\n  caller\n}) {\n  assert(errorReporter, \"Set up an error callback with setErrorReporter, or configure Sentry with initializeEnvironment\");\n  const error = reportableError(maybeError, caller);\n  errorReporter({ error, tags: { ...error.tags, ...tags }, extras: { ...error.extras, ...extras } });\n  return error;\n}\nfunction reportableError(error, caller) {\n  if (error instanceof Error) {\n    return error;\n  }\n  return new UnhandledError(error, caller);\n}\nvar UnhandledError = class extends Error {\n  constructor(error, caller) {\n    const message = error ? JSON.stringify(error) : \"No error message provided\";\n    super(message);\n    this.message = message;\n    if (caller && Error.captureStackTrace) {\n      Error.captureStackTrace(this, caller);\n    } else {\n      try {\n        throw new Error();\n      } catch (e) {\n        this.stack = e.stack;\n      }\n    }\n  }\n};\n\n// ../shared/src/ServiceMap.ts\nvar cachedServiceMap;\nfunction getServiceMap() {\n  if (cachedServiceMap)\n    return cachedServiceMap;\n  cachedServiceMap = extractServiceMap();\n  return cachedServiceMap;\n}\nfunction extractServiceMap() {\n  var _a, _b, _c;\n  const location = window.location;\n  let services = (_a = window == null ? void 0 : window.bootstrap) == null ? void 0 : _a.services;\n  if (services) {\n    return services;\n  }\n  let topOrigin;\n  try {\n    const topWindow = window.top;\n    topOrigin = topWindow.location.origin;\n    services = (_c = (_b = window.top) == null ? void 0 : _b.bootstrap) == null ? void 0 : _c.services;\n    if (services) {\n      return services;\n    }\n  } catch (e) {\n  }\n  if (topOrigin && topOrigin !== location.origin) {\n    throw Error(`Unexpectedly embedded by ${topOrigin} (expected ${location.origin})`);\n  }\n  if (location.origin.endsWith(\"framer.com\") || location.origin.endsWith(\"framer.dev\")) {\n    throw Error(\"ServiceMap data was not provided in document\");\n  }\n  try {\n    const servicesJSON = new URLSearchParams(location.search).get(\"services\") || new URLSearchParams(location.hash.substring(1)).get(\"services\");\n    if (servicesJSON) {\n      services = JSON.parse(servicesJSON);\n    }\n  } catch (e) {\n  }\n  if (services && typeof services === \"object\" && services.api) {\n    return services;\n  }\n  throw Error(\"ServiceMap requested but not available\");\n}\n\n// ../shared/src/logger.ts\nfunction jsonSafeCopy(obj, depth = 0, seen = new Set()) {\n  var _a, _b;\n  if (obj === null)\n    return obj;\n  const type = typeof obj;\n  if (type === \"function\")\n    return `[Function: ${(_a = obj.name) != null ? _a : \"unknown\"}]`;\n  if (type !== \"object\")\n    return obj;\n  if (obj instanceof Error)\n    return `[${obj.toString()}]`;\n  if (seen.has(obj))\n    return \"[Circular]\";\n  if (depth > 2)\n    return \"...\";\n  seen.add(obj);\n  try {\n    if (typeof obj.toJSON === \"function\") {\n      return jsonSafeCopy(obj.toJSON(), depth + 1, seen);\n    } else if (Array.isArray(obj)) {\n      return obj.map((v) => jsonSafeCopy(v, depth + 1, seen));\n    } else if (Object.getPrototypeOf(obj) !== Object.prototype) {\n      return `[Object: ${obj.__class || ((_b = obj.constructor) == null ? void 0 : _b.name)}]`;\n    } else {\n      const result = {};\n      for (const [key6, v] of Object.entries(obj)) {\n        result[key6] = jsonSafeCopy(v, depth + 1, seen);\n      }\n      return result;\n    }\n  } catch (e) {\n    return `[Throws: ${e.message}]`;\n  } finally {\n    seen.delete(obj);\n  }\n}\nvar LogLevel;\n(function(LogLevel2) {\n  LogLevel2[LogLevel2[\"Trace\"] = 0] = \"Trace\";\n  LogLevel2[LogLevel2[\"Debug\"] = 1] = \"Debug\";\n  LogLevel2[LogLevel2[\"Info\"] = 2] = \"Info\";\n  LogLevel2[LogLevel2[\"Warn\"] = 3] = \"Warn\";\n  LogLevel2[LogLevel2[\"Error\"] = 4] = \"Error\";\n  LogLevel2[LogLevel2[\"NotLogging\"] = 5] = \"NotLogging\";\n})(LogLevel || (LogLevel = {}));\nvar levelNames = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\nvar postfixNames = [\":trace\", \":debug\", \":info\", \":warn\", \":error\"];\nfunction applyLogLevelSpec(spec, all) {\n  for (const s of spec.split(/[ ,]/)) {\n    let match = s.trim();\n    if (match.length === 0)\n      continue;\n    let level = 1;\n    let inverted = false;\n    if (match.startsWith(\"-\")) {\n      match = match.slice(1);\n      level = 3;\n      inverted = true;\n    }\n    for (let i = 0; i <= 4; i++) {\n      const postfix = postfixNames[i];\n      if (match.endsWith(postfix)) {\n        level = i;\n        if (inverted) {\n          level += 1;\n        }\n        match = match.slice(0, match.length - postfix.length);\n        if (match.length === 0) {\n          match = \"*\";\n        }\n        break;\n      }\n    }\n    const regex = new RegExp(\"^\" + match.replace(/[*]/g, \".*\") + \"$\");\n    for (const logger of all) {\n      if (logger.id.match(regex)) {\n        logger.level = level;\n      }\n    }\n  }\n}\nvar LogEntry = class {\n  constructor(logger, level, parts) {\n    this.logger = logger;\n    this.level = level;\n    this.parts = parts;\n    this.time = Date.now();\n  }\n  toMessage() {\n    if (this.stringPrefix)\n      return this.parts;\n    const r = [\n      new Date(this.time).toISOString().substr(-14, 14),\n      levelNames[this.level] + \": [\" + this.logger.id + \"]\"\n    ];\n    let i = 0;\n    for (; i < this.parts.length; i++) {\n      const part = this.parts[i];\n      if (typeof part === \"string\") {\n        r.push(part);\n        continue;\n      }\n      break;\n    }\n    this.stringPrefix = r.join(\" \");\n    this.parts.splice(0, i, this.stringPrefix);\n    return this.parts;\n  }\n  toString() {\n    return this.toMessage().map((part) => {\n      var _a, _b;\n      const type = typeof part;\n      if (type === \"string\")\n        return part;\n      if (type === \"function\")\n        return `[Function: ${(_a = part.name) != null ? _a : \"unknown\"}]`;\n      if (part instanceof Error)\n        return (_b = part.stack) != null ? _b : part.toString();\n      const json = JSON.stringify(jsonSafeCopy(part));\n      if ((json == null ? void 0 : json.length) > 253) {\n        return json.slice(0, 250) + \"...\";\n      }\n      return json;\n    }).join(\" \");\n  }\n};\nvar logLevelSpec = \"app:info\";\nvar isNode = typeof process !== \"undefined\" && !!process.kill;\nvar isCI = isNode && !!process.env.CI;\nif (isCI) {\n  logLevelSpec = \"-:warn\";\n} else if (isNode) {\n  logLevelSpec = \"\";\n}\ntry {\n  if (typeof window !== \"undefined\" && window.localStorage) {\n    logLevelSpec = window.localStorage.logLevel || logLevelSpec;\n  }\n} catch {\n}\ntry {\n  if (typeof process !== \"undefined\") {\n    logLevelSpec = process.env.DEBUG || logLevelSpec;\n  }\n} catch {\n}\ntry {\n  if (typeof window !== \"undefined\") {\n    Object.assign(window, { setLogLevel });\n  }\n} catch {\n}\ntry {\n  if (typeof window !== \"undefined\" && window.postMessage && window.top === window) {\n    window.addEventListener(\"message\", (msg2) => {\n      if (!msg2.data || typeof msg2.data !== \"object\")\n        return;\n      const { loggerId, level, parts, printed } = msg2.data;\n      if (typeof loggerId !== \"string\")\n        return;\n      if (!Array.isArray(parts) || parts.length < 1 || typeof level !== \"number\")\n        return;\n      parts[0] = parts[0].replace(\"[\", \"*[\");\n      const logger = getLogger(loggerId);\n      const entry = new LogEntry(logger, level, parts);\n      entry.stringPrefix = parts[0];\n      replayBuffer.push(entry);\n      if (printed)\n        return;\n      if (logger.level > level)\n        return;\n      console == null ? void 0 : console.log(...entry.toMessage());\n    });\n  }\n} catch {\n}\nvar postLogEntry;\ntry {\n  if (typeof window !== \"undefined\" && window.postMessage && window.top !== window) {\n    postLogEntry = (entry) => {\n      try {\n        const parts = entry.toMessage().map((p) => jsonSafeCopy(p));\n        const logger = entry.logger;\n        const level = entry.level;\n        const printed = logger.level <= entry.level;\n        const data = { loggerId: logger.id, level, parts, printed };\n        window.top.postMessage(data, getServiceMap().app);\n      } catch {\n      }\n    };\n  }\n} catch {\n}\nvar loggers = {};\nvar replayBuffer = [];\nfunction createLogEntry(logger, level, parts) {\n  var _a;\n  const entry = new LogEntry(logger, level, parts);\n  replayBuffer.push(entry);\n  postLogEntry == null ? void 0 : postLogEntry(entry);\n  const oldest = Date.now() - 1e3 * 60 * 60;\n  while (replayBuffer.length > 1e3 || ((_a = replayBuffer[0]) == null ? void 0 : _a.time) < oldest) {\n    replayBuffer.shift();\n  }\n  return entry;\n}\nfunction getLogReplayBuffer() {\n  return replayBuffer;\n}\nfunction getLogger(id) {\n  const existing = loggers[id];\n  if (existing)\n    return existing;\n  const logger = new Logger(id);\n  loggers[id] = logger;\n  applyLogLevelSpec(logLevelSpec, [logger]);\n  return logger;\n}\nfunction setLogLevel(spec, replay = true) {\n  try {\n    if (typeof window !== \"undefined\" && window.localStorage) {\n      window.localStorage.logLevel = spec;\n    }\n  } catch {\n  }\n  const previousSpec = logLevelSpec;\n  logLevelSpec = spec;\n  const all = Object.values(loggers);\n  for (const logger of all) {\n    logger.level = 3;\n  }\n  applyLogLevelSpec(spec, all);\n  if (replay && replayBuffer.length > 0) {\n    console == null ? void 0 : console.log(\"--- LOG REPLAY ---\");\n    for (const entry of replayBuffer) {\n      if (entry.logger.level > entry.level)\n        continue;\n      if (entry.level >= 3) {\n        console == null ? void 0 : console.warn(...entry.toMessage());\n      } else {\n        console == null ? void 0 : console.log(...entry.toMessage());\n      }\n    }\n    console == null ? void 0 : console.log(\"--- END OF LOG REPLAY ---\");\n  }\n  return previousSpec;\n}\nvar Logger = class {\n  constructor(id) {\n    this.id = id;\n    this.level = 3;\n    this.didLog = {};\n    this.trace = (...parts) => {\n      if (this.level > 0)\n        return;\n      const entry = new LogEntry(this, 0, parts);\n      console == null ? void 0 : console.log(...entry.toMessage());\n    };\n    this.debug = (...parts) => {\n      const entry = createLogEntry(this, 1, parts);\n      if (this.level > 1)\n        return;\n      console == null ? void 0 : console.log(...entry.toMessage());\n    };\n    this.info = (...parts) => {\n      const entry = createLogEntry(this, 2, parts);\n      if (this.level > 2)\n        return;\n      console == null ? void 0 : console.info(...entry.toMessage());\n    };\n    this.warn = (...parts) => {\n      const entry = createLogEntry(this, 3, parts);\n      if (this.level > 3)\n        return;\n      console == null ? void 0 : console.warn(...entry.toMessage());\n    };\n    this.warnOncePerMinute = (firstPart, ...parts) => {\n      if (this.didLog[firstPart] > Date.now())\n        return;\n      this.didLog[firstPart] = Date.now() + 1e3 * 60;\n      parts.unshift(firstPart);\n      const entry = createLogEntry(this, 3, parts);\n      if (this.level > 3)\n        return;\n      console == null ? void 0 : console.warn(...entry.toMessage());\n    };\n    this.error = (...parts) => {\n      const entry = createLogEntry(this, 4, parts);\n      if (this.level > 4)\n        return;\n      console == null ? void 0 : console.error(...entry.toMessage());\n    };\n    this.errorOncePerMinute = (firstPart, ...parts) => {\n      if (this.didLog[firstPart] > Date.now())\n        return;\n      this.didLog[firstPart] = Date.now() + 1e3 * 60;\n      parts.unshift(firstPart);\n      const entry = createLogEntry(this, 4, parts);\n      if (this.level > 4)\n        return;\n      console == null ? void 0 : console.error(...entry.toMessage());\n    };\n    this.reportError = (maybeError, extras) => {\n      const logs = getLogReplayBuffer().slice(-100).map((entry) => entry.toString().slice(0, 1e3)).join(\"\\n\");\n      const reportedError = reportError({\n        caller: this.reportError,\n        error: maybeError,\n        tags: {\n          handler: \"logger\",\n          where: this.id\n        },\n        extras: { ...extras, logs }\n      });\n      extras ? this.error(reportedError, extras) : this.error(reportedError);\n    };\n    this.reportErrorOncePerMinute = (error, extras) => {\n      if (!isErrorWithMessage(error) || this.didLog[error.message] > Date.now())\n        return;\n      this.didLog[error.message] = Date.now() + 1e3 * 60;\n      this.reportError(error, extras);\n    };\n  }\n  extend(name) {\n    const id = this.id + \":\" + name;\n    return getLogger(id);\n  }\n  getBufferedMessages() {\n    return replayBuffer.filter((entry) => entry.logger === this);\n  }\n  setLevel(level) {\n    const previous = this.level;\n    this.level = level;\n    return previous;\n  }\n  isLoggingTraceMessages() {\n    return this.level >= 0;\n  }\n};\nfunction isErrorWithMessage(maybeError) {\n  return Object.prototype.hasOwnProperty.call(maybeError, \"message\");\n}\n\n// ../shared/src/moduleIdentifiers.ts\nvar ModuleType;\n(function(ModuleType2) {\n  ModuleType2[\"Canvas\"] = \"canvasComponent\";\n  ModuleType2[\"Code\"] = \"codeFile\";\n  ModuleType2[\"Screen\"] = \"screen\";\n})(ModuleType || (ModuleType = {}));\n\n// ../shared/src/TaskQueues.ts\nvar log = getLogger(\"task-queue\");\n\n// src/animation/Animatable/Animatable.ts\nfunction Animatable(value) {\n  deprecationWarning(\"Animatable()\", \"2.0.0\", \"the new animation API (https://www.framer.com/api/animation/)\");\n  return isAnimatable2(value) ? value : new AnimatableValue(value);\n}\n(function(Animatable3) {\n  function transaction(update) {\n    const transactionId = Math.random();\n    const updatedValues = new Set();\n    const updater = (animatable, value) => {\n      animatable.set(value, transactionId);\n      updatedValues.add(animatable);\n    };\n    update(updater, transactionId);\n    const finishObservers = [];\n    updatedValues.forEach((value) => {\n      finishObservers.push(...value.finishTransaction(transactionId));\n    });\n    finishObservers.forEach((finish) => {\n      finish(transactionId);\n    });\n  }\n  Animatable3.transaction = transaction;\n  function getNumber2(value, defaultValue = 0) {\n    return Animatable3.get(value, defaultValue);\n  }\n  Animatable3.getNumber = getNumber2;\n  function get(value, defaultValue) {\n    if (value === void 0 || value === null) {\n      return defaultValue;\n    }\n    if (isAnimatable2(value)) {\n      return value.get();\n    }\n    return value;\n  }\n  Animatable3.get = get;\n  function objectToValues(object) {\n    if (!object) {\n      return object;\n    }\n    const result = {};\n    for (const key6 in object) {\n      const value = object[key6];\n      if (isAnimatable2(value)) {\n        result[key6] = value.get();\n      } else {\n        result[key6] = value;\n      }\n    }\n    return result;\n  }\n  Animatable3.objectToValues = objectToValues;\n})(Animatable || (Animatable = {}));\nvar onUpdateKey = \"onUpdate\";\nvar finishTransactionKey = \"finishTransaction\";\nfunction isAnimatable2(value) {\n  return value !== null && typeof value === \"object\" && onUpdateKey in value && value[onUpdateKey] instanceof Function && finishTransactionKey in value && value[finishTransactionKey] instanceof Function;\n}\nfunction animatableInterpolation(value, currentInterpolation) {\n  return {\n    interpolate(from, to) {\n      const fromValue = from.get();\n      const toValue = to.get();\n      const result = Animatable(fromValue);\n      return (progress2) => {\n        const v = currentInterpolation.interpolate(fromValue, toValue)(progress2);\n        result.set(v);\n        return result;\n      };\n    },\n    difference(from, to) {\n      const v = from.get();\n      return currentInterpolation.difference(v, to.get());\n    }\n  };\n}\nvar AnimatableValue = class {\n  constructor(value) {\n    this.value = value;\n    this.observers = new Observers();\n  }\n  static interpolationFor(value, currentInterpolation) {\n    if (isAnimatable2(value)) {\n      return animatableInterpolation(value, currentInterpolation);\n    }\n  }\n  get() {\n    return this.value;\n  }\n  set(value, transaction) {\n    const oldValue = this.value;\n    if (isAnimatable2(value)) {\n      value = value.get();\n    }\n    this.value = value;\n    const change = {\n      value,\n      oldValue\n    };\n    this.observers.notify(change, transaction);\n  }\n  finishTransaction(transaction) {\n    return this.observers.finishTransaction(transaction);\n  }\n  onUpdate(handler) {\n    return this.observers.add(handler);\n  }\n};\n\n// src/utils/utils.ts\nfunction isFunction(value) {\n  return value instanceof Function;\n}\nfunction isString2(value) {\n  return typeof value === \"string\";\n}\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\nfunction isArray(value) {\n  return value instanceof Array;\n}\nfunction isObject(value) {\n  return typeof value === \"object\";\n}\n\n// src/render/style/backgroundImageFromProps.ts\nfunction applyForwardOverrides(background, props) {\n  const { _forwardedOverrideId, _forwardedOverrides, id } = props;\n  const forwardedOverrideId = _forwardedOverrideId != null ? _forwardedOverrideId : id;\n  const src = _forwardedOverrides && forwardedOverrideId ? _forwardedOverrides[forwardedOverrideId] : void 0;\n  if (src && typeof src === \"string\") {\n    background = { ...background, src };\n  }\n  return background;\n}\nfunction backgroundImageFromProps(props) {\n  const { background, image } = props;\n  if (image !== void 0 && background && !BackgroundImage.isImageObject(background)) {\n    return;\n  }\n  let backgroundImage = null;\n  if (isString2(image)) {\n    backgroundImage = { src: image };\n  } else {\n    backgroundImage = Animatable.get(background, null);\n  }\n  if (!BackgroundImage.isImageObject(backgroundImage)) {\n    return;\n  }\n  return applyForwardOverrides(backgroundImage, props);\n}\n\n// src/render/types/NewConstraints.tsx\n\n\n// src/render/utils/roundedNumber.ts\nfunction roundedNumber(value, decimals) {\n  const d = Math.round(Math.abs(decimals));\n  const multiplier = Math.pow(10, d);\n  return Math.round(value * multiplier) / multiplier;\n}\nfunction roundedNumberString(value, decimals) {\n  const result = value.toFixed(decimals);\n  if (decimals === 0) {\n    return result;\n  }\n  return result.replace(/\\.?0+$/, \"\");\n}\nfunction roundWithOffset(value, offset) {\n  if (offset === 0) {\n    return Math.round(value);\n  }\n  offset -= offset | 0;\n  if (offset < 0) {\n    offset = 1 - offset;\n  }\n  return Math.round(value - offset) + offset;\n}\n\n// src/render/types/Point.ts\nfunction Point(x, y) {\n  return { x, y };\n}\n(function(Point2) {\n  Point2.add = (...args) => {\n    return args.reduce((previousValue, currentValue) => {\n      return { x: previousValue.x + currentValue.x, y: previousValue.y + currentValue.y };\n    }, { x: 0, y: 0 });\n  };\n  Point2.subtract = (a2, b2) => {\n    return { x: a2.x - b2.x, y: a2.y - b2.y };\n  };\n  Point2.multiply = (a2, b2) => {\n    return { x: a2.x * b2, y: a2.y * b2 };\n  };\n  Point2.divide = (a2, b2) => {\n    return { x: a2.x / b2, y: a2.y / b2 };\n  };\n  Point2.absolute = (point) => {\n    return {\n      x: Math.abs(point.x),\n      y: Math.abs(point.y)\n    };\n  };\n  Point2.reverse = (point) => {\n    return {\n      x: point.x * -1,\n      y: point.y * -1\n    };\n  };\n  Point2.pixelAligned = (point, offset = { x: 0, y: 0 }) => {\n    return {\n      x: roundWithOffset(point.x, offset.x),\n      y: roundWithOffset(point.y, offset.y)\n    };\n  };\n  Point2.distance = (a2, b2) => {\n    const deltaX = Math.abs(a2.x - b2.x);\n    const deltaY = Math.abs(a2.y - b2.y);\n    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n  };\n  Point2.angle = (a2, b2) => {\n    return Math.atan2(b2.y - a2.y, b2.x - a2.x) * 180 / Math.PI - 90;\n  };\n  Point2.isEqual = (a2, b2) => {\n    return a2.x === b2.x && a2.y === b2.y;\n  };\n  Point2.rotationNormalizer = () => {\n    let lastValue;\n    return (value) => {\n      if (typeof lastValue !== \"number\") {\n        lastValue = value;\n      }\n      const diff = lastValue - value;\n      const maxDiff = Math.abs(diff) + 180;\n      const nTimes = Math.floor(maxDiff / 360);\n      if (diff < 180) {\n        value -= nTimes * 360;\n      }\n      if (diff > 180) {\n        value += nTimes * 360;\n      }\n      lastValue = value;\n      return value;\n    };\n  };\n  function center(a2, b2) {\n    return {\n      x: (a2.x + b2.x) / 2,\n      y: (a2.y + b2.y) / 2\n    };\n  }\n  Point2.center = center;\n})(Point || (Point = {}));\n\n// src/render/types/Rect.ts\nvar Rect;\n(function(Rect2) {\n  function equals(rect, other) {\n    if (rect === other)\n      return true;\n    if (!rect || !other)\n      return false;\n    return rect.x === other.x && rect.y === other.y && rect.width === other.width && rect.height === other.height;\n  }\n  Rect2.equals = equals;\n  Rect2.atOrigin = (size2) => {\n    return { ...size2, x: 0, y: 0 };\n  };\n  Rect2.fromTwoPoints = (a2, b2) => {\n    return {\n      x: Math.min(a2.x, b2.x),\n      y: Math.min(a2.y, b2.y),\n      width: Math.abs(a2.x - b2.x),\n      height: Math.abs(a2.y - b2.y)\n    };\n  };\n  Rect2.fromRect = (rect) => {\n    return {\n      x: rect.left,\n      y: rect.top,\n      width: rect.right - rect.left,\n      height: rect.bottom - rect.top\n    };\n  };\n  Rect2.multiply = (rect, n) => {\n    return {\n      x: rect.x * n,\n      y: rect.y * n,\n      width: rect.width * n,\n      height: rect.height * n\n    };\n  };\n  Rect2.divide = (rect, n) => {\n    return Rect2.multiply(rect, 1 / n);\n  };\n  Rect2.offset = (rect, delta2) => {\n    const xOffset = typeof delta2.x === \"number\" ? delta2.x : 0;\n    const yOffset = typeof delta2.y === \"number\" ? delta2.y : 0;\n    return {\n      ...rect,\n      x: rect.x + xOffset,\n      y: rect.y + yOffset\n    };\n  };\n  function inflate(rect, value) {\n    if (value === 0)\n      return rect;\n    const doubleValue = 2 * value;\n    return {\n      x: rect.x - value,\n      y: rect.y - value,\n      width: rect.width + doubleValue,\n      height: rect.height + doubleValue\n    };\n  }\n  Rect2.inflate = inflate;\n  Rect2.pixelAligned = (rect) => {\n    const x = Math.round(rect.x);\n    const y = Math.round(rect.y);\n    const rectMaxX = Math.round(rect.x + rect.width);\n    const rectMaxY = Math.round(rect.y + rect.height);\n    const width = Math.max(rectMaxX - x, 0);\n    const height = Math.max(rectMaxY - y, 0);\n    return { x, y, width, height };\n  };\n  Rect2.halfPixelAligned = (rect) => {\n    const x = Math.round(rect.x * 2) / 2;\n    const y = Math.round(rect.y * 2) / 2;\n    const rectMaxX = Math.round((rect.x + rect.width) * 2) / 2;\n    const rectMaxY = Math.round((rect.y + rect.height) * 2) / 2;\n    const width = Math.max(rectMaxX - x, 1);\n    const height = Math.max(rectMaxY - y, 1);\n    return { x, y, width, height };\n  };\n  Rect2.round = (rect, decimals = 0) => {\n    const x = roundedNumber(rect.x, decimals);\n    const y = roundedNumber(rect.y, decimals);\n    const width = roundedNumber(rect.width, decimals);\n    const height = roundedNumber(rect.height, decimals);\n    return { x, y, width, height };\n  };\n  Rect2.roundToOutside = (rect) => {\n    const x = Math.floor(rect.x);\n    const y = Math.floor(rect.y);\n    const rectMaxX = Math.ceil(rect.x + rect.width);\n    const rectMaxY = Math.ceil(rect.y + rect.height);\n    const width = Math.max(rectMaxX - x, 0);\n    const height = Math.max(rectMaxY - y, 0);\n    return { x, y, width, height };\n  };\n  Rect2.minX = (rect) => {\n    return rect.x;\n  };\n  Rect2.maxX = (rect) => {\n    return rect.x + rect.width;\n  };\n  Rect2.minY = (rect) => {\n    return rect.y;\n  };\n  Rect2.maxY = (rect) => {\n    return rect.y + rect.height;\n  };\n  Rect2.positions = (rect) => {\n    return {\n      minX: rect.x,\n      midX: rect.x + rect.width / 2,\n      maxX: Rect2.maxX(rect),\n      minY: rect.y,\n      midY: rect.y + rect.height / 2,\n      maxY: Rect2.maxY(rect)\n    };\n  };\n  Rect2.center = (rect) => {\n    return {\n      x: rect.x + rect.width / 2,\n      y: rect.y + rect.height / 2\n    };\n  };\n  Rect2.fromPoints = (ps) => {\n    const xValues = ps.map((point) => point.x);\n    const yValues = ps.map((point) => point.y);\n    const x = Math.min(...xValues);\n    const y = Math.min(...yValues);\n    const width = Math.max(...xValues) - x;\n    const height = Math.max(...yValues) - y;\n    return { x, y, width, height };\n  };\n  Rect2.merge = (...rect) => {\n    const min = {\n      x: Math.min(...rect.map(Rect2.minX)),\n      y: Math.min(...rect.map(Rect2.minY))\n    };\n    const max = {\n      x: Math.max(...rect.map(Rect2.maxX)),\n      y: Math.max(...rect.map(Rect2.maxY))\n    };\n    return Rect2.fromTwoPoints(min, max);\n  };\n  Rect2.intersection = (rect1, rect2) => {\n    const x = Math.max(rect1.x, rect2.x);\n    const x2 = Math.min(rect1.x + rect1.width, rect2.x + rect2.width);\n    const y = Math.max(rect1.y, rect2.y);\n    const y2 = Math.min(rect1.y + rect1.height, rect2.y + rect2.height);\n    return { x, y, width: x2 - x, height: y2 - y };\n  };\n  Rect2.points = (rect) => {\n    return [\n      { x: Rect2.minX(rect), y: Rect2.minY(rect) },\n      { x: Rect2.minX(rect), y: Rect2.maxY(rect) },\n      { x: Rect2.maxX(rect), y: Rect2.minY(rect) },\n      { x: Rect2.maxX(rect), y: Rect2.maxY(rect) }\n    ];\n  };\n  Rect2.transform = (rect, matrix) => {\n    const { x: x1, y: y1 } = matrix.transformPoint({ x: rect.x, y: rect.y });\n    const { x: x2, y: y2 } = matrix.transformPoint({ x: rect.x + rect.width, y: rect.y });\n    const { x: x3, y: y3 } = matrix.transformPoint({ x: rect.x + rect.width, y: rect.y + rect.height });\n    const { x: x4, y: y4 } = matrix.transformPoint({ x: rect.x, y: rect.y + rect.height });\n    const x = Math.min(x1, x2, x3, x4);\n    const width = Math.max(x1, x2, x3, x4) - x;\n    const y = Math.min(y1, y2, y3, y4);\n    const height = Math.max(y1, y2, y3, y4) - y;\n    return { x, y, width, height };\n  };\n  Rect2.containsPoint = (rect, point) => {\n    if (point.x < Rect2.minX(rect)) {\n      return false;\n    }\n    if (point.x > Rect2.maxX(rect)) {\n      return false;\n    }\n    if (point.y < Rect2.minY(rect)) {\n      return false;\n    }\n    if (point.y > Rect2.maxY(rect)) {\n      return false;\n    }\n    if (isNaN(rect.x)) {\n      return false;\n    }\n    if (isNaN(rect.y)) {\n      return false;\n    }\n    return true;\n  };\n  Rect2.containsRect = (rectA, rectB) => {\n    for (const point of Rect2.points(rectB)) {\n      if (!Rect2.containsPoint(rectA, point)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  Rect2.toCSS = (rect) => {\n    return {\n      display: \"block\",\n      transform: `translate(${rect.x}px, ${rect.y}px)`,\n      width: `${rect.width}px`,\n      height: `${rect.height}px`\n    };\n  };\n  Rect2.inset = (rect, n) => {\n    return {\n      x: rect.x + n,\n      y: rect.y + n,\n      width: Math.max(0, rect.width - 2 * n),\n      height: Math.max(0, rect.height - 2 * n)\n    };\n  };\n  Rect2.intersects = (rectA, rectB) => {\n    return !(rectB.x >= Rect2.maxX(rectA) || Rect2.maxX(rectB) <= rectA.x || rectB.y >= Rect2.maxY(rectA) || Rect2.maxY(rectB) <= rectA.y);\n  };\n  Rect2.overlapHorizontally = (rectA, rectB) => {\n    const aMax = Rect2.maxX(rectA);\n    const bMax = Rect2.maxX(rectB);\n    return aMax > rectB.x && bMax > rectA.x;\n  };\n  Rect2.overlapVertically = (rectA, rectB) => {\n    const aMax = Rect2.maxY(rectA);\n    const bMax = Rect2.maxY(rectB);\n    return aMax > rectB.y && bMax > rectA.y;\n  };\n  Rect2.doesNotIntersect = (rect, rects) => {\n    return rects.find((comparingRect) => {\n      return Rect2.intersects(comparingRect, rect);\n    }) === void 0;\n  };\n  Rect2.isEqual = (rectA, rectB) => {\n    if (rectA && rectB) {\n      const { x, y, width, height } = rectA;\n      return rectB.x === x && rectB.y === y && rectB.width === width && rectB.height === height;\n    } else {\n      return rectA === rectB;\n    }\n  };\n  Rect2.cornerPoints = (rect) => {\n    const rectMinX = rect.x;\n    const rectMaxX = rect.x + rect.width;\n    const rectMinY = rect.y;\n    const rectMaxY = rect.y + rect.height;\n    const corner1 = { x: rectMinX, y: rectMinY };\n    const corner2 = { x: rectMaxX, y: rectMinY };\n    const corner3 = { x: rectMaxX, y: rectMaxY };\n    const corner4 = { x: rectMinX, y: rectMaxY };\n    return [corner1, corner2, corner3, corner4];\n  };\n  Rect2.midPoints = (rect) => {\n    const rectMinX = rect.x;\n    const rectMidX = rect.x + rect.width / 2;\n    const rectMaxX = rect.x + rect.width;\n    const rectMinY = rect.y;\n    const rectMidY = rect.y + rect.height / 2;\n    const rectMaxY = rect.y + rect.height;\n    const corner1 = { x: rectMidX, y: rectMinY };\n    const corner2 = { x: rectMaxX, y: rectMidY };\n    const corner3 = { x: rectMidX, y: rectMaxY };\n    const corner4 = { x: rectMinX, y: rectMidY };\n    return [corner1, corner2, corner3, corner4];\n  };\n  Rect2.pointDistance = (rect, point) => {\n    let x = 0;\n    let y = 0;\n    if (point.x < rect.x) {\n      x = rect.x - point.x;\n    } else if (point.x > Rect2.maxX(rect)) {\n      x = point.x - Rect2.maxX(rect);\n    }\n    if (point.y < rect.y) {\n      y = rect.y - point.y;\n    } else if (point.y > Rect2.maxY(rect)) {\n      y = point.y - Rect2.maxY(rect);\n    }\n    return Point.distance({ x, y }, { x: 0, y: 0 });\n  };\n  const fromAnyDefaults = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  };\n  Rect2.fromAny = (rect, defaults = fromAnyDefaults) => {\n    return {\n      x: rect.x || defaults.x,\n      y: rect.y || defaults.y,\n      width: rect.width || defaults.width,\n      height: rect.height || defaults.height\n    };\n  };\n})(Rect || (Rect = {}));\n\n// src/render/utils/isFiniteNumber.ts\nfunction isFiniteNumber(value) {\n  return typeof value === \"number\" && isFinite(value);\n}\nfunction finiteNumber(value) {\n  return isFiniteNumber(value) ? value : void 0;\n}\n\n// src/utils/type-guards.ts\nfunction isEmpty(obj) {\n  return !obj || !Object.keys(obj).length && obj.constructor === Object;\n}\nfunction isReactElement(test2) {\n  return typeof test2 !== \"string\" && typeof test2 !== \"number\";\n}\nfunction isReactChild(test2) {\n  return test2 !== null && typeof test2 !== \"undefined\" && typeof test2 !== \"boolean\" && !isEmpty(test2);\n}\n\n// src/render/types/Constraints.ts\nvar constraintDefaults = {\n  left: null,\n  right: null,\n  top: null,\n  bottom: null,\n  centerX: \"50%\",\n  centerY: \"50%\",\n  aspectRatio: null,\n  parentSize: null,\n  width: 100,\n  height: 100\n};\nvar DimensionType;\n(function(DimensionType2) {\n  DimensionType2[DimensionType2[\"FixedNumber\"] = 0] = \"FixedNumber\";\n  DimensionType2[DimensionType2[\"Percentage\"] = 1] = \"Percentage\";\n  DimensionType2[DimensionType2[\"Auto\"] = 2] = \"Auto\";\n  DimensionType2[DimensionType2[\"FractionOfFreeSpace\"] = 3] = \"FractionOfFreeSpace\";\n})(DimensionType || (DimensionType = {}));\nfunction isConstraintSupportingChild(child) {\n  if (!isReactChild(child) || !isReactElement(child)) {\n    return false;\n  }\n  return true;\n}\nvar ConstraintMask;\n(function(ConstraintMask2) {\n  ConstraintMask2.quickfix = (constraints) => {\n    if (constraints.widthType === 2 || constraints.heightType === 2) {\n      constraints.aspectRatio = null;\n    }\n    if (isFiniteNumber(constraints.aspectRatio)) {\n      if (constraints.left && constraints.right || constraints.top && constraints.bottom) {\n        constraints.widthType = 0;\n        constraints.heightType = 0;\n      }\n      if (constraints.left && constraints.right && constraints.top && constraints.bottom) {\n        constraints.bottom = false;\n      }\n      if (constraints.widthType !== 0 && constraints.heightType !== 0) {\n        constraints.heightType = 0;\n      }\n    }\n    if (constraints.left && constraints.right) {\n      if (constraints.fixedSize || constraints.widthType === 2) {\n        constraints.right = false;\n      }\n      constraints.widthType = 0;\n    }\n    if (constraints.top && constraints.bottom) {\n      if (constraints.fixedSize || constraints.heightType === 2) {\n        constraints.bottom = false;\n      }\n      constraints.heightType = 0;\n    }\n    return constraints;\n  };\n})(ConstraintMask || (ConstraintMask = {}));\nfunction valueToDimensionType(value) {\n  if (typeof value === \"string\") {\n    const trimmedValue = value.trim();\n    if (trimmedValue === \"auto\")\n      return 2;\n    if (trimmedValue.endsWith(\"fr\"))\n      return 3;\n    if (trimmedValue.endsWith(\"%\"))\n      return 1;\n  }\n  return 0;\n}\nvar ConstraintValues;\n(function(ConstraintValues2) {\n  ConstraintValues2.fromProperties = (props) => {\n    const { left, right, top, bottom, width, height, centerX, centerY, aspectRatio, autoSize } = props;\n    const constraints = ConstraintMask.quickfix({\n      left: isFiniteNumber(left) || isAnimatable2(left),\n      right: isFiniteNumber(right) || isAnimatable2(right),\n      top: isFiniteNumber(top) || isAnimatable2(top),\n      bottom: isFiniteNumber(bottom) || isAnimatable2(bottom),\n      widthType: valueToDimensionType(width),\n      heightType: valueToDimensionType(height),\n      aspectRatio: aspectRatio || null,\n      fixedSize: autoSize === true\n    });\n    let widthValue = null;\n    let heightValue = null;\n    let widthType = 0;\n    let heightType = 0;\n    if (constraints.widthType !== 0 && typeof width === \"string\") {\n      const parsedWidth = parseFloat(width);\n      if (width.endsWith(\"fr\")) {\n        widthType = 3;\n        widthValue = parsedWidth;\n      } else if (width === \"auto\") {\n        widthType = 2;\n      } else {\n        widthType = 1;\n        widthValue = parsedWidth / 100;\n      }\n    } else if (width !== void 0 && typeof width !== \"string\") {\n      widthValue = Animatable.getNumber(width);\n    }\n    if (constraints.heightType !== 0 && typeof height === \"string\") {\n      const parsedHeight = parseFloat(height);\n      if (height.endsWith(\"fr\")) {\n        heightType = 3;\n        heightValue = parsedHeight;\n      } else if (height === \"auto\") {\n        heightType = 2;\n      } else {\n        heightType = 1;\n        heightValue = parseFloat(height) / 100;\n      }\n    } else if (height !== void 0 && typeof height !== \"string\") {\n      heightValue = Animatable.getNumber(height);\n    }\n    let centerAnchorX = 0.5;\n    let centerAnchorY = 0.5;\n    if (centerX) {\n      centerAnchorX = parseFloat(centerX) / 100;\n    }\n    if (centerY) {\n      centerAnchorY = parseFloat(centerY) / 100;\n    }\n    return {\n      left: constraints.left ? Animatable.getNumber(left) : null,\n      right: constraints.right ? Animatable.getNumber(right) : null,\n      top: constraints.top ? Animatable.getNumber(top) : null,\n      bottom: constraints.bottom ? Animatable.getNumber(bottom) : null,\n      widthType,\n      heightType,\n      width: widthValue,\n      height: heightValue,\n      aspectRatio: constraints.aspectRatio || null,\n      centerAnchorX,\n      centerAnchorY\n    };\n  };\n  ConstraintValues2.toMinSize = (values, parentSize, autoSize = null) => {\n    let width = null;\n    let height = null;\n    const parentWidth = parentSize ? parentSize.width : null;\n    const parentHeight = parentSize ? parentSize.height : null;\n    const hOpposingPinsOffset = pinnedOffset(values.left, values.right);\n    if (parentWidth && isFiniteNumber(hOpposingPinsOffset)) {\n      width = parentWidth - hOpposingPinsOffset;\n    } else if (autoSize && values.widthType === 2) {\n      width = autoSize.width;\n    } else if (isFiniteNumber(values.width)) {\n      switch (values.widthType) {\n        case 0:\n          width = values.width;\n          break;\n        case 3:\n          width = 0;\n          break;\n        case 1:\n          if (parentWidth) {\n            width = parentWidth * values.width;\n          }\n          break;\n      }\n    }\n    const vOpposingPinsOffset = pinnedOffset(values.top, values.bottom);\n    if (parentHeight && isFiniteNumber(vOpposingPinsOffset)) {\n      height = parentHeight - vOpposingPinsOffset;\n    } else if (autoSize && values.heightType === 2) {\n      height = autoSize.height;\n    } else if (isFiniteNumber(values.height)) {\n      switch (values.heightType) {\n        case 0:\n          height = values.height;\n          break;\n        case 3:\n          height = 0;\n          break;\n        case 1:\n          if (parentHeight) {\n            height = parentHeight * values.height;\n          }\n          break;\n      }\n    }\n    return sizeAfterApplyingDefaultsAndAspectRatio(width, height, values);\n  };\n  ConstraintValues2.toSize = (values, parentSize, autoSize, freeSpace) => {\n    let width = null;\n    let height = null;\n    const parentWidth = parentSize ? Animatable.getNumber(parentSize.width) : null;\n    const parentHeight = parentSize ? Animatable.getNumber(parentSize.height) : null;\n    const hOpposingPinsOffset = pinnedOffset(values.left, values.right);\n    if (parentWidth && isFiniteNumber(hOpposingPinsOffset)) {\n      width = parentWidth - hOpposingPinsOffset;\n    } else if (autoSize && values.widthType === 2) {\n      width = autoSize.width;\n    } else if (isFiniteNumber(values.width)) {\n      switch (values.widthType) {\n        case 0:\n          width = values.width;\n          break;\n        case 3:\n          width = freeSpace ? freeSpace.freeSpaceInParent.width / freeSpace.freeSpaceUnitDivisor.width * values.width : 0;\n          break;\n        case 1:\n          if (parentWidth) {\n            width = parentWidth * values.width;\n          }\n          break;\n      }\n    }\n    const vOpposingPinsOffset = pinnedOffset(values.top, values.bottom);\n    if (parentHeight && isFiniteNumber(vOpposingPinsOffset)) {\n      height = parentHeight - vOpposingPinsOffset;\n    } else if (autoSize && values.heightType === 2) {\n      height = autoSize.height;\n    } else if (isFiniteNumber(values.height)) {\n      switch (values.heightType) {\n        case 0:\n          height = values.height;\n          break;\n        case 3:\n          height = freeSpace ? freeSpace.freeSpaceInParent.height / freeSpace.freeSpaceUnitDivisor.height * values.height : 0;\n          break;\n        case 1:\n          if (parentHeight) {\n            height = parentHeight * values.height;\n          }\n          break;\n      }\n    }\n    return sizeAfterApplyingDefaultsAndAspectRatio(width, height, values);\n  };\n  ConstraintValues2.toRect = (values, parentSize, autoSize = null, pixelAlign = false, freeSpace = null) => {\n    let x = values.left || 0;\n    let y = values.top || 0;\n    let width = null;\n    let height = null;\n    const parentWidth = parentSize ? Animatable.getNumber(parentSize.width) : null;\n    const parentHeight = parentSize ? Animatable.getNumber(parentSize.height) : null;\n    const hOpposingPinsOffset = pinnedOffset(values.left, values.right);\n    if (parentWidth && isFiniteNumber(hOpposingPinsOffset)) {\n      width = parentWidth - hOpposingPinsOffset;\n    } else if (autoSize && values.widthType === 2) {\n      width = autoSize.width;\n    } else if (isFiniteNumber(values.width)) {\n      switch (values.widthType) {\n        case 0:\n          width = values.width;\n          break;\n        case 3:\n          width = freeSpace ? freeSpace.freeSpaceInParent.width / freeSpace.freeSpaceUnitDivisor.width * values.width : null;\n          break;\n        case 1:\n          if (parentWidth) {\n            width = parentWidth * values.width;\n          }\n          break;\n      }\n    }\n    const vOpposingPinsOffset = pinnedOffset(values.top, values.bottom);\n    if (parentHeight && isFiniteNumber(vOpposingPinsOffset)) {\n      height = parentHeight - vOpposingPinsOffset;\n    } else if (autoSize && values.heightType === 2) {\n      height = autoSize.height;\n    } else if (isFiniteNumber(values.height)) {\n      switch (values.heightType) {\n        case 0:\n          height = values.height;\n          break;\n        case 3:\n          height = freeSpace ? freeSpace.freeSpaceInParent.height / freeSpace.freeSpaceUnitDivisor.height * values.height : null;\n          break;\n        case 1:\n          if (parentHeight) {\n            height = parentHeight * values.height;\n          }\n          break;\n      }\n    }\n    const sizeWithDefaults = sizeAfterApplyingDefaultsAndAspectRatio(width, height, values);\n    width = sizeWithDefaults.width;\n    height = sizeWithDefaults.height;\n    if (values.left !== null) {\n      x = values.left;\n    } else if (parentWidth && values.right !== null) {\n      x = parentWidth - values.right - width;\n    } else if (parentWidth) {\n      x = values.centerAnchorX * parentWidth - width / 2;\n    }\n    if (values.top !== null) {\n      y = values.top;\n    } else if (parentHeight && values.bottom !== null) {\n      y = parentHeight - values.bottom - height;\n    } else if (parentHeight) {\n      y = values.centerAnchorY * parentHeight - height / 2;\n    }\n    const f = { x, y, width, height };\n    if (pixelAlign) {\n      return Rect.pixelAligned(f);\n    }\n    return f;\n  };\n})(ConstraintValues || (ConstraintValues = {}));\nvar defaultWidth = 200;\nvar defaultHeight = 200;\nfunction sizeAfterApplyingDefaultsAndAspectRatio(width, height, values) {\n  let w = isFiniteNumber(width) ? width : defaultWidth;\n  let h = isFiniteNumber(height) ? height : defaultHeight;\n  if (isFiniteNumber(values.aspectRatio) && values.aspectRatio > 0) {\n    if (isFiniteNumber(values.left) && isFiniteNumber(values.right)) {\n      h = w / values.aspectRatio;\n    } else if (isFiniteNumber(values.top) && isFiniteNumber(values.bottom)) {\n      w = h * values.aspectRatio;\n    } else if (values.widthType !== 0) {\n      h = w / values.aspectRatio;\n    } else {\n      w = h * values.aspectRatio;\n    }\n  }\n  return {\n    width: w,\n    height: h\n  };\n}\nfunction pinnedOffset(start, end) {\n  if (!isFiniteNumber(start) || !isFiniteNumber(end))\n    return null;\n  return start + end;\n}\nfunction getMergedConstraintsProps(props, constraints) {\n  const result = {};\n  if (props.constraints) {\n    result.constraints = { ...props.constraints, ...constraints };\n  } else {\n    Object.assign(result, constraints);\n  }\n  return result;\n}\n\n// src/render/types/NewConstraints.tsx\nfunction isString3(t) {\n  return typeof t === \"string\";\n}\nfunction containsInvalidStringValues(props) {\n  const { left, right, top, bottom, center } = props;\n  if ([right, bottom].some(isString3)) {\n    return true;\n  }\n  if (isString3(left) && (!center || center === \"y\")) {\n    return true;\n  }\n  if (isString3(top) && (!center || center === \"x\")) {\n    return true;\n  }\n  return false;\n}\nfunction constraintsEnabled(props) {\n  const { _constraints } = props;\n  if (!_constraints) {\n    return false;\n  }\n  if (containsInvalidStringValues(props)) {\n    return false;\n  }\n  return _constraints.enabled;\n}\nfunction sizeFromFiniteNumberProps(props) {\n  const { size: size2 } = props;\n  let { width, height } = props;\n  if (isFiniteNumber(size2)) {\n    if (width === void 0) {\n      width = size2;\n    }\n    if (height === void 0) {\n      height = size2;\n    }\n  }\n  if (isFiniteNumber(width) && isFiniteNumber(height)) {\n    return {\n      width,\n      height\n    };\n  }\n  return null;\n}\nfunction rectFromFiniteNumberProps(props) {\n  const size2 = sizeFromFiniteNumberProps(props);\n  if (size2 === null) {\n    return null;\n  }\n  const { left, top } = props;\n  if (isFiniteNumber(left) && isFiniteNumber(top)) {\n    return {\n      x: left,\n      y: top,\n      ...size2\n    };\n  }\n  return null;\n}\nfunction calculateRect(props, parentSize, pixelAlign = true) {\n  if (!constraintsEnabled(props) || parentSize === ParentSizeState.Disabled || parentSize === ParentSizeState.DisabledForCurrentLevel) {\n    return rectFromFiniteNumberProps(props);\n  }\n  const constraintValues = getConstraintValues(props);\n  return ConstraintValues.toRect(constraintValues, deprecatedParentSize(parentSize), null, pixelAlign);\n}\nfunction getConstraintValues(props) {\n  const { left, right, top, bottom, center, _constraints, size: size2 } = props;\n  let { width, height } = props;\n  if (width === void 0) {\n    width = size2;\n  }\n  if (height === void 0) {\n    height = size2;\n  }\n  const { aspectRatio, autoSize } = _constraints;\n  const constraintMask = ConstraintMask.quickfix({\n    left: isFiniteNumber(left),\n    right: isFiniteNumber(right),\n    top: isFiniteNumber(top),\n    bottom: isFiniteNumber(bottom),\n    widthType: valueToDimensionType(width),\n    heightType: valueToDimensionType(height),\n    aspectRatio: aspectRatio || null,\n    fixedSize: autoSize === true\n  });\n  let widthValue = null;\n  let heightValue = null;\n  let widthType = DimensionType.FixedNumber;\n  let heightType = DimensionType.FixedNumber;\n  if (constraintMask.widthType !== DimensionType.FixedNumber && typeof width === \"string\") {\n    const parsedWidth = parseFloat(width);\n    if (width.endsWith(\"fr\")) {\n      widthType = DimensionType.FractionOfFreeSpace;\n      widthValue = parsedWidth;\n    } else if (width === \"auto\") {\n      widthType = DimensionType.Auto;\n    } else {\n      widthType = DimensionType.Percentage;\n      widthValue = parsedWidth / 100;\n    }\n  } else if (width !== void 0 && typeof width !== \"string\") {\n    widthValue = width;\n  }\n  if (constraintMask.heightType !== DimensionType.FixedNumber && typeof height === \"string\") {\n    const parsedHeight = parseFloat(height);\n    if (height.endsWith(\"fr\")) {\n      heightType = DimensionType.FractionOfFreeSpace;\n      heightValue = parsedHeight;\n    } else if (height === \"auto\") {\n      heightType = DimensionType.Auto;\n    } else {\n      heightType = DimensionType.Percentage;\n      heightValue = parseFloat(height) / 100;\n    }\n  } else if (height !== void 0 && typeof height !== \"string\") {\n    heightValue = height;\n  }\n  let centerAnchorX = 0.5;\n  let centerAnchorY = 0.5;\n  if (center === true || center === \"x\") {\n    constraintMask.left = false;\n    if (typeof left === \"string\") {\n      centerAnchorX = parseFloat(left) / 100;\n    }\n  }\n  if (center === true || center === \"y\") {\n    constraintMask.top = false;\n    if (typeof top === \"string\") {\n      centerAnchorY = parseFloat(top) / 100;\n    }\n  }\n  return {\n    left: constraintMask.left ? left : null,\n    right: constraintMask.right ? right : null,\n    top: constraintMask.top ? top : null,\n    bottom: constraintMask.bottom ? bottom : null,\n    widthType,\n    heightType,\n    width: widthValue,\n    height: heightValue,\n    aspectRatio: constraintMask.aspectRatio || null,\n    centerAnchorX,\n    centerAnchorY\n  };\n}\nvar ParentSizeState;\n(function(ParentSizeState2) {\n  ParentSizeState2[ParentSizeState2[\"Unknown\"] = 0] = \"Unknown\";\n  ParentSizeState2[ParentSizeState2[\"Disabled\"] = 1] = \"Disabled\";\n  ParentSizeState2[ParentSizeState2[\"DisabledForCurrentLevel\"] = 2] = \"DisabledForCurrentLevel\";\n})(ParentSizeState || (ParentSizeState = {}));\nvar ConstraintsContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({ size: 0 });\nfunction deprecatedParentSize(parentSize) {\n  if (parentSize === 0 || parentSize === 1 || parentSize === 2) {\n    return null;\n  }\n  return parentSize;\n}\nfunction useParentSize() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ConstraintsContext).size;\n}\nfunction isSize(o) {\n  return typeof o === \"object\";\n}\nvar ProvideParentSize = (props) => {\n  const currentParentSize = useParentSize();\n  const { parentSize, children } = props;\n  const memoKey = isSize(parentSize) ? [parentSize.width, parentSize.height] : [parentSize, -1];\n  const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({ size: parentSize }), memoKey);\n  if (currentParentSize === 1) {\n    return children ? /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, children) : null;\n  }\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ConstraintsContext.Provider, {\n    value\n  }, children);\n};\nvar ConsumeParentSize = ConstraintsContext.Consumer;\nfunction useProvideParentSize(node, parentSize) {\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ProvideParentSize, {\n    parentSize\n  }, node);\n}\nfunction useConstraints(props) {\n  const parentSize = useParentSize();\n  return calculateRect(props, parentSize);\n}\n\n// src/render/utils/setDocumentStyles.ts\nvar cache = new Set();\nvar styleElement;\nfunction setDocumentStyles(css) {\n  if (cache.has(css) || typeof document === \"undefined\")\n    return;\n  cache.add(css);\n  if (!styleElement) {\n    styleElement = document.createElement(\"style\");\n    styleElement.type = \"text/css\";\n    document.head && document.head.appendChild(styleElement);\n  }\n  styleElement.appendChild(document.createTextNode(css));\n}\n\n// src/render/types/RenderEnvironment.ts\nvar RenderTarget;\n(function(RenderTarget2) {\n  RenderTarget2[\"canvas\"] = \"CANVAS\";\n  RenderTarget2[\"export\"] = \"EXPORT\";\n  RenderTarget2[\"thumbnail\"] = \"THUMBNAIL\";\n  RenderTarget2[\"preview\"] = \"PREVIEW\";\n})(RenderTarget || (RenderTarget = {}));\nvar RenderEnvironment = {\n  imageBaseURL: \"\",\n  target: RenderTarget.preview,\n  zoom: 1\n};\nfunction executeInRenderEnvironment(customEnvironment, task) {\n  const previousEnvironment = Object.assign({}, RenderEnvironment);\n  Object.assign(RenderEnvironment, customEnvironment);\n  const result = task();\n  Object.assign(RenderEnvironment, previousEnvironment);\n  return result;\n}\nfunction setGlobalRenderEnvironment(environment3) {\n  Object.assign(RenderEnvironment, environment3);\n}\nfunction useRenderEnvironment(target, imageBaseURL, zoom) {\n  let willChangeElements = false;\n  if (RenderEnvironment.imageBaseURL !== imageBaseURL) {\n    RenderEnvironment.imageBaseURL = imageBaseURL;\n    willChangeElements = true;\n  }\n  if (RenderEnvironment.target !== target) {\n    RenderEnvironment.target = target;\n    willChangeElements = true;\n  }\n  if (RenderEnvironment.zoom !== zoom) {\n    RenderEnvironment.zoom = zoom;\n  }\n  return { willChangeElements };\n}\n(function(RenderTarget2) {\n  function current() {\n    return RenderEnvironment.target;\n  }\n  RenderTarget2.current = current;\n  function hasRestrictions() {\n    const target = RenderEnvironment.target;\n    if (target === RenderTarget2.canvas)\n      return true;\n    if (target === RenderTarget2.export)\n      return true;\n    return false;\n  }\n  RenderTarget2.hasRestrictions = hasRestrictions;\n})(RenderTarget || (RenderTarget = {}));\n\n// src/render/utils/injectComponentCSSRules.ts\nvar componentCSSRules = `\n\n[data-framer-component-type] {\n    position: absolute;\n}\n`;\nvar textCSSRules = `\n[data-framer-component-type=\"Text\"] {\n    cursor: inherit;\n}\n\n[data-framer-component-text-autosized] * {\n    white-space: pre;\n}\n`;\nvar stackCSSRules = `\n:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > *,\n:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-component-type],\n:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-stack-gap] > *,\n:not([data-framer-generated]) > [data-framer-stack-content-wrapper] > [data-framer-stack-gap] > [data-framer-component-type] {\n    position: relative;\n}\n\n[data-framer-stack-gap] > * {\n    margin-top: calc(var(--stack-gap-y) / 2);\n    margin-bottom: calc(var(--stack-gap-y) / 2);\n    margin-right: calc(var(--stack-gap-x) / 2);\n    margin-left: calc(var(--stack-gap-x) / 2);\n}\n\n/* This should take the language direction into account */\n[data-framer-stack-direction-reverse=\"false\"]\n[data-framer-stack-gap]\n> *:first-child,\n[data-framer-stack-direction-reverse=\"true\"]\n[data-framer-stack-gap]\n> *:last-child {\n    margin-top: 0;\n    margin-left: 0;\n}\n\n/* This should take the language direction into account */\n[data-framer-stack-direction-reverse=\"false\"]\n[data-framer-stack-gap]\n> *:last-child,\n[data-framer-stack-direction-reverse=\"true\"]\n[data-framer-stack-gap]\n> *:first-child {\n    margin-right: 0;\n    margin-bottom: 0;\n}\n`;\nvar navigationCSSRules = `\nNavigationContainer\n[data-framer-component-type=\"NavigationContainer\"] > *,\n[data-framer-component-type=\"NavigationContainer\"] > [data-framer-component-type] {\n    position: relative;\n}\n`;\nvar scrollCSSRules = `\n[data-framer-component-type=\"Scroll\"]::-webkit-scrollbar {\n    display: none;\n}\n[data-framer-component-type=\"ScrollContentWrapper\"] > * {\n    position: relative;\n}\n`;\nvar nativeScrollCSSRules = `\n[data-framer-component-type=\"NativeScroll\"] {\n    -webkit-overflow-scrolling: touch;\n}\n\n[data-framer-component-type=\"NativeScroll\"] > * {\n    position: relative;\n}\n\n[data-framer-component-type=\"NativeScroll\"].direction-both {\n    overflow-x: scroll;\n    overflow-y: scroll;\n}\n\n[data-framer-component-type=\"NativeScroll\"].direction-vertical {\n    overflow-x: hidden;\n    overflow-y: scroll;\n}\n\n[data-framer-component-type=\"NativeScroll\"].direction-horizontal {\n    overflow-x: scroll;\n    overflow-y: hidden;\n}\n\n[data-framer-component-type=\"NativeScroll\"].direction-vertical > * {\n    width: 100% !important;\n}\n\n[data-framer-component-type=\"NativeScroll\"].direction-horizontal > * {\n    height: 100% !important;\n}\n\n[data-framer-component-type=\"NativeScroll\"].scrollbar-hidden::-webkit-scrollbar {\n    display: none;\n}\n`;\nvar pageContentWrapperWrapperCSSRules = `\n[data-framer-component-type=\"PageContentWrapper\"] > *,\n[data-framer-component-type=\"PageContentWrapper\"] > [data-framer-component-type] {\n    position: relative;\n}\n`;\nvar presenceCSS = `\n[data-is-present=\"false\"], [data-is-present=\"false\"] * {\n    pointer-events: none !important;\n}\n`;\nvar cursorCSS = `\n[data-framer-cursor=\"pointer\"] {\n    cursor: pointer;\n}\n[data-framer-cursor=\"grab\"] {\n    cursor: grab;\n}\n[data-framer-cursor=\"grab\"]:active {\n    cursor: grabbing;\n}\n`;\nvar frameCSSRules = (isPreview) => {\n  return isPreview ? ` [data-framer-component-type=\"Frame\"] * { pointer-events: auto; } ` : ``;\n};\nvar textSelectionCSSRules = (isPreview) => {\n  return isPreview ? `\n        body :not(input):not(textarea):not([contenteditable=\"true\"]) {\n            user-select: none;\n            -webkit-user-select: none;\n        }\n\n        [data-framer-component-type=\"Text\"], [data-framer-component-type=\"Text\"] * {\n        pointer-events: none !important;\n        user-select: none;\n        -webkit-user-select: none;\n    }` : ``;\n};\nvar combineCSSRules = (isPreview) => `\n${componentCSSRules}\n${textCSSRules}\n${stackCSSRules}\n${navigationCSSRules}\n${scrollCSSRules}\n${nativeScrollCSSRules}\n${pageContentWrapperWrapperCSSRules}\n${presenceCSS}\n${cursorCSS}\n${frameCSSRules(isPreview)}\n${textSelectionCSSRules(isPreview)}\n`;\nvar combinedCSSRules = combineCSSRules(false);\nvar combinedCSSRulesForPreview = combineCSSRules(true);\nvar injectComponentCSSRules = () => {\n  const styles = RenderTarget.current() === RenderTarget.preview ? combinedCSSRulesForPreview : combinedCSSRules;\n  setDocumentStyles(styles);\n};\n\n// src/render/utils/processOverrideForwarding.ts\n\nfunction processOverrideForwarding(props, children) {\n  if (!children) {\n    children = props.children;\n    if (!children)\n      return { props, children };\n  }\n  let _forwardedOverrides = props._forwardedOverrides;\n  const extractions = props._overrideForwardingDescription;\n  if (extractions) {\n    _forwardedOverrides = void 0;\n    for (const key6 in extractions) {\n      const propName = extractions[key6];\n      const value = props[propName];\n      if (value !== void 0) {\n        if (!_forwardedOverrides) {\n          _forwardedOverrides = {};\n          props = { ...props };\n        }\n        _forwardedOverrides[key6] = props[propName];\n        delete props[propName];\n      }\n    }\n  }\n  if (!_forwardedOverrides)\n    return { props, children };\n  children = react__WEBPACK_IMPORTED_MODULE_0__.Children.map(children, (child) => {\n    if (!(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(child))\n      return child;\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(child, { _forwardedOverrides });\n  });\n  return { props, children };\n}\n\n// src/render/types/Color/Utils.ts\nfunction modulate(value, rangeA, rangeB, limit = false) {\n  const [fromLow, fromHigh] = rangeA;\n  const [toLow, toHigh] = rangeB;\n  const result = toLow + (value - fromLow) / (fromHigh - fromLow) * (toHigh - toLow);\n  if (limit === true) {\n    if (toLow < toHigh) {\n      if (result < toLow) {\n        return toLow;\n      }\n      if (result > toHigh) {\n        return toHigh;\n      }\n    } else {\n      if (result > toLow) {\n        return toLow;\n      }\n      if (result < toHigh) {\n        return toHigh;\n      }\n    }\n  }\n  return result;\n}\nfunction isNumeric(value) {\n  return !isNaN(value) && isFinite(value);\n}\nfunction percentToFraction(val) {\n  const digits = numberFromString(val);\n  if (digits !== void 0) {\n    if (val.includes(\"%\")) {\n      return digits / 100;\n    }\n    return digits;\n  }\n  return 0;\n}\nfunction numberFromString(input) {\n  const match = input.match(/\\d?\\.?\\d+/);\n  return match ? Number(match[0]) : void 0;\n}\n\n// src/render/types/Color/converters.ts\nvar import_hsluv = __toModule(require_hsluv());\n\n// src/render/types/Color/types.ts\nvar ColorFormat;\n(function(ColorFormat2) {\n  ColorFormat2[\"RGB\"] = \"rgb\";\n  ColorFormat2[\"HSL\"] = \"hsl\";\n  ColorFormat2[\"HSV\"] = \"hsv\";\n  ColorFormat2[\"HEX\"] = \"hex\";\n  ColorFormat2[\"NAME\"] = \"name\";\n})(ColorFormat || (ColorFormat = {}));\nvar ColorMixModelType;\n(function(ColorMixModelType2) {\n  ColorMixModelType2[\"RGB\"] = \"rgb\";\n  ColorMixModelType2[\"RGBA\"] = \"rgba\";\n  ColorMixModelType2[\"HSL\"] = \"hsl\";\n  ColorMixModelType2[\"HSLA\"] = \"hsla\";\n  ColorMixModelType2[\"HUSL\"] = \"husl\";\n})(ColorMixModelType || (ColorMixModelType = {}));\n\n// src/render/types/Color/CSSNames.ts\nvar cssNames = {\n  aliceblue: \"f0f8ff\",\n  antiquewhite: \"faebd7\",\n  aqua: \"0ff\",\n  aquamarine: \"7fffd4\",\n  azure: \"f0ffff\",\n  beige: \"f5f5dc\",\n  bisque: \"ffe4c4\",\n  black: \"000\",\n  blanchedalmond: \"ffebcd\",\n  blue: \"00f\",\n  blueviolet: \"8a2be2\",\n  brown: \"a52a2a\",\n  burlywood: \"deb887\",\n  burntsienna: \"ea7e5d\",\n  cadetblue: \"5f9ea0\",\n  chartreuse: \"7fff00\",\n  chocolate: \"d2691e\",\n  coral: \"ff7f50\",\n  cornflowerblue: \"6495ed\",\n  cornsilk: \"fff8dc\",\n  crimson: \"dc143c\",\n  cyan: \"0ff\",\n  darkblue: \"00008b\",\n  darkcyan: \"008b8b\",\n  darkgoldenrod: \"b8860b\",\n  darkgray: \"a9a9a9\",\n  darkgreen: \"006400\",\n  darkgrey: \"a9a9a9\",\n  darkkhaki: \"bdb76b\",\n  darkmagenta: \"8b008b\",\n  darkolivegreen: \"556b2f\",\n  darkorange: \"ff8c00\",\n  darkorchid: \"9932cc\",\n  darkred: \"8b0000\",\n  darksalmon: \"e9967a\",\n  darkseagreen: \"8fbc8f\",\n  darkslateblue: \"483d8b\",\n  darkslategray: \"2f4f4f\",\n  darkslategrey: \"2f4f4f\",\n  darkturquoise: \"00ced1\",\n  darkviolet: \"9400d3\",\n  deeppink: \"ff1493\",\n  deepskyblue: \"00bfff\",\n  dimgray: \"696969\",\n  dimgrey: \"696969\",\n  dodgerblue: \"1e90ff\",\n  firebrick: \"b22222\",\n  floralwhite: \"fffaf0\",\n  forestgreen: \"228b22\",\n  fuchsia: \"f0f\",\n  gainsboro: \"dcdcdc\",\n  ghostwhite: \"f8f8ff\",\n  gold: \"ffd700\",\n  goldenrod: \"daa520\",\n  gray: \"808080\",\n  green: \"008000\",\n  greenyellow: \"adff2f\",\n  grey: \"808080\",\n  honeydew: \"f0fff0\",\n  hotpink: \"ff69b4\",\n  indianred: \"cd5c5c\",\n  indigo: \"4b0082\",\n  ivory: \"fffff0\",\n  khaki: \"f0e68c\",\n  lavender: \"e6e6fa\",\n  lavenderblush: \"fff0f5\",\n  lawngreen: \"7cfc00\",\n  lemonchiffon: \"fffacd\",\n  lightblue: \"add8e6\",\n  lightcoral: \"f08080\",\n  lightcyan: \"e0ffff\",\n  lightgoldenrodyellow: \"fafad2\",\n  lightgray: \"d3d3d3\",\n  lightgreen: \"90ee90\",\n  lightgrey: \"d3d3d3\",\n  lightpink: \"ffb6c1\",\n  lightsalmon: \"ffa07a\",\n  lightseagreen: \"20b2aa\",\n  lightskyblue: \"87cefa\",\n  lightslategray: \"789\",\n  lightslategrey: \"789\",\n  lightsteelblue: \"b0c4de\",\n  lightyellow: \"ffffe0\",\n  lime: \"0f0\",\n  limegreen: \"32cd32\",\n  linen: \"faf0e6\",\n  magenta: \"f0f\",\n  maroon: \"800000\",\n  mediumaquamarine: \"66cdaa\",\n  mediumblue: \"0000cd\",\n  mediumorchid: \"ba55d3\",\n  mediumpurple: \"9370db\",\n  mediumseagreen: \"3cb371\",\n  mediumslateblue: \"7b68ee\",\n  mediumspringgreen: \"00fa9a\",\n  mediumturquoise: \"48d1cc\",\n  mediumvioletred: \"c71585\",\n  midnightblue: \"191970\",\n  mintcream: \"f5fffa\",\n  mistyrose: \"ffe4e1\",\n  moccasin: \"ffe4b5\",\n  navajowhite: \"ffdead\",\n  navy: \"000080\",\n  oldlace: \"fdf5e6\",\n  olive: \"808000\",\n  olivedrab: \"6b8e23\",\n  orange: \"ffa500\",\n  orangered: \"ff4500\",\n  orchid: \"da70d6\",\n  palegoldenrod: \"eee8aa\",\n  palegreen: \"98fb98\",\n  paleturquoise: \"afeeee\",\n  palevioletred: \"db7093\",\n  papayawhip: \"ffefd5\",\n  peachpuff: \"ffdab9\",\n  peru: \"cd853f\",\n  pink: \"ffc0cb\",\n  plum: \"dda0dd\",\n  powderblue: \"b0e0e6\",\n  purple: \"800080\",\n  rebeccapurple: \"663399\",\n  red: \"f00\",\n  rosybrown: \"bc8f8f\",\n  royalblue: \"4169e1\",\n  saddlebrown: \"8b4513\",\n  salmon: \"fa8072\",\n  sandybrown: \"f4a460\",\n  seagreen: \"2e8b57\",\n  seashell: \"fff5ee\",\n  sienna: \"a0522d\",\n  silver: \"c0c0c0\",\n  skyblue: \"87ceeb\",\n  slateblue: \"6a5acd\",\n  slategray: \"708090\",\n  slategrey: \"708090\",\n  snow: \"fffafa\",\n  springgreen: \"00ff7f\",\n  steelblue: \"4682b4\",\n  tan: \"d2b48c\",\n  teal: \"008080\",\n  thistle: \"d8bfd8\",\n  tomato: \"ff6347\",\n  turquoise: \"40e0d0\",\n  violet: \"ee82ee\",\n  wheat: \"f5deb3\",\n  white: \"fff\",\n  whitesmoke: \"f5f5f5\",\n  yellow: \"ff0\",\n  yellowgreen: \"9acd32\"\n};\n\n// src/render/types/Color/converters.ts\nfunction rgbToHsluv(r, g, b2) {\n  const [h, s, l] = (0, import_hsluv.rgbToHsluv)([r / 255, g / 255, b2 / 255]);\n  return { h, s, l };\n}\nfunction rgbaFromHusl(h, s, l, a2 = 1) {\n  const rgb = (0, import_hsluv.hsluvToRgb)([h, s, l]);\n  return {\n    r: rgb[0] * 255,\n    g: rgb[1] * 255,\n    b: rgb[2] * 255,\n    a: a2\n  };\n}\nfunction hsvToStr(h, s, v, a2) {\n  const _h = Math.round(h);\n  const _s = Math.round(s * 100);\n  const _v = Math.round(v * 100);\n  return a2 === void 0 || a2 === 1 ? \"hsv(\" + _h + \", \" + _s + \"%, \" + _v + \"%)\" : \"hsva(\" + _h + \", \" + _s + \"%, \" + _v + \"%, \" + a2 + \")\";\n}\nfunction rgbToRgb(r, g, b2) {\n  return {\n    r: isNumeric(r) ? bound01(r, 255) * 255 : 0,\n    g: isNumeric(g) ? bound01(g, 255) * 255 : 0,\n    b: isNumeric(b2) ? bound01(b2, 255) * 255 : 0\n  };\n}\nfunction rgbToHex(r, g, b2, allow3Char) {\n  const hex2 = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b2).toString(16))];\n  if (allow3Char && hex2[0].charAt(0) === hex2[0].charAt(1) && hex2[1].charAt(0) === hex2[1].charAt(1) && hex2[2].charAt(0) === hex2[2].charAt(1)) {\n    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);\n  }\n  return hex2.join(\"\");\n}\nfunction rgbToHsl(r, g, b2) {\n  let l;\n  let s;\n  const _r = bound01(r, 255);\n  const _g = bound01(g, 255);\n  const _b = bound01(b2, 255);\n  const max = Math.max(_r, _g, _b);\n  const min = Math.min(_r, _g, _b);\n  let h = s = l = (max + min) / 2;\n  if (max === min) {\n    h = s = 0;\n  } else {\n    const d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    switch (max) {\n      case _r:\n        h = (_g - _b) / d + (_g < _b ? 6 : 0);\n        break;\n      case _g:\n        h = (_b - _r) / d + 2;\n        break;\n      case _b:\n        h = (_r - _g) / d + 4;\n        break;\n    }\n    h /= 6;\n  }\n  return { h: h * 360, s, l };\n}\nfunction hue2rgb(p, q, t) {\n  if (t < 0) {\n    t += 1;\n  }\n  if (t > 1) {\n    t -= 1;\n  }\n  if (t < 1 / 6) {\n    return p + (q - p) * 6 * t;\n  }\n  if (t < 1 / 2) {\n    return q;\n  }\n  if (t < 2 / 3) {\n    return p + (q - p) * (2 / 3 - t) * 6;\n  }\n  return p;\n}\nfunction hslToRgb(h, s, l) {\n  let r;\n  let g;\n  let b2;\n  h = bound01(h, 360);\n  s = bound01(s * 100, 100);\n  l = bound01(l * 100, 100);\n  if (s === 0) {\n    r = g = b2 = l;\n  } else {\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    r = hue2rgb(p, q, h + 1 / 3);\n    g = hue2rgb(p, q, h);\n    b2 = hue2rgb(p, q, h - 1 / 3);\n  }\n  return { r: r * 255, g: g * 255, b: b2 * 255 };\n}\nfunction rgbToHsv(r, g, b2) {\n  r = bound01(r, 255);\n  g = bound01(g, 255);\n  b2 = bound01(b2, 255);\n  const max = Math.max(r, g, b2);\n  const min = Math.min(r, g, b2);\n  const d = max - min;\n  let h;\n  const s = max === 0 ? 0 : d / max;\n  const v = max;\n  if (max === min) {\n    h = 0;\n  } else {\n    switch (max) {\n      case r:\n        h = (g - b2) / d + (g < b2 ? 6 : 0);\n        break;\n      case g:\n        h = (b2 - r) / d + 2;\n        break;\n      case b2:\n        h = (r - g) / d + 4;\n        break;\n    }\n    h /= 6;\n  }\n  return { h, s, v };\n}\nfunction hsvToRgb(h, s, v) {\n  h = bound01(h, 360) * 6;\n  s = bound01(s * 100, 100);\n  v = bound01(v * 100, 100);\n  const i = Math.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i % 6, r = [v, q, p, p, t, v][mod], g = [t, v, v, q, p, p][mod], b2 = [p, p, t, v, v, q][mod];\n  return { r: r * 255, g: g * 255, b: b2 * 255 };\n}\nfunction bound01(n, max) {\n  let _max;\n  let _n;\n  if (typeof max === \"string\")\n    _max = parseFloat(max);\n  else\n    _max = max;\n  if (typeof n === \"string\") {\n    if (isOnePointZero(n)) {\n      n = \"100%\";\n    }\n    const processPercent = isPercentage(n);\n    _n = Math.min(_max, Math.max(0, parseFloat(n)));\n    if (processPercent) {\n      _n = Math.floor(_n * _max) / 100;\n    }\n  } else {\n    _n = n;\n  }\n  if (Math.abs(_n - _max) < 1e-6) {\n    return 1;\n  }\n  return _n % _max / _max;\n}\nfunction isOnePointZero(n) {\n  return typeof n === \"string\" && n.includes(\".\") && parseFloat(n) === 1;\n}\nfunction isPercentage(n) {\n  return typeof n === \"string\" && n.includes(\"%\");\n}\nfunction pad2(char) {\n  if (char.length === 1) {\n    return \"0\" + char;\n  } else {\n    return \"\" + char;\n  }\n}\nvar matchers = function() {\n  const cssInteger = \"[-\\\\+]?\\\\d+%?\";\n  const cssNumber = \"[-\\\\+]?\\\\d*\\\\.\\\\d+%?\";\n  const cssUnit = \"(?:\" + cssNumber + \")|(?:\" + cssInteger + \")\";\n  const permissiveMatch3 = \"[\\\\s|\\\\(]+(\" + cssUnit + \")[,|\\\\s]+(\" + cssUnit + \")[,|\\\\s]+(\" + cssUnit + \")\\\\s*\\\\)?\";\n  const permissiveMatch4 = \"[\\\\s|\\\\(]+(\" + cssUnit + \")[,|\\\\s]+(\" + cssUnit + \")[,|\\\\s]+(\" + cssUnit + \")[,|\\\\s]+(\" + cssUnit + \")\\\\s*\\\\)?\";\n  return {\n    rgb: new RegExp(\"rgb\" + permissiveMatch3),\n    rgba: new RegExp(\"rgba\" + permissiveMatch4),\n    hsl: new RegExp(\"hsl\" + permissiveMatch3),\n    hsla: new RegExp(\"hsla\" + permissiveMatch4),\n    hsv: new RegExp(\"hsv\" + permissiveMatch3),\n    hsva: new RegExp(\"hsva\" + permissiveMatch4),\n    hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n    hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,\n    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/\n  };\n}();\nfunction stringToObject(inputColor) {\n  if (inputColor.includes(\"gradient(\"))\n    return false;\n  if (inputColor.includes(\"var(\"))\n    return false;\n  const trimLeft = /^[\\s,#]+/;\n  const trimRight = /\\s+$/;\n  let color2 = inputColor.replace(trimLeft, \"\").replace(trimRight, \"\").toLowerCase();\n  let named = false;\n  if (cssNames[color2]) {\n    color2 = cssNames[color2];\n    named = true;\n  }\n  if (color2 === \"transparent\") {\n    return {\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 0,\n      format: ColorFormat.NAME\n    };\n  }\n  let match;\n  if (match = matchers.rgb.exec(color2)) {\n    return {\n      r: parseInt(match[1]),\n      g: parseInt(match[2]),\n      b: parseInt(match[3]),\n      a: 1,\n      format: ColorFormat.RGB\n    };\n  }\n  if (match = matchers.rgba.exec(color2)) {\n    return {\n      r: parseInt(match[1]),\n      g: parseInt(match[2]),\n      b: parseInt(match[3]),\n      a: parseFloat(match[4]),\n      format: ColorFormat.RGB\n    };\n  }\n  if (match = matchers.hsl.exec(color2)) {\n    return {\n      h: parseInt(match[1]),\n      s: percentToFraction(match[2]),\n      l: percentToFraction(match[3]),\n      a: 1,\n      format: ColorFormat.HSL\n    };\n  }\n  if (match = matchers.hsla.exec(color2)) {\n    return {\n      h: parseInt(match[1]),\n      s: percentToFraction(match[2]),\n      l: percentToFraction(match[3]),\n      a: parseFloat(match[4]),\n      format: ColorFormat.HSL\n    };\n  }\n  if (match = matchers.hsv.exec(color2)) {\n    return {\n      h: parseInt(match[1]),\n      s: percentToFraction(match[2]),\n      v: percentToFraction(match[3]),\n      a: 1,\n      format: ColorFormat.HSV\n    };\n  }\n  if (match = matchers.hsva.exec(color2)) {\n    return {\n      h: parseInt(match[1]),\n      s: percentToFraction(match[2]),\n      v: percentToFraction(match[3]),\n      a: parseFloat(match[4]),\n      format: ColorFormat.HSV\n    };\n  }\n  if (match = matchers.hex8.exec(color2)) {\n    return {\n      r: parseIntFromHex(match[1]),\n      g: parseIntFromHex(match[2]),\n      b: parseIntFromHex(match[3]),\n      a: convertHexToDecimal(match[4]),\n      format: named ? ColorFormat.NAME : ColorFormat.HEX\n    };\n  }\n  if (match = matchers.hex6.exec(color2)) {\n    return {\n      r: parseIntFromHex(match[1]),\n      g: parseIntFromHex(match[2]),\n      b: parseIntFromHex(match[3]),\n      a: 1,\n      format: named ? ColorFormat.NAME : ColorFormat.HEX\n    };\n  }\n  if (match = matchers.hex4.exec(color2)) {\n    return {\n      r: parseIntFromHex(`${match[1]}${match[1]}`),\n      g: parseIntFromHex(`${match[2]}${match[2]}`),\n      b: parseIntFromHex(`${match[3]}${match[3]}`),\n      a: convertHexToDecimal(match[4] + \"\" + match[4]),\n      format: named ? ColorFormat.NAME : ColorFormat.HEX\n    };\n  }\n  if (match = matchers.hex3.exec(color2)) {\n    return {\n      r: parseIntFromHex(`${match[1]}${match[1]}`),\n      g: parseIntFromHex(`${match[2]}${match[2]}`),\n      b: parseIntFromHex(`${match[3]}${match[3]}`),\n      a: 1,\n      format: named ? ColorFormat.NAME : ColorFormat.HEX\n    };\n  } else {\n    return false;\n  }\n}\nfunction parseIntFromHex(hex2) {\n  return parseInt(hex2, 16);\n}\nfunction convertHexToDecimal(h) {\n  return parseIntFromHex(h) / 255;\n}\n\n// src/render/types/Color/Color.ts\nvar cache2 = new Map();\nfunction Color(color2, r, g, b2) {\n  if (typeof color2 === \"string\") {\n    let c2 = cache2.get(color2);\n    if (c2)\n      return c2;\n    c2 = createColor(color2);\n    if (c2 === void 0)\n      return { ...Color(\"black\"), isValid: false };\n    cache2.set(color2, c2);\n    return c2;\n  }\n  const created = createColor(color2, r, g, b2);\n  return created !== void 0 ? created : { ...Color(\"black\"), isValid: false };\n}\nfunction createColor(color2, r, g, b2) {\n  if (color2 === \"\")\n    return void 0;\n  const colorData = getCompleteColorStrategy(color2, r, g, b2);\n  if (colorData) {\n    const newColor = {\n      r: colorData.r,\n      g: colorData.g,\n      b: colorData.b,\n      a: colorData.a,\n      h: colorData.h,\n      s: colorData.s,\n      l: colorData.l,\n      initialValue: typeof color2 === \"string\" && colorData.format !== ColorFormat.HSV ? color2 : void 0,\n      roundA: Math.round(100 * colorData.a) / 100,\n      format: colorData.format,\n      mix: Color.mix,\n      toValue: () => Color.toRgbString(newColor)\n    };\n    return newColor;\n  } else {\n    return void 0;\n  }\n}\n(function(Color2) {\n  function inspect2(color2, initialValue) {\n    if (color2.format === ColorFormat.HSL) {\n      return `<${color2.constructor.name} h:${color2.h} s:${color2.s} l:${color2.l} a:${color2.a}>`;\n    } else if (color2.format === ColorFormat.HEX || color2.format === ColorFormat.NAME) {\n      return `<${color2.constructor.name} \"${initialValue}\">`;\n    } else {\n      return `<${color2.constructor.name} r:${color2.r} g:${color2.g} b:${color2.b} a:${color2.a}>`;\n    }\n  }\n  Color2.inspect = inspect2;\n  function isColor(color2) {\n    if (typeof color2 === \"string\") {\n      return Color2.isColorString(color2);\n    } else {\n      return Color2.isColorObject(color2);\n    }\n  }\n  Color2.isColor = isColor;\n  function isColorString2(colorString) {\n    if (typeof colorString === \"string\") {\n      return stringToObject(colorString) !== false;\n    }\n    return false;\n  }\n  Color2.isColorString = isColorString2;\n  function isColorObject(color2) {\n    return color2 && typeof color2 !== \"string\" && typeof color2.r === \"number\" && typeof color2.g === \"number\" && typeof color2.b === \"number\" && typeof color2.h === \"number\" && typeof color2.s === \"number\" && typeof color2.l === \"number\" && typeof color2.a === \"number\" && typeof color2.roundA === \"number\" && typeof color2.format === \"string\";\n  }\n  Color2.isColorObject = isColorObject;\n  function toString(color2) {\n    return Color2.toRgbString(color2);\n  }\n  Color2.toString = toString;\n  function toHex(color2, allow3Char = false) {\n    return rgbToHex(color2.r, color2.g, color2.b, allow3Char);\n  }\n  Color2.toHex = toHex;\n  function toHexString(color2, allow3Char = false) {\n    return `#${Color2.toHex(color2, allow3Char)}`;\n  }\n  Color2.toHexString = toHexString;\n  function toRgbString(color2) {\n    return color2.a === 1 ? \"rgb(\" + Math.round(color2.r) + \", \" + Math.round(color2.g) + \", \" + Math.round(color2.b) + \")\" : \"rgba(\" + Math.round(color2.r) + \", \" + Math.round(color2.g) + \", \" + Math.round(color2.b) + \", \" + color2.roundA + \")\";\n  }\n  Color2.toRgbString = toRgbString;\n  function toHusl(color2) {\n    return {\n      ...rgbToHsluv(color2.r, color2.g, color2.b),\n      a: color2.roundA\n    };\n  }\n  Color2.toHusl = toHusl;\n  function toHslString(color2) {\n    const hsl = Color2.toHsl(color2);\n    const h = Math.round(hsl.h);\n    const s = Math.round(hsl.s * 100);\n    const l = Math.round(hsl.l * 100);\n    return color2.a === 1 ? \"hsl(\" + h + \", \" + s + \"%, \" + l + \"%)\" : \"hsla(\" + h + \", \" + s + \"%, \" + l + \"%, \" + color2.roundA + \")\";\n  }\n  Color2.toHslString = toHslString;\n  function toHsv(color2) {\n    const hsv = rgbToHsv(color2.r, color2.g, color2.b);\n    return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: color2.a };\n  }\n  Color2.toHsv = toHsv;\n  function toHsvString(color2) {\n    const hsv = rgbToHsv(color2.r, color2.g, color2.b);\n    const h = Math.round(hsv.h * 360);\n    const s = Math.round(hsv.s * 100);\n    const v = Math.round(hsv.v * 100);\n    return color2.a === 1 ? \"hsv(\" + h + \", \" + s + \"%, \" + v + \"%)\" : \"hsva(\" + h + \", \" + s + \"%, \" + v + \"%, \" + color2.roundA + \")\";\n  }\n  Color2.toHsvString = toHsvString;\n  function toName(color2) {\n    if (color2.a === 0) {\n      return \"transparent\";\n    }\n    if (color2.a < 1) {\n      return false;\n    }\n    const hex2 = rgbToHex(color2.r, color2.g, color2.b, true);\n    for (const key6 of Object.keys(cssNames)) {\n      const value = cssNames[key6];\n      if (value === hex2) {\n        return key6;\n      }\n    }\n    return false;\n  }\n  Color2.toName = toName;\n  function toHsl(color2) {\n    return {\n      h: Math.round(color2.h),\n      s: color2.s,\n      l: color2.l,\n      a: color2.a\n    };\n  }\n  Color2.toHsl = toHsl;\n  function toRgb(color2) {\n    return {\n      r: Math.round(color2.r),\n      g: Math.round(color2.g),\n      b: Math.round(color2.b),\n      a: color2.a\n    };\n  }\n  Color2.toRgb = toRgb;\n  function brighten(color2, amount = 10) {\n    const rgb = Color2.toRgb(color2);\n    rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));\n    rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));\n    rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));\n    return Color2(rgb);\n  }\n  Color2.brighten = brighten;\n  function lighten(color2, amount = 10) {\n    const hsl = Color2.toHsl(color2);\n    hsl.l += amount / 100;\n    hsl.l = Math.min(1, Math.max(0, hsl.l));\n    return Color2(hsl);\n  }\n  Color2.lighten = lighten;\n  function darken(color2, amount = 10) {\n    const hsl = Color2.toHsl(color2);\n    hsl.l -= amount / 100;\n    hsl.l = Math.min(1, Math.max(0, hsl.l));\n    return Color2(hsl);\n  }\n  Color2.darken = darken;\n  function saturate(color2, amount = 10) {\n    const hsl = Color2.toHsl(color2);\n    hsl.s += amount / 100;\n    hsl.s = Math.min(1, Math.max(0, hsl.s));\n    return Color2(hsl);\n  }\n  Color2.saturate = saturate;\n  function desaturate(color2, amount = 10) {\n    const hsl = Color2.toHsl(color2);\n    hsl.s -= amount / 100;\n    hsl.s = Math.min(1, Math.max(0, hsl.s));\n    return Color2(hsl);\n  }\n  Color2.desaturate = desaturate;\n  function grayscale(color2) {\n    return Color2.desaturate(color2, 100);\n  }\n  Color2.grayscale = grayscale;\n  function hueRotate(color2, angle) {\n    const hsl = Color2.toHsl(color2);\n    hsl.h += angle;\n    hsl.h = hsl.h > 360 ? hsl.h - 360 : hsl.h;\n    return Color2(hsl);\n  }\n  Color2.hueRotate = hueRotate;\n  function alpha2(color2, a2 = 1) {\n    return Color2({\n      r: color2.r,\n      g: color2.g,\n      b: color2.b,\n      a: a2\n    });\n  }\n  Color2.alpha = alpha2;\n  function transparent(color2) {\n    return Color2.alpha(color2, 0);\n  }\n  Color2.transparent = transparent;\n  function multiplyAlpha(color2, alphaValue = 1) {\n    return Color2({\n      r: color2.r,\n      g: color2.g,\n      b: color2.b,\n      a: color2.a * alphaValue\n    });\n  }\n  Color2.multiplyAlpha = multiplyAlpha;\n  function interpolate2(colorA, colorB, model = ColorMixModelType.RGB) {\n    if (!Color2.isColorObject(colorA) || !Color2.isColorObject(colorB)) {\n      throw new TypeError(\"Both arguments for Color.interpolate must be Color objects\");\n    }\n    return (progress2) => {\n      const color2 = Color2.mixAsColor(colorA, colorB, progress2, false, model);\n      return color2;\n    };\n  }\n  Color2.interpolate = interpolate2;\n  function mix2(from, toColor, { model = ColorMixModelType.RGB } = {}) {\n    const fromColor = typeof from === \"string\" ? Color2(from) : from;\n    const mixer = Color2.interpolate(fromColor, toColor, model);\n    return (p) => Color2.toRgbString(mixer(p));\n  }\n  Color2.mix = mix2;\n  function mixAsColor(colorA, colorB, fraction2 = 0.5, limit = false, model = ColorMixModelType.RGB) {\n    let result = null;\n    if (ColorMixModel.isRGB(model)) {\n      result = Color2({\n        r: modulate(fraction2, [0, 1], [colorA.r, colorB.r], limit),\n        g: modulate(fraction2, [0, 1], [colorA.g, colorB.g], limit),\n        b: modulate(fraction2, [0, 1], [colorA.b, colorB.b], limit),\n        a: modulate(fraction2, [0, 1], [colorA.a, colorB.a], limit)\n      });\n    } else {\n      let hslA, hslB;\n      if (ColorMixModel.isHSL(model)) {\n        hslA = Color2.toHsl(colorA);\n        hslB = Color2.toHsl(colorB);\n      } else {\n        hslA = Color2.toHusl(colorA);\n        hslB = Color2.toHusl(colorB);\n      }\n      if (hslA.s === 0) {\n        hslA.h = hslB.h;\n      } else if (hslB.s === 0) {\n        hslB.h = hslA.h;\n      }\n      const fromH = hslA.h;\n      const toH = hslB.h;\n      let deltaH = toH - fromH;\n      if (deltaH > 180) {\n        deltaH = toH - 360 - fromH;\n      } else if (deltaH < -180) {\n        deltaH = toH + 360 - fromH;\n      }\n      const tween = {\n        h: modulate(fraction2, [0, 1], [fromH, fromH + deltaH], limit),\n        s: modulate(fraction2, [0, 1], [hslA.s, hslB.s], limit),\n        l: modulate(fraction2, [0, 1], [hslA.l, hslB.l], limit),\n        a: modulate(fraction2, [0, 1], [colorA.a, colorB.a], limit)\n      };\n      if (ColorMixModel.isHSL(model)) {\n        result = Color2(tween);\n      } else {\n        result = Color2(rgbaFromHusl(tween.h, tween.s, tween.l, tween.a));\n      }\n    }\n    return result;\n  }\n  Color2.mixAsColor = mixAsColor;\n  function random(alphaValue = 1) {\n    function gen() {\n      return Math.floor(Math.random() * 255);\n    }\n    return Color2(\"rgba(\" + gen() + \", \" + gen() + \", \" + gen() + \", \" + alphaValue + \")\");\n  }\n  Color2.random = random;\n  function grey(amount = 0.5, alphaValue = 1) {\n    amount = Math.floor(amount * 255);\n    return Color2(\"rgba(\" + amount + \", \" + amount + \", \" + amount + \", \" + alphaValue + \")\");\n  }\n  Color2.grey = grey;\n  Color2.gray = Color2.grey;\n  function rgbToHsl2(r, g, b2) {\n    return rgbToHsl(r, g, b2);\n  }\n  Color2.rgbToHsl = rgbToHsl2;\n  Color2.isValidColorProperty = function(name, value) {\n    const isColorKey = name.toLowerCase().slice(-5) === \"color\" || name === \"fill\" || name === \"stroke\";\n    if (isColorKey && typeof value === \"string\" && Color2.isColorString(value)) {\n      return true;\n    }\n    return false;\n  };\n  function difference(colorA, colorB) {\n    const _r = (colorA.r + colorB.r) / 2;\n    const deltaR = colorA.r - colorB.r;\n    const deltaG = colorA.g - colorB.g;\n    const deltaB = colorA.b - colorB.b;\n    const deltaR2 = Math.pow(deltaR, 2);\n    const deltaG2 = Math.pow(deltaG, 2);\n    const deltaB2 = Math.pow(deltaB, 2);\n    return Math.sqrt(2 * deltaR2 + 4 * deltaG2 + 3 * deltaB2 + _r * (deltaR2 - deltaB2) / 256);\n  }\n  Color2.difference = difference;\n  function equal2(colorA, colorB, tolerance = 0.1) {\n    if (Math.abs(colorA.r - colorB.r) >= tolerance) {\n      return false;\n    }\n    if (Math.abs(colorA.g - colorB.g) >= tolerance) {\n      return false;\n    }\n    if (Math.abs(colorA.b - colorB.b) >= tolerance) {\n      return false;\n    }\n    if (Math.abs(colorA.a - colorB.a) * 256 >= tolerance) {\n      return false;\n    }\n    return true;\n  }\n  Color2.equal = equal2;\n})(Color || (Color = {}));\nvar ColorMixModel = {\n  isRGB(colorModel) {\n    return colorModel === ColorMixModelType.RGB || colorModel === ColorMixModelType.RGBA;\n  },\n  isHSL(colorModel) {\n    return colorModel === ColorMixModelType.HSL || colorModel === ColorMixModelType.HSLA;\n  }\n};\nfunction getCompleteColorStrategy(colorOrR, g, b2, a2 = 1) {\n  let completeColor;\n  if (typeof colorOrR === \"number\" && !Number.isNaN(colorOrR) && typeof g === \"number\" && !Number.isNaN(g) && typeof b2 === \"number\" && !Number.isNaN(b2)) {\n    const _r = colorOrR;\n    const _g = g;\n    const _b = b2;\n    const _a = a2;\n    completeColor = getCompleteColorFromRGB({ r: _r, g: _g, b: _b, a: _a });\n  } else if (typeof colorOrR === \"string\") {\n    completeColor = getCompleteColorFromString(colorOrR);\n  } else if (typeof colorOrR === \"object\") {\n    if (colorOrR.hasOwnProperty(\"r\") && colorOrR.hasOwnProperty(\"g\") && colorOrR.hasOwnProperty(\"b\")) {\n      completeColor = getCompleteColorFromRGB(colorOrR);\n    } else {\n      completeColor = getCompleteColorFromHSL(colorOrR);\n    }\n  }\n  return completeColor;\n}\nfunction getCompleteColorFromString(color2) {\n  const result = stringToObject(color2);\n  if (result) {\n    if (result.format === ColorFormat.HSL) {\n      return getCompleteColorFromHSL(result);\n    } else if (result.format === ColorFormat.HSV) {\n      return getCompleteColorFromHSV(result);\n    } else {\n      return getCompleteColorFromRGB(result);\n    }\n  }\n}\nfunction getCompleteColorFromHSV(color2) {\n  const rgb = hsvToRgb(color2.h, color2.s, color2.v);\n  const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);\n  return {\n    ...hsl,\n    ...rgb,\n    format: ColorFormat.RGB,\n    a: color2.a !== void 0 ? correctAlpha(color2.a) : 1\n  };\n}\nfunction getCompleteColorFromRGB(color2) {\n  const rgb = rgbToRgb(color2.r, color2.g, color2.b);\n  const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);\n  return {\n    ...hsl,\n    ...rgb,\n    format: ColorFormat.RGB,\n    a: color2.a !== void 0 ? correctAlpha(color2.a) : 1\n  };\n}\nfunction getCompleteColorFromHSL(color2) {\n  let h;\n  let s;\n  let l;\n  let rgb = { r: 0, g: 0, b: 0 };\n  let hsl = { h: 0, s: 0, l: 0 };\n  h = isNumeric(color2.h) ? color2.h : 0;\n  h = (h + 360) % 360;\n  s = isNumeric(color2.s) ? color2.s : 1;\n  if (typeof color2.s === \"string\") {\n    s = numberFromString(color2.s);\n  }\n  l = isNumeric(color2.l) ? color2.l : 0.5;\n  if (typeof color2.l === \"string\") {\n    l = numberFromString(color2.l);\n  }\n  rgb = hslToRgb(h, s, l);\n  hsl = {\n    h,\n    s,\n    l\n  };\n  return {\n    ...rgb,\n    ...hsl,\n    a: color2.a === void 0 ? 1 : color2.a,\n    format: ColorFormat.HSL\n  };\n}\nfunction correctAlpha(alphaValue) {\n  alphaValue = parseFloat(alphaValue);\n  if (alphaValue < 0) {\n    alphaValue = 0;\n  }\n  if (isNaN(alphaValue) || alphaValue > 1) {\n    alphaValue = 1;\n  }\n  return alphaValue;\n}\n\n// src/render/types/Color/ConvertColor.ts\nvar ConvertColor;\n(function(ConvertColor2) {\n  function hueRotate(color2, angle) {\n    return Color.toHslString(Color.hueRotate(Color(color2), angle));\n  }\n  ConvertColor2.hueRotate = hueRotate;\n  function setAlpha(color2, alpha2) {\n    return Color.toRgbString(Color.alpha(Color(color2), alpha2));\n  }\n  ConvertColor2.setAlpha = setAlpha;\n  function getAlpha(color2) {\n    const obj = stringToObject(color2);\n    return obj ? obj.a : 1;\n  }\n  ConvertColor2.getAlpha = getAlpha;\n  function multiplyAlpha(color2, alpha2) {\n    return Color.toRgbString(Color.multiplyAlpha(Color(color2), alpha2));\n  }\n  ConvertColor2.multiplyAlpha = multiplyAlpha;\n  function toHex(color2) {\n    return Color.toHexString(Color(color2)).toUpperCase();\n  }\n  ConvertColor2.toHex = toHex;\n  function toRgb(color2) {\n    return Color.toRgb(Color(color2));\n  }\n  ConvertColor2.toRgb = toRgb;\n  function toRgbString(color2) {\n    return Color.toRgbString(Color(color2));\n  }\n  ConvertColor2.toRgbString = toRgbString;\n  function toHSV(color2) {\n    return Color.toHsv(Color(color2));\n  }\n  ConvertColor2.toHSV = toHSV;\n  function toHSL(color2) {\n    return Color.toHsl(Color(color2));\n  }\n  ConvertColor2.toHSL = toHSL;\n  function toHslString(color2) {\n    return Color.toHslString(Color(color2));\n  }\n  ConvertColor2.toHslString = toHslString;\n  function toHsvString(color2) {\n    return Color.toHsvString(Color(color2));\n  }\n  ConvertColor2.toHsvString = toHsvString;\n  function hsvToHSLString(hsv) {\n    return Color.toHslString(Color(hsvToStr(hsv.h, hsv.s, hsv.v, hsv.a)));\n  }\n  ConvertColor2.hsvToHSLString = hsvToHSLString;\n  function hsvToString(hsv) {\n    return hsvToStr(hsv.h, hsv.s, hsv.v);\n  }\n  ConvertColor2.hsvToString = hsvToString;\n  function rgbaToString(color2) {\n    return Color.toRgbString(Color(color2));\n  }\n  ConvertColor2.rgbaToString = rgbaToString;\n  function hslToString(hsl) {\n    return Color.toRgbString(Color(hsl));\n  }\n  ConvertColor2.hslToString = hslToString;\n  function toColorPickerSquare(h) {\n    return Color.toRgbString(Color({ h, s: 1, l: 0.5, a: 1 }));\n  }\n  ConvertColor2.toColorPickerSquare = toColorPickerSquare;\n  function isValid(color2) {\n    return Color(color2).isValid !== false;\n  }\n  ConvertColor2.isValid = isValid;\n  function equals(a2, b2) {\n    if (typeof a2 === \"string\") {\n      a2 = Color(a2);\n    }\n    if (typeof b2 === \"string\") {\n      b2 = Color(b2);\n    }\n    return Color.equal(a2, b2);\n  }\n  ConvertColor2.equals = equals;\n  function toHexOrRgbaString(input) {\n    const color2 = Color(input);\n    return color2.a !== 1 ? Color.toRgbString(color2) : Color.toHexString(color2);\n  }\n  ConvertColor2.toHexOrRgbaString = toHexOrRgbaString;\n})(ConvertColor || (ConvertColor = {}));\n\n// src/render/utils/transformCustomValues.ts\nvar isCustomValue2 = (v) => {\n  return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nvar isColorProp = (key6) => key6 === \"background\" || key6.endsWith(\"color\") || key6.endsWith(\"Color\");\nvar resolveSingleCustomValue = (key6, v) => {\n  if (v && typeof v === \"object\") {\n    invariant(isCustomValue2(v), \"Motion styles must be numbers, strings, or an instance with a `toValue` and `mix` methods.\");\n    return v.toValue();\n  } else if (isColorProp(key6) && typeof v === \"string\" && Color.isColor(v)) {\n    return Color(v).toValue();\n  }\n  return v;\n};\nvar resolveCustomValues = (key6, v) => {\n  if (Array.isArray(v)) {\n    const numValues = v.length;\n    const resolved = [];\n    for (let i = 0; i < numValues; i++) {\n      resolved.push(resolveSingleCustomValue(key6, v[i]));\n    }\n    return resolved;\n  } else {\n    return resolveSingleCustomValue(key6, v);\n  }\n};\nvar customValueHandlers = {\n  size: {\n    set: (inputValues, outputValues, value) => {\n      if (inputValues.height === void 0) {\n        outputValues.height = value;\n      }\n      if (inputValues.width === void 0) {\n        outputValues.width = value;\n      }\n    },\n    type: px\n  },\n  radius: {\n    set: (inputValues, outputValues, value) => {\n      outputValues.borderRadius = value;\n    },\n    type: px\n  },\n  shadow: {\n    set: (inputValues, outputValues, value) => {\n      outputValues.boxShadow = value;\n    },\n    type: complex\n  }\n};\nvar transformValues = (values) => {\n  const transformedValues = {};\n  for (const key6 in values) {\n    const resolved = resolveCustomValues(key6, values[key6]);\n    const valueHandler = customValueHandlers[key6];\n    if (valueHandler) {\n      const isDefaultType = valueHandler.type && typeof values[key6] === \"number\";\n      const value = isDefaultType ? valueHandler.type.transform(values[key6]) : values[key6];\n      valueHandler.set(values, transformedValues, value);\n    } else {\n      transformedValues[key6] = resolved;\n    }\n  }\n  return transformedValues;\n};\n\n// src/render/presentation/Layer.tsx\n\n\n// src/render/utils/isEqual.ts\nvar isArray2 = Array.isArray;\nvar keyList = Object.keys;\nvar hasProp = Object.prototype.hasOwnProperty;\nfunction equal(a2, b2, deep) {\n  if (a2 === b2)\n    return true;\n  if (a2 && b2 && typeof a2 === \"object\" && typeof b2 === \"object\") {\n    const arrA = isArray2(a2);\n    const arrB = isArray2(b2);\n    let i, length, key6;\n    if (arrA && arrB) {\n      length = a2.length;\n      if (length !== b2.length)\n        return false;\n      for (i = length; i-- !== 0; ) {\n        if (!deep && a2[i] !== b2[i])\n          return false;\n        if (deep && !equal(a2[i], b2[i], true))\n          return false;\n      }\n      return true;\n    }\n    if (arrA !== arrB)\n      return false;\n    const dateA = a2 instanceof Date;\n    const dateB = b2 instanceof Date;\n    if (dateA !== dateB)\n      return false;\n    if (dateA && dateB)\n      return a2.getTime() === b2.getTime();\n    const regexpA = a2 instanceof RegExp;\n    const regexpB = b2 instanceof RegExp;\n    if (regexpA !== regexpB)\n      return false;\n    if (regexpA && regexpB)\n      return a2.toString() === b2.toString();\n    if (typeof a2.equals === \"function\" && typeof b2.equals === \"function\") {\n      return a2.equals(b2);\n    }\n    const keys2 = keyList(a2);\n    length = keys2.length;\n    if (length !== keyList(b2).length)\n      return false;\n    for (i = length; i-- !== 0; ) {\n      if (!hasProp.call(b2, keys2[i]))\n        return false;\n    }\n    for (i = length; i-- !== 0; ) {\n      key6 = keys2[i];\n      if (key6 === \"_owner\" && a2.$$typeof) {\n        continue;\n      }\n      if (!deep && a2[key6] !== b2[key6])\n        return false;\n      if (deep && !equal(a2[key6], b2[key6], true))\n        return false;\n    }\n    return true;\n  }\n  return a2 !== a2 && b2 !== b2;\n}\nfunction isEqual(a2, b2, deep = true) {\n  try {\n    return equal(a2, b2, deep);\n  } catch (error) {\n    if (error.message && error.message.match(/stack|recursion/i) || error.number === -2146828260) {\n      console.warn(\"Warning: isEqual does not handle circular references.\", error.name, error.message);\n      return false;\n    }\n    throw error;\n  }\n}\n\n// src/render/utils/useWebkitFixes.ts\n\nfunction resetSetStyle(element, key6, toValue, microtask = true) {\n  if (!element) {\n    return;\n  }\n  const value = toValue ? toValue : element.style[key6];\n  const reset = () => {\n    element.style[key6] = value;\n  };\n  element.style[key6] = null;\n  if (microtask) {\n    void Promise.resolve().then(reset);\n  } else {\n    setTimeout(reset, 0);\n  }\n}\n\n// src/render/utils/optionalReactDOM.ts\nfunction optionalReactDOM() {\n  if (typeof safeWindow !== \"undefined\" && safeWindow[\"ReactDOM\"]) {\n    return safeWindow[\"ReactDOM\"];\n  }\n  return void 0;\n}\n\n// src/render/utils/elementForComponent.ts\nfunction elementForComponent(component) {\n  const ReactDOM = optionalReactDOM();\n  if (!ReactDOM) {\n    return null;\n  }\n  const element = ReactDOM.findDOMNode(component);\n  return element;\n}\n\n// src/utils/environment.ts\nvar environment_exports = {};\n__export(environment_exports, {\n  deviceFont: () => deviceFont,\n  deviceOS: () => deviceOS,\n  devicePixelRatio: () => devicePixelRatio2,\n  deviceType: () => deviceType,\n  environment: () => environment,\n  isAndroid: () => isAndroid,\n  isBrowser: () => isBrowser2,\n  isChrome: () => isChrome,\n  isDataUrl: () => isDataUrl,\n  isDesktop: () => isDesktop,\n  isEdge: () => isEdge,\n  isFileUrl: () => isFileUrl,\n  isFirefox: () => isFirefox,\n  isFramerX: () => isFramerX,\n  isIOS: () => isIOS,\n  isJP2Supported: () => isJP2Supported,\n  isLocalAssetUrl: () => isLocalAssetUrl,\n  isLocalServerUrl: () => isLocalServerUrl,\n  isLocalUrl: () => isLocalUrl,\n  isMacOS: () => isMacOS,\n  isMobile: () => isMobile,\n  isPhone: () => isPhone,\n  isRelativeUrl: () => isRelativeUrl,\n  isSafari: () => isSafari,\n  isTablet: () => isTablet,\n  isTest: () => isTest,\n  isTouch: () => isTouch,\n  isWebKit: () => isWebKit,\n  isWebPSupported: () => isWebPSupported,\n  isWindows: () => isWindows,\n  webkitVersion: () => webkitVersion\n});\nvar isBrowser2 = () => typeof document === \"object\";\nvar isWebKit = () => navigator.userAgent.includes(\"AppleWebKit/\") && !isChrome() && !isEdge();\nvar webkitVersion = () => {\n  let version2 = -1;\n  const regexp = /AppleWebKit\\/([\\d.]+)/;\n  const result = regexp.exec(navigator.userAgent);\n  if (result) {\n    version2 = parseFloat(result[1]);\n  }\n  return version2;\n};\nvar isChrome = () => /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor) && !isEdge();\nvar isSafari = () => /Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor);\nvar isFirefox = () => /Firefox\\/\\d+\\.\\d+$/.test(navigator.userAgent);\nvar isFramerX = () => /FramerX/.test(navigator.userAgent);\nvar isEdge = () => /Edg\\//.test(navigator.userAgent);\nvar isAndroid = () => /(android)/i.test(navigator.userAgent);\nvar isIOS = () => /(iPhone|iPod|iPad)/i.test(navigator.platform);\nvar isMacOS = () => /Mac/.test(navigator.platform);\nvar isWindows = () => /Win/.test(navigator.platform);\nvar isTouch = () => safeWindow.ontouchstart === null && safeWindow.ontouchmove === null && safeWindow.ontouchend === null;\nvar isDesktop = () => deviceType() === \"desktop\";\nvar isPhone = () => deviceType() === \"phone\";\nvar isTablet = () => deviceType() === \"tablet\";\nvar isMobile = () => isPhone() || isTablet();\nvar isFileUrl = (url) => url.startsWith(\"file://\");\nvar isDataUrl = (url) => url.startsWith(\"data:\");\nvar isTest = () => false;\nvar isRelativeUrl = (url) => !/^([a-zA-Z]{1,8}:\\/\\/).*$/.test(url);\nvar isLocalServerUrl = (url) => /[a-zA-Z]{1,8}:\\/\\/127\\.0\\.0\\.1/.test(url) || /[a-zA-Z]{1,8}:\\/\\/localhost/.test(url);\nvar isLocalUrl = (url) => {\n  if (isFileUrl(url))\n    return true;\n  if (isLocalServerUrl(url))\n    return true;\n  return false;\n};\nvar isLocalAssetUrl = (url, baseUrl) => {\n  if (baseUrl === null)\n    baseUrl = safeWindow.location.href;\n  if (isDataUrl(url))\n    return false;\n  if (isLocalUrl(url))\n    return true;\n  if (isRelativeUrl(url) && isLocalUrl(baseUrl))\n    return true;\n  return false;\n};\nvar devicePixelRatio2 = () => safeWindow.devicePixelRatio;\nvar isJP2Supported = function() {\n  if (isFirefox())\n    return false;\n  return isWebKit();\n};\nvar isWebPSupported = () => isChrome();\nvar deviceType = () => {\n  if (/(tablet)|(iPad)|(Nexus 9)/i.test(navigator.userAgent))\n    return \"tablet\";\n  if (/(mobi)/i.test(navigator.userAgent))\n    return \"phone\";\n  return \"desktop\";\n};\nvar deviceOS = () => {\n  if (isMacOS())\n    return \"macos\";\n  if (isIOS())\n    return \"ios\";\n  if (isAndroid())\n    return \"android\";\n  if (isWindows())\n    return \"windows\";\n};\nvar deviceFont = (os) => {\n  if (!os) {\n    os = deviceOS();\n  }\n  const fonts = {\n    apple: \"-apple-system, BlinkMacSystemFont, SF Pro Text, SF UI Text, Helvetica Neue\",\n    google: \"Roboto, Helvetica Neue\",\n    microsoft: \"Segoe UI, Helvetica Neue\"\n  };\n  if (os === \"macos\")\n    return fonts.apple;\n  if (os === \"ios\")\n    return fonts.apple;\n  if (os === \"android\")\n    return fonts.google;\n  if (os === \"windows\")\n    return fonts.microsoft;\n  return fonts.apple;\n};\nvar environment = {\n  isWebKit,\n  webkitVersion,\n  isChrome,\n  isSafari,\n  isFirefox,\n  isFramerX,\n  isEdge,\n  isAndroid,\n  isIOS,\n  isMacOS,\n  isWindows,\n  isTouch,\n  isDesktop,\n  isPhone,\n  isTablet,\n  isMobile,\n  isFileUrl,\n  isDataUrl,\n  isRelativeUrl,\n  isLocalServerUrl,\n  isLocalUrl,\n  isLocalAssetUrl,\n  devicePixelRatio: devicePixelRatio2,\n  isJP2Supported,\n  isWebPSupported,\n  deviceType,\n  deviceOS,\n  deviceFont\n};\n\n// src/render/utils/setLayerBacked.ts\nvar smallValue = \"0.000001px\";\nvar translateZ = ` translateZ(${smallValue})`;\nvar useTranslateZHack = isFramerX() || isSafari() || isTest();\nfunction forceLayerBackingWithMotionStyle(motionStyle) {\n  motionStyle.willChange = \"transform\";\n  const onCanvas = RenderTarget.current() === RenderTarget.canvas;\n  if (useTranslateZHack && onCanvas) {\n    motionStyle.translateZ = smallValue;\n  }\n}\nfunction forceLayerBackingWithCSSProperties(cssProperties) {\n  cssProperties.willChange = \"transform\";\n  setTranslateZHack(cssProperties, true);\n}\nfunction setTranslateZHack(style, enabled) {\n  const onCanvas = RenderTarget.current() === RenderTarget.canvas;\n  if (!useTranslateZHack || !onCanvas) {\n    return;\n  }\n  const transform2 = style.transform || \"\";\n  if (enabled) {\n    const hasTranslateZ = transform2.includes(translateZ);\n    if (!hasTranslateZ) {\n      style.transform = transform2 + translateZ;\n    }\n  } else {\n    style.transform = transform2.replace(translateZ, \"\");\n  }\n}\n\n// src/render/presentation/Layer.tsx\nvar Layer = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  static applyWillChange(props, style, usingMotionStyle) {\n    if (props.willChangeTransform) {\n      if (usingMotionStyle) {\n        forceLayerBackingWithMotionStyle(style);\n      } else {\n        forceLayerBackingWithCSSProperties(style);\n      }\n    }\n  }\n  shouldComponentUpdate(nextProps, nextState) {\n    return nextProps._needsMeasure || this.state !== nextState || !isEqual(this.props, nextProps);\n  }\n  componentDidUpdate(prevProps) {\n    const element = elementForComponent(this);\n    if (this.props[\"clip\"] && this.props[\"radius\"] === 0 && prevProps[\"radius\"] !== 0) {\n      resetSetStyle(element, \"overflow\", \"hidden\", false);\n    }\n  }\n};\nLayer.defaultProps = {};\n\n// src/render/utils/extractStyleFromProps.ts\nfunction extractStyleFromProps(props, name, styleRef, into) {\n  if (into === void 0) {\n    into = name;\n  }\n  if (props[name] !== void 0) {\n    styleRef[into] = props[name];\n    return;\n  }\n}\n\n// src/utils/string.ts\nvar hash = (value) => {\n  let hasher = 0, i, chr;\n  if (value.length === 0)\n    return hasher;\n  for (i = 0; i < value.length; i++) {\n    chr = value.charCodeAt(i);\n    hasher = (hasher << 5) - hasher + chr;\n    hasher |= 0;\n  }\n  return hasher;\n};\n\n// src/utils/memoize.ts\nfunction manageCache(cache4, maxEntries) {\n  const size2 = cache4.size;\n  if (size2 < maxEntries)\n    return;\n  let i = Math.round(Math.random());\n  for (const key6 of cache4.keys()) {\n    if ((++i & 1) === 1)\n      continue;\n    cache4.delete(key6);\n  }\n}\nfunction memoize(maxEntries, cache4, key6, create) {\n  const r = cache4.get(key6);\n  if (r)\n    return r;\n  manageCache(cache4, maxEntries);\n  const g = create(key6);\n  cache4.set(key6, g);\n  return g;\n}\n\n// src/render/utils/gradientColorStops.ts\nvar CSSVariableRegExp = /var\\(.+\\)/;\nvar colorCache = new Map();\nfunction cachedMultiplyAlpha(s, a2) {\n  const key6 = [s, a2];\n  if (CSSVariableRegExp.test(s)) {\n    return s;\n  }\n  return memoize(1e3, colorCache, key6, () => ConvertColor.multiplyAlpha(s, a2));\n}\nfunction gradientColorStops(gradient, alpha2 = 1) {\n  let stops;\n  if (\"stops\" in gradient) {\n    stops = gradient.stops;\n  } else {\n    stops = [\n      { value: gradient.start, position: 0 },\n      { value: gradient.end, position: 1 }\n    ];\n  }\n  if (alpha2 === 1) {\n    return stops;\n  } else {\n    return stops.map((stop) => ({ ...stop, value: cachedMultiplyAlpha(stop.value, alpha2) }));\n  }\n}\nfunction gradientColorStopsHash(gradient, alpha2) {\n  let result = 0;\n  gradientColorStops(gradient, alpha2).forEach((stop) => {\n    result ^= hash(stop.value) ^ stop.position;\n  });\n  return result;\n}\n\n// src/render/types/SimpleGradient.ts\nvar simpleGradientKeys = [\"start\", \"end\"];\nfunction isSimpleGradient(value) {\n  return value && simpleGradientKeys.every((key6) => key6 in value);\n}\n\n// src/render/types/MultiStopGradient.ts\nvar multiStopGradientKeys = [\"stops\"];\nfunction isMultiStopGradient(value) {\n  return value && multiStopGradientKeys.every((key6) => key6 in value);\n}\n\n// src/render/types/LinearGradient.ts\nvar linearGradientKeys = [\"angle\", \"alpha\"];\nvar LinearGradient;\n(function(LinearGradient2) {\n  function isLinearGradient(value) {\n    return value && linearGradientKeys.every((key6) => key6 in value) && (isSimpleGradient(value) || isMultiStopGradient(value));\n  }\n  LinearGradient2.isLinearGradient = isLinearGradient;\n  function hash2(linearGradient) {\n    return linearGradient.angle ^ gradientColorStopsHash(linearGradient, linearGradient.alpha);\n  }\n  LinearGradient2.hash = hash2;\n  function toCSS(linearGradient, overrideAngle) {\n    const stops = gradientColorStops(linearGradient, linearGradient.alpha);\n    const angle = overrideAngle !== void 0 ? overrideAngle : linearGradient.angle;\n    const cssStops = stops.map((stop) => `${stop.value} ${stop.position * 100}%`);\n    return `linear-gradient(${angle}deg, ${cssStops.join(\", \")})`;\n  }\n  LinearGradient2.toCSS = toCSS;\n})(LinearGradient || (LinearGradient = {}));\n\n// src/render/types/RadialGradient.ts\nvar radialGradientKeys = [\n  \"widthFactor\",\n  \"heightFactor\",\n  \"centerAnchorX\",\n  \"centerAnchorY\",\n  \"alpha\"\n];\nvar RadialGradient;\n(function(RadialGradient2) {\n  function isRadialGradient(value) {\n    return value && radialGradientKeys.every((key6) => key6 in value) && (isSimpleGradient(value) || isMultiStopGradient(value));\n  }\n  RadialGradient2.isRadialGradient = isRadialGradient;\n  function hash2(radialGradient) {\n    return radialGradient.centerAnchorX ^ radialGradient.centerAnchorY ^ radialGradient.widthFactor ^ radialGradient.heightFactor ^ gradientColorStopsHash(radialGradient, radialGradient.alpha);\n  }\n  RadialGradient2.hash = hash2;\n  function toCSS(radialGradient) {\n    const { alpha: alpha2, widthFactor, heightFactor, centerAnchorX, centerAnchorY } = radialGradient;\n    const stops = gradientColorStops(radialGradient, alpha2);\n    const cssStops = stops.map((stop) => `${stop.value} ${stop.position * 100}%`);\n    return `radial-gradient(${widthFactor * 100}% ${heightFactor * 100}% at ${centerAnchorX * 100}% ${centerAnchorY * 100}%, ${cssStops.join(\", \")})`;\n  }\n  RadialGradient2.toCSS = toCSS;\n})(RadialGradient || (RadialGradient = {}));\n\n// src/render/utils/isMotionValue.ts\nvar isMotionValue2 = (v) => v instanceof MotionValue;\n\n// src/render/traits/Background.ts\nfunction collectBackgroundFromProps({ background, backgroundColor }, style) {\n  if (backgroundColor) {\n    if (typeof backgroundColor === \"string\" || isMotionValue2(backgroundColor)) {\n      style.backgroundColor = backgroundColor;\n    } else if (Color.isColorObject(background)) {\n      style.backgroundColor = background.initialValue || Color.toRgbString(background);\n    }\n  } else if (background) {\n    background = Animatable.get(background, null);\n    if (typeof background === \"string\" || isMotionValue2(background)) {\n      style.background = background;\n    } else if (LinearGradient.isLinearGradient(background)) {\n      style.background = LinearGradient.toCSS(background);\n    } else if (RadialGradient.isRadialGradient(background)) {\n      style.background = RadialGradient.toCSS(background);\n    } else if (Color.isColorObject(background)) {\n      style.backgroundColor = background.initialValue || Color.toRgbString(background);\n    }\n  }\n}\n\n// src/render/presentation/Frame/getStyleForFrameProps.ts\nfunction hasLeftAndRight(style) {\n  if (!style)\n    return false;\n  return style.left !== void 0 && style.right !== void 0;\n}\nfunction hasTopAndBottom(style) {\n  if (!style)\n    return false;\n  return style.top !== void 0 && style.bottom !== void 0;\n}\nfunction getStyleForFrameProps(props) {\n  if (!props) {\n    return {};\n  }\n  const style = {};\n  if (props.preserve3d === true) {\n    style.transformStyle = \"preserve-3d\";\n  } else if (props.preserve3d === false) {\n    style.transformStyle = \"flat\";\n  }\n  if (props.backfaceVisible === true) {\n    style.backfaceVisibility = \"visible\";\n  } else if (props.backfaceVisible === false) {\n    style.backfaceVisibility = \"hidden\";\n  }\n  if (style.backfaceVisibility) {\n    style.WebkitBackfaceVisibility = style.backfaceVisibility;\n  }\n  if (props.perspective !== void 0) {\n    style.perspective = style.WebkitPerspective = props.perspective;\n  }\n  if (!props.__fromCanvasComponent) {\n    if (props.center === true) {\n      style.left = \"50%\";\n      style.top = \"50%\";\n    } else {\n      if (props.center === \"x\") {\n        style.left = \"50%\";\n      } else if (props.center === \"y\") {\n        style.top = \"50%\";\n      }\n    }\n  }\n  extractStyleFromProps(props, \"size\", style);\n  extractStyleFromProps(props, \"width\", style);\n  extractStyleFromProps(props, \"height\", style);\n  extractStyleFromProps(props, \"minWidth\", style);\n  extractStyleFromProps(props, \"minHeight\", style);\n  extractStyleFromProps(props, \"top\", style);\n  extractStyleFromProps(props, \"right\", style);\n  extractStyleFromProps(props, \"bottom\", style);\n  extractStyleFromProps(props, \"left\", style);\n  extractStyleFromProps(props, \"position\", style);\n  extractStyleFromProps(props, \"overflow\", style);\n  extractStyleFromProps(props, \"opacity\", style);\n  if (!props._border || !props._border.borderWidth)\n    extractStyleFromProps(props, \"border\", style);\n  extractStyleFromProps(props, \"borderRadius\", style);\n  extractStyleFromProps(props, \"radius\", style, \"borderRadius\");\n  extractStyleFromProps(props, \"color\", style);\n  extractStyleFromProps(props, \"shadow\", style, \"boxShadow\");\n  extractStyleFromProps(props, \"x\", style);\n  extractStyleFromProps(props, \"y\", style);\n  extractStyleFromProps(props, \"z\", style);\n  extractStyleFromProps(props, \"rotate\", style);\n  extractStyleFromProps(props, \"rotateX\", style);\n  extractStyleFromProps(props, \"rotateY\", style);\n  extractStyleFromProps(props, \"rotateZ\", style);\n  extractStyleFromProps(props, \"scale\", style);\n  extractStyleFromProps(props, \"scaleX\", style);\n  extractStyleFromProps(props, \"scaleY\", style);\n  extractStyleFromProps(props, \"skew\", style);\n  extractStyleFromProps(props, \"skewX\", style);\n  extractStyleFromProps(props, \"skewY\", style);\n  extractStyleFromProps(props, \"originX\", style);\n  extractStyleFromProps(props, \"originY\", style);\n  extractStyleFromProps(props, \"originZ\", style);\n  collectBackgroundFromProps(props, style);\n  return style;\n}\n\n// src/render/utils/useLayoutId.ts\n\n\n// src/components/AnimateLayout/LayoutIdContext.tsx\n\n\nvar LayoutIdContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  getLayoutId: (args) => null,\n  persistLayoutIdCache: () => {\n  },\n  top: false,\n  enabled: true\n});\nfunction LayoutIdProvider({ children }) {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LayoutIdContext);\n  if (context.top)\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, children);\n  const cache4 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    byId: {},\n    byName: {},\n    byLastId: {},\n    byPossibleId: {},\n    byLastName: {},\n    byLayoutId: {},\n    count: {\n      byId: {},\n      byName: {}\n    }\n  });\n  const screen = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    byId: {},\n    byName: {},\n    byLastId: {},\n    byPossibleId: {},\n    byLastName: {},\n    byLayoutId: {}\n  });\n  const usedIds = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Set()).current;\n  const getLayoutId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ id, name, duplicatedFrom }) => {\n    if (!id)\n      return null;\n    const cacheKey = name ? \"byName\" : \"byId\";\n    const previousId = cache4.current[cacheKey][id];\n    if (previousId)\n      return previousId;\n    const nodeIdentifier = name || id;\n    if (!duplicatedFrom && !usedIds.has(nodeIdentifier) && (!cache4.current.byLayoutId[nodeIdentifier] || cache4.current.byLayoutId[nodeIdentifier] === nodeIdentifier)) {\n      if (cache4.current.count[cacheKey][nodeIdentifier] === void 0) {\n        cache4.current.count[cacheKey][nodeIdentifier] = 0;\n        cache4.current.byLayoutId[nodeIdentifier] = nodeIdentifier;\n        screen.current[cacheKey][id] = nodeIdentifier;\n      }\n      usedIds.add(nodeIdentifier);\n      return nodeIdentifier;\n    }\n    let possibleMatch = void 0;\n    if (duplicatedFrom == null ? void 0 : duplicatedFrom.length) {\n      for (let index = duplicatedFrom.length - 1; index >= 0; index--) {\n        const duplicatedId = duplicatedFrom[index];\n        const match = cache4.current[cacheKey][duplicatedId];\n        const byLastIdMatch = cache4.current.byLastId[duplicatedId];\n        if (byLastIdMatch && !possibleMatch) {\n          const matchedLayoutId = cache4.current.byLayoutId[byLastIdMatch];\n          const shouldUseNamedLastIdMatch = !matchedLayoutId || matchedLayoutId === name;\n          if (byLastIdMatch && !usedIds.has(byLastIdMatch) && (name ? shouldUseNamedLastIdMatch : true)) {\n            possibleMatch = [byLastIdMatch, duplicatedId];\n          }\n        }\n        const previousLayoutId = cache4.current.byLayoutId[match];\n        const shouldUseNamedMatch = !previousLayoutId || previousLayoutId === name;\n        if (match && !usedIds.has(match) && (name ? shouldUseNamedMatch : true)) {\n          screen.current[cacheKey][id] = match;\n          screen.current.byLastId[duplicatedId] = match;\n          usedIds.add(match);\n          return match;\n        }\n      }\n    }\n    const last = cache4.current.byLastId[id];\n    if (last && !usedIds.has(last)) {\n      usedIds.add(last);\n      screen.current.byId[id] = last;\n      return last;\n    }\n    if (possibleMatch) {\n      const [match, duplicatedId] = possibleMatch;\n      screen.current[cacheKey][id] = match;\n      screen.current.byLastId[duplicatedId] = match;\n      usedIds.add(match);\n      return match;\n    }\n    const possible = cache4.current.byPossibleId[id];\n    if (possible && !usedIds.has(possible)) {\n      usedIds.add(possible);\n      screen.current.byId[id] = possible;\n      return possible;\n    }\n    const rootDuplicatedId = duplicatedFrom == null ? void 0 : duplicatedFrom[0];\n    const identifier = name || rootDuplicatedId || id;\n    const value = cache4.current.count[cacheKey][identifier] + 1 || 0;\n    const { layoutId, value: nextValue } = nextLayoutId(identifier, value, usedIds);\n    cache4.current.count[cacheKey][identifier] = nextValue;\n    screen.current[cacheKey][id] = layoutId;\n    if (duplicatedFrom == null ? void 0 : duplicatedFrom.length) {\n      if (!name) {\n        screen.current.byLastId[duplicatedFrom[duplicatedFrom.length - 1]] = layoutId;\n        if (duplicatedFrom.length > 1) {\n          for (let index = 0; index < duplicatedFrom.length - 1; index++) {\n            const possibleId = duplicatedFrom[index];\n            if (!screen.current.byPossibleId[possibleId]) {\n              screen.current.byPossibleId[possibleId] = layoutId;\n            }\n          }\n        }\n      }\n    }\n    screen.current.byLayoutId[layoutId] = nodeIdentifier;\n    usedIds.add(layoutId);\n    return layoutId;\n  }, []);\n  const persistLayoutIdCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    cache4.current = {\n      byId: {\n        ...cache4.current.byId,\n        ...screen.current.byId\n      },\n      byLastId: {\n        ...cache4.current.byLastId,\n        ...screen.current.byLastId\n      },\n      byPossibleId: {\n        ...cache4.current.byPossibleId,\n        ...screen.current.byPossibleId\n      },\n      byName: {\n        ...cache4.current.byName,\n        ...screen.current.byName\n      },\n      byLastName: { ...cache4.current.byLastName, ...screen.current.byLastName },\n      byLayoutId: { ...cache4.current.byLayoutId, ...screen.current.byLayoutId },\n      count: {\n        ...cache4.current.count,\n        byName: {}\n      }\n    };\n    screen.current = {\n      byId: {},\n      byName: {},\n      byLastId: {},\n      byPossibleId: {},\n      byLastName: {},\n      byLayoutId: {}\n    };\n    usedIds.clear();\n  }, []);\n  const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    getLayoutId,\n    persistLayoutIdCache,\n    top: true,\n    enabled: true\n  }).current;\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(LayoutIdContext.Provider, {\n    value: contextValue\n  }, children);\n}\nfunction nextLayoutId(identifier, initialValue, usedIds) {\n  let value = initialValue;\n  let layoutId = value ? `${identifier}-${value}` : identifier;\n  while (usedIds.has(layoutId)) {\n    value++;\n    layoutId = `${identifier}-${value}`;\n  }\n  return { layoutId, value };\n}\nfunction AutomaticLayoutIds({ enabled = true, ...props }) {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LayoutIdContext);\n  const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      ...context,\n      enabled\n    };\n  }, [enabled]);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(LayoutIdContext.Provider, {\n    ...props,\n    value: contextValue\n  });\n}\n\n// src/render/utils/useLayoutId.ts\nfunction useLayoutId2(props, { specificLayoutId, postfix } = {}) {\n  const { name, layoutIdKey, duplicatedFrom, __fromCodeComponentNode = false } = props;\n  const { getLayoutId, enabled } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LayoutIdContext);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!enabled)\n      return props.layoutId;\n    const existingLayoutId = specificLayoutId || props.layoutId;\n    if (!existingLayoutId) {\n      if (!layoutIdKey || __fromCodeComponentNode)\n        return void 0;\n    }\n    const layoutIdCandidate = existingLayoutId || getLayoutId({ id: layoutIdKey, name, duplicatedFrom });\n    if (!layoutIdCandidate)\n      return void 0;\n    return postfix ? `${layoutIdCandidate}-${postfix}` : layoutIdCandidate;\n  }, [enabled]);\n}\n\n// src/render/utils/transformTemplate.ts\nfunction transformTemplate(center) {\n  return (_, generated) => {\n    if (center === true) {\n      return `translate(-50%, -50%) ${generated}`;\n    } else {\n      if (center === \"x\") {\n        return `translateX(-50%) ${generated}`;\n      } else if (center === \"y\") {\n        return `translateY(-50%) ${generated}`;\n      }\n    }\n    return generated || \"none\";\n  };\n}\n\n// src/render/utils/useMeasureLayout.ts\n\n\n// src/utils/runtimeInjection.ts\nvar mockWithWarning = (message) => {\n  return () => {\n    warnOnce(message);\n  };\n};\nvar implementation = {\n  useImageSource(image) {\n    return image.src;\n  },\n  useImageElement(image, rect, nodeId) {\n    const element = new Image();\n    element.src = runtime.useImageSource(image, rect, nodeId);\n    return element;\n  }\n};\nvar isRuntimeInjected = false;\nvar runtimeProxy = {\n  get(target, key6, reciever) {\n    if (Reflect.has(target, key6)) {\n      return Reflect.get(target, key6, reciever);\n    }\n    if (isRuntimeInjected) {\n      return mockWithWarning(`${String(key6)} is not available in this version of Framer.`);\n    } else {\n      return mockWithWarning(`${String(key6)} is only available inside of Framer. https://www.framer.com/`);\n    }\n  }\n};\nvar runtime = new Proxy(implementation, runtimeProxy);\nfunction _injectRuntime(injectedRuntime) {\n  Object.assign(implementation, injectedRuntime);\n  isRuntimeInjected = true;\n}\n\n// src/render/utils/nodeIdFromString.ts\nfunction nodeIdFromString(str) {\n  return str.replace(/^id_/, \"\").replace(/\\\\/g, \"\");\n}\n\n// src/render/presentation/ComponentContainerContext.tsx\n\nvar ComponentContainerContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\n\n// src/components/hoc/withMeasuredSize.tsx\n\n\n// src/modules/useForceUpdate.ts\n\nfunction useForceUpdate2() {\n  const [_, setForcedRenderCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => setForcedRenderCount((v) => v + 1), []);\n}\n\n// ../../node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js\nvar resizeObservers = [];\n\n// ../../node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js\nvar hasActiveObservations = function() {\n  return resizeObservers.some(function(ro) {\n    return ro.activeTargets.length > 0;\n  });\n};\n\n// ../../node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js\nvar hasSkippedObservations = function() {\n  return resizeObservers.some(function(ro) {\n    return ro.skippedTargets.length > 0;\n  });\n};\n\n// ../../node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js\nvar msg = \"ResizeObserver loop completed with undelivered notifications.\";\nvar deliverResizeLoopError = function() {\n  var event;\n  if (typeof ErrorEvent === \"function\") {\n    event = new ErrorEvent(\"error\", {\n      message: msg\n    });\n  } else {\n    event = document.createEvent(\"Event\");\n    event.initEvent(\"error\", false, false);\n    event.message = msg;\n  }\n  window.dispatchEvent(event);\n};\n\n// ../../node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js\nvar ResizeObserverBoxOptions;\n(function(ResizeObserverBoxOptions2) {\n  ResizeObserverBoxOptions2[\"BORDER_BOX\"] = \"border-box\";\n  ResizeObserverBoxOptions2[\"CONTENT_BOX\"] = \"content-box\";\n  ResizeObserverBoxOptions2[\"DEVICE_PIXEL_CONTENT_BOX\"] = \"device-pixel-content-box\";\n})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));\n\n// ../../node_modules/@juggle/resize-observer/lib/utils/freeze.js\nvar freeze = function(obj) {\n  return Object.freeze(obj);\n};\n\n// ../../node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js\nvar ResizeObserverSize = function() {\n  function ResizeObserverSize2(inlineSize, blockSize) {\n    this.inlineSize = inlineSize;\n    this.blockSize = blockSize;\n    freeze(this);\n  }\n  return ResizeObserverSize2;\n}();\n\n// ../../node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js\nvar DOMRectReadOnly = function() {\n  function DOMRectReadOnly2(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.top = this.y;\n    this.left = this.x;\n    this.bottom = this.top + this.height;\n    this.right = this.left + this.width;\n    return freeze(this);\n  }\n  DOMRectReadOnly2.prototype.toJSON = function() {\n    var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;\n    return { x, y, top, right, bottom, left, width, height };\n  };\n  DOMRectReadOnly2.fromRect = function(rectangle) {\n    return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n  };\n  return DOMRectReadOnly2;\n}();\n\n// ../../node_modules/@juggle/resize-observer/lib/utils/element.js\nvar isSVG = function(target) {\n  return target instanceof SVGElement && \"getBBox\" in target;\n};\nvar isHidden = function(target) {\n  if (isSVG(target)) {\n    var _a = target.getBBox(), width = _a.width, height = _a.height;\n    return !width && !height;\n  }\n  var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;\n  return !(offsetWidth || offsetHeight || target.getClientRects().length);\n};\nvar isElement = function(obj) {\n  var _a, _b;\n  if (obj instanceof Element) {\n    return true;\n  }\n  var scope = (_b = (_a = obj) === null || _a === void 0 ? void 0 : _a.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView;\n  return !!(scope && obj instanceof scope.Element);\n};\nvar isReplacedElement = function(target) {\n  switch (target.tagName) {\n    case \"INPUT\":\n      if (target.type !== \"image\") {\n        break;\n      }\n    case \"VIDEO\":\n    case \"AUDIO\":\n    case \"EMBED\":\n    case \"OBJECT\":\n    case \"CANVAS\":\n    case \"IFRAME\":\n    case \"IMG\":\n      return true;\n  }\n  return false;\n};\n\n// ../../node_modules/@juggle/resize-observer/lib/utils/global.js\nvar global2 = typeof window !== \"undefined\" ? window : {};\n\n// ../../node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js\nvar cache3 = new WeakMap();\nvar scrollRegexp = /auto|scroll/;\nvar verticalRegexp = /^tb|vertical/;\nvar IE = /msie|trident/i.test(global2.navigator && global2.navigator.userAgent);\nvar parseDimension = function(pixel) {\n  return parseFloat(pixel || \"0\");\n};\nvar size = function(inlineSize, blockSize, switchSizes) {\n  if (inlineSize === void 0) {\n    inlineSize = 0;\n  }\n  if (blockSize === void 0) {\n    blockSize = 0;\n  }\n  if (switchSizes === void 0) {\n    switchSizes = false;\n  }\n  return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);\n};\nvar zeroBoxes = freeze({\n  devicePixelContentBoxSize: size(),\n  borderBoxSize: size(),\n  contentBoxSize: size(),\n  contentRect: new DOMRectReadOnly(0, 0, 0, 0)\n});\nvar calculateBoxSizes = function(target, forceRecalculation) {\n  if (forceRecalculation === void 0) {\n    forceRecalculation = false;\n  }\n  if (cache3.has(target) && !forceRecalculation) {\n    return cache3.get(target);\n  }\n  if (isHidden(target)) {\n    cache3.set(target, zeroBoxes);\n    return zeroBoxes;\n  }\n  var cs = getComputedStyle(target);\n  var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();\n  var removePadding = !IE && cs.boxSizing === \"border-box\";\n  var switchSizes = verticalRegexp.test(cs.writingMode || \"\");\n  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || \"\");\n  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || \"\");\n  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);\n  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);\n  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);\n  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);\n  var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);\n  var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);\n  var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);\n  var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);\n  var horizontalPadding = paddingLeft + paddingRight;\n  var verticalPadding = paddingTop + paddingBottom;\n  var horizontalBorderArea = borderLeft + borderRight;\n  var verticalBorderArea = borderTop + borderBottom;\n  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;\n  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;\n  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;\n  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;\n  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;\n  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;\n  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;\n  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;\n  var boxes = freeze({\n    devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),\n    borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),\n    contentBoxSize: size(contentWidth, contentHeight, switchSizes),\n    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)\n  });\n  cache3.set(target, boxes);\n  return boxes;\n};\nvar calculateBoxSize = function(target, observedBox, forceRecalculation) {\n  var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;\n  switch (observedBox) {\n    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:\n      return devicePixelContentBoxSize;\n    case ResizeObserverBoxOptions.BORDER_BOX:\n      return borderBoxSize;\n    default:\n      return contentBoxSize;\n  }\n};\n\n// ../../node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js\nvar ResizeObserverEntry = function() {\n  function ResizeObserverEntry2(target) {\n    var boxes = calculateBoxSizes(target);\n    this.target = target;\n    this.contentRect = boxes.contentRect;\n    this.borderBoxSize = freeze([boxes.borderBoxSize]);\n    this.contentBoxSize = freeze([boxes.contentBoxSize]);\n    this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);\n  }\n  return ResizeObserverEntry2;\n}();\n\n// ../../node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js\nvar calculateDepthForNode = function(node) {\n  if (isHidden(node)) {\n    return Infinity;\n  }\n  var depth = 0;\n  var parent = node.parentNode;\n  while (parent) {\n    depth += 1;\n    parent = parent.parentNode;\n  }\n  return depth;\n};\n\n// ../../node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js\nvar broadcastActiveObservations = function() {\n  var shallowestDepth = Infinity;\n  var callbacks2 = [];\n  resizeObservers.forEach(function processObserver(ro) {\n    if (ro.activeTargets.length === 0) {\n      return;\n    }\n    var entries = [];\n    ro.activeTargets.forEach(function processTarget(ot) {\n      var entry = new ResizeObserverEntry(ot.target);\n      var targetDepth = calculateDepthForNode(ot.target);\n      entries.push(entry);\n      ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);\n      if (targetDepth < shallowestDepth) {\n        shallowestDepth = targetDepth;\n      }\n    });\n    callbacks2.push(function resizeObserverCallback() {\n      ro.callback.call(ro.observer, entries, ro.observer);\n    });\n    ro.activeTargets.splice(0, ro.activeTargets.length);\n  });\n  for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {\n    var callback = callbacks_1[_i];\n    callback();\n  }\n  return shallowestDepth;\n};\n\n// ../../node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js\nvar gatherActiveObservationsAtDepth = function(depth) {\n  resizeObservers.forEach(function processObserver(ro) {\n    ro.activeTargets.splice(0, ro.activeTargets.length);\n    ro.skippedTargets.splice(0, ro.skippedTargets.length);\n    ro.observationTargets.forEach(function processTarget(ot) {\n      if (ot.isActive()) {\n        if (calculateDepthForNode(ot.target) > depth) {\n          ro.activeTargets.push(ot);\n        } else {\n          ro.skippedTargets.push(ot);\n        }\n      }\n    });\n  });\n};\n\n// ../../node_modules/@juggle/resize-observer/lib/utils/process.js\nvar process2 = function() {\n  var depth = 0;\n  gatherActiveObservationsAtDepth(depth);\n  while (hasActiveObservations()) {\n    depth = broadcastActiveObservations();\n    gatherActiveObservationsAtDepth(depth);\n  }\n  if (hasSkippedObservations()) {\n    deliverResizeLoopError();\n  }\n  return depth > 0;\n};\n\n// ../../node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js\nvar trigger;\nvar callbacks = [];\nvar notify = function() {\n  return callbacks.splice(0).forEach(function(cb2) {\n    return cb2();\n  });\n};\nvar queueMicroTask = function(callback) {\n  if (!trigger) {\n    var toggle_1 = 0;\n    var el_1 = document.createTextNode(\"\");\n    var config = { characterData: true };\n    new MutationObserver(function() {\n      return notify();\n    }).observe(el_1, config);\n    trigger = function() {\n      el_1.textContent = \"\" + (toggle_1 ? toggle_1-- : toggle_1++);\n    };\n  }\n  callbacks.push(callback);\n  trigger();\n};\n\n// ../../node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js\nvar queueResizeObserver = function(cb2) {\n  queueMicroTask(function ResizeObserver2() {\n    requestAnimationFrame(cb2);\n  });\n};\n\n// ../../node_modules/@juggle/resize-observer/lib/utils/scheduler.js\nvar watching = 0;\nvar isWatching = function() {\n  return !!watching;\n};\nvar CATCH_PERIOD = 250;\nvar observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };\nvar events = [\n  \"resize\",\n  \"load\",\n  \"transitionend\",\n  \"animationend\",\n  \"animationstart\",\n  \"animationiteration\",\n  \"keyup\",\n  \"keydown\",\n  \"mouseup\",\n  \"mousedown\",\n  \"mouseover\",\n  \"mouseout\",\n  \"blur\",\n  \"focus\"\n];\nvar time = function(timeout) {\n  if (timeout === void 0) {\n    timeout = 0;\n  }\n  return Date.now() + timeout;\n};\nvar scheduled = false;\nvar Scheduler = function() {\n  function Scheduler2() {\n    var _this = this;\n    this.stopped = true;\n    this.listener = function() {\n      return _this.schedule();\n    };\n  }\n  Scheduler2.prototype.run = function(timeout) {\n    var _this = this;\n    if (timeout === void 0) {\n      timeout = CATCH_PERIOD;\n    }\n    if (scheduled) {\n      return;\n    }\n    scheduled = true;\n    var until = time(timeout);\n    queueResizeObserver(function() {\n      var elementsHaveResized = false;\n      try {\n        elementsHaveResized = process2();\n      } finally {\n        scheduled = false;\n        timeout = until - time();\n        if (!isWatching()) {\n          return;\n        }\n        if (elementsHaveResized) {\n          _this.run(1e3);\n        } else if (timeout > 0) {\n          _this.run(timeout);\n        } else {\n          _this.start();\n        }\n      }\n    });\n  };\n  Scheduler2.prototype.schedule = function() {\n    this.stop();\n    this.run();\n  };\n  Scheduler2.prototype.observe = function() {\n    var _this = this;\n    var cb2 = function() {\n      return _this.observer && _this.observer.observe(document.body, observerConfig);\n    };\n    document.body ? cb2() : global2.addEventListener(\"DOMContentLoaded\", cb2);\n  };\n  Scheduler2.prototype.start = function() {\n    var _this = this;\n    if (this.stopped) {\n      this.stopped = false;\n      this.observer = new MutationObserver(this.listener);\n      this.observe();\n      events.forEach(function(name) {\n        return global2.addEventListener(name, _this.listener, true);\n      });\n    }\n  };\n  Scheduler2.prototype.stop = function() {\n    var _this = this;\n    if (!this.stopped) {\n      this.observer && this.observer.disconnect();\n      events.forEach(function(name) {\n        return global2.removeEventListener(name, _this.listener, true);\n      });\n      this.stopped = true;\n    }\n  };\n  return Scheduler2;\n}();\nvar scheduler = new Scheduler();\nvar updateCount = function(n) {\n  !watching && n > 0 && scheduler.start();\n  watching += n;\n  !watching && scheduler.stop();\n};\n\n// ../../node_modules/@juggle/resize-observer/lib/ResizeObservation.js\nvar skipNotifyOnElement = function(target) {\n  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === \"inline\";\n};\nvar ResizeObservation = function() {\n  function ResizeObservation2(target, observedBox) {\n    this.target = target;\n    this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;\n    this.lastReportedSize = {\n      inlineSize: 0,\n      blockSize: 0\n    };\n  }\n  ResizeObservation2.prototype.isActive = function() {\n    var size2 = calculateBoxSize(this.target, this.observedBox, true);\n    if (skipNotifyOnElement(this.target)) {\n      this.lastReportedSize = size2;\n    }\n    if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {\n      return true;\n    }\n    return false;\n  };\n  return ResizeObservation2;\n}();\n\n// ../../node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js\nvar ResizeObserverDetail = function() {\n  function ResizeObserverDetail2(resizeObserver, callback) {\n    this.activeTargets = [];\n    this.skippedTargets = [];\n    this.observationTargets = [];\n    this.observer = resizeObserver;\n    this.callback = callback;\n  }\n  return ResizeObserverDetail2;\n}();\n\n// ../../node_modules/@juggle/resize-observer/lib/ResizeObserverController.js\nvar observerMap = new WeakMap();\nvar getObservationIndex = function(observationTargets, target) {\n  for (var i = 0; i < observationTargets.length; i += 1) {\n    if (observationTargets[i].target === target) {\n      return i;\n    }\n  }\n  return -1;\n};\nvar ResizeObserverController = function() {\n  function ResizeObserverController2() {\n  }\n  ResizeObserverController2.connect = function(resizeObserver, callback) {\n    var detail = new ResizeObserverDetail(resizeObserver, callback);\n    observerMap.set(resizeObserver, detail);\n  };\n  ResizeObserverController2.observe = function(resizeObserver, target, options) {\n    var detail = observerMap.get(resizeObserver);\n    var firstObservation = detail.observationTargets.length === 0;\n    if (getObservationIndex(detail.observationTargets, target) < 0) {\n      firstObservation && resizeObservers.push(detail);\n      detail.observationTargets.push(new ResizeObservation(target, options && options.box));\n      updateCount(1);\n      scheduler.schedule();\n    }\n  };\n  ResizeObserverController2.unobserve = function(resizeObserver, target) {\n    var detail = observerMap.get(resizeObserver);\n    var index = getObservationIndex(detail.observationTargets, target);\n    var lastObservation = detail.observationTargets.length === 1;\n    if (index >= 0) {\n      lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);\n      detail.observationTargets.splice(index, 1);\n      updateCount(-1);\n    }\n  };\n  ResizeObserverController2.disconnect = function(resizeObserver) {\n    var _this = this;\n    var detail = observerMap.get(resizeObserver);\n    detail.observationTargets.slice().forEach(function(ot) {\n      return _this.unobserve(resizeObserver, ot.target);\n    });\n    detail.activeTargets.splice(0, detail.activeTargets.length);\n  };\n  return ResizeObserverController2;\n}();\n\n// ../../node_modules/@juggle/resize-observer/lib/ResizeObserver.js\nvar ResizeObserver = function() {\n  function ResizeObserver2(callback) {\n    if (arguments.length === 0) {\n      throw new TypeError(\"Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.\");\n    }\n    if (typeof callback !== \"function\") {\n      throw new TypeError(\"Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.\");\n    }\n    ResizeObserverController.connect(this, callback);\n  }\n  ResizeObserver2.prototype.observe = function(target, options) {\n    if (arguments.length === 0) {\n      throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n    }\n    if (!isElement(target)) {\n      throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n    }\n    ResizeObserverController.observe(this, target, options);\n  };\n  ResizeObserver2.prototype.unobserve = function(target) {\n    if (arguments.length === 0) {\n      throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n    }\n    if (!isElement(target)) {\n      throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n    }\n    ResizeObserverController.unobserve(this, target);\n  };\n  ResizeObserver2.prototype.disconnect = function() {\n    ResizeObserverController.disconnect(this);\n  };\n  ResizeObserver2.toString = function() {\n    return \"function ResizeObserver () { [polyfill code] }\";\n  };\n  return ResizeObserver2;\n}();\n\n// src/components/hoc/withMeasuredSize.tsx\nvar DEFAULT_SIZE = 200;\nvar _sharedResizeObserver, _callbacks;\nvar SharedObserver = class {\n  constructor() {\n    __privateAdd(this, _sharedResizeObserver, void 0);\n    __privateAdd(this, _callbacks, new WeakMap());\n    var _a;\n    const ResizeObserver2 = (_a = window.ResizeObserver) != null ? _a : ResizeObserver;\n    __privateSet(this, _sharedResizeObserver, new ResizeObserver2(this.updateResizedElements.bind(this)));\n  }\n  updateResizedElements(entries) {\n    for (const entry of entries) {\n      const callbackForElement = __privateGet(this, _callbacks).get(entry.target);\n      if (callbackForElement)\n        callbackForElement(entry.contentRect);\n    }\n  }\n  observeElementWithCallback(element, callback) {\n    __privateGet(this, _sharedResizeObserver).observe(element);\n    __privateGet(this, _callbacks).set(element, callback);\n  }\n  unobserve(element) {\n    __privateGet(this, _sharedResizeObserver).unobserve(element);\n    __privateGet(this, _callbacks).delete(element);\n  }\n};\n_sharedResizeObserver = new WeakMap();\n_callbacks = new WeakMap();\nvar sharedResizeObserver = new SharedObserver();\nfunction useMeasuredSize(ref) {\n  const forceUpdate = useForceUpdate2();\n  const size2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  function updateSize(newSize) {\n    if (newSize.width === 0 && newSize.height === 0)\n      return;\n    if (!size2.current || newSize.height !== size2.current.height || newSize.width !== size2.current.width) {\n      size2.current = { width: newSize.width, height: newSize.height };\n      forceUpdate();\n    }\n  }\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (!ref.current)\n      return;\n    const { offsetWidth, offsetHeight } = ref.current;\n    updateSize({\n      width: offsetWidth,\n      height: offsetHeight\n    });\n    sharedResizeObserver.observeElementWithCallback(ref.current, updateSize);\n    return () => {\n      if (!ref.current)\n        return;\n      sharedResizeObserver.unobserve(ref.current);\n    };\n  }, []);\n  return size2.current;\n}\nvar SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE = \"data-framer-size-compatibility-wrapper\";\nvar withMeasuredSize = (Component19) => (props) => {\n  var _a, _b, _c, _d;\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const size2 = useMeasuredSize(ref);\n  const dataProps = { [SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE]: true };\n  const shouldRender = Boolean(size2);\n  const fallbackWidth = (_a = props.width) != null ? _a : DEFAULT_SIZE;\n  const fallbackHeight = (_b = props.height) != null ? _b : DEFAULT_SIZE;\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n    style: { width: \"100%\", height: \"100%\", pointerEvents: \"none\" },\n    ref,\n    ...dataProps\n  }, shouldRender && /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Component19, {\n    ...props,\n    width: (_c = size2 == null ? void 0 : size2.width) != null ? _c : fallbackWidth,\n    height: (_d = size2 == null ? void 0 : size2.height) != null ? _d : fallbackHeight\n  }));\n};\n\n// src/render/utils/getMeasurableCodeComponentChildren.ts\nfunction getMeasurableCodeComponentChildren(element) {\n  const childrenCollection = element.firstElementChild && element.firstElementChild.hasAttribute(SIZE_COMPATIBILITY_WRAPPER_ATTRIBUTE) ? element.firstElementChild.children : element.children;\n  return [...childrenCollection].filter(isMeasurable).map(unwrapInlinedDisplayContents);\n}\nfunction isMeasurable(element) {\n  if (element instanceof HTMLBaseElement || element instanceof HTMLHeadElement || element instanceof HTMLLinkElement || element instanceof HTMLMetaElement || element instanceof HTMLScriptElement || element instanceof HTMLStyleElement || element instanceof HTMLTitleElement) {\n    return false;\n  }\n  return element instanceof HTMLElement || element instanceof SVGElement;\n}\nfunction unwrapInlinedDisplayContents(element) {\n  if (!(element instanceof HTMLElement))\n    return element;\n  if (element.children.length === 0)\n    return element;\n  if (element.style.display !== \"contents\")\n    return element;\n  const firstMeasurableChild = [...element.children].find(isMeasurable);\n  if (firstMeasurableChild) {\n    return unwrapInlinedDisplayContents(firstMeasurableChild);\n  }\n  return element;\n}\n\n// src/render/utils/useMeasureLayout.ts\nfunction useMeasureLayout(props, ref, getChildren = () => [], options = {}) {\n  const { id, visible, _needsMeasure } = props;\n  const { skipHook = false } = options;\n  const inCodeComponent = Boolean((0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ComponentContainerContext));\n  const onCanvas = RenderTarget.current() === RenderTarget.canvas;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (!onCanvas || inCodeComponent || skipHook) {\n      return;\n    }\n    if (!(ref.current && id && visible && _needsMeasure)) {\n      return;\n    }\n    runtime.queueMeasureRequest(nodeIdFromString(id), ref.current, getChildren(ref.current));\n  });\n}\nfunction measureClosestComponentContainer(element) {\n  const container = element.closest(\"[data-framer-component-container]\");\n  if (!container)\n    return;\n  runtime.queueMeasureRequest(nodeIdFromString(container.id), container, getMeasurableCodeComponentChildren(container));\n}\n\n// src/render/utils/layoutHintDataPropsForCenter.ts\nvar isChrome2 = isChrome();\nfunction layoutHintDataPropsForCenter(center) {\n  const props = {};\n  if (!isChrome2 || RenderTarget.current() !== RenderTarget.canvas) {\n    return props;\n  }\n  if (center === true || center === \"x\") {\n    props[\"data-framer-layout-hint-center-x\"] = true;\n  }\n  if (center === true || center === \"y\") {\n    props[\"data-framer-layout-hint-center-y\"] = true;\n  }\n  return props;\n}\n\n// src/render/style/BackgroundImageComponent.tsx\n\n\n// src/render/utils/imageRendering.ts\nfunction minZoomForPixelatedImageRendering(image, containerSize, devicePixelRatio3 = 1) {\n  var _a, _b, _c, _d;\n  let { width: frameWidth, height: frameHeight } = containerSize;\n  const imageWidth = (_b = (_a = image.pixelWidth) != null ? _a : image.intrinsicWidth) != null ? _b : 0;\n  const imageHeight = (_d = (_c = image.pixelHeight) != null ? _c : image.intrinsicHeight) != null ? _d : 0;\n  if (frameWidth < 1 || frameHeight < 1 || imageWidth < 1 || imageHeight < 1) {\n    return void 0;\n  }\n  frameWidth *= devicePixelRatio3;\n  frameHeight *= devicePixelRatio3;\n  const frameAspectRatio = frameWidth / frameHeight;\n  const imageAspectRatio = imageWidth / imageHeight;\n  switch (image.fit) {\n    case \"fill\":\n      if (imageAspectRatio > frameAspectRatio) {\n        return imageHeight / frameHeight;\n      } else {\n        return imageWidth / frameWidth;\n      }\n    case \"fit\":\n    case \"stretch\":\n      return Math.max(imageWidth / frameWidth, imageHeight / frameHeight);\n  }\n}\nfunction imageRenderingForZoom(zoom, minPixelatedZoom) {\n  if (minPixelatedZoom && Math.max(1, zoom) > minPixelatedZoom) {\n    return \"pixelated\";\n  }\n  return \"auto\";\n}\n\n// src/render/style/BackgroundImageComponent.tsx\nvar wrapperStyle = {\n  position: \"absolute\",\n  pointerEvents: \"none\",\n  userSelect: \"none\",\n  borderRadius: \"inherit\",\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0\n};\nfunction cssObjectFit(imageFit) {\n  switch (imageFit) {\n    case \"fit\":\n      return \"contain\";\n    case \"stretch\":\n      return \"fill\";\n    default:\n      return \"cover\";\n  }\n}\nfunction cssImageRendering(image, containerSize) {\n  if (!containerSize)\n    return \"auto\";\n  const devicePixelRatio3 = RenderTarget.current() === RenderTarget.canvas ? safeWindow.devicePixelRatio : 1;\n  const minPixelatedZoom = minZoomForPixelatedImageRendering(image, containerSize, devicePixelRatio3);\n  if (RenderTarget.current() === RenderTarget.canvas) {\n    return imageRenderingForZoom(1, minPixelatedZoom);\n  } else {\n    return imageRenderingForZoom(RenderEnvironment.zoom, minPixelatedZoom);\n  }\n}\nfunction getImageStyle(image, containerSize) {\n  return {\n    pointerEvents: \"none\",\n    userSelect: \"none\",\n    display: \"block\",\n    width: \"100%\",\n    height: \"100%\",\n    borderRadius: \"inherit\",\n    objectPosition: \"center\",\n    objectFit: cssObjectFit(image.fit),\n    imageRendering: cssImageRendering(image, containerSize)\n  };\n}\nfunction BackgroundImageComponent({ image, containerSize, nodeId, layoutId }) {\n  const wrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const isStaticRendering = !isBrowser2() || RenderTarget.current() === RenderTarget.export;\n  if (layoutId) {\n    layoutId = layoutId + \"-background\";\n  }\n  const source = runtime.useImageSource(image, containerSize, nodeId);\n  const imageStyle = getImageStyle(image, containerSize);\n  if (!isStaticRendering) {\n    const imageElement = runtime.useImageElement(image, containerSize, nodeId);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n      const wrapper = wrapperRef.current;\n      if (wrapper === null)\n        return;\n      wrapper.appendChild(imageElement);\n      return () => {\n        wrapper.removeChild(imageElement);\n      };\n    }, [imageElement]);\n    Object.assign(imageElement.style, imageStyle);\n  }\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(motion.div, {\n    ref: wrapperRef,\n    style: wrapperStyle,\n    layoutId\n  }, isStaticRendering ? /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"img\", {\n    src: source,\n    style: imageStyle\n  }) : null);\n}\n\n// src/render/presentation/Frame/FrameWithMotion.tsx\nfunction hasEvents(props) {\n  for (const key6 in props) {\n    if (key6 === \"drag\" || key6.startsWith(\"while\") || typeof props[key6] === \"function\" && key6.startsWith(\"on\") && !key6.includes(\"Animation\")) {\n      return true;\n    }\n  }\n  return false;\n}\nvar pointerEvents = [\n  \"onAuxClick\",\n  \"onClick\",\n  \"onDoubleClick\",\n  \"onMouse\",\n  \"onMouseDown\",\n  \"onMouseUp\",\n  \"onTapDown\",\n  \"onTap\",\n  \"onTapUp\",\n  \"onPointer\",\n  \"onPointerDown\",\n  \"onPointerUp\",\n  \"onTouch\",\n  \"onTouchDown\",\n  \"onTouchUp\"\n];\nvar pointerEventsSet = new Set([\n  ...pointerEvents,\n  ...pointerEvents.map((event) => `${event}Capture`)\n]);\nfunction getCursorFromEvents(props) {\n  if (props.drag) {\n    return \"grab\";\n  }\n  for (const key6 in props) {\n    if (pointerEventsSet.has(key6)) {\n      return \"pointer\";\n    }\n  }\n  return void 0;\n}\nfunction unwrapFrameProps(frameProps) {\n  const {\n    left,\n    top,\n    bottom,\n    right,\n    width,\n    height,\n    minWidth,\n    minHeight,\n    center,\n    _constraints,\n    size: size2,\n    widthType,\n    heightType\n  } = frameProps;\n  const constraintProps = {\n    top: resolveMotionValue(top),\n    left: resolveMotionValue(left),\n    bottom: resolveMotionValue(bottom),\n    right: resolveMotionValue(right),\n    width: resolveMotionValue(width),\n    height: resolveMotionValue(height),\n    minWidth: resolveMotionValue(minWidth),\n    minHeight: resolveMotionValue(minHeight),\n    size: resolveMotionValue(size2),\n    center,\n    _constraints,\n    widthType,\n    heightType\n  };\n  return constraintProps;\n}\nvar defaultFrameRect = { x: 0, y: 0, width: 200, height: 200 };\nfunction useStyleAndRect(props) {\n  injectComponentCSSRules();\n  const inCodeComponent = Boolean((0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ComponentContainerContext));\n  const { style, _initialStyle, __fromCanvasComponent, size: size2 } = props;\n  const unwrappedProps = unwrapFrameProps(props);\n  const constraintsRect = useConstraints(unwrappedProps);\n  const defaultStyle = {\n    display: \"block\",\n    flexShrink: 0,\n    userSelect: \"none\"\n  };\n  if (!props.__fromCanvasComponent) {\n    defaultStyle.backgroundColor = props.background === void 0 ? \"rgba(0, 170, 255, 0.3)\" : void 0;\n  }\n  if (!hasEvents(props)) {\n    defaultStyle.pointerEvents = \"none\";\n  }\n  const addTextCentering = react__WEBPACK_IMPORTED_MODULE_0__.Children.count(props.children) > 0 && react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(props.children).every((child) => {\n    return typeof child === \"string\" || typeof child === \"number\";\n  });\n  const centerTextStyle = addTextCentering && {\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    textAlign: \"center\"\n  };\n  const propsStyle = getStyleForFrameProps(props);\n  if (size2 === void 0 && !__fromCanvasComponent) {\n    if (!hasLeftAndRight(propsStyle)) {\n      defaultStyle.width = defaultFrameRect.width;\n    }\n    if (!hasTopAndBottom(propsStyle)) {\n      defaultStyle.height = defaultFrameRect.height;\n    }\n  }\n  if (unwrappedProps.minWidth !== void 0) {\n    defaultStyle.minWidth = unwrappedProps.minWidth;\n  }\n  if (unwrappedProps.minHeight !== void 0) {\n    defaultStyle.minHeight = unwrappedProps.minHeight;\n  }\n  let constraintsStyle = {};\n  if (constraintsEnabled(unwrappedProps)) {\n    if (constraintsRect && !isAutoSized(props)) {\n      constraintsStyle = {\n        left: constraintsRect.x,\n        top: constraintsRect.y,\n        width: constraintsRect.width,\n        height: constraintsRect.height,\n        right: void 0,\n        bottom: void 0\n      };\n    }\n  }\n  Object.assign(defaultStyle, centerTextStyle, _initialStyle, propsStyle, constraintsStyle, style);\n  Layer.applyWillChange(props, defaultStyle, true);\n  let resultStyle = defaultStyle;\n  if (!defaultStyle.transform) {\n    resultStyle = { x: 0, y: 0, ...defaultStyle };\n  }\n  if (props.positionSticky) {\n    const onCanvas = RenderTarget.current() === RenderTarget.canvas;\n    if (!onCanvas || inCodeComponent) {\n      resultStyle.position = \"sticky\";\n      resultStyle.willChange = \"transform\";\n      resultStyle.zIndex = 1;\n      resultStyle.top = props.positionStickyTop;\n      resultStyle.right = props.positionStickyRight;\n      resultStyle.bottom = props.positionStickyBottom;\n      resultStyle.left = props.positionStickyLeft;\n    }\n  }\n  return [resultStyle, constraintsRect];\n}\nvar filteredProps = new Set([\n  \"width\",\n  \"height\",\n  \"opacity\",\n  \"overflow\",\n  \"radius\",\n  \"background\",\n  \"color\",\n  \"x\",\n  \"y\",\n  \"z\",\n  \"rotate\",\n  \"rotateX\",\n  \"rotateY\",\n  \"rotateZ\",\n  \"scale\",\n  \"scaleX\",\n  \"scaleY\",\n  \"skew\",\n  \"skewX\",\n  \"skewY\",\n  \"originX\",\n  \"originY\",\n  \"originZ\"\n]);\nfunction getMotionProps(props) {\n  const motionProps = {};\n  for (const key6 in props) {\n    const isValid = isValidMotionProp(key6) || (0, import_is_prop_valid.default)(key6);\n    if (isValid && !filteredProps.has(key6)) {\n      motionProps[key6] = props[key6];\n    } else if (key6 === \"positionTransition\" || key6 === \"layoutTransition\") {\n      motionProps[\"layout\"] = true;\n      if (typeof props[key6] !== \"boolean\" && !props.transition) {\n        motionProps[\"transition\"] = props[key6];\n      }\n    }\n  }\n  return motionProps;\n}\nfunction hasDataFramerName(props) {\n  return \"data-framer-name\" in props;\n}\nvar FrameWithMotion = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function FrameWithMotion2(props, ref) {\n  if (safeWindow[\"perf\"])\n    safeWindow[\"perf\"].nodeRender();\n  const { visible = true } = props;\n  if (!visible)\n    return null;\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(VisibleFrame, {\n    ...props,\n    ref\n  });\n});\nvar VisibleFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function VisibleFrame2(props, forwardedRef) {\n  const { _border, name, center, border } = props;\n  const { props: propsWithOverrides, children } = processOverrideForwarding(props);\n  const motionProps = getMotionProps(propsWithOverrides);\n  const layoutId = useLayoutId2(props);\n  const cursor = getCursorFromEvents(props);\n  const fallbackRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const ref = forwardedRef != null ? forwardedRef : fallbackRef;\n  const dataProps = {\n    \"data-framer-component-type\": \"Frame\",\n    \"data-framer-cursor\": cursor,\n    \"data-framer-highlight\": cursor === \"pointer\" ? true : void 0,\n    \"data-layoutid\": layoutId\n  };\n  if (!hasDataFramerName(props) && name) {\n    dataProps[\"data-framer-name\"] = name;\n  }\n  const [currentStyle, rect] = useStyleAndRect(propsWithOverrides);\n  const unwrappedProps = unwrapFrameProps(propsWithOverrides);\n  const autoSized = isAutoSized(unwrappedProps);\n  if (center && !(rect && !autoSized && constraintsEnabled(unwrappedProps))) {\n    motionProps.transformTemplate = transformTemplate(center);\n    Object.assign(dataProps, layoutHintDataPropsForCenter(center));\n  } else {\n    motionProps.transformTemplate = transformTemplate(false);\n  }\n  useMeasureLayout(props, ref);\n  const backgroundImage = backgroundImageFromProps(props);\n  const inCodeComponent = Boolean((0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ComponentContainerContext));\n  const parentSize = resolveParentSize(propsWithOverrides, unwrappedProps, rect, inCodeComponent);\n  const wrappedContent = useProvideParentSize(/* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, backgroundImage ? /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(BackgroundImageComponent, {\n    image: backgroundImage,\n    containerSize: rect != null ? rect : void 0,\n    nodeId: props.id && nodeIdFromString(props.id),\n    layoutId\n  }) : null, children, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Border, {\n    ..._border,\n    border,\n    layoutId\n  })), parentSize);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(motion.div, {\n    ...dataProps,\n    ...motionProps,\n    layoutId,\n    style: currentStyle,\n    ref,\n    transformValues\n  }, wrappedContent);\n});\nfunction resolveParentSize(props, unwrappedProps, rect, inCodeComponent) {\n  if (inCodeComponent) {\n    return rect ? { width: rect.width, height: rect.height } : ParentSizeState.Disabled;\n  }\n  const { _usesDOMRect } = props;\n  const {\n    widthType = DimensionType.FixedNumber,\n    heightType = DimensionType.FixedNumber,\n    width,\n    height\n  } = unwrappedProps;\n  if (rect && !_usesDOMRect) {\n    return rect;\n  }\n  if (widthType === DimensionType.FixedNumber && heightType === DimensionType.FixedNumber && typeof width === \"number\" && typeof height === \"number\") {\n    return { width, height };\n  }\n  if (_usesDOMRect) {\n    return ParentSizeState.DisabledForCurrentLevel;\n  }\n  return ParentSizeState.Unknown;\n}\nfunction isAutoSized({\n  width,\n  height\n}) {\n  return width === \"auto\" || width === \"min-content\" || height === \"auto\" || height === \"min-content\";\n}\n\n// src/components/EmptyState.tsx\n\n\n// src/render/presentation/Frame/index.tsx\n\n\n\n// src/components/hoc/WithEvents.tsx\n\n\n// src/utils/events.ts\nfunction pointForEvent(event, customTarget = null) {\n  let target;\n  if (customTarget instanceof HTMLElement) {\n    target = customTarget;\n  }\n  if (!target && event.target instanceof HTMLElement) {\n    target = event.target;\n  }\n  if (!target) {\n    return { x: event.pageX, y: event.pageY };\n  }\n  if (safeWindow.webkitConvertPointFromPageToNode) {\n    let webkitPoint = new WebKitPoint(event.pageX, event.pageY);\n    webkitPoint = safeWindow.webkitConvertPointFromPageToNode(target, webkitPoint);\n    return { x: webkitPoint.x, y: webkitPoint.y };\n  }\n  const rect = target.getBoundingClientRect();\n  const width = parseFloat(target.style.width);\n  const height = parseFloat(target.style.height);\n  const scale2 = {\n    x: width ? width / rect.width : 1,\n    y: height ? height / rect.height : 1\n  };\n  const point = {\n    x: scale2.x * (event.pageX - rect.left - target.clientLeft + target.scrollLeft),\n    y: scale2.y * (event.pageY - rect.top - target.clientTop + target.scrollTop)\n  };\n  return point;\n}\n\n// src/core/Time.ts\nvar _raf = (f) => {\n  setTimeout(f, 1 / 60);\n};\nvar __raf = safeWindow[\"requestAnimationFrame\"] || _raf;\nvar raf = (f) => __raf(f);\n\n// src/core/EventEmitter.ts\nvar import_eventemitter3 = __toModule(require_eventemitter3());\nvar EventEmitter = class {\n  constructor() {\n    this._emitter = new import_eventemitter3.EventEmitter();\n  }\n  eventNames() {\n    return this._emitter.eventNames();\n  }\n  eventListeners() {\n    const listeners = {};\n    for (const eventName of this._emitter.eventNames()) {\n      listeners[eventName] = this._emitter.listeners(eventName);\n    }\n    return listeners;\n  }\n  on(eventName, fn) {\n    this.addEventListener(eventName, fn, false, false, this);\n  }\n  off(eventName, fn) {\n    this.removeEventListeners(eventName, fn);\n  }\n  once(eventName, fn) {\n    this.addEventListener(eventName, fn, true, false, this);\n  }\n  unique(eventName, fn) {\n    this.addEventListener(eventName, fn, false, true, this);\n  }\n  addEventListener(eventName, fn, once, unique, context) {\n    if (unique) {\n      for (const name of this._emitter.eventNames()) {\n        if (fn === this._emitter.listeners(name)) {\n          return;\n        }\n      }\n    }\n    if (once === true) {\n      this._emitter.once(eventName, fn, context);\n    } else {\n      this._emitter.addListener(eventName, fn, context);\n    }\n  }\n  removeEventListeners(eventName, fn) {\n    if (eventName) {\n      this._emitter.removeListener(eventName, fn);\n    } else {\n      this.removeAllEventListeners();\n    }\n  }\n  removeAllEventListeners() {\n    this._emitter.removeAllListeners();\n  }\n  countEventListeners(eventName, handler) {\n    if (eventName) {\n      return this._emitter.listeners(eventName).length;\n    } else {\n      let count = 0;\n      for (const name of this._emitter.eventNames()) {\n        count += this._emitter.listeners(name).length;\n      }\n      return count;\n    }\n  }\n  emit(eventName, ...args) {\n    this._emitter.emit(eventName, ...args);\n  }\n};\n\n// src/core/Loop.ts\nvar LoopTimeStep = 1 / 60;\nvar Loop = class extends EventEmitter {\n  constructor(start = false) {\n    super();\n    this._started = false;\n    this._frame = 0;\n    this._frameTasks = [];\n    this.tick = () => {\n      if (!this._started)\n        return;\n      raf(this.tick);\n      this.emit(\"update\", this._frame, LoopTimeStep);\n      this.emit(\"render\", this._frame, LoopTimeStep);\n      this._processFrameTasks();\n      this._frame++;\n    };\n    if (start) {\n      this.start();\n    }\n  }\n  addFrameTask(task) {\n    this._frameTasks.push(task);\n  }\n  _processFrameTasks() {\n    const postEventTasks = this._frameTasks;\n    const length = postEventTasks.length;\n    if (length === 0)\n      return;\n    for (let i = 0; i < length; i++) {\n      postEventTasks[i]();\n    }\n    postEventTasks.length = 0;\n  }\n  static set TimeStep(value) {\n    LoopTimeStep = value;\n  }\n  static get TimeStep() {\n    return LoopTimeStep;\n  }\n  start() {\n    if (this._started)\n      return this;\n    this._frame = 0;\n    this._started = true;\n    raf(this.tick);\n    return this;\n  }\n  stop() {\n    this._started = false;\n    return this;\n  }\n  get frame() {\n    return this._frame;\n  }\n  get time() {\n    return this._frame * LoopTimeStep;\n  }\n};\nvar MainLoop = new Loop();\n\n// src/utils/math.ts\nvar clamp3 = (value, a2, b2) => {\n  const min = Math.min(a2, b2);\n  const max = Math.max(a2, b2);\n  if (value < min) {\n    value = min;\n  }\n  if (value > max) {\n    value = max;\n  }\n  return value;\n};\n\n// src/events/FramerEvent.ts\nvar FramerEvent = class {\n  constructor(originalEvent, session) {\n    this.originalEvent = originalEvent;\n    this.session = session;\n    this.time = Date.now();\n    this.loopTime = MainLoop.time;\n    const customTarget = session && session.startEvent && session.startEvent.target || originalEvent.target;\n    const eventLike = FramerEvent.eventLikeFromOriginalEvent(originalEvent);\n    this.point = pointForEvent(eventLike, customTarget);\n    const deviceTarget = session && session.originElement ? session.originElement : document.body;\n    this.devicePoint = pointForEvent(eventLike, deviceTarget);\n    this.target = originalEvent.target || null;\n    const lastEvent = session && session.lastEvent;\n    if (originalEvent instanceof WheelEvent) {\n      this.delta = { x: originalEvent.deltaX, y: originalEvent.deltaY };\n    } else if (lastEvent && this.devicePoint && lastEvent.devicePoint) {\n      this.delta = Point.subtract(this.devicePoint, lastEvent.devicePoint);\n    } else {\n      this.delta = { x: 0, y: 0 };\n    }\n  }\n  static eventLikeFromOriginalEvent(originalEvent) {\n    if (\"touches\" in originalEvent) {\n      let touches = originalEvent.touches;\n      if (!touches || !touches.length) {\n        if (originalEvent.changedTouches && originalEvent.changedTouches.length) {\n          touches = originalEvent.changedTouches;\n        }\n      }\n      if (!touches || !touches.length) {\n        return { pageX: 0, pageY: 0, target: null };\n      }\n      const firstTouch = touches[0];\n      const pageX = firstTouch.clientX || firstTouch.screenX || firstTouch.pageX;\n      const pageY = firstTouch.clientY || firstTouch.screenY || firstTouch.pageY;\n      return {\n        pageX,\n        pageY,\n        target: originalEvent.target\n      };\n    }\n    return originalEvent;\n  }\n  velocity(t) {\n    return this.session ? this.session.velocity(t) : { x: 0, y: 0 };\n  }\n  get offset() {\n    return this.session ? this.session.offset(this) : { x: 0, y: 0 };\n  }\n  get isLeftMouseClick() {\n    if (environment_exports.isTouch()) {\n      return void 0;\n    }\n    if (\"button\" in this.originalEvent && \"buttons\" in this.originalEvent && \"ctrlKey\" in this.originalEvent) {\n      return (this.originalEvent.button === 0 || this.originalEvent.buttons === 1) && !this.originalEvent.ctrlKey;\n    }\n    return false;\n  }\n};\n\n// src/components/hoc/WithDragging.tsx\n\n\n// src/animation/Animators/Integrator.ts\nvar Integrator = class {\n  constructor(accelerationFunction) {\n    this.accelerationForState = accelerationFunction;\n  }\n  integrateState(state, dt) {\n    const a2 = this.evaluateState(state);\n    const b2 = this.evaluateStateWithDerivative(state, dt * 0.5, a2);\n    const c2 = this.evaluateStateWithDerivative(state, dt * 0.5, b2);\n    const d = this.evaluateStateWithDerivative(state, dt, c2);\n    const dxdt = 1 / 6 * (a2.dx + 2 * (b2.dx + c2.dx) + d.dx);\n    const dvdt = 1 / 6 * (a2.dv + 2 * (b2.dv + c2.dv) + d.dv);\n    state.x = state.x + dxdt * dt;\n    state.v = state.v + dvdt * dt;\n    return state;\n  }\n  evaluateState(initialState2) {\n    const dv = this.accelerationForState(initialState2);\n    return { dx: initialState2.v, dv };\n  }\n  evaluateStateWithDerivative(initialState2, dt, derivative) {\n    const state = {\n      x: initialState2.x + derivative.dx * dt,\n      v: initialState2.v + derivative.dv * dt\n    };\n    const output = {\n      dx: state.v,\n      dv: this.accelerationForState(state)\n    };\n    return output;\n  }\n};\n\n// src/animation/Animators/FrictionAnimator.ts\nvar FrictionAnimator = class {\n  constructor(options) {\n    this.options = {\n      velocity: 0,\n      friction: 2,\n      tolerance: 1 / 10\n    };\n    Object.assign(this.options, options);\n    this.state = {\n      x: 0,\n      v: this.options.velocity\n    };\n    this.integrator = new Integrator((state) => -(this.options.friction * state.v));\n  }\n  setFrom(value) {\n    this.state.x = value;\n  }\n  setTo(value) {\n  }\n  setVelocity(velocity) {\n    this.state.v = velocity;\n  }\n  getState() {\n    return this.state;\n  }\n  isReady() {\n    return true;\n  }\n  next(delta2) {\n    this.state = this.integrator.integrateState(this.state, delta2);\n    return this.state.x;\n  }\n  isFinished() {\n    return Math.abs(this.state.v) < this.options.tolerance;\n  }\n};\n\n// src/animation/Animators/SpringCurveValueConverter.ts\nvar epsilon = 1e-3;\nvar minDuration2 = 0.01;\nvar maxDuration2 = 10;\nvar minDamping2 = Number.MIN_VALUE;\nvar maxDamping2 = 1;\nfunction approximateRoot2(func, derivative, initialGuess, times = 12) {\n  let result = initialGuess;\n  for (let i = 1, end = times, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {\n    result = result - func(result) / derivative(result);\n  }\n  return result;\n}\nfunction angularFrequency(undampedFrequency, dampingRatio) {\n  return undampedFrequency * Math.sqrt(1 - Math.pow(dampingRatio, 2));\n}\nvar SpringCurveValueConverter;\n(function(SpringCurveValueConverter2) {\n  function computeDampingRatio(tension, friction, mass = 1) {\n    return friction / (2 * Math.sqrt(mass * tension));\n  }\n  SpringCurveValueConverter2.computeDampingRatio = computeDampingRatio;\n  function computeDuration(tension, friction, velocity = 0, mass = 1) {\n    let duration;\n    const dampingRatio = computeDampingRatio(tension, friction);\n    const undampedFrequency = Math.sqrt(tension / mass);\n    if (dampingRatio < 1) {\n      const a2 = Math.sqrt(1 - Math.pow(dampingRatio, 2));\n      const b2 = velocity / (a2 * undampedFrequency);\n      const c2 = dampingRatio / a2;\n      const d = -((b2 - c2) / epsilon);\n      if (d <= 0) {\n        return null;\n      }\n      duration = Math.log(d) / (dampingRatio * undampedFrequency);\n    } else {\n      return null;\n    }\n    return duration;\n  }\n  SpringCurveValueConverter2.computeDuration = computeDuration;\n  function computeDerivedCurveOptions(dampingRatio, duration, velocity = 0, mass = 1) {\n    let derivative, envelope;\n    dampingRatio = Math.max(Math.min(dampingRatio, maxDamping2), minDamping2);\n    duration = Math.max(Math.min(duration, maxDuration2), minDuration2);\n    if (dampingRatio < 1) {\n      envelope = function(envelopeUndampedFrequency) {\n        const exponentialDecay = envelopeUndampedFrequency * dampingRatio;\n        const currentDisplacement = exponentialDecay * duration;\n        const a2 = exponentialDecay - velocity;\n        const b2 = angularFrequency(envelopeUndampedFrequency, dampingRatio);\n        const c2 = Math.exp(-currentDisplacement);\n        return epsilon - a2 / b2 * c2;\n      };\n      derivative = function(derivativeUndampedFrequency) {\n        const exponentialDecay = derivativeUndampedFrequency * dampingRatio;\n        const currentDisplacement = exponentialDecay * duration;\n        const d = currentDisplacement * velocity + velocity;\n        const e = Math.pow(dampingRatio, 2) * Math.pow(derivativeUndampedFrequency, 2) * duration;\n        const f = Math.exp(-currentDisplacement);\n        const g = angularFrequency(Math.pow(derivativeUndampedFrequency, 2), dampingRatio);\n        const factor = -envelope(derivativeUndampedFrequency) + epsilon > 0 ? -1 : 1;\n        return factor * ((d - e) * f) / g;\n      };\n    } else {\n      envelope = function(envelopeUndampedFrequency) {\n        const a2 = Math.exp(-envelopeUndampedFrequency * duration);\n        const b2 = (envelopeUndampedFrequency - velocity) * duration + 1;\n        return -epsilon + a2 * b2;\n      };\n      derivative = function(derivativeUndampedFrequency) {\n        const a2 = Math.exp(-derivativeUndampedFrequency * duration);\n        const b2 = (velocity - derivativeUndampedFrequency) * Math.pow(duration, 2);\n        return a2 * b2;\n      };\n    }\n    const result = {\n      tension: 100,\n      friction: 10,\n      velocity\n    };\n    const initialGuess = 5 / duration;\n    const undampedFrequency = approximateRoot2(envelope, derivative, initialGuess);\n    if (!isNaN(undampedFrequency)) {\n      result.tension = Math.pow(undampedFrequency, 2) * mass;\n      result.friction = dampingRatio * 2 * Math.sqrt(mass * result.tension);\n    }\n    return result;\n  }\n  SpringCurveValueConverter2.computeDerivedCurveOptions = computeDerivedCurveOptions;\n})(SpringCurveValueConverter || (SpringCurveValueConverter = {}));\n\n// src/animation/Animators/SpringAnimator.ts\nvar SpringTensionFrictionDefaults = {\n  tension: 500,\n  friction: 10,\n  tolerance: 1 / 1e4,\n  velocity: 0\n};\nvar SpringDampingDurationDefaults = {\n  dampingRatio: 1,\n  duration: 1,\n  velocity: 0,\n  mass: 1\n};\nfunction isDampingDurationSpringOptions(options) {\n  if (!options) {\n    return false;\n  }\n  return typeof options.dampingRatio === \"number\" || typeof options.duration === \"number\" || typeof options.mass === \"number\";\n}\nvar SpringAnimator = class {\n  constructor(options, interpolation) {\n    this.interpolation = interpolation;\n    let _opt;\n    if (isDampingDurationSpringOptions(options)) {\n      const toPass = { ...SpringDampingDurationDefaults, ...options };\n      _opt = SpringCurveValueConverter.computeDerivedCurveOptions(toPass.dampingRatio, toPass.duration, toPass.velocity, toPass.mass);\n    } else {\n      _opt = options;\n    }\n    this.options = { ...SpringTensionFrictionDefaults, ..._opt };\n    this.state = {\n      x: 0,\n      v: this.options.velocity\n    };\n    this.integrator = new Integrator((state) => -this.options.tension * state.x - this.options.friction * state.v);\n  }\n  isReady() {\n    return this.interpolator !== void 0 && this.difference !== void 0;\n  }\n  next(delta2) {\n    this.state = this.integrator.integrateState(this.state, delta2);\n    const value = this.interpolator(this.progress());\n    return value;\n  }\n  isFinished() {\n    const positionNearZero = Math.abs(this.state.x) < this.options.tolerance;\n    const velocityNearZero = Math.abs(this.state.v) < this.options.tolerance;\n    return positionNearZero && velocityNearZero;\n  }\n  setFrom(value) {\n    this.current = value;\n    this.updateInterpolator();\n  }\n  setVelocity(velocity) {\n    this.state.v = velocity;\n  }\n  progress() {\n    return 1 - this.state.x / this.difference;\n  }\n  setTo(value) {\n    this.destination = value;\n    this.difference = this.interpolation.difference(this.destination, this.current);\n    this.state.x = this.difference;\n    this.updateInterpolator();\n  }\n  getState() {\n    return this.state;\n  }\n  updateInterpolator() {\n    if (this.current === void 0 || this.destination === void 0) {\n      return;\n    }\n    this.interpolator = this.interpolation.interpolate(this.current, this.destination);\n  }\n};\n\n// src/interpolation/Interpolation.ts\nfunction isInterpolatable(value) {\n  return typeof value === \"function\" && value.interpolationFor && typeof value.interpolationFor === \"function\";\n}\nvar Interpolation;\n(function(Interpolation3) {\n  function handleUndefined(from, to) {\n    if (from === void 0) {\n      from = to;\n    }\n    if (to === void 0) {\n      to = from;\n    }\n    return [from, to];\n  }\n  Interpolation3.handleUndefined = handleUndefined;\n})(Interpolation || (Interpolation = {}));\n\n// src/interpolation/NumberInterpolation.ts\nvar NumberInterpolation = {\n  interpolate(from, to) {\n    ;\n    [from, to] = Interpolation.handleUndefined(from, to);\n    const a1 = +from;\n    const b1 = to - a1;\n    return (progress2) => {\n      const value = a1 + b1 * progress2;\n      return value;\n    };\n  },\n  difference(from, to) {\n    return to - from;\n  }\n};\n\n// src/interpolation/ObjectInterpolation.ts\nvar ObjectInterpolation = (valueInterpolation) => {\n  return {\n    interpolate(from, to) {\n      ;\n      [from, to] = Interpolation.handleUndefined(from, to);\n      const result = Object.assign({}, from);\n      const interpolations = {};\n      const keys2 = new Set();\n      for (const key6 in from) {\n        interpolations[key6] = valueInterpolation.interpolate(from[key6], to[key6]);\n        keys2.add(key6);\n      }\n      for (const key6 in to) {\n        if (!keys2.has(key6)) {\n          interpolations[key6] = valueInterpolation.interpolate(from[key6], to[key6]);\n          keys2.add(key6);\n        }\n      }\n      return (progress2) => {\n        for (const key6 in interpolations) {\n          result[key6] = interpolations[key6](progress2);\n        }\n        return result;\n      };\n    },\n    difference(from, to) {\n      let sum = 0;\n      for (const key6 in from) {\n        const difference = valueInterpolation.difference(from[key6], to[key6]);\n        sum += Math.pow(difference, 2);\n      }\n      return Math.sqrt(sum);\n    }\n  };\n};\n\n// src/interpolation/NoInterpolation.ts\nvar NoInterpolation = {\n  interpolate(from, to) {\n    ;\n    [from, to] = Interpolation.handleUndefined(from, to);\n    return (progress2) => {\n      return progress2 < 0.5 ? from : to;\n    };\n  },\n  difference(from, to) {\n    return from === to ? 0 : 1;\n  }\n};\n\n// src/interpolation/ColorInterpolation.ts\nvar ColorInterpolation = (type = ColorMixModelType.HUSL) => {\n  return {\n    interpolate(from, to) {\n      ;\n      [from, to] = Interpolation.handleUndefined(from, to);\n      return Color.interpolate(Color(from), Color(to), type);\n    },\n    difference(from, to) {\n      return Color.difference(Color(from), Color(to));\n    }\n  };\n};\n\n// src/interpolation/ValueInterpolation.ts\nvar DefaultInterpolationOptions = {\n  colorModel: ColorMixModelType.HUSL\n};\nvar ValueInterpolation = class {\n  constructor(options = DefaultInterpolationOptions) {\n    this.interpolate = (from, to) => {\n      ;\n      [from, to] = Interpolation.handleUndefined(from, to);\n      return this.interPolationForValue(from).interpolate(from, to);\n    };\n    this.difference = (from, to) => {\n      const interpolation = this.interPolationForValue(from);\n      return interpolation.difference(from, to);\n    };\n    this.options = { ...DefaultInterpolationOptions, ...options };\n  }\n  interPolationForValue(value) {\n    const type = typeof value;\n    if (type === \"number\") {\n      return NumberInterpolation;\n    } else if (type === \"boolean\" || type === \"function\") {\n      return NoInterpolation;\n    } else if (Color.isColor(value)) {\n      return ColorInterpolation(this.options.colorModel);\n    } else if (type === \"object\") {\n      if (value === null) {\n        return NoInterpolation;\n      }\n      const constructor = value.constructor;\n      if (constructor && isInterpolatable(constructor)) {\n        const interpolation = constructor.interpolationFor(value, this);\n        if (interpolation && interpolation !== this && interpolation.constructor !== ValueInterpolation) {\n          return interpolation;\n        }\n      }\n      return ObjectInterpolation(this);\n    }\n    console.warn(`No interpolation defined for ${value}`);\n    return NoInterpolation;\n  }\n};\nvar AnyInterpolation = new ValueInterpolation();\n\n// src/animation/Animators/InertialScrollAnimator.ts\nvar Defaults = {\n  velocity: 0,\n  min: 0,\n  max: 0,\n  momentum: {\n    friction: 2,\n    tolerance: 10\n  },\n  bounce: {\n    tension: 500,\n    friction: 10,\n    tolerance: 1\n  }\n};\nvar InertialScrollAnimator = class {\n  constructor(options) {\n    this.options = Object.assign({ ...Defaults }, options);\n    this.frictionAnimator = new FrictionAnimator({\n      friction: this.options.momentum.friction,\n      tolerance: this.options.momentum.tolerance,\n      velocity: this.options.velocity\n    });\n    this.springAnimator = new SpringAnimator({\n      tension: this.options.bounce.tension,\n      friction: this.options.bounce.friction,\n      tolerance: this.options.bounce.tolerance,\n      velocity: this.options.velocity\n    }, NumberInterpolation);\n    this.useSpring = false;\n  }\n  isReady() {\n    return true;\n  }\n  next(delta2) {\n    this.current = this.currentAnimator.next(delta2);\n    if (!this.useSpring) {\n      this.tryTransitionToSpring();\n    }\n    return this.current;\n  }\n  get currentAnimator() {\n    if (this.useSpring) {\n      return this.springAnimator;\n    }\n    return this.frictionAnimator;\n  }\n  isFinished() {\n    return this.currentAnimator.isFinished();\n  }\n  get state() {\n    return this.currentAnimator.getState();\n  }\n  setFrom(value) {\n    this.setState({ x: value, v: this.state.v });\n  }\n  setState(state) {\n    this.frictionAnimator.setFrom(state.x);\n    this.frictionAnimator.setVelocity(state.v);\n    if (this.isValidState()) {\n      return this.tryTransitionToSpring();\n    } else {\n      let bound = 0;\n      if (this.state.x <= this.options.min) {\n        bound = this.options.min;\n      }\n      if (this.state.x >= this.options.max) {\n        bound = this.options.max;\n      }\n      return this.transitionToSpring(bound);\n    }\n  }\n  setTo(destination) {\n    this.frictionAnimator.setTo(destination);\n    this.springAnimator.setTo(destination);\n  }\n  setLimits(min, max) {\n    this.options.min = min;\n    this.options.max = max;\n  }\n  tryTransitionToSpring() {\n    const belowMinWithVelocity = this.state.x < this.options.min && this.state.v <= 0;\n    const aboveMaxWithVelocity = this.state.x > this.options.max && this.state.v >= 0;\n    if (belowMinWithVelocity || aboveMaxWithVelocity) {\n      let bound;\n      if (belowMinWithVelocity) {\n        bound = this.options.min;\n      } else {\n        bound = this.options.max;\n      }\n      this.transitionToSpring(bound);\n    } else {\n      this.useSpring = false;\n    }\n  }\n  transitionToSpring(bound) {\n    this.springAnimator.setFrom(this.state.x);\n    this.springAnimator.setVelocity(this.state.v);\n    this.springAnimator.setTo(bound);\n    this.useSpring = true;\n  }\n  isValidState() {\n    const belowMinTravelingBack = this.state.x < this.options.min && this.state.v > 0;\n    const aboveMaxTravelingBack = this.state.x > this.options.max && this.state.v < 0;\n    if (belowMinTravelingBack || aboveMaxTravelingBack) {\n      let bound;\n      if (belowMinTravelingBack) {\n        bound = this.options.min;\n      } else {\n        bound = this.options.max;\n      }\n      const friction = this.frictionAnimator.options.friction;\n      const solution = 1 - friction * (bound - this.state.x) / this.state.v;\n      return solution > 0;\n    }\n    return true;\n  }\n};\n\n// src/animation/Drivers/AnimationDriver.ts\nvar AnimationDriver = class {\n  constructor(animator, updateCallback, finishedCallback) {\n    this.animator = animator;\n    this.updateCallback = updateCallback;\n    this.finishedCallback = finishedCallback;\n    this.update = (frame2, elapsed) => {\n      if (this.animator.isFinished()) {\n        this.finish();\n      } else {\n        const value = this.animator.next(elapsed);\n        this.updateCallback(value);\n      }\n    };\n    if (!this.animator.isReady()) {\n      console.warn(\"AnimationDriver initialized with animator that isn't ready\");\n    }\n  }\n  finish() {\n    if (this.finishedCallback) {\n      this.finishedCallback(this.animator.isFinished());\n    }\n  }\n  isFinished() {\n    return this.animator.isFinished();\n  }\n};\n\n// src/animation/Drivers/MainLoopDriver.ts\nvar MainLoopAnimationDriver = class extends AnimationDriver {\n  play() {\n    if (RenderEnvironment.target !== RenderTarget.preview) {\n      this.finishedCallback && this.finishedCallback(false);\n      return;\n    }\n    MainLoop.on(\"update\", this.update);\n  }\n  cancel() {\n    MainLoop.off(\"update\", this.update);\n  }\n  finish() {\n    MainLoop.off(\"update\", this.update);\n    super.finish();\n  }\n};\n\n// src/components/hoc/WithDragging.tsx\nvar DraggingContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({ dragging: false });\nvar hoistNonReactStatic = require_hoist_non_react_statics_cjs();\nfunction WithDragging(Component19) {\n  const _WithDraggingHOC = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props, defaultProps) {\n      super(props, defaultProps);\n      this.state = {\n        isDragging: false\n      };\n      this.x = Animatable(0);\n      this.y = Animatable(0);\n      this.onChangePosition = (change, transaction) => {\n        if (change.value === change.oldValue) {\n          return;\n        }\n        if (this.props.onMove) {\n          this.props.onMove(this.point, this);\n        }\n      };\n      this.isMoving = false;\n      this.isAnimating = false;\n      this.directionLockAxis = null;\n      this._constraints = null;\n      this.panStart = (event) => {\n        if (!this.props.enabled) {\n          return;\n        }\n        this.isMoving = this.isAnimating;\n        this.stopAnimation();\n        this.resetdirectionLock();\n        this.layerStartPoint = this.point;\n        this.correctedLayerStartPoint = this.point;\n        if (this._constraints && this.props.bounce) {\n          this.correctedLayerStartPoint = this.constrainPosition(this.correctedLayerStartPoint, this._constraints, 1 / this.props.overdragScale);\n        }\n        this.previousPoint = this.correctedLayerStartPoint;\n        if (!this.state.isDragging) {\n          this.setState({ isDragging: true });\n        }\n        if (this.props.onDragSessionStart) {\n          this.props.onDragSessionStart(event, this);\n        }\n      };\n      this.pan = (event) => {\n        const {\n          enabled,\n          speedX,\n          speedY,\n          directionLock,\n          overdragScale,\n          vertical,\n          horizontal,\n          pixelAlign,\n          onDragStart,\n          onDragWillMove,\n          onDragDidMove,\n          onDragSessionMove\n        } = this.props;\n        if (!enabled) {\n          return;\n        }\n        let point = { ...this.previousPoint };\n        point.x += event.delta.x * speedX;\n        point.y += event.delta.y * speedY;\n        this.previousPoint = { ...point };\n        if (this._constraints) {\n          point = this.constrainPosition(point, this._constraints, overdragScale);\n        }\n        if (directionLock) {\n          if (this.directionLockAxis === null) {\n            const offset = event.offset;\n            offset.x = offset.x * speedX;\n            offset.y = offset.y * speedY;\n            this.updatedirectionLock(offset);\n            return;\n          } else {\n            if (this.directionLockAxis === \"y\") {\n              point.x = this.layerStartPoint.x;\n            }\n            if (this.directionLockAxis === \"x\") {\n              point.y = this.layerStartPoint.y;\n            }\n          }\n        }\n        if (!this.state.isDragging) {\n          this.setState({ isDragging: true });\n          this.isMoving = true;\n          if (onDragStart) {\n            onDragStart(event, this);\n          }\n        }\n        if (onDragWillMove) {\n          onDragWillMove(event, this);\n        }\n        if (pixelAlign) {\n          point.x = Math.round(point.x);\n          point.y = Math.round(point.y);\n        }\n        if (!horizontal && !vertical) {\n          return;\n        }\n        let axis = null;\n        if (horizontal && !vertical) {\n          axis = \"x\";\n        } else if (vertical && !horizontal) {\n          axis = \"y\";\n        }\n        this.setPoint(point, axis);\n        if (onDragDidMove) {\n          onDragDidMove(event, this);\n        }\n        if (onDragSessionMove) {\n          onDragSessionMove(event, this);\n        }\n      };\n      this.panEnd = (event) => {\n        if (!this.props.enabled) {\n          return;\n        }\n        this.startAnimation(event);\n        const { onDragSessionEnd, onDragEnd } = this.props;\n        if (this.state.isDragging) {\n          if (onDragEnd) {\n            onDragEnd(event, this);\n          }\n        }\n        if (onDragSessionEnd) {\n          onDragSessionEnd(event, this);\n        }\n        if (this.state.isDragging) {\n          this.setState({ isDragging: false });\n        }\n        this.isMoving = this.isAnimating;\n      };\n      this.mouseWheelStart = (event) => {\n        this.correctedLayerStartPoint = this.point;\n        this.previousPoint = this.correctedLayerStartPoint;\n        this.stopAnimation();\n      };\n      this.mouseWheel = (event) => {\n        const {\n          enabled,\n          speedX,\n          speedY,\n          vertical,\n          horizontal,\n          pixelAlign,\n          onDragWillMove,\n          onDragDidMove,\n          mouseWheel\n        } = this.props;\n        if (!mouseWheel || !enabled) {\n          return;\n        }\n        let point = { ...this.point };\n        point.x -= event.delta.x * speedX;\n        point.y -= event.delta.y * speedY;\n        if (this._constraints) {\n          point = this.constrainPosition(point, this._constraints, 0, false);\n        }\n        if (onDragWillMove) {\n          onDragWillMove(event, this);\n        }\n        if (pixelAlign) {\n          point.x = Math.round(point.x);\n          point.y = Math.round(point.y);\n        }\n        if (!horizontal && !vertical) {\n          return;\n        }\n        let axis = null;\n        if (horizontal && !vertical) {\n          axis = \"x\";\n        } else if (vertical && !horizontal) {\n          axis = \"y\";\n        }\n        this.setPoint(point, axis);\n        if (onDragDidMove) {\n          onDragDidMove(event, this);\n        }\n      };\n      this.mouseWheelEnd = (event) => {\n      };\n      this.onAnimationStep = (axis, value) => {\n        if (axis === \"x\" && this.props.horizontal === false) {\n          return;\n        }\n        if (axis === \"y\" && this.props.vertical === false) {\n          return;\n        }\n        let delta2 = 0;\n        if (this.constraints) {\n          if (this.props.bounce) {\n            delta2 = value - this.getValue(axis);\n          } else {\n            const { minX, minY, maxX, maxY } = this.calculateConstraints(this._constraints);\n            if (axis === \"x\") {\n              delta2 = clamp3(value, minX, maxX) - this.getValue(axis);\n            }\n            if (axis === \"y\") {\n              delta2 = clamp3(value, minY, maxY) - this.getValue(axis);\n            }\n          }\n        } else {\n          delta2 = value - this.getValue(axis);\n        }\n        const updatePoint = this.point;\n        if (axis === \"x\") {\n          updatePoint[axis] = updatePoint[axis] + delta2;\n        }\n        if (axis === \"y\") {\n          updatePoint[axis] = updatePoint[axis] + delta2;\n        }\n        this.setPoint(updatePoint, axis);\n      };\n      this.onAnimationStop = (axis) => {\n        if (axis === \"x\" && this.props.horizontal === false) {\n          return;\n        }\n        if (axis === \"y\" && this.props.vertical === false) {\n          return;\n        }\n        if (!this.animation) {\n          return;\n        }\n        if (this.props.pixelAlign) {\n          const point = this.point;\n          point.x = Math.round(point.x);\n          point.y = Math.round(point.y);\n          this.setPoint(point, axis);\n        }\n        if (this.animation.x.isFinished() && this.animation.y.isFinished()) {\n          return this.stopAnimation();\n        }\n      };\n      this.stopAnimation = () => {\n        this.isAnimating = false;\n        this.isMoving = false;\n        if (!this.animation) {\n          return;\n        }\n        this.animation.x.cancel();\n        this.animation.y.cancel();\n        if (this.props.onDragAnimationEnd) {\n          this.props.onDragAnimationEnd(this.animation, this);\n        }\n        this.animation = null;\n      };\n      const x = this.props.left;\n      const y = this.props.top;\n      if (!x) {\n        this.x = Animatable(0);\n      } else if (isAnimatable2(x)) {\n        this.x = x;\n      } else {\n        this.x = Animatable(x);\n      }\n      if (!y) {\n        this.y = Animatable(0);\n      } else if (isAnimatable2(y)) {\n        this.y = y;\n      } else {\n        this.y = Animatable(y);\n      }\n      this.x.onUpdate(this.onChangePosition);\n      this.y.onUpdate(this.onChangePosition);\n      const constraints = this.props.constraints;\n      if (constraints) {\n        this.constraints = constraints;\n      }\n    }\n    UNSAFE_componentWillReceiveProps(props) {\n      if (this.props.left !== props.left && isFiniteNumber(props.left)) {\n        this.x.set(props.left);\n      }\n      if (this.props.top !== props.top && isFiniteNumber(props.top)) {\n        this.y.set(props.top);\n      }\n      const constraints = props.constraints;\n      if (constraints) {\n        this.constraints = constraints;\n      }\n    }\n    get point() {\n      return { x: this.x.get(), y: this.y.get() };\n    }\n    setPoint(point, axis = null) {\n      switch (axis) {\n        case \"x\":\n          this.x.set(point.x);\n          break;\n        case \"y\":\n          this.y.set(point.y);\n          break;\n        case null:\n          this.x.set(point.x);\n          this.y.set(point.y);\n          break;\n      }\n    }\n    getValue(axis) {\n      switch (axis) {\n        case \"x\":\n          return this.x.get();\n        case \"y\":\n          return this.y.get();\n      }\n    }\n    get width() {\n      const width = this.props.width;\n      if (!width) {\n        return 100;\n      }\n      if (isAnimatable2(width)) {\n        return width.get();\n      }\n      if (typeof width === \"string\") {\n        return parseFloat(width);\n      }\n      return width;\n    }\n    get height() {\n      const height = this.props.height;\n      if (!height) {\n        return 100;\n      }\n      if (isAnimatable2(height)) {\n        return height.get();\n      }\n      if (typeof height === \"string\") {\n        return parseFloat(height);\n      }\n      return height;\n    }\n    get constraints() {\n      return this._constraints;\n    }\n    set constraints(value) {\n      if (value !== null && typeof value === \"object\") {\n        this._constraints = {\n          x: value.x || 0,\n          y: value.y || 0,\n          width: value.width || 0,\n          height: value.height || 0\n        };\n      } else {\n        this._constraints = null;\n      }\n      if (this._constraints) {\n        this.updateAnimationConstraints(this._constraints);\n      }\n    }\n    get constraintsOffset() {\n      if (!this.constraints) {\n        return { x: 0, y: 0 };\n      }\n      const { minX, minY, maxX, maxY } = this.calculateConstraints(this._constraints);\n      const point = this.point;\n      const constrainedPoint = { x: clamp3(point.x, minX, maxX), y: clamp3(point.y, minY, maxY) };\n      const offset = { x: point.x - constrainedPoint.x, y: point.y - constrainedPoint.y };\n      return offset;\n    }\n    get isBeyondConstraints() {\n      const constraintsOffset = this.constraintsOffset;\n      if (constraintsOffset.x !== 0) {\n        return true;\n      }\n      if (constraintsOffset.y !== 0) {\n        return true;\n      }\n      return false;\n    }\n    clampAndScale(value, min, max, scale2, scaleAllowed) {\n      if (!scaleAllowed) {\n        return clamp3(value, min, max);\n      }\n      if (value < min) {\n        value = min + (value - min) * scale2;\n      }\n      if (value > max) {\n        value = max + (value - max) * scale2;\n      }\n      return value;\n    }\n    calculateConstraints(bounds) {\n      if (!bounds) {\n        return { minX: Infinity, maxX: Infinity, minY: Infinity, maxY: Infinity };\n      }\n      if (bounds.width < this.width) {\n        bounds.width = this.width;\n      }\n      if (bounds.height < this.height) {\n        bounds.height = this.height;\n      }\n      const constraints = {\n        minX: Rect.minX(bounds),\n        maxX: Rect.maxX(bounds),\n        minY: Rect.minY(bounds),\n        maxY: Rect.maxY(bounds)\n      };\n      constraints.maxX -= this.width;\n      constraints.maxY -= this.height;\n      return constraints;\n    }\n    constrainPosition(proposedPoint, bounds, scale2, overdrag = this.props.overdrag) {\n      const { maxX, maxY, minX, minY } = this.calculateConstraints(this._constraints);\n      const point = {\n        x: this.clampAndScale(proposedPoint.x, minX, maxX, scale2, overdrag),\n        y: this.clampAndScale(proposedPoint.y, minY, maxY, scale2, overdrag)\n      };\n      if (this.props.speedX === 0 || this.props.horizontal === false) {\n        point.x = proposedPoint.x;\n      }\n      if (this.props.speedY === 0 || this.props.vertical === false) {\n        point.y = proposedPoint.y;\n      }\n      return point;\n    }\n    updatedirectionLock(correctedDelta) {\n      if (Math.abs(correctedDelta.y) > this.props.directionLockThreshold.y) {\n        this.directionLockAxis = \"y\";\n      } else if (Math.abs(correctedDelta.x) > this.props.directionLockThreshold.x) {\n        this.directionLockAxis = \"x\";\n      }\n      if (this.directionLockAxis !== null) {\n        if (this.props.onDragDirectionLockStart) {\n          this.props.onDragDirectionLockStart(this.directionLockAxis, this);\n        }\n      }\n    }\n    resetdirectionLock() {\n      this.directionLockAxis = null;\n    }\n    setupAnimation() {\n      if (this.animation) {\n        return;\n      }\n      this.animation = { x: this.setupAnimationForAxis(\"x\"), y: this.setupAnimationForAxis(\"y\") };\n      this.updateAnimationConstraints(this._constraints);\n    }\n    setupAnimationForAxis(axis) {\n      const properties = {};\n      properties[axis] = true;\n      const animator = new InertialScrollAnimator({\n        momentum: this.props.momentumOptions,\n        bounce: this.props.bounceOptions\n      });\n      const updateCallback = (value) => {\n        this.onAnimationStep(axis, value);\n      };\n      const doneCallback = () => {\n        this.onAnimationStop(axis);\n      };\n      return new MainLoopAnimationDriver(animator, updateCallback, doneCallback);\n    }\n    updateAnimationConstraints(constraints) {\n      if (!this.animation) {\n        return;\n      }\n      if (constraints) {\n        const { minX, minY, maxX, maxY } = this.calculateConstraints(constraints);\n        this.animation.x.animator.setLimits(minX, maxX);\n        this.animation.y.animator.setLimits(minY, maxY);\n      } else {\n        this.animation.x.animator.setLimits(-Infinity, Infinity);\n        this.animation.y.animator.setLimits(-Infinity, Infinity);\n      }\n    }\n    startAnimation(event) {\n      const {\n        momentum,\n        bounce,\n        momentumVelocityMultiplier,\n        speedX,\n        speedY,\n        overdrag,\n        onDragAnimationStart\n      } = this.props;\n      if (!(momentum || bounce)) {\n        return;\n      }\n      if (this.isBeyondConstraints === false && momentum === false) {\n        return;\n      }\n      if (this.isBeyondConstraints === false && this.state.isDragging === false) {\n        return;\n      }\n      const { minX, minY, maxX, maxY } = this.calculateConstraints(this._constraints);\n      const startAnimationX = overdrag === true || this.point.x > minX && this.point.x < maxX;\n      const startAnimationY = overdrag === true || this.point.y > minY && this.point.y < maxY;\n      if (startAnimationX === startAnimationY && startAnimationY === false) {\n        return;\n      }\n      const velocity = event.velocity(0.1);\n      let velocityX = velocity.x * momentumVelocityMultiplier * speedX;\n      let velocityY = velocity.y * momentumVelocityMultiplier * speedY;\n      if (this.directionLockAxis === \"x\") {\n        velocityY = 0;\n      }\n      if (this.directionLockAxis === \"y\") {\n        velocityX = 0;\n      }\n      this.setupAnimation();\n      this.isAnimating = true;\n      this.isMoving = true;\n      if (!this.animation) {\n        return;\n      }\n      this.animation.x.animator.setState({ x: this.point.x, v: velocityX });\n      if (startAnimationX) {\n        this.animation.x.play();\n      }\n      this.animation.y.animator.setState({ x: this.point.y, v: velocityY });\n      if (startAnimationY) {\n        this.animation.y.play();\n      }\n      if (onDragAnimationStart) {\n        onDragAnimationStart(this.animation, this);\n      }\n    }\n    wrapHandler(ownHandler, originalHandler) {\n      if (!originalHandler) {\n        return ownHandler;\n      }\n      return (event) => {\n        ownHandler(event);\n        originalHandler(event);\n      };\n    }\n    render() {\n      const {\n        onPanStart,\n        onPan,\n        onPanEnd,\n        onMouseWheelStart,\n        onMouseWheel,\n        onMouseWheelEnd,\n        ...attributes\n      } = this.props;\n      const originalProps = { ...attributes };\n      Object.keys(_WithDraggingHOC.draggingDefaultProps).forEach((key6) => {\n        delete originalProps[key6];\n      });\n      originalProps.onPanStart = this.wrapHandler(this.panStart, onPanStart);\n      originalProps.onPan = this.wrapHandler(this.pan, onPan);\n      originalProps.onPanEnd = this.wrapHandler(this.panEnd, onPanEnd);\n      originalProps.onMouseWheelStart = this.wrapHandler(this.mouseWheelStart, onMouseWheelStart);\n      originalProps.onMouseWheel = this.wrapHandler(this.mouseWheel, onMouseWheel);\n      originalProps.onMouseWheelEnd = this.wrapHandler(this.mouseWheelEnd, onMouseWheelEnd);\n      originalProps.left = this.x;\n      originalProps.top = this.y;\n      return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(DraggingContext.Provider, {\n        value: { dragging: this.state.isDragging }\n      }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Component19, {\n        ...originalProps\n      }));\n    }\n  };\n  let WithDraggingHOC = _WithDraggingHOC;\n  WithDraggingHOC.draggingDefaultProps = {\n    momentum: true,\n    momentumOptions: { friction: 2.1, tolerance: 1 },\n    momentumVelocityMultiplier: 800,\n    speedX: 1,\n    speedY: 1,\n    bounce: true,\n    bounceOptions: { friction: 40, tension: 200, tolerance: 1 },\n    directionLock: false,\n    directionLockThreshold: { x: 10, y: 10 },\n    overdrag: true,\n    overdragScale: 0.5,\n    pixelAlign: true,\n    velocityTimeout: 100,\n    velocityScale: 890,\n    horizontal: true,\n    vertical: true,\n    enabled: true,\n    constraints: {},\n    mouseWheel: false\n  };\n  WithDraggingHOC.defaultProps = Object.assign({}, Component19.defaultProps, _WithDraggingHOC.draggingDefaultProps);\n  const withDragging = WithDraggingHOC;\n  hoistNonReactStatic(withDragging, Component19);\n  return withDragging;\n}\n\n// src/components/hoc/WithEvents.tsx\nvar hoistNonReactStatic2 = require_hoist_non_react_statics_cjs();\nvar hoverProps = {\n  onMouseEnter: \"mouseenter\",\n  onMouseLeave: \"mouseleave\"\n};\nvar hoverEventKeys = Object.keys(hoverProps);\nvar eventHandlerMapping = {\n  panstart: [\"onPanStart\"],\n  pan: [\"onPan\"],\n  panend: [\"onPanEnd\"],\n  tapstart: [\"onTapStart\", \"onMouseDown\"],\n  tap: [\"onTap\", \"onClick\"],\n  tapend: [\"onTapEnd\", \"onMouseUp\"],\n  mousewheelstart: [\"onMouseWheelStart\"],\n  mousewheel: [\"onMouseWheel\"],\n  mousewheelend: [\"onMouseWheelEnd\"]\n};\nvar tapEventKeys = new Set([\"tapstart\", \"tap\", \"tapend\"]);\nfunction WithEvents(BaseComponent) {\n  var _a;\n  const withEvents = (_a = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor() {\n      super(...arguments);\n      this.shouldCancelTap = false;\n      this.activeEventListeners = new Map();\n      this.hasFramerEventListener = false;\n      this.component = (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    }\n    get element() {\n      return this.component.current && this.component.current.element;\n    }\n    componentDidMount() {\n      this.addEventListeners();\n    }\n    componentDidUpdate(prevProps) {\n      this.addEventListeners(prevProps);\n    }\n    componentWillUnmount() {\n      this.removeEventListeners();\n    }\n    addEventListeners(prevProps) {\n      if (this.element && !this.hasFramerEventListener) {\n        this.element.addEventListener(\"FramerEvent\", ({ detail }) => {\n          const type = detail.type;\n          const framerEvent = detail.event;\n          this.handleEvent(type, framerEvent);\n        });\n        hoverEventKeys.forEach((eventName) => this.addHoverEvent(eventName));\n        this.hasFramerEventListener = true;\n      } else if (this.element && prevProps) {\n        hoverEventKeys.forEach((eventName) => this.checkHoverEvent(eventName, prevProps));\n      } else if (!this.element) {\n        this.hasFramerEventListener = false;\n      }\n    }\n    removeEventListeners() {\n      hoverEventKeys.forEach((eventName) => this.removeHoverEvent(eventName));\n    }\n    addHoverEvent(eventName) {\n      const originalEventListener = this.props[eventName];\n      if (this.element && originalEventListener) {\n        const eventListener = (e) => {\n          const framerEvent = new FramerEvent(e);\n          originalEventListener(framerEvent);\n        };\n        this.activeEventListeners.set(eventName, eventListener);\n        const domEventName = hoverProps[eventName];\n        this.element.addEventListener(domEventName, eventListener);\n      }\n    }\n    removeHoverEvent(eventName) {\n      const eventListener = this.activeEventListeners.get(eventName);\n      if (this.element && eventListener) {\n        const domEventName = hoverProps[eventName];\n        this.element.removeEventListener(domEventName, eventListener);\n        this.activeEventListeners.delete(eventName);\n      }\n    }\n    checkHoverEvent(eventName, prevProps) {\n      if (prevProps[eventName] !== this.props[eventName]) {\n        this.removeHoverEvent(eventName);\n        this.addHoverEvent(eventName);\n      }\n    }\n    handleEvent(type, framerEvent) {\n      const eventListenerKeys = eventHandlerMapping[type];\n      if (!eventListenerKeys)\n        return;\n      eventListenerKeys.forEach((eventKey) => {\n        const eventListener = this.props[eventKey];\n        const cancelEvent = this.shouldCancelTap && tapEventKeys.has(eventKey);\n        if (eventListener && !cancelEvent) {\n          eventListener(framerEvent);\n        }\n      });\n    }\n    render() {\n      return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(DraggingContext.Consumer, null, (value) => {\n        this.shouldCancelTap = value.dragging;\n        return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(BaseComponent, {\n          ...this.props,\n          ref: this.component\n        });\n      });\n    }\n  }, _a.defaultProps = Object.assign({}, BaseComponent.defaultProps), _a);\n  hoistNonReactStatic2(withEvents, BaseComponent);\n  return withEvents;\n}\n\n// src/render/presentation/Frame/DeprecatedFrame.tsx\n\n\n// src/data/ObservableObject.ts\nvar hasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction ObservableObject(initial = {}, makeAnimatables = false, observeAnimatables = true) {\n  const unproxiedState = {};\n  unproxiedState[$private] = {\n    makeAnimatables,\n    observeAnimatables,\n    observers: new Observers(),\n    reset() {\n      for (const key6 in state) {\n        if (hasOwnProperty(state, key6)) {\n          state[key6] = hasOwnProperty(initial, key6) ? initial[key6] : void 0;\n        }\n      }\n    },\n    transactions: new Set()\n  };\n  const state = new Proxy(unproxiedState, sharedProxyHandler);\n  Object.assign(state, initial);\n  return state;\n}\n(function(ObservableObject2) {\n  function resetObject(target) {\n    return target[$private].reset();\n  }\n  ObservableObject2.resetObject = resetObject;\n  function addObserver(target, observer) {\n    return target[$private].observers.add(observer);\n  }\n  ObservableObject2.addObserver = addObserver;\n})(ObservableObject || (ObservableObject = {}));\nvar ObservableObjectProxyHandler = class {\n  constructor() {\n    this.set = (target, key6, value, receiver) => {\n      if (key6 === $private) {\n        return false;\n      }\n      const privateObject = target[$private];\n      let animatable;\n      let rawValue;\n      if (isAnimatable2(value)) {\n        animatable = value;\n        rawValue = animatable.get();\n      } else {\n        rawValue = value;\n      }\n      if (privateObject.makeAnimatables && typeof value !== \"function\" && typeof value !== \"object\" && !animatable) {\n        animatable = Animatable(value);\n      }\n      if (privateObject.observeAnimatables && animatable) {\n        const transactions = privateObject.transactions;\n        animatable.onUpdate({\n          update: (change, transaction) => {\n            if (transaction) {\n              transactions.add(transaction);\n            }\n            privateObject.observers.notify({ value: receiver }, transaction);\n          },\n          finish: (transaction) => {\n            if (transactions.delete(transaction)) {\n              privateObject.observers.finishTransaction(transaction);\n            }\n          }\n        });\n      }\n      let result = false;\n      let changed = true;\n      if (target[key6] !== void 0) {\n        if (isAnimatable2(target[key6])) {\n          changed = target[key6].get() !== rawValue;\n          target[key6].set(rawValue);\n        } else {\n          changed = target[key6] !== rawValue;\n          target[key6] = rawValue;\n        }\n        const rawValueIsObject = rawValue !== null && typeof rawValue === \"object\";\n        if (Array.isArray(rawValue) || rawValueIsObject)\n          changed = true;\n        result = true;\n      } else {\n        if (animatable) {\n          value = animatable;\n        }\n        result = Reflect.set(target, key6, value);\n      }\n      if (changed) {\n        privateObject.observers.notify({ value: receiver });\n      }\n      return result;\n    };\n    this.get = (target, key6, receiver) => {\n      if (key6 === $private) {\n        return target[key6];\n      }\n      const value = Reflect.get(target, key6, receiver);\n      return typeof value === \"function\" ? value.bind(receiver) : value;\n    };\n  }\n  deleteProperty(target, key6) {\n    const result = Reflect.deleteProperty(target, key6);\n    target[$private].observers.notify({ value: target });\n    return result;\n  }\n  ownKeys(target) {\n    const keys2 = Reflect.ownKeys(target);\n    const privateIndex = keys2.indexOf($private);\n    if (privateIndex !== -1) {\n      keys2.splice(privateIndex, 1);\n    }\n    return keys2;\n  }\n  getOwnPropertyDescriptor(target, key6) {\n    if (key6 === $private) {\n      return void 0;\n    }\n    return Reflect.getOwnPropertyDescriptor(target, key6);\n  }\n};\nvar sharedProxyHandler = new ObservableObjectProxyHandler();\nvar $private = Symbol(\"private\");\n\n// src/render/traits/Radius.ts\nvar key2 = \"radius\";\nfunction hasRadius(props) {\n  return key2 in props;\n}\nfunction getRadiusValue(value) {\n  let num = Number(value);\n  if (typeof value === \"string\" && isNaN(num)) {\n    return value;\n  } else if (isAnimatable2(value)) {\n    num = Animatable.getNumber(value);\n  }\n  return num ? `${num}px` : \"0\";\n}\nfunction hasRadiusValue(value) {\n  return value && value !== \"0\";\n}\nfunction collectRadiusFromProps(props, style) {\n  if (!hasRadius(props))\n    return;\n  const { radius } = props;\n  if (typeof radius === \"string\" || isAnimatable2(radius) || isFiniteNumber(radius)) {\n    const radiusValue = getRadiusValue(radius);\n    if (hasRadiusValue(radiusValue)) {\n      style.borderTopLeftRadius = style.borderTopRightRadius = style.borderBottomRightRadius = style.borderBottomLeftRadius = radiusValue;\n    }\n  } else if (radius) {\n    const topLeft = getRadiusValue(radius.topLeft);\n    const topRight = getRadiusValue(radius.topRight);\n    const bottomRight = getRadiusValue(radius.bottomRight);\n    const bottomLeft = getRadiusValue(radius.bottomLeft);\n    if (hasRadiusValue(topLeft) || hasRadiusValue(topRight) || hasRadiusValue(bottomRight) || hasRadiusValue(bottomLeft)) {\n      style.borderTopLeftRadius = topLeft;\n      style.borderTopRightRadius = topRight;\n      style.borderBottomRightRadius = bottomRight;\n      style.borderBottomLeftRadius = bottomLeft;\n    }\n  }\n}\n\n// src/render/traits/Blending.ts\nfunction collectBlendingFromProps(node, style) {\n  if (!node.blendingMode || node.blendingMode === \"normal\")\n    return;\n  style.mixBlendMode = node.blendingMode;\n}\n\n// src/render/traits/Overflow.ts\nfunction collectOverflowFromProps(props, style) {\n  if (props.overflow) {\n    style.overflow = props.overflow;\n  }\n}\n\n// src/render/traits/Opacity.ts\nvar key3 = \"opacity\";\nfunction withOpacity(target) {\n  return key3 in target;\n}\nfunction collectOpacityFromProps(props, style) {\n  if (!withOpacity(props))\n    return;\n  const opacity = Animatable.getNumber(props.opacity);\n  if (opacity === 1)\n    return;\n  style.opacity = opacity;\n}\n\n// src/render/style/shadow.tsx\n\n\n// src/render/types/Shadow.ts\nvar shadowKeys = [\"color\", \"x\", \"y\", \"blur\"];\nvar Shadow;\n(function(Shadow3) {\n  function is(shadow) {\n    return shadow && shadowKeys.every((key6) => key6 in shadow);\n  }\n  Shadow3.is = is;\n})(Shadow || (Shadow = {}));\nvar boxShadowKeys = [\"inset\", \"color\", \"x\", \"y\", \"blur\", \"spread\"];\nvar BoxShadow;\n(function(BoxShadow2) {\n  function is(shadow) {\n    return shadow && boxShadowKeys.every((key6) => key6 in shadow);\n  }\n  BoxShadow2.is = is;\n  function toCSS(shadow) {\n    const inset = shadow.inset ? \"inset \" : \"\";\n    return `${inset}${shadow.x}px ${shadow.y}px ${shadow.blur}px ${shadow.spread}px ${shadow.color}`;\n  }\n  BoxShadow2.toCSS = toCSS;\n})(BoxShadow || (BoxShadow = {}));\n\n// src/render/presentation/CustomProperties.tsx\n\nvar VariableRegex = /var\\(([^),]+)/;\nvar CustomPropertiesContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(() => null);\nvar CustomProperties = class extends react__WEBPACK_IMPORTED_MODULE_0__.PureComponent {\n  constructor() {\n    super(...arguments);\n    this.lookup = (variable) => {\n      const match = VariableRegex.exec(variable);\n      const customProperty = match ? match[1].trim() : \"\";\n      return this.props.customProperties[customProperty] || null;\n    };\n  }\n  render() {\n    const { children, customProperties } = this.props;\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(CustomPropertiesContext.Provider, {\n      value: this.lookup\n    }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n      style: customProperties\n    }, children));\n  }\n};\n\n// src/render/style/shadow.tsx\nfunction shadowsAsFilter(shadows) {\n  const filters = [];\n  if (shadows && shadows.length) {\n    const dropShadows = shadows.map((shadowItem) => {\n      return `drop-shadow(${shadowItem.x}px ${shadowItem.y}px ${shadowItem.blur}px ${shadowItem.color})`;\n    });\n    filters.push(...dropShadows);\n  }\n  return filters;\n}\nfunction collectTextShadowsForProps(props, style) {\n  if (!props.shadows || props.shadows.length === 0)\n    return;\n  const textShadow = props.shadows.map((shadow) => {\n    return `${shadow.x}px ${shadow.y}px ${shadow.blur}px ${shadow.color}`;\n  }).join(\", \");\n  if (!textShadow)\n    return;\n  style.textShadow = textShadow;\n}\nfunction collectBoxShadowsForProps(props, style) {\n  if (!props.shadows || props.shadows.length === 0)\n    return;\n  const boxShadow = props.shadows.map((shadowItem) => BoxShadow.toCSS(shadowItem)).join(\", \");\n  if (!boxShadow)\n    return;\n  style.boxShadow = boxShadow;\n}\nfunction shadowForShape(boxShadows, rect, shapeId, fillAlpha, strokeAlpha, strokeWidth, strokeClipId, svgStrokeAttributes) {\n  const definition = [];\n  let outsetElement = null;\n  let insetElement = null;\n  const needsStrokeClip = false;\n  const shadows = [];\n  const insetShadows = [];\n  const boxShadowsCount = boxShadows.length;\n  const svgShadowClass = \"svg-shadow\";\n  const svgShadowProps = RenderTarget.current() === RenderTarget.canvas ? { className: svgShadowClass } : {};\n  for (let i = 0, il = boxShadowsCount; i < il; i++) {\n    const shadow = boxShadows[i];\n    shadow.inset ? insetShadows.push(shadow) : shadows.push(shadow);\n  }\n  if (shadows.length > 0) {\n    shadows.reverse();\n    const outsideShadowId = shapeId.add(\"_shadow_out\");\n    const normalizedFrame = Rect.atOrigin(rect);\n    const shadowRects = [normalizedFrame];\n    for (let i = 0, il = shadows.length; i < il; i++) {\n      const shadow = shadows[i];\n      const shadowFrame = localShadowFrame(shadow, normalizedFrame, true);\n      if (shadowFrame === null) {\n        continue;\n      }\n      shadowRects.push(shadowFrame);\n    }\n    let maxBlur = 0;\n    const filterElements = [];\n    const mergeElements = [];\n    for (let i = 0, il = shadows.length; i < il; i++) {\n      const shadow = shadows[i];\n      const shadowElements = outerShadowElements(shapeId, shadow, i);\n      maxBlur = Math.max(maxBlur, shadow.blur);\n      filterElements.push(shadowElements.filterElements);\n      mergeElements.push(shadowElements.mergeElement);\n    }\n    let expandStrokeWidth = strokeWidth;\n    if (!isFiniteNumber(expandStrokeWidth))\n      expandStrokeWidth = 0;\n    let miter = svgStrokeAttributes.strokeMiterlimit;\n    if (!isFiniteNumber(miter))\n      miter = 4;\n    let shadowRect = Rect.merge(...shadowRects);\n    shadowRect = Rect.inflate(shadowRect, (expandStrokeWidth * miter / 2 + maxBlur) * 1.1);\n    const width = rect.width + (strokeWidth ? strokeWidth / 2 : 0.1);\n    const height = rect.height + (strokeWidth ? strokeWidth / 2 : 0.1);\n    const filterX = shadowRect.x / width * 100;\n    const filterY = shadowRect.y / height * 100;\n    const filterWidth = shadowRect.width / width * 100;\n    const filterHeight = shadowRect.height / height * 100;\n    definition.push(/* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"filter\", {\n      key: outsideShadowId.id,\n      id: outsideShadowId.id,\n      x: `${filterX.toFixed(1)}%`,\n      y: `${filterY.toFixed(1)}%`,\n      width: `${filterWidth.toFixed(1)}%`,\n      height: `${filterHeight.toFixed(1)}%`,\n      filterUnits: \"objectBoundingBox\",\n      ...svgShadowProps\n    }, filterElements, shadows.length > 1 ? /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"feMerge\", null, mergeElements) : null));\n    outsetElement = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"g\", {\n      filter: outsideShadowId.urlLink,\n      ...svgShadowProps\n    }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"use\", {\n      ...svgStrokeAttributes,\n      fill: \"black\",\n      fillOpacity: fillAlpha <= 0 ? 0 : 1,\n      stroke: \"black\",\n      strokeOpacity: strokeAlpha <= 0 ? 0 : 1,\n      strokeWidth: strokeAlpha > 0 ? strokeWidth : 0,\n      xlinkHref: shapeId.link,\n      clipPath: strokeClipId.urlLink\n    }));\n  }\n  if (insetShadows.length) {\n    insetShadows.reverse();\n    const insideShadowId = shapeId.add(\"_shadow_inside\");\n    const normalizedFrame = Rect.atOrigin(rect);\n    const shadowFrames = [normalizedFrame];\n    for (let i = 0, il = insetShadows.length; i < il; i++) {\n      const shadow = insetShadows[i];\n      const shadowFrame = localShadowFrame(shadow, normalizedFrame, true);\n      if (shadowFrame === null) {\n        continue;\n      }\n      shadowFrames.push(shadowFrame);\n    }\n    const shadowRect = Rect.merge(...shadowFrames);\n    const width = rect.width + (strokeWidth ? strokeWidth / 2 : 0.1);\n    const height = rect.height + (strokeWidth ? strokeWidth / 2 : 0.1);\n    const filterX = shadowRect.x / width * 100;\n    const filterY = shadowRect.y / height * 100;\n    const filterWidth = shadowRect.width / width * 100;\n    const filterHeight = shadowRect.height / height * 100;\n    const filterElements = [];\n    const mergeElements = [];\n    for (let i = 0, il = insetShadows.length; i < il; i++) {\n      const shadow = insetShadows[i];\n      const shadowElements = innerShadowElements(shapeId, shadow, i);\n      filterElements.push(shadowElements.filterElements);\n      mergeElements.push(shadowElements.mergeElement);\n    }\n    definition.push(/* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"filter\", {\n      key: insideShadowId.id,\n      id: insideShadowId.id,\n      x: `${filterX.toFixed(1)}%`,\n      y: `${filterY.toFixed(1)}%`,\n      width: `${filterWidth.toFixed(1)}%`,\n      height: `${filterHeight.toFixed(1)}%`,\n      filterUnits: \"objectBoundingBox\",\n      ...svgShadowProps\n    }, filterElements, insetShadows.length > 1 ? /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"feMerge\", null, mergeElements) : null));\n    let clipPath;\n    if (needsStrokeClip) {\n      clipPath = strokeClipId.urlLink;\n    }\n    insetElement = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"use\", {\n      fill: \"black\",\n      fillOpacity: \"1\",\n      filter: insideShadowId.urlLink,\n      xlinkHref: shapeId.link,\n      clipPath,\n      ...svgShadowProps\n    });\n  }\n  return { definition, outsetElement, insetElement, needsStrokeClip };\n}\nfunction outerShadowElements(shapeID, shadow, index) {\n  const shadowKey = shapeID.add(\"_outer_shadow\" + index);\n  const offsetResultId = shadowKey.add(\"offset\").id;\n  const blurResultId = shadowKey.add(\"blur\").id;\n  const matrixResultId = shadowKey.add(\"matrix\").id;\n  const filterElements = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(OuterShadowFilterElements, {\n    key: shadowKey.id + \"-filters\",\n    shadow,\n    blurId: blurResultId,\n    offsetId: offsetResultId,\n    matrixId: matrixResultId\n  });\n  const mergeElement = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"feMergeNode\", {\n    key: shadowKey.id + \"-merge\",\n    in: matrixResultId\n  });\n  return { filterElements, mergeElement };\n}\nvar OuterShadowFilterElements = (props) => {\n  const lookup = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CustomPropertiesContext);\n  const { shadow, blurId, offsetId, matrixId } = props;\n  let color2 = shadow.color;\n  const result = lookup(color2);\n  if (result) {\n    color2 = result;\n  }\n  const rgb = ConvertColor.toRgb(color2);\n  const r = roundedNumberString(rgb.r / 255, 3);\n  const g = roundedNumberString(rgb.g / 255, 3);\n  const b2 = roundedNumberString(rgb.b / 255, 3);\n  const matrixValues = `0 0 0 0 ${r}   0 0 0 0 ${g}   0 0 0 0 ${b2}  0 0 0 ${rgb.a} 0`;\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"feOffset\", {\n    dx: shadow.x,\n    dy: shadow.y,\n    in: \"SourceAlpha\",\n    result: offsetId\n  }), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"feGaussianBlur\", {\n    stdDeviation: shadow.blur / 2,\n    in: offsetId,\n    result: blurId\n  }), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"feColorMatrix\", {\n    colorInterpolationFilters: \"sRGB\",\n    values: matrixValues,\n    type: \"matrix\",\n    in: blurId,\n    result: matrixId\n  }));\n};\nfunction innerShadowElements(shapeID, shadow, index) {\n  const shadowKey = shapeID.add(\"_inside_shadow\" + index);\n  const blurId = shadowKey.add(\"blur\").id;\n  const offsetId = shadowKey.add(\"offset\").id;\n  const compositeId = shadowKey.add(\"composite\").id;\n  const matrixId = shadowKey.add(\"matrix\").id;\n  const filterElements = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(InnerShadowFilterElements, {\n    key: shadowKey.id + \"-filters\",\n    shadow,\n    blurId,\n    offsetId,\n    compositeId,\n    matrixId\n  });\n  const mergeElement = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"feMergeNode\", {\n    key: shadowKey.id + \"-merge\",\n    in: matrixId\n  });\n  return { filterElements, mergeElement };\n}\nvar InnerShadowFilterElements = (props) => {\n  const lookup = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CustomPropertiesContext);\n  const { shadow, blurId, offsetId, compositeId, matrixId } = props;\n  let color2 = shadow.color;\n  const result = lookup(color2);\n  if (result) {\n    color2 = result;\n  }\n  const rgb = ConvertColor.toRgb(color2);\n  const r = rgb.r / 255;\n  const g = rgb.g / 255;\n  const b2 = rgb.b / 255;\n  const matrixValues = `0 0 0 0 ${r}   0 0 0 0 ${g}   0 0 0 0 ${b2}  0 0 0 ${rgb.a} 0`;\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"feGaussianBlur\", {\n    stdDeviation: shadow.blur / 2,\n    in: \"SourceAlpha\",\n    result: blurId\n  }), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"feOffset\", {\n    dx: shadow.x,\n    dy: shadow.y,\n    in: blurId,\n    result: offsetId\n  }), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"feComposite\", {\n    in: offsetId,\n    in2: \"SourceAlpha\",\n    operator: \"arithmetic\",\n    k2: \"-1\",\n    k3: \"1\",\n    result: compositeId\n  }), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"feColorMatrix\", {\n    colorInterpolationFilters: \"sRGB\",\n    values: matrixValues,\n    type: \"matrix\",\n    in: compositeId,\n    result: matrixId\n  }));\n};\nfunction localShadowFrame(shadow, frame2, isSVG2) {\n  let growth = shadow.blur;\n  if (BoxShadow.is(shadow)) {\n    if (isSVG2 !== true) {\n      if (shadow.inset)\n        return null;\n      growth += shadow.spread;\n    }\n  }\n  let minX;\n  let maxX;\n  let minY;\n  let maxY;\n  if (isSVG2 === true) {\n    minX = -Math.abs(shadow.x) - growth;\n    maxX = Math.abs(shadow.x) + frame2.width + growth;\n    minY = -Math.abs(shadow.y) - growth;\n    maxY = Math.abs(shadow.y) + frame2.height + growth;\n  } else {\n    minX = shadow.x - growth;\n    maxX = shadow.x + frame2.width + growth;\n    minY = shadow.y - growth;\n    maxY = shadow.y + frame2.height + growth;\n  }\n  if (maxX <= minX || maxY <= minY)\n    return null;\n  return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };\n}\n\n// src/render/utils/filtersForNode.ts\nfunction collectLayerFilters(props, style) {\n  const filters = [];\n  if (isFiniteNumber(props.brightness)) {\n    filters.push(`brightness(${props.brightness / 100})`);\n  }\n  if (isFiniteNumber(props.contrast)) {\n    filters.push(`contrast(${props.contrast / 100})`);\n  }\n  if (isFiniteNumber(props.grayscale)) {\n    filters.push(`grayscale(${props.grayscale / 100})`);\n  }\n  if (isFiniteNumber(props.hueRotate)) {\n    filters.push(`hue-rotate(${props.hueRotate}deg)`);\n  }\n  if (isFiniteNumber(props.invert)) {\n    filters.push(`invert(${props.invert / 100})`);\n  }\n  if (isFiniteNumber(props.saturate)) {\n    filters.push(`saturate(${props.saturate / 100})`);\n  }\n  if (isFiniteNumber(props.sepia)) {\n    filters.push(`sepia(${props.sepia / 100})`);\n  }\n  if (isFiniteNumber(props.blur)) {\n    filters.push(`blur(${props.blur}px)`);\n  }\n  if (props.dropShadows) {\n    filters.push(...shadowsAsFilter(props.dropShadows));\n  }\n  if (filters.length === 0)\n    return;\n  style.filter = style.WebkitFilter = filters.join(\" \");\n}\nfunction collectBackgroundFilters(props, style) {\n  if (isFiniteNumber(props.backgroundBlur)) {\n    style.backdropFilter = style.WebkitBackdropFilter = `blur(${props.backgroundBlur}px)`;\n  }\n}\nfunction collectFiltersFromProps(props, style) {\n  collectBackgroundFilters(props, style);\n  collectLayerFilters(props, style);\n}\n\n// src/render/traits/TextColor.ts\nfunction collectTextColorFromProps(props, style) {\n  const { color: color2 } = props;\n  if (typeof color2 === \"string\") {\n    style.color = color2;\n  } else if (Color.isColorObject(color2)) {\n    style.color = color2.initialValue || Color.toRgbString(color2);\n  }\n}\n\n// src/render/style/collectVisualStyleFromProps.ts\nfunction collectVisualStyleFromProps(props, style, isTextNode = false) {\n  collectBackgroundFromProps(props, style);\n  collectRadiusFromProps(props, style);\n  collectFiltersFromProps(props, style);\n  collectBlendingFromProps(props, style);\n  collectOverflowFromProps(props, style);\n  collectOpacityFromProps(props, style);\n  collectTextColorFromProps(props, style);\n  if (isTextNode) {\n    collectTextShadowsForProps(props, style);\n  } else {\n    collectBoxShadowsForProps(props, style);\n  }\n}\n\n// src/render/traits/Transform.ts\nvar { getNumber } = Animatable;\nvar transformDefaults = {\n  z: 0,\n  rotation: 0,\n  rotationX: 0,\n  rotationY: 0,\n  rotationZ: 0,\n  scale: 1,\n  scaleX: 1,\n  scaleY: 1,\n  scaleZ: 1,\n  skew: 0,\n  skewX: 0,\n  skewY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  originZ: 0\n};\nfunction getRotation(rotation, rotate) {\n  if (typeof rotate === \"string\") {\n    rotate = parseFloat(rotate);\n  }\n  return isFiniteNumber(rotate) ? rotate : getNumber(rotation);\n}\nfunction collectTransformFromProps(props, rect, style) {\n  const motionStyle = style;\n  const x = typeof rect.x === \"number\" ? `${rect.x}px` : rect.x;\n  const y = typeof rect.y === \"number\" ? `${rect.y}px` : rect.y;\n  const z = getNumber(props.z);\n  const scaleZ = getNumber(props.scaleZ);\n  const originZ = getNumber(props.originZ);\n  const rotationZ = getRotation(props.rotationZ, resolveMotionValue(motionStyle.rotateZ));\n  const rotationX = getRotation(props.rotationX, resolveMotionValue(motionStyle.rotateX));\n  const rotationY = getRotation(props.rotationY, resolveMotionValue(motionStyle.rotateY));\n  const scale2 = getNumber(props.scale);\n  const scaleX = getNumber(props.scaleX);\n  const scaleY = getNumber(props.scaleY);\n  const skew = getNumber(props.skew);\n  const skewX = getNumber(props.skewX);\n  const skewY = getNumber(props.skewY);\n  const rotation = getRotation(props.rotation, resolveMotionValue(motionStyle.rotate));\n  const force3d = RenderEnvironment.target === RenderTarget.export;\n  if (force3d || z !== 0 || scaleZ !== 1 || originZ !== 0 || rotationZ !== 0 || rotationX !== 0 || rotationY !== 0) {\n    style.transform = `\n            ${`translate3d(${x}, ${y}, ${z}px)`}\n            scale3d(${scaleX * scale2}, ${scaleY * scale2}, ${scaleZ})\n            skew(${skew}deg,${skew}deg)\n            skewX(${skewX}deg)\n            skewY(${skewY}deg)\n            translateZ(${originZ}px)\n            rotateX(${rotationX}deg)\n            rotateY(${rotationY}deg)\n            rotateZ(${(rotation + rotationZ).toFixed(4)}deg)\n            translateZ(${-originZ}px)`;\n  } else {\n    style.transform = `\n            ${`translate(${x}, ${y})`}\n            scale(${scaleX * scale2}, ${scaleY * scale2})\n            skew(${skew}deg,${skew}deg)\n            skewX(${skewX}deg)\n            skewY(${skewY}deg)\n            rotate(${rotation.toFixed(4)}deg)`;\n  }\n  const transformOrigin = `${getNumber(props.originX) * 100}% ${getNumber(props.originY) * 100}%`;\n  style.transformOrigin = transformOrigin;\n  style.WebkitTransformOrigin = transformOrigin;\n}\n\n// src/render/presentation/Frame/DeprecatedFrame.tsx\nfunction cssBackgroundSize(size2) {\n  switch (size2) {\n    case \"fit\":\n      return \"contain\";\n    case \"stretch\":\n      return \"100% 100%\";\n    default:\n      return \"cover\";\n  }\n}\nfunction collectBackgroundImageFromProps(props, style) {\n  const image = backgroundImageFromProps(props);\n  if (image) {\n    style.backgroundImage = `url(\"${image.src}\")`;\n    style.backgroundSize = cssBackgroundSize(image.fit);\n    style.backgroundRepeat = \"no-repeat\";\n    style.backgroundPosition = \"center\";\n  }\n}\nfunction toPixelString(value) {\n  return isFiniteNumber(value) ? `${value}px` : value;\n}\nfunction applyLayoutProp(style, props, key6) {\n  if (props[key6] !== void 0) {\n    const value = Animatable.get(props[key6], void 0);\n    style[key6] = toPixelString(value);\n  }\n}\nvar _DeprecatedFrame = class extends Layer {\n  constructor() {\n    super(...arguments);\n    this.element = null;\n    this.imageDidChange = false;\n    this.state = {\n      size: null\n    };\n    this.updateStyle = () => {\n      if (!this.element) {\n        return;\n      }\n      Object.assign(this.element.style, this.getStyle());\n    };\n    this.setElement = (element) => {\n      this.element = element;\n    };\n    this.onPropsChange = (props) => {\n      const rect = _DeprecatedFrame.rect(Animatable.objectToValues(props.value));\n      if (this.state.size && isAnimatable2(this.state.size.width) && isAnimatable2(props.value.width)) {\n        this.state.size.width.set(rect.width);\n      }\n      if (this.state.size && isAnimatable2(this.state.size.height) && isAnimatable2(props.value.height)) {\n        this.state.size.height.set(rect.height);\n      }\n      this.updateStyle();\n    };\n    this.onSizeChange = () => {\n      this.updateStyle();\n    };\n  }\n  static rect(props) {\n    const constraintValues = ConstraintValues.fromProperties(props);\n    return ConstraintValues.toRect(constraintValues, props.parentSize || null, null, true);\n  }\n  get rect() {\n    return _DeprecatedFrame.rect(this.props);\n  }\n  static getDerivedStateFromProps(nextProps, prevState) {\n    const size2 = _DeprecatedFrame.updatedSize(nextProps, prevState);\n    const { target } = RenderEnvironment;\n    const nextBackgroundImageSrc = nextProps.background && BackgroundImage.isImageObject(nextProps.background) ? nextProps.background.src : null;\n    if (nextBackgroundImageSrc) {\n      return {\n        size: size2\n      };\n    }\n    if (prevState.size) {\n      if (target === RenderTarget.preview) {\n        return null;\n      }\n      if (prevState.size.width === size2.width && prevState.size.height === size2.height) {\n        return null;\n      }\n    }\n    return {\n      size: size2\n    };\n  }\n  static updatedSize(props, state) {\n    const rect = _DeprecatedFrame.rect(props);\n    let size2 = state.size;\n    const newSize = { width: rect.width, height: rect.height };\n    const { target } = RenderEnvironment;\n    if (!size2) {\n      if (target === RenderTarget.preview) {\n        size2 = ObservableObject(newSize, true);\n      } else {\n        size2 = newSize;\n      }\n    } else {\n      if (isAnimatable2(size2.width) && isAnimatable2(size2.height)) {\n        size2.width.set(newSize.width);\n        size2.height.set(newSize.height);\n      } else {\n        size2 = newSize;\n      }\n    }\n    return size2;\n  }\n  getStyle() {\n    const rect = this.rect;\n    const style = {\n      display: \"block\",\n      position: \"absolute\",\n      width: `${rect.width}px`,\n      height: `${rect.height}px`,\n      pointerEvents: void 0,\n      userSelect: \"none\"\n    };\n    let left = Animatable.get(this.props.left, void 0);\n    let top = Animatable.get(this.props.top, void 0);\n    Object.assign(style, this.props._initialStyle);\n    const hasParentSize = this.context.size !== ParentSizeState.Disabled;\n    const perspective = Animatable.get(this.props.perspective, void 0);\n    style.perspective = perspective;\n    style.WebkitPerspective = perspective;\n    let backfaceVisibility = void 0;\n    const backfaceVisible = Animatable.get(this.props.backfaceVisible, void 0);\n    if (backfaceVisible === true) {\n      backfaceVisibility = \"visible\";\n    } else if (backfaceVisible === false) {\n      backfaceVisibility = \"hidden\";\n    }\n    style.backfaceVisibility = backfaceVisibility;\n    style.WebkitBackfaceVisibility = backfaceVisibility;\n    const preserve3d = Animatable.get(this.props.preserve3d, void 0);\n    if (preserve3d === true) {\n      style.transformStyle = \"preserve-3d\";\n    } else if (preserve3d === false) {\n      style.transformStyle = \"flat\";\n    }\n    if (!hasParentSize) {\n      applyLayoutProp(style, this.props, \"right\");\n      applyLayoutProp(style, this.props, \"bottom\");\n      const width = Animatable.get(this.props.width, void 0);\n      const stringWidth = toPixelString(width);\n      const height = Animatable.get(this.props.height, void 0);\n      const stringHeight = toPixelString(height);\n      if (typeof left === \"string\" && left.endsWith(\"%\") && this.props.right === null) {\n        left = `calc(${left} - calc(${stringWidth}} / 2))`;\n        style.width = stringWidth;\n      }\n      if (typeof top === \"string\" && top.endsWith(\"%\") && this.props.bottom === null) {\n        top = `calc(${top} - calc(${stringHeight} / 2))`;\n        style.height = stringHeight;\n      }\n      if (top !== void 0 && style.bottom !== void 0) {\n        style.height = void 0;\n        top = toPixelString(Animatable.get(this.props.top, void 0));\n      } else {\n        style.height = stringHeight;\n      }\n      if (left !== void 0 && style.right !== void 0) {\n        style.width = void 0;\n        left = toPixelString(Animatable.get(this.props.left, void 0));\n      } else {\n        style.width = stringWidth;\n      }\n    }\n    const transformRect = { ...rect };\n    if (typeof left !== \"undefined\") {\n      transformRect.x = left;\n    }\n    if (typeof top !== \"undefined\") {\n      transformRect.y = top;\n    }\n    collectTransformFromProps(this.props, transformRect, style);\n    collectVisualStyleFromProps(this.props, style);\n    collectBackgroundImageFromProps(this.props, style);\n    Layer.applyWillChange(this.props, style, false);\n    if (this.props.style) {\n      Object.assign(style, this.props.style);\n    }\n    return style;\n  }\n  componentDidMount() {\n    const { target } = RenderEnvironment;\n    if (target === RenderTarget.preview) {\n      this.propsObserver = ObservableObject(this.props, true);\n      this.propsObserverCancel = ObservableObject.addObserver(this.propsObserver, this.onPropsChange);\n      if (this.props.parentSize && isAnimatable2(this.props.parentSize.width) && isAnimatable2(this.props.parentSize.height)) {\n        this.sizeObserver = ObservableObject(this.props.parentSize, true);\n        this.sizeObserverCancel = ObservableObject.addObserver(this.sizeObserver, this.onSizeChange);\n      }\n    }\n  }\n  componentDidUpdate() {\n    const { target } = RenderEnvironment;\n    this.propsObserverCancel && this.propsObserverCancel();\n    this.sizeObserverCancel && this.sizeObserverCancel();\n    if (target === RenderTarget.preview) {\n      this.propsObserver = ObservableObject(this.props, true);\n      this.propsObserverCancel = ObservableObject.addObserver(this.propsObserver, this.onPropsChange);\n      if (this.props.parentSize && isAnimatable2(this.props.parentSize.width) && isAnimatable2(this.props.parentSize.height)) {\n        this.sizeObserver = ObservableObject(this.props.parentSize, true);\n        this.sizeObserverCancel = ObservableObject.addObserver(this.sizeObserver, this.onSizeChange);\n      }\n    }\n  }\n  componentWillUnmount() {\n    this.propsObserverCancel && this.propsObserverCancel();\n    this.propsObserverCancel = void 0;\n    this.sizeObserverCancel && this.sizeObserverCancel();\n    this.sizeObserverCancel = void 0;\n  }\n  render() {\n    if (safeWindow[\"perf\"])\n      safeWindow[\"perf\"].nodeRender();\n    const { visible, id, className } = this.props;\n    if (!visible) {\n      return null;\n    }\n    const style = this.getStyle();\n    const rect = this.rect;\n    const parentSize = { width: rect.width, height: rect.height };\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n      id,\n      style,\n      ref: this.setElement,\n      className\n    }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ProvideParentSize, {\n      parentSize\n    }, this.layoutChildren()), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Border, {\n      ...this.props\n    }));\n  }\n  layoutChildren() {\n    let _forwardedOverrides = this.props._forwardedOverrides;\n    const extractions = this.props._overrideForwardingDescription;\n    if (extractions) {\n      let added = false;\n      _forwardedOverrides = {};\n      for (const key6 in extractions) {\n        added = true;\n        _forwardedOverrides[key6] = this.props[extractions[key6]];\n      }\n      if (!added) {\n        _forwardedOverrides = void 0;\n      }\n    }\n    let children = react__WEBPACK_IMPORTED_MODULE_0__.Children.map(this.props.children, (child) => {\n      if (isConstraintSupportingChild(child)) {\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(child, {\n          parentSize: this.state.size,\n          _forwardedOverrides\n        });\n      } else if (_forwardedOverrides && child) {\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(child, { _forwardedOverrides });\n      } else {\n        return child;\n      }\n    });\n    if (children && children.length === 1 && typeof children[0] === \"string\") {\n      children = [/* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Center, {\n        key: \"0\"\n      }, children)];\n    }\n    return children;\n  }\n};\nvar DeprecatedFrame = _DeprecatedFrame;\nDeprecatedFrame.supportsConstraints = true;\nDeprecatedFrame.defaultFrameSpecificProps = {\n  ...constraintDefaults,\n  ...transformDefaults,\n  opacity: 1,\n  background: Color(\"rgba(0, 170, 255, 0.3)\"),\n  visible: true,\n  borderWidth: 0,\n  borderColor: \"#222\",\n  borderStyle: \"solid\"\n};\nDeprecatedFrame.defaultProps = {\n  ...Layer.defaultProps,\n  ..._DeprecatedFrame.defaultFrameSpecificProps\n};\nDeprecatedFrame.contextType = ConstraintsContext;\nvar Center = (props) => {\n  const style = Object.assign({}, {\n    height: \"100%\",\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    fontFamily: \"Helvetica\"\n  }, props.style || {});\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n    style\n  }, props.children);\n};\n\n// src/render/presentation/Frame/isDeprecatedFrameProps.ts\nvar frameWithMotionPropsFields = [\n  \"_border\",\n  \"_constraints\",\n  \"animate\",\n  \"initial\",\n  \"variants\",\n  \"transition\",\n  \"inherit\",\n  \"center\",\n  \"initial\",\n  \"transformTemplate\",\n  \"transformValues\",\n  \"animate\",\n  \"variants\",\n  \"transition\",\n  \"onUpdate\",\n  \"onAnimationComplete\",\n  \"onPanSessionStart\",\n  \"onTapCancel\",\n  \"whileTap\",\n  \"whileHover\",\n  \"onHoverStart\",\n  \"onHoverEnd\",\n  \"drag\",\n  \"dragDirectionLock\",\n  \"dragPropagation\",\n  \"dragConstraints\",\n  \"dragElastic\",\n  \"dragMomentum\",\n  \"dragTransition\",\n  \"onDragStart\",\n  \"onDragEnd\",\n  \"onDrag\",\n  \"onDirectionLock\",\n  \"onDragTransitionEnd\",\n  \"x\",\n  \"y\",\n  \"rotate\",\n  \"rotateX\",\n  \"rotateY\",\n  \"rotateZ\",\n  \"position\",\n  \"border\",\n  \"borderRadius\",\n  \"shadow\",\n  \"size\"\n];\nvar deprecatedFramePropsFields = [\n  \"autoSize\",\n  \"aspectRatio\",\n  \"borderWidth\",\n  \"borderStyle\",\n  \"borderColor\",\n  \"centerX\",\n  \"centerY\"\n];\nfunction isDeprecatedFrameProps(props) {\n  let field;\n  for (const propKey in props) {\n    if (isAnimatable2(props[propKey]))\n      return true;\n  }\n  for (field of frameWithMotionPropsFields) {\n    if (props.hasOwnProperty(field))\n      return false;\n  }\n  for (field of deprecatedFramePropsFields) {\n    if (props.hasOwnProperty(field))\n      return true;\n  }\n  return false;\n}\n\n// src/render/presentation/Frame/index.tsx\nvar DeprecatedFrameWithEvents = WithEvents(DeprecatedFrame);\nvar Frame = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function Frame2(props, ref) {\n  const parentSize = useParentSize();\n  if (isDeprecatedFrameProps(props)) {\n    const currentParentSize = props.parentSize || deprecatedParentSize(parentSize);\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(DeprecatedFrameWithEvents, {\n      ...props,\n      parentSize: currentParentSize\n    });\n  }\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FrameWithMotion, {\n    ...props,\n    ref\n  });\n});\n\n// src/components/EmptyState.tsx\nfunction EmptyState({\n  title = \"\",\n  description = \"Click and drag the connector to any frame on the canvas \\u2192\",\n  children,\n  size: size2,\n  hide,\n  insideUserCodeComponent = false\n}) {\n  const { target } = RenderEnvironment;\n  const childCount = react__WEBPACK_IMPORTED_MODULE_0__.Children.count(children);\n  if (insideUserCodeComponent && childCount === 0) {\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FrameWithMotion, {\n      ...size2,\n      \"data-name\": \"placeholder\"\n    });\n  }\n  if (target !== RenderTarget.canvas)\n    return null;\n  if (hide)\n    return null;\n  if (childCount !== 0)\n    return null;\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FrameWithMotion, {\n    key: \"empty-state\",\n    className: \"framerInternalUI-canvasPlaceholder\",\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0,\n    style: { position: \"absolute\" }\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n    style: {\n      display: \"flex\",\n      alignItems: \"center\",\n      lineHeight: \"1.4\",\n      height: \"100%\",\n      width: \"100%\"\n    }\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n    style: {\n      display: \"flex\",\n      alignItems: \"center\",\n      justifyContent: \"center\",\n      flexDirection: \"column\",\n      width: \"100%\",\n      WebkitMaskImage: `linear-gradient(90deg, black, black calc(100% - 12px * ${scaleFactor}), transparent)`\n    }\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Title, null, title), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Description, null, description))));\n}\nvar scaleFactor = \"var(--framerInternalCanvas-canvasPlaceholderContentScaleFactor, 1)\";\nvar Title = ({ children }) => {\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", {\n    style: {\n      display: \"flex\",\n      flexDirection: \"column\",\n      textAlign: \"center\",\n      flexGrow: 1,\n      flexShrink: 0,\n      fontWeight: 600,\n      marginBottom: \"5px\"\n    }\n  }, children);\n};\nvar Description = ({ children }) => {\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"span\", {\n    style: {\n      display: \"flex\",\n      flexDirection: \"column\",\n      textAlign: \"center\",\n      flexGrow: 1,\n      flexShrink: 0,\n      fontWeight: 400,\n      maxWidth: \"200px\"\n    }\n  }, children);\n};\n\n// src/components/Scroll/useWheelScroll.ts\n\n\n// src/render/utils/debounce.ts\nfunction debounce(fn, time3) {\n  let timeout;\n  const debounced = (...args) => {\n    safeWindow.clearTimeout(timeout);\n    timeout = safeWindow.setTimeout(fn, time3, ...args);\n  };\n  const cancel = () => {\n    safeWindow.clearTimeout(timeout);\n  };\n  debounced.cancel = cancel;\n  return debounced;\n}\n\n// src/components/Scroll/useWheelScroll.ts\nfunction useWheelScroll(ref, {\n  enabled,\n  initial,\n  prev,\n  direction,\n  constraints,\n  offsetX,\n  offsetY,\n  onScrollStart,\n  onScroll,\n  onScrollEnd\n}) {\n  const isWheelScrollActive = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  const getPointData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const point = getPoint(offsetX, offsetY);\n    const data = {\n      point,\n      velocity: { x: offsetX.getVelocity(), y: offsetY.getVelocity() },\n      offset: { x: point.x - initial.x, y: point.y - initial.y },\n      delta: { x: point.x - prev.x, y: point.y - prev.y }\n    };\n    prev.x = point.x;\n    prev.y = point.y;\n    return data;\n  }, []);\n  let handler;\n  if (enabled) {\n    let clampX = function(v) {\n      return constraints.current === null ? v : clamp3(v, constraints.current.left, constraints.current.right);\n    }, clampY = function(v) {\n      return constraints.current === null ? v : clamp3(v, constraints.current.top, constraints.current.bottom);\n    }, updateX = function(delta2) {\n      offsetX.stop();\n      offsetX.set(clampX(offsetX.get() - delta2));\n    }, updateY = function(delta2) {\n      offsetY.stop();\n      offsetY.set(clampY(offsetY.get() - delta2));\n    };\n    const debouncedOnScrollEnd = debounce(() => {\n      onScrollEnd && onScrollEnd(getPointData());\n      isWheelScrollActive.current = false;\n    }, 200);\n    handler = (e) => {\n      e.preventDefault();\n      if (!isWheelScrollActive.current) {\n        const x = offsetX.get();\n        const y = offsetY.get();\n        initial.x = x;\n        initial.y = y;\n        prev.x = x;\n        prev.y = y;\n        onScrollStart && onScrollStart(getPointData());\n        isWheelScrollActive.current = true;\n      }\n      switch (direction) {\n        case \"horizontal\":\n          updateX(e.deltaX);\n          break;\n        case \"vertical\":\n          updateY(e.deltaY);\n          break;\n        default:\n          updateX(e.deltaX);\n          updateY(e.deltaY);\n      }\n      onScroll && onScroll(getPointData());\n      debouncedOnScrollEnd();\n    };\n  }\n  useDomEvent(ref, \"wheel\", handler, { passive: false });\n}\nfunction getPoint(x, y) {\n  return { x: x.get(), y: y.get() };\n}\n\n// src/components/Scroll/EmulatedScroll.tsx\nvar directionMap = {\n  horizontal: \"x\",\n  vertical: \"y\",\n  both: true\n};\nfunction convertScrollDirectionToDrag(scrollDirection) {\n  return scrollDirection ? directionMap[scrollDirection] : scrollDirection;\n}\nvar useUpdateChildSize = ({\n  dragDirection,\n  children,\n  fromCanvasComponent\n}) => {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return react__WEBPACK_IMPORTED_MODULE_0__.Children.map(children, (child) => {\n      if (child === null || typeof child !== \"object\" || typeof child.type === \"string\") {\n        return child;\n      }\n      const updatedSize = {};\n      switch (dragDirection) {\n        case \"vertical\":\n          updatedSize.width = \"100%\";\n          break;\n        case \"horizontal\":\n          updatedSize.height = \"100%\";\n          break;\n        default:\n          return child;\n      }\n      const update = fromCanvasComponent ? { style: Object.assign({}, child.props.style, updatedSize) } : updatedSize;\n      return (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(child, update);\n    });\n  }, [dragDirection, children]);\n};\nvar numberFromOptionalMotionValue = (value) => {\n  return typeof value === \"number\" ? value : value.get();\n};\nvar EmulatedScroll = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function EmulatedScroll2(props, forwardedRef) {\n  const {\n    direction = \"vertical\",\n    directionLock = false,\n    dragEnabled = true,\n    dragElastic,\n    dragMomentum,\n    dragTransition,\n    wheelEnabled = true,\n    contentOffsetX = 0,\n    contentOffsetY = 0,\n    contentWidth,\n    contentHeight,\n    onScrollStart,\n    onScroll,\n    onScrollEnd,\n    onDragStart,\n    onDrag,\n    onDragEnd,\n    onUpdate,\n    onDirectionLock,\n    style,\n    children,\n    scrollAnimate,\n    resetOffset,\n    overdragEnabled = true,\n    layoutId: specificLayoutId,\n    native,\n    ...containerProps\n  } = props;\n  const layoutId = useLayoutId2(props, { specificLayoutId, postfix: \"scroll\" });\n  const defaultX = useMotionValue(typeof contentOffsetX === \"number\" ? contentOffsetX : 0);\n  const defaultY = useMotionValue(typeof contentOffsetY === \"number\" ? contentOffsetY : 0);\n  const x = isMotionValue2(contentOffsetX) ? contentOffsetX : defaultX;\n  const y = isMotionValue2(contentOffsetY) ? contentOffsetY : defaultY;\n  const measuredConstraints = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const dragControls = useDragControls();\n  const isInTarget = useIsInCurrentNavigationTarget();\n  const wasInTargetRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n  injectComponentCSSRules();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    dragControls.updateConstraints();\n  });\n  function setMeasureDragConstraints(constraints) {\n    constraints = offsetToZero(constraints);\n    if (contentWidth !== void 0)\n      constraints.left = -contentWidth;\n    if (contentHeight !== void 0)\n      constraints.top = -contentHeight;\n    return measuredConstraints.current = constraints;\n  }\n  const { initial, prev } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    initial: { x: 0, y: 0 },\n    prev: { x: 0, y: 0 }\n  }).current;\n  const isPreview = RenderTarget.current() === RenderTarget.preview;\n  const containerFallbackRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const containerRef = forwardedRef || containerFallbackRef;\n  const contentRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const lastOffsetRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  function shouldResetScroll(inTarget) {\n    const hasEnteredTarget = inTarget && wasInTargetRef.current === false;\n    return resetOffset && hasEnteredTarget;\n  }\n  function measureAndUpdateScrollOffset() {\n    if (!contentRef.current || !containerRef.current)\n      return;\n    const mustReset = shouldResetScroll(isInTarget);\n    wasInTargetRef.current = isInTarget;\n    const previous = lastOffsetRef.current;\n    if (previous === null && contentOffsetX === void 0 && contentOffsetY === void 0)\n      return;\n    const shouldUpdateOffset = previous === null || !isMotionValue2(contentOffsetX) && contentOffsetX !== previous.offsetX || !isMotionValue2(contentOffsetY) && contentOffsetY !== previous.offsetY;\n    const currentMaxXOffset = contentRef.current.offsetWidth - containerRef.current.offsetWidth;\n    const currentMaxYOffset = contentRef.current.offsetHeight - containerRef.current.offsetHeight;\n    const hasSizeChanged = currentMaxXOffset !== (previous == null ? void 0 : previous.maxXOffset) || currentMaxYOffset !== (previous == null ? void 0 : previous.maxYOffset);\n    const hasScrollOffsetChanged = (previous == null ? void 0 : previous.x) !== x.get() || (previous == null ? void 0 : previous.y) !== y.get();\n    const shouldStayPinned = hasSizeChanged && !hasScrollOffsetChanged;\n    if (mustReset || shouldUpdateOffset || shouldStayPinned) {\n      const currentOffsetX = direction !== \"vertical\" ? numberFromOptionalMotionValue(contentOffsetX) : 0;\n      const currentOffsetY = direction !== \"horizontal\" ? numberFromOptionalMotionValue(contentOffsetY) : 0;\n      const nextXOffset = -Math.min(currentOffsetX, currentMaxXOffset);\n      const nextYOffset = -Math.min(currentOffsetY, currentMaxYOffset);\n      x.set(nextXOffset);\n      y.set(nextYOffset);\n      lastOffsetRef.current = {\n        maxXOffset: currentMaxXOffset,\n        maxYOffset: currentMaxYOffset,\n        offsetX: currentOffsetX,\n        offsetY: currentOffsetY,\n        x: nextXOffset,\n        y: nextYOffset\n      };\n    }\n  }\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (RenderTarget.current() !== RenderTarget.canvas)\n      return;\n    measureAndUpdateScrollOffset();\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (RenderTarget.current() === RenderTarget.canvas)\n      return;\n    measureAndUpdateScrollOffset();\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (shouldResetScroll(isInTarget))\n      measureAndUpdateScrollOffset();\n    if (isInTarget === false)\n      wasInTargetRef.current = false;\n  }, [isInTarget]);\n  const getLatestPoint = () => ({ x: x.get(), y: y.get() });\n  const resetInitialPoint = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const point = getLatestPoint();\n    initial.x = point.x;\n    initial.y = point.y;\n    prev.x = point.x;\n    prev.y = point.y;\n  }, []);\n  const getPointData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const point = getLatestPoint();\n    const data = {\n      point,\n      velocity: { x: x.getVelocity(), y: y.getVelocity() },\n      offset: { x: point.x - initial.x, y: point.y - initial.y },\n      delta: { x: point.x - prev.x, y: point.y - prev.y }\n    };\n    prev.x = point.x;\n    prev.y = point.y;\n    return data;\n  }, [x, y]);\n  const updateScrollListeners = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    onUpdate && onUpdate({ x: x.get(), y: y.get() });\n    onScroll && onScroll(getPointData());\n  }, [onScroll, onUpdate, getPointData, x, y]);\n  const scheduleUpdateScrollListeners = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    es_default.update(updateScrollListeners, false, true);\n  }, [updateScrollListeners]);\n  const onMotionDragStart = (event, info) => {\n    resetInitialPoint();\n    onDragStart && onDragStart(event, info);\n    onScrollStart && onScrollStart(info);\n  };\n  const onMotionDragTransitionEnd = () => onScrollEnd && onScrollEnd(getPointData());\n  const onWheelScrollStart = (info) => {\n    dragControls.updateConstraints();\n    onScrollStart == null ? void 0 : onScrollStart(info);\n  };\n  useWheelScroll(containerRef, {\n    enabled: wheelEnabled,\n    initial,\n    prev,\n    direction,\n    offsetX: x,\n    offsetY: y,\n    onScrollStart: onWheelScrollStart,\n    onScroll,\n    onScrollEnd,\n    constraints: measuredConstraints\n  });\n  const overdragX = useMotionValue(0);\n  const overdragY = useMotionValue(0);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    const setScrollX = (xValue) => {\n      const element = containerRef.current;\n      if (!(element instanceof HTMLDivElement))\n        return;\n      element.scrollLeft = -xValue;\n      const constraints = measuredConstraints.current;\n      if (constraints && overdragEnabled) {\n        let overdragXValue = 0;\n        if (xValue > constraints.right)\n          overdragXValue = xValue;\n        if (xValue < constraints.left)\n          overdragXValue = xValue - constraints.left;\n        overdragX.set(overdragXValue);\n      }\n      scheduleUpdateScrollListeners();\n    };\n    const currentX = x.get();\n    if (currentX !== 0)\n      setScrollX(currentX);\n    return x.onChange(setScrollX);\n  }, [x, overdragX, scheduleUpdateScrollListeners, overdragEnabled]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    const setScrollY = (yValue) => {\n      const element = containerRef.current;\n      if (!(element instanceof HTMLDivElement))\n        return;\n      element.scrollTop = -yValue;\n      const constraints = measuredConstraints.current;\n      if (constraints && overdragEnabled) {\n        let overdragYValue = 0;\n        if (yValue > constraints.bottom)\n          overdragYValue = yValue;\n        if (yValue < constraints.top)\n          overdragYValue = yValue - constraints.top;\n        overdragY.set(overdragYValue);\n      }\n      scheduleUpdateScrollListeners();\n    };\n    const currentY = y.get();\n    if (currentY !== 0)\n      setScrollY(currentY);\n    return y.onChange(setScrollY);\n  }, [y, overdragY, scheduleUpdateScrollListeners, overdragEnabled]);\n  const nativeOnScroll = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const element = containerRef.current;\n    if (!(element instanceof HTMLDivElement))\n      return;\n    const xDelta = Math.abs(x.get() + element.scrollLeft);\n    const yDelta = Math.abs(y.get() + element.scrollTop);\n    if (xDelta > 1)\n      x.set(-element.scrollLeft);\n    if (yDelta > 1)\n      y.set(-element.scrollTop);\n  }, [x, y]);\n  const isEmpty2 = react__WEBPACK_IMPORTED_MODULE_0__.Children.count(children) === 0;\n  const width = direction !== \"vertical\" && !isEmpty2 ? \"auto\" : \"100%\";\n  const height = direction !== \"horizontal\" && !isEmpty2 ? \"auto\" : \"100%\";\n  const size2 = !containerProps.__fromCanvasComponent ? {\n    width: containerProps.__fromCodeComponentNode ? \"100%\" : containerProps.width,\n    height: containerProps.__fromCodeComponentNode ? \"100%\" : containerProps.height\n  } : {};\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FrameWithMotion, {\n    \"data-framer-component-type\": \"Scroll\",\n    background: \"none\",\n    ...containerProps,\n    ...size2,\n    style: {\n      ...style,\n      willChange: isPreview ? \"transform\" : void 0,\n      overflow: \"hidden\"\n    },\n    onScroll: nativeOnScroll,\n    preserve3d: containerProps.preserve3d,\n    ref: containerRef,\n    layoutId,\n    onBeforeLayoutMeasure: measureAndUpdateScrollOffset\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FrameWithMotion, {\n    \"data-framer-component-type\": \"ScrollContentWrapper\",\n    animate: scrollAnimate,\n    drag: dragEnabled && convertScrollDirectionToDrag(direction),\n    dragDirectionLock: directionLock,\n    dragElastic,\n    dragMomentum,\n    dragTransition,\n    dragConstraints: containerRef,\n    dragControls,\n    onDragStart: onMotionDragStart,\n    onDrag,\n    onDragEnd,\n    onDragTransitionEnd: onMotionDragTransitionEnd,\n    onDirectionLock,\n    onMeasureDragConstraints: setMeasureDragConstraints,\n    width,\n    height,\n    _dragX: x,\n    _dragY: y,\n    position: \"relative\",\n    x: overdragEnabled ? overdragX : void 0,\n    y: overdragEnabled ? overdragY : void 0,\n    ref: contentRef,\n    style: {\n      display: isEmpty2 ? \"block\" : \"inline-block\",\n      willChange: isPreview ? \"transform\" : void 0,\n      backgroundColor: \"transparent\",\n      overflow: \"visible\",\n      minWidth: \"100%\",\n      minHeight: \"100%\"\n    },\n    preserve3d: containerProps.preserve3d\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(EmptyState, {\n    children,\n    size: {\n      width: isFiniteNumber(containerProps.width) ? containerProps.width : \"100%\",\n      height: isFiniteNumber(containerProps.height) ? containerProps.height : \"100%\"\n    },\n    insideUserCodeComponent: !containerProps.__fromCodeComponentNode,\n    title: \"Scroll\",\n    description: \"Click and drag the connector to any frame on the canvas \\u2192\"\n  }), useUpdateChildSize({\n    dragDirection: direction,\n    children,\n    fromCanvasComponent: containerProps.__fromCanvasComponent\n  })));\n});\nfunction offsetToZero({ top, left, right, bottom }) {\n  const width = right - left;\n  const height = bottom - top;\n  return {\n    top: -height,\n    left: -width,\n    right: 0,\n    bottom: 0\n  };\n}\n\n// src/components/Scroll/NativeScroll.tsx\n\n\n// src/modules/cx.ts\nfunction cx(...classNames) {\n  return classNames.filter(Boolean).join(\" \");\n}\n\n// src/components/utils/useEmulatedTouchScroll.ts\n\n\n// src/components/utils/animatePointWithInertia.ts\nvar AnimationPhase;\n(function(AnimationPhase2) {\n  AnimationPhase2[AnimationPhase2[\"None\"] = 0] = \"None\";\n  AnimationPhase2[AnimationPhase2[\"Running\"] = 1] = \"Running\";\n  AnimationPhase2[AnimationPhase2[\"Completed\"] = 2] = \"Completed\";\n  AnimationPhase2[AnimationPhase2[\"Cancelled\"] = 3] = \"Cancelled\";\n})(AnimationPhase || (AnimationPhase = {}));\nfunction isRunningAnimation(...phases) {\n  let runningAny = false;\n  let cancelledAny = false;\n  phases.forEach((phase) => {\n    runningAny = runningAny || phase === 1;\n    cancelledAny = cancelledAny || phase === 3;\n  });\n  return runningAny && !cancelledAny;\n}\nfunction didFinishAnimations(...phases) {\n  return phases.every((phase) => phase === 0 || phase === 2);\n}\nvar timeConstant = 400;\nfunction animatePointWithInertia({\n  from,\n  velocity,\n  onUpdate,\n  onComplete,\n  onStop\n}) {\n  const latest = from;\n  let animationPhaseX = 0;\n  let animationPhaseY = 0;\n  const animations2 = [];\n  const updateHandler = () => {\n    if (isRunningAnimation(animationPhaseX, animationPhaseY)) {\n      onUpdate(latest);\n    }\n  };\n  const completionHandler = () => {\n    if (didFinishAnimations(animationPhaseX, animationPhaseY)) {\n      onComplete();\n    }\n  };\n  if (velocity.x) {\n    animationPhaseX = 1;\n    animations2.push(inertia({\n      from: from.x,\n      velocity: -velocity.x,\n      timeConstant,\n      onUpdate: (value) => {\n        latest.x = value;\n        es_default.update(updateHandler, false, true);\n      },\n      onComplete: () => {\n        if (animationPhaseX !== 1) {\n          throw Error(\"animation x should be running when completing\");\n        }\n        animationPhaseX = 2;\n        completionHandler();\n      }\n    }));\n  }\n  if (velocity.y) {\n    animationPhaseY = 1;\n    animations2.push(inertia({\n      from: from.y,\n      velocity: -velocity.y,\n      timeConstant,\n      onUpdate: (value) => {\n        latest.y = value;\n        es_default.update(updateHandler, false, true);\n      },\n      onComplete: () => {\n        if (animationPhaseY !== 1) {\n          throw Error(\"animation y should be running when completing\");\n        }\n        animationPhaseY = 2;\n        completionHandler();\n      }\n    }));\n  }\n  if (!isRunningAnimation(animationPhaseX, animationPhaseY)) {\n    completionHandler();\n  }\n  return {\n    stop: () => {\n      if (!isRunningAnimation(animationPhaseX, animationPhaseY))\n        return;\n      animations2.forEach((animation) => animation.stop());\n      animationPhaseX = animationPhaseX === 1 ? 3 : animationPhaseX;\n      animationPhaseY = animationPhaseY === 1 ? 3 : animationPhaseY;\n      onStop();\n    }\n  };\n}\n\n// src/components/utils/useEmulatedTouchScroll.ts\nvar scrollThreshold = 3;\nvar isTouchDevice = isTouch();\nvar isSafariBrowser = isSafari();\nfunction getTouchAction(element) {\n  if (!(element instanceof HTMLElement))\n    return null;\n  return element.style.touchAction;\n}\nfunction canPanInDirection(element, direction) {\n  switch (direction) {\n    case \"horizontal\":\n      return getTouchAction(element) === \"pan-x\";\n    case \"vertical\":\n      return getTouchAction(element) === \"pan-y\";\n    default:\n      return false;\n  }\n}\nfunction isInteractiveElement(element) {\n  const tag = element.tagName.toLowerCase();\n  if (tag === \"input\")\n    return true;\n  if (tag === \"text\")\n    return true;\n  if (tag === \"textarea\")\n    return true;\n  return false;\n}\nfunction canStartScrollFromElement(element, direction) {\n  if (!(element instanceof Element))\n    return false;\n  if (isInteractiveElement(element))\n    return false;\n  if (element.hasAttribute(\"draggable\")) {\n    if (!canPanInDirection(element, direction)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getEventPoint(event) {\n  return {\n    x: event.pageX,\n    y: event.pageY\n  };\n}\nfunction setStyle(element, property, value) {\n  if (element == null ? void 0 : element.style) {\n    element.style[property] = value;\n  }\n}\nfunction getStyle(element, property) {\n  var _a;\n  return (_a = element == null ? void 0 : element.style) == null ? void 0 : _a[property];\n}\nvar TouchScrollPhase;\n(function(TouchScrollPhase2) {\n  TouchScrollPhase2[TouchScrollPhase2[\"Idle\"] = 0] = \"Idle\";\n  TouchScrollPhase2[TouchScrollPhase2[\"TouchDown\"] = 1] = \"TouchDown\";\n  TouchScrollPhase2[TouchScrollPhase2[\"Drag\"] = 2] = \"Drag\";\n  TouchScrollPhase2[TouchScrollPhase2[\"DragLocked\"] = 3] = \"DragLocked\";\n  TouchScrollPhase2[TouchScrollPhase2[\"DragAnimation\"] = 4] = \"DragAnimation\";\n  TouchScrollPhase2[TouchScrollPhase2[\"Interrupted\"] = 5] = \"Interrupted\";\n})(TouchScrollPhase || (TouchScrollPhase = {}));\nvar emptyObject = {};\nObject.freeze(emptyObject);\nfunction useEmulateTouchScroll(ref, direction, enabled) {\n  if (isTouchDevice)\n    return emptyObject;\n  if (RenderTarget.current() !== RenderTarget.preview)\n    return emptyObject;\n  const scrollAnimationControlsRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!ref.current)\n      return;\n    const element = ref.current;\n    let phase = 0;\n    let targets = null;\n    let downPoint = null;\n    let scrollOffsetStart = null;\n    let mouseMoveEvents = [];\n    function onMouseMove(event) {\n      var _a;\n      switch (phase) {\n        case 0:\n        case 4:\n        case 3:\n          return;\n      }\n      if (event.metaKey)\n        return;\n      const point = getEventPoint(event);\n      if (!downPoint)\n        return;\n      const offset = Point.subtract(point, downPoint);\n      if (phase === 1 || phase === 5) {\n        const deltaX = Math.abs(offset.x);\n        const deltaY = Math.abs(offset.y);\n        if ((deltaX > scrollThreshold || deltaY > scrollThreshold) && deltaX !== deltaY) {\n          const scrollDirection = deltaX > deltaY ? \"horizontal\" : \"vertical\";\n          const shouldIgnoreBecauseOfDirectionLock = direction === \"horizontal\" && scrollDirection === \"vertical\" || direction === \"vertical\" && scrollDirection === \"horizontal\";\n          if (shouldIgnoreBecauseOfDirectionLock) {\n            phase = 3;\n            return;\n          }\n          phase = 2;\n          targets == null ? void 0 : targets.forEach(([target]) => setStyle(target, \"pointerEvents\", \"none\"));\n        }\n      }\n      if (isSafariBrowser)\n        event.preventDefault();\n      if (phase !== 2)\n        return;\n      (_a = window.getSelection()) == null ? void 0 : _a.empty();\n      mouseMoveEvents = getRecentEvents([...mouseMoveEvents, event]);\n      if (scrollOffsetStart) {\n        if (direction !== \"vertical\")\n          element.scrollLeft = scrollOffsetStart.x - offset.x;\n        if (direction !== \"horizontal\")\n          element.scrollTop = scrollOffsetStart.y - offset.y;\n      }\n    }\n    function onMouseUp(event) {\n      window.removeEventListener(\"mousemove\", onMouseMove, false);\n      window.removeEventListener(\"mouseup\", onMouseUp);\n      if (phase === 2 && targets) {\n        targets.forEach(([target, originalPointerEventsValue]) => setStyle(target, \"pointerEvents\", originalPointerEventsValue || \"auto\"));\n      }\n      targets = null;\n      const velocity = calculateVelocity({ mouseMoveEvents, mouseUpEvent: event });\n      downPoint = null;\n      if (phase === 2) {\n        const shouldAnimateY = direction !== \"horizontal\" && velocity.y !== 0;\n        const shouldAnimateX = direction !== \"vertical\" && velocity.x !== 0;\n        if (!shouldAnimateY && !shouldAnimateX) {\n          phase = 0;\n          return;\n        }\n        phase = 4;\n        scrollAnimationControlsRef.current = animatePointWithInertia({\n          from: { x: element.scrollLeft, y: element.scrollTop },\n          velocity: {\n            x: shouldAnimateX ? velocity.x : 0,\n            y: shouldAnimateY ? velocity.y : 0\n          },\n          onUpdate: (position) => {\n            if (shouldAnimateX)\n              element.scrollLeft = position.x;\n            if (shouldAnimateY)\n              element.scrollTop = position.y;\n          },\n          onStop: () => {\n            if (phase !== 5) {\n              phase = 0;\n            }\n            scrollAnimationControlsRef.current = null;\n          },\n          onComplete: () => {\n            if (phase !== 4) {\n              throw Error(\"On animation completion we should still be in the animation phase\");\n            }\n            phase = 0;\n            scrollAnimationControlsRef.current = null;\n          }\n        });\n      } else {\n        phase = 0;\n      }\n    }\n    function onMouseWheel() {\n      var _a;\n      (_a = scrollAnimationControlsRef.current) == null ? void 0 : _a.stop();\n    }\n    function onMouseDown(event) {\n      var _a;\n      if (!enabled)\n        return;\n      if (event.metaKey)\n        return;\n      if (!canStartScrollFromElement(event.target, direction)) {\n        if (phase === 4) {\n          phase = 0;\n          (_a = scrollAnimationControlsRef.current) == null ? void 0 : _a.stop();\n        }\n        return;\n      }\n      const previousPhase = phase;\n      phase = previousPhase === 4 ? 5 : 1;\n      downPoint = getEventPoint(event);\n      targets = document.elementsFromPoint(downPoint.x, downPoint.y).filter((targetEl) => targetEl instanceof HTMLElement || targetEl instanceof SVGElement).map((targetEl) => [targetEl, getStyle(targetEl, \"pointerEvents\")]);\n      scrollOffsetStart = { x: element.scrollLeft, y: element.scrollTop };\n      mouseMoveEvents = [];\n      if (scrollAnimationControlsRef.current) {\n        if (previousPhase !== 4) {\n          throw Error(\"When stopping a drag animation we need to be animating\");\n        }\n        scrollAnimationControlsRef.current.stop();\n      }\n      window.addEventListener(\"mousemove\", onMouseMove);\n      window.addEventListener(\"mouseup\", onMouseUp);\n      element.addEventListener(\"mousewheel\", onMouseWheel);\n    }\n    element.addEventListener(\"mousedown\", onMouseDown);\n    return () => {\n      var _a;\n      element.removeEventListener(\"mousedown\", onMouseDown);\n      element.removeEventListener(\"mousewheel\", onMouseWheel);\n      window.removeEventListener(\"mousemove\", onMouseMove);\n      window.removeEventListener(\"mouseup\", onMouseUp);\n      phase = 5;\n      (_a = scrollAnimationControlsRef.current) == null ? void 0 : _a.stop();\n    };\n  }, [ref, direction, enabled]);\n  return react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(() => {\n    return {\n      cancelEmulatedTouchScrollAnimation: () => {\n        var _a;\n        (_a = scrollAnimationControlsRef.current) == null ? void 0 : _a.stop();\n      }\n    };\n  }, []);\n}\nvar timeDelta = 4 / 60 * 1e3;\nfunction getRecentEvents(events2) {\n  const currentTime = new CustomEvent(\"getTime\").timeStamp;\n  const maxAge = currentTime - timeDelta;\n  return events2.filter((event) => event.timeStamp > maxAge);\n}\nvar zeroPoint = { x: 0, y: 0 };\nfunction calculateVelocity({\n  mouseMoveEvents,\n  mouseUpEvent\n}) {\n  const recentMouseMoveEvents = getRecentEvents(mouseMoveEvents);\n  const oldestMouseMoveEvent = recentMouseMoveEvents[0];\n  if (!oldestMouseMoveEvent)\n    return zeroPoint;\n  const deltaX = mouseUpEvent.clientX - oldestMouseMoveEvent.clientX;\n  const deltaY = mouseUpEvent.clientY - oldestMouseMoveEvent.clientY;\n  const time3 = mouseUpEvent.timeStamp - oldestMouseMoveEvent.timeStamp;\n  if (time3 === 0)\n    return zeroPoint;\n  return {\n    x: deltaX / time3 * 1e3,\n    y: deltaY / time3 * 1e3\n  };\n}\n\n// src/components/NavigationContainerContext.tsx\n\n\nvar NavigationContainerContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(true);\nfunction useIsInCurrentNavigationTarget() {\n  const isInCurrentNavigationTarget = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NavigationContainerContext);\n  return isInCurrentNavigationTarget;\n}\n\n// src/components/utils/useUpdateScrollOffset.ts\n\nfunction useUpdateScrollOffset(ref, side, offset, cancelEmulatedTouchScrollAnimation) {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (isMotionValue2(offset)) {\n      const updateScrollLeft = () => {\n        cancelEmulatedTouchScrollAnimation == null ? void 0 : cancelEmulatedTouchScrollAnimation();\n        const element = ref.current;\n        if (element)\n          element[side] = Math.abs(offset.get());\n      };\n      updateScrollLeft();\n      return offset.onChange(updateScrollLeft);\n    } else if (isFiniteNumber(offset)) {\n      const element = ref.current;\n      if (!element)\n        return;\n      cancelEmulatedTouchScrollAnimation == null ? void 0 : cancelEmulatedTouchScrollAnimation();\n      element[side] = Math.abs(offset);\n    }\n  }, [offset]);\n}\n\n// src/components/Scroll/NativeScroll.tsx\nvar NativeScroll = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function NativeScroll2(props, forwardedRef) {\n  const {\n    direction = \"vertical\",\n    scrollBarVisible = false,\n    dragEnabled = true,\n    contentOffsetX = 0,\n    contentOffsetY = 0,\n    contentWidth,\n    contentHeight,\n    children,\n    resetOffset,\n    onScroll,\n    className,\n    directionLock = false,\n    wheelEnabled = true,\n    scrollAnimate,\n    dragTransition,\n    dragMomentum,\n    dragElastic,\n    overdragEnabled = true,\n    onScrollStart,\n    onScrollEnd,\n    onDragStart,\n    onDrag,\n    onDragEnd,\n    onUpdate,\n    onDirectionLock,\n    layoutId: specificLayoutId,\n    native,\n    ...containerProps\n  } = props;\n  const layoutId = useLayoutId2(props, { specificLayoutId, postfix: \"scroll\" });\n  const fallbackRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const ref = forwardedRef || fallbackRef;\n  const { cancelEmulatedTouchScrollAnimation } = useEmulateTouchScroll(ref, direction, dragEnabled);\n  injectComponentCSSRules();\n  const isInTarget = useIsInCurrentNavigationTarget();\n  const previousIsInTargetRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(isInTarget);\n  const updateScrollOffsetHandler = () => {\n    if (!resetOffset)\n      return;\n    const previousIsTarget = previousIsInTargetRef.current;\n    previousIsInTargetRef.current = isInTarget;\n    const shouldResetOffset = isInTarget && !previousIsTarget;\n    if (!shouldResetOffset)\n      return;\n    const element = ref.current;\n    if (!element)\n      return;\n    if (direction !== \"vertical\") {\n      cancelEmulatedTouchScrollAnimation == null ? void 0 : cancelEmulatedTouchScrollAnimation();\n      element.scrollLeft = Math.abs(isMotionValue2(contentOffsetX) ? contentOffsetX.get() : contentOffsetX);\n    }\n    if (direction !== \"horizontal\") {\n      cancelEmulatedTouchScrollAnimation == null ? void 0 : cancelEmulatedTouchScrollAnimation();\n      element.scrollTop = Math.abs(isMotionValue2(contentOffsetY) ? contentOffsetY.get() : contentOffsetY);\n    }\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(updateScrollOffsetHandler, [isInTarget]);\n  useUpdateScrollOffset(ref, \"scrollLeft\", contentOffsetX, cancelEmulatedTouchScrollAnimation);\n  useUpdateScrollOffset(ref, \"scrollTop\", contentOffsetY, cancelEmulatedTouchScrollAnimation);\n  const size2 = !containerProps.__fromCanvasComponent ? {\n    width: containerProps.__fromCodeComponentNode ? \"100%\" : containerProps.width,\n    height: containerProps.__fromCodeComponentNode ? \"100%\" : containerProps.height\n  } : {};\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FrameWithMotion, {\n    ref,\n    \"data-framer-component-type\": \"NativeScroll\",\n    background: \"none\",\n    ...containerProps,\n    ...size2,\n    onScroll,\n    layoutId,\n    onBeforeLayoutMeasure: updateScrollOffsetHandler,\n    className: cx(className, `direction-${direction}`, !scrollBarVisible && \"scrollbar-hidden\")\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(EmptyState, {\n    children,\n    size: {\n      width: isFiniteNumber(containerProps.width) ? containerProps.width : \"100%\",\n      height: isFiniteNumber(containerProps.height) ? containerProps.height : \"100%\"\n    },\n    insideUserCodeComponent: !containerProps.__fromCodeComponentNode,\n    title: \"Scroll\",\n    description: \"Click and drag the connector to any frame on the canvas \\u2192\"\n  }), children);\n});\n\n// src/components/Scroll/Scroll.tsx\nvar Scroll = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function Scroll2(props, forwardedRef) {\n  if (props.native) {\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(NativeScroll, {\n      ref: forwardedRef,\n      ...props\n    });\n  } else {\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(EmulatedScroll, {\n      ref: forwardedRef,\n      ...props\n    });\n  }\n});\naddPropertyControls(Scroll, {\n  native: {\n    type: ControlType.Boolean,\n    defaultValue: false\n  },\n  direction: {\n    type: ControlType.SegmentedEnum,\n    title: \"Direction\",\n    options: [\"vertical\", \"horizontal\", \"both\"],\n    defaultValue: \"vertical\"\n  },\n  contentOffsetX: {\n    type: ControlType.Number,\n    title: \"Offset X\",\n    defaultValue: 0,\n    min: 0,\n    step: 10,\n    displayStepper: true,\n    hidden: ({ direction }) => direction === \"vertical\"\n  },\n  contentOffsetY: {\n    type: ControlType.Number,\n    title: \"Offset Y\",\n    defaultValue: 0,\n    min: 0,\n    step: 10,\n    displayStepper: true,\n    hidden: ({ direction }) => direction === \"horizontal\"\n  },\n  directionLock: {\n    type: ControlType.Boolean,\n    title: \"Lock\",\n    enabledTitle: \"1 Axis\",\n    disabledTitle: \"Off\",\n    defaultValue: true,\n    hidden: ({ native }) => native === true\n  },\n  dragEnabled: {\n    type: ControlType.Boolean,\n    title: \"Drag\",\n    enabledTitle: \"On\",\n    disabledTitle: \"Off\",\n    defaultValue: true\n  },\n  overdragEnabled: {\n    type: ControlType.Boolean,\n    title: \"Overdrag\",\n    enabledTitle: \"On\",\n    disabledTitle: \"Off\",\n    defaultValue: true,\n    hidden: ({ native }) => native === true\n  },\n  wheelEnabled: {\n    type: ControlType.Boolean,\n    title: \"Wheel\",\n    enabledTitle: \"On\",\n    disabledTitle: \"Off\",\n    defaultValue: true,\n    hidden: ({ native }) => native === true\n  },\n  scrollBarVisible: {\n    type: ControlType.Boolean,\n    title: \"Scroll Bar\",\n    enabledTitle: \"Visible\",\n    disabledTitle: \"Hidden\",\n    defaultValue: false,\n    hidden: ({ native }) => native === false\n  },\n  resetOffset: {\n    type: ControlType.Boolean,\n    title: \"Reset\",\n    enabledTitle: \"True\",\n    disabledTitle: \"False\",\n    defaultValue: false\n  }\n});\nScroll.supportsConstraints = true;\n\n// src/components/Draggable.ts\nvar Draggable = WithDragging(DeprecatedFrameWithEvents);\n\n// src/components/Scroll/DeprecatedScroll.tsx\n\n\n// src/components/utils/RectProvider.ts\nfunction isRectProviding(c2) {\n  return \"rect\" in c2 && c2.rect instanceof Function;\n}\n\n// src/utils/observable.ts\nfunction getObservableNumber(value, defaultValue = 0) {\n  if (!value) {\n    return defaultValue;\n  }\n  if (isAnimatable2(value)) {\n    return value.get();\n  }\n  return value;\n}\n\n// src/components/Scroll/DeprecatedScroll.tsx\nvar _DeprecatedScroll = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  wrapHandlers(dragHandler, scrollHandler) {\n    if (!scrollHandler) {\n      return dragHandler;\n    }\n    return (event, draggable) => {\n      if (dragHandler) {\n        dragHandler(event, draggable);\n      }\n      scrollHandler(event, this);\n    };\n  }\n  render() {\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ConsumeParentSize, null, ({ size: newParentSize }) => {\n      const parentSize = deprecatedParentSize(newParentSize);\n      const frameProps = Object.assign({}, this.props, {\n        parentSize\n      });\n      Object.keys(_DeprecatedScroll.scrollProps).map((key6) => {\n        delete frameProps[key6];\n      });\n      if (!this.props.children) {\n        return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(DeprecatedFrame, {\n          ...frameProps\n        }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Draggable, {\n          width: frameProps.width,\n          height: frameProps.height\n        }));\n      }\n      const contentSize = { top: 0, left: 0, bottom: 0, right: 0 };\n      const { width, height } = DeprecatedFrame.rect(frameProps);\n      const children = react__WEBPACK_IMPORTED_MODULE_0__.Children.map(this.props.children, (child) => {\n        if (child === null || typeof child !== \"object\" || typeof child.type === \"string\") {\n          return child;\n        }\n        const type = child.type;\n        if (isRectProviding(type)) {\n          const frame2 = type.rect(child.props, parentSize);\n          if (frame2) {\n            contentSize.top = Math.min(Rect.minY(frame2), contentSize.top);\n            contentSize.left = Math.min(Rect.minX(frame2), contentSize.left);\n            contentSize.bottom = Math.max(Rect.maxY(frame2), contentSize.bottom);\n            contentSize.right = Math.max(Rect.maxX(frame2), contentSize.right);\n          }\n        }\n        const update = {};\n        if (this.props.direction === \"vertical\") {\n          update.width = width;\n        } else if (this.props.direction === \"horizontal\") {\n          update.height = height;\n        }\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(child, update);\n      });\n      const {\n        onScrollStart,\n        onScroll,\n        onScrollEnd,\n        onScrollSessionStart,\n        onScrollSessionEnd\n      } = this.props;\n      const w = getObservableNumber(width);\n      const h = getObservableNumber(height);\n      const contentW = Math.max(contentSize.right, w);\n      const contentH = Math.max(contentSize.bottom, h);\n      const x = Math.min(0, w - contentW);\n      const y = Math.min(0, h - contentH);\n      const constraints = {\n        x,\n        y,\n        width: contentW + contentW - w,\n        height: contentH + contentH - h\n      };\n      const draggableProps = {};\n      draggableProps.enabled = this.props.draggingEnabled;\n      draggableProps.background = \"none\";\n      draggableProps.width = contentW;\n      draggableProps.height = contentH;\n      draggableProps.constraints = constraints;\n      draggableProps.onMove = this.props.onMove;\n      draggableProps.onDragSessionStart = this.wrapHandlers(this.props.onDragSessionStart, onScrollSessionStart);\n      draggableProps.onDragSessionMove = this.props.onDragSessionMove;\n      draggableProps.onDragSessionEnd = this.wrapHandlers(this.props.onDragSessionEnd, onScrollSessionEnd);\n      draggableProps.onDragAnimationStart = this.props.onDragAnimationStart;\n      draggableProps.onDragAnimationEnd = this.props.onDragAnimationEnd;\n      draggableProps.onDragDidMove = this.wrapHandlers(this.props.onDragDidMove, onScroll);\n      draggableProps.onDragDirectionLockStart = this.props.onDragDirectionLockStart;\n      draggableProps.onDragStart = this.wrapHandlers(this.props.onDragStart, onScrollStart);\n      draggableProps.onDragEnd = this.wrapHandlers(this.props.onDragEnd, onScrollEnd);\n      draggableProps.onDragWillMove = this.props.onDragWillMove;\n      draggableProps.horizontal = this.props.direction !== \"vertical\";\n      draggableProps.vertical = this.props.direction !== \"horizontal\";\n      draggableProps.directionLock = this.props.directionLock;\n      draggableProps.mouseWheel = true;\n      draggableProps.left = this.props.contentOffsetX;\n      draggableProps.top = this.props.contentOffsetY;\n      draggableProps.preserve3d = this.props.preserve3d;\n      return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(DeprecatedFrame, {\n        ...frameProps\n      }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Draggable, {\n        ...draggableProps\n      }, children), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(EmptyState, {\n        children: this.props.children,\n        size: { width: w, height: h },\n        title: \"Connect to scrollable area\"\n      }));\n    });\n  }\n};\nvar DeprecatedScroll = _DeprecatedScroll;\nDeprecatedScroll.supportsConstraints = true;\nDeprecatedScroll.scrollProps = {\n  draggingEnabled: true,\n  direction: \"vertical\",\n  directionLock: true,\n  mouseWheel: true,\n  contentOffsetX: null,\n  contentOffsetY: null\n};\nDeprecatedScroll.defaultProps = Object.assign({}, DeprecatedFrame.defaultProps, _DeprecatedScroll.scrollProps, {\n  overflow: \"visible\",\n  background: \"none\",\n  width: \"100%\",\n  height: \"100%\"\n});\nDeprecatedScroll.propertyControls = {\n  direction: {\n    type: ControlType.SegmentedEnum,\n    title: \"Direction\",\n    options: [\"vertical\", \"horizontal\", \"both\"]\n  },\n  directionLock: {\n    type: ControlType.Boolean,\n    title: \"Lock\",\n    enabledTitle: \"1 Axis\",\n    disabledTitle: \"Off\",\n    hidden(props) {\n      return props.direction !== \"both\";\n    }\n  }\n};\n\n// src/components/Screen.tsx\n\n\n// src/events/recognizer/GestureRecognizer.ts\nvar State3;\n(function(State4) {\n  State4[State4[\"Possible\"] = 2] = \"Possible\";\n  State4[State4[\"Began\"] = 4] = \"Began\";\n  State4[State4[\"Changed\"] = 8] = \"Changed\";\n  State4[State4[\"Ended\"] = 16] = \"Ended\";\n  State4[State4[\"Failed\"] = 32] = \"Failed\";\n  State4[State4[\"Cancelled\"] = 64] = \"Cancelled\";\n  State4[State4[\"Recognized\"] = 128] = \"Recognized\";\n})(State3 || (State3 = {}));\nfunction stateName(state) {\n  switch (state) {\n    case 2:\n      return \"Possible\";\n    case 4:\n      return \"Began\";\n    case 8:\n      return \"Changed\";\n    case 16:\n      return \"Ended\";\n    case 32:\n      return \"Failed\";\n    case 64:\n      return \"Cancelled\";\n    case 128:\n      return \"Recognized\";\n    default:\n      return \"Unknown\";\n  }\n}\nfunction containsBitmask(value, bitmask) {\n  return (value & bitmask) !== 0;\n}\nvar GestureRecognizer = class {\n  constructor() {\n    this._state = 2;\n    this.preventers = [];\n  }\n  get state() {\n    return this._state;\n  }\n  setState(state) {\n    this._state = state;\n  }\n  get isPrevented() {\n    let prevented = false;\n    for (const recognizer of this.preventers) {\n      if (recognizer.state & (4 | 8 | 16)) {\n        prevented = true;\n        break;\n      }\n    }\n    return prevented;\n  }\n  canBePreventedBy(recognizer) {\n    this.preventers.push(recognizer);\n  }\n  hasState(bitmask) {\n    return containsBitmask(this.state, bitmask);\n  }\n  stateSwitch(newState) {\n    let allowedStates;\n    switch (this.state) {\n      case 2:\n        allowedStates = 4 | 128 | 32;\n        break;\n      case 4:\n        allowedStates = 8 | 64 | 16;\n        break;\n      case 8:\n        allowedStates = 8 | 64 | 16;\n        break;\n      case 128:\n      case 16:\n      case 64:\n      case 32:\n        allowedStates = 2;\n        break;\n      default:\n        allowedStates = 0;\n    }\n    if (!containsBitmask(newState, allowedStates)) {\n      console.warn(`Unallowed state change from ${stateName(this.state)} to ${stateName(newState)}`);\n      return;\n    }\n    this.setState(newState);\n  }\n  cancel() {\n    if (this.hasState(4 | 8)) {\n      this.setState(64);\n    }\n    this.reset();\n  }\n  reset() {\n    if (!this.hasState(2)) {\n      this.stateSwitch(2);\n    }\n  }\n};\n\n// src/events/recognizer/PanGestureRecognizer.ts\nvar PanGestureRecognizer = class extends GestureRecognizer {\n  constructor() {\n    super(...arguments);\n    this.eventType = \"pan\";\n  }\n  pointerSessionBegan(session, event) {\n    this.recognize(session, event);\n  }\n  pointerSessionMoved(session, event) {\n    this.recognize(session, event);\n  }\n  pointerSessionEnded(session, event) {\n    this.panend(event);\n  }\n  recognize(session, event) {\n    if (Math.abs(event.delta.x) > 0 || Math.abs(event.delta.y) > 0) {\n      if (this.startEvent) {\n        this.pan(event);\n      } else {\n        this.panstart(event);\n      }\n    }\n  }\n  reset() {\n    this.startEvent = null;\n    super.reset();\n  }\n  panstart(event) {\n    if (!this.hasState(State3.Possible) || event.isLeftMouseClick !== void 0 && !event.isLeftMouseClick) {\n      return;\n    }\n    this.stateSwitch(State3.Began);\n    this.startEvent = event;\n    if (this.handler && this.startEvent.target) {\n      this.handler.gestureBegan(this.eventType, event, this.startEvent.target);\n    }\n  }\n  pan(event) {\n    if (!this.hasState(State3.Began | State3.Changed)) {\n      return;\n    }\n    if (!this.startEvent) {\n      return;\n    }\n    this.stateSwitch(State3.Changed);\n    if (this.handler && this.startEvent.target) {\n      this.handler.gestureChanged(this.eventType, event, this.startEvent.target);\n    }\n  }\n  panend(event) {\n    if (!this.hasState(State3.Began | State3.Changed)) {\n      return;\n    }\n    if (!this.startEvent) {\n      return;\n    }\n    this.stateSwitch(State3.Ended);\n    if (this.handler && this.startEvent.target) {\n      this.handler.gestureEnded(this.eventType, event, this.startEvent.target);\n    }\n  }\n};\n\n// src/events/recognizer/TapGestureRecognizer.ts\nvar TapGestureRecognizer = class extends GestureRecognizer {\n  constructor() {\n    super(...arguments);\n    this.eventType = \"tap\";\n  }\n  pointerSessionBegan(session, event) {\n    if (this.handler && (event.isLeftMouseClick === void 0 || event.isLeftMouseClick)) {\n      this.handler.gestureBegan(this.eventType, event, null);\n    }\n  }\n  pointerSessionMoved(session, event) {\n  }\n  pointerSessionEnded(session, event) {\n    if (this.isPrevented) {\n      this.stateSwitch(State3.Failed);\n    } else if (!session.startEvent || session.startEvent.target === event.target) {\n      this.stateSwitch(State3.Recognized);\n      if (this.handler) {\n        this.handler.gestureChanged(this.eventType, event, null);\n      }\n    } else {\n      this.stateSwitch(State3.Failed);\n    }\n    if (this.handler) {\n      this.handler.gestureEnded(this.eventType, event, null);\n    }\n  }\n};\n\n// src/events/recognizer/MouseWheelGestureRecognizer.ts\nvar MouseWheelGestureRecognizer = class extends GestureRecognizer {\n  constructor() {\n    super(...arguments);\n    this.eventType = \"mousewheel\";\n    this.onMouseWheelEnd = debounce((event) => {\n      if (this.handler && this.startEvent) {\n        this.stateSwitch(State3.Ended);\n        this.handler.gestureEnded(this.eventType, event, this.startEvent.target);\n        this.startEvent = null;\n        this.reset();\n      }\n    }, 300);\n  }\n  pointerSessionBegan(session, event) {\n  }\n  pointerSessionMoved(session, event) {\n  }\n  pointerSessionEnded(session, event) {\n  }\n  mouseWheel(session, event) {\n    if (!this.handler)\n      return;\n    if (this.hasState(State3.Possible)) {\n      this.startEvent = event;\n      this.stateSwitch(State3.Began);\n      this.handler.gestureBegan(this.eventType, event, this.startEvent.target);\n      return;\n    }\n    if (this.hasState(State3.Began | State3.Changed) && this.startEvent) {\n      this.stateSwitch(State3.Changed);\n      this.handler.gestureChanged(this.eventType, event, this.startEvent.target);\n    }\n    this.onMouseWheelEnd(event);\n  }\n};\n\n// src/events/FramerEventSession.ts\nvar FramerEventSession = class {\n  constructor(dispatcher, customOrigin) {\n    this.events = [];\n    this.recognizers = [];\n    this.mouseWheelRecognizer = new MouseWheelGestureRecognizer();\n    this.dispatcher = dispatcher;\n    if (customOrigin) {\n      this.originElement = customOrigin;\n    } else {\n      this.originElement = document.body;\n    }\n    const pan = new PanGestureRecognizer();\n    const tap = new TapGestureRecognizer();\n    pan.handler = this;\n    tap.handler = this;\n    this.mouseWheelRecognizer.handler = this;\n    this.recognizers = [tap, pan];\n  }\n  get isStarted() {\n    return this.events.length !== 0;\n  }\n  get startEvent() {\n    if (this.isStarted) {\n      return this.events[0];\n    } else {\n      return null;\n    }\n  }\n  get lastEvent() {\n    if (this.events.length > 0) {\n      return this.events[this.events.length - 1];\n    } else {\n      return null;\n    }\n  }\n  processEvent(event) {\n    this.events.push(event);\n    return event;\n  }\n  pointerDown(event) {\n    if (this.isStarted) {\n      return;\n    }\n    this.processEvent(event);\n    this.recognizers.map((r) => {\n      r.cancel();\n      r.pointerSessionBegan(this, event);\n    });\n  }\n  pointerMove(event) {\n    if (!this.isStarted) {\n      return;\n    }\n    this.processEvent(event);\n    this.recognizers.map((r) => {\n      r.pointerSessionMoved(this, event);\n    });\n  }\n  pointerUp(event) {\n    if (!this.isStarted) {\n      return;\n    }\n    this.processEvent(event);\n    this.recognizers.map((r) => {\n      r.pointerSessionEnded(this, event);\n    });\n    this.clearEvents();\n    this.recognizers.map((r) => {\n      r.reset();\n    });\n  }\n  mouseWheel(event) {\n    this.processEvent(event);\n    this.mouseWheelRecognizer.mouseWheel(this, event);\n    this.clearEvents();\n  }\n  clearEvents() {\n    this.events = [];\n  }\n  dispatch(type, event, target = null) {\n    const dispatchTarget = target || this.startEvent && this.startEvent.target || event.target;\n    if (dispatchTarget) {\n      this.dispatcher(type, event, dispatchTarget);\n    }\n  }\n  gestureBegan(type, event, target) {\n    this.dispatch(`${type}start`, event, target);\n  }\n  gestureChanged(type, event, target) {\n    this.dispatch(type, event, target);\n  }\n  gestureEnded(type, event, target) {\n    this.dispatch(`${type}end`, event, target);\n  }\n  velocity(t = Loop.TimeStep * 2) {\n    if (!this.isStarted || this.events.length < 2) {\n      return { x: 0, y: 0 };\n    }\n    const events2 = this.events;\n    let i = events2.length - 1;\n    let event = null;\n    while (i >= 0) {\n      event = events2[i];\n      if (MainLoop.time - event.loopTime > t) {\n        break;\n      }\n      i--;\n    }\n    if (!event) {\n      return { x: 0, y: 0 };\n    }\n    const current = events2[events2.length - 1];\n    const time3 = (MainLoop.time - event.loopTime) * 1e3;\n    if (time3 === 0) {\n      return { x: 0, y: 0 };\n    }\n    const velocity = {\n      x: (current.devicePoint.x - event.devicePoint.x) / time3,\n      y: (current.devicePoint.y - event.devicePoint.y) / time3\n    };\n    if (velocity.x === Infinity) {\n      velocity.x = 0;\n    }\n    if (velocity.y === Infinity) {\n      velocity.y = 0;\n    }\n    return velocity;\n  }\n  offset(event) {\n    if (!this.startEvent) {\n      return { x: 0, y: 0 };\n    }\n    const subtract = (pointA, pointB) => {\n      return {\n        x: pointA.x - pointB.x,\n        y: pointA.y - pointB.y\n      };\n    };\n    return subtract(event.devicePoint, this.startEvent.devicePoint);\n  }\n};\n\n// src/events/recognizer/TouchEventListener.ts\n\nvar TouchEventListener = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor() {\n    super(...arguments);\n    this.domTouchStart = (originalEvent) => {\n      safeWindow.addEventListener(\"touchmove\", this.domTouchMove);\n      safeWindow.addEventListener(\"touchend\", this.domTouchEnd);\n      const event = new FramerEvent(originalEvent, this.props.session);\n      this.props.session.pointerDown(event);\n    };\n    this.domTouchMove = (originalEvent) => {\n      const event = new FramerEvent(originalEvent, this.props.session);\n      this.props.session.pointerMove(event);\n    };\n    this.domTouchEnd = (originalEvent) => {\n      safeWindow.removeEventListener(\"touchmove\", this.domTouchMove);\n      safeWindow.removeEventListener(\"touchend\", this.domTouchEnd);\n      const event = new FramerEvent(originalEvent, this.props.session);\n      this.props.session.pointerUp(event);\n    };\n  }\n  render() {\n    return this.props.children;\n  }\n  componentDidMount() {\n    safeWindow.addEventListener(\"touchstart\", this.domTouchStart);\n  }\n  componentWillUnmount() {\n    safeWindow.removeEventListener(\"touchstart\", this.domTouchStart);\n    safeWindow.removeEventListener(\"touchmove\", this.domTouchMove);\n    safeWindow.removeEventListener(\"touchend\", this.domTouchEnd);\n  }\n};\n\n// src/events/recognizer/MouseEventListener.ts\n\nvar MouseEventListener = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor() {\n    super(...arguments);\n    this.domMouseDown = (originalEvent) => {\n      safeWindow.addEventListener(\"mousemove\", this.domMouseMove);\n      safeWindow.addEventListener(\"mouseup\", this.domMouseUp);\n      const event = new FramerEvent(originalEvent, this.props.session);\n      this.props.session.pointerDown(event);\n    };\n    this.domMouseMove = (originalEvent) => {\n      const leftMouseButtonOnlyDown = originalEvent.buttons === void 0 ? originalEvent.which === 1 : originalEvent.buttons === 1;\n      if (!leftMouseButtonOnlyDown) {\n        this.domMouseUp(originalEvent);\n        return;\n      }\n      const event = new FramerEvent(originalEvent, this.props.session);\n      this.props.session.pointerMove(event);\n    };\n    this.domMouseUp = (originalEvent) => {\n      safeWindow.removeEventListener(\"mousemove\", this.domMouseMove);\n      safeWindow.removeEventListener(\"mouseup\", this.domMouseUp);\n      const event = new FramerEvent(originalEvent, this.props.session);\n      this.props.session.pointerUp(event);\n    };\n    this.domMouseWheel = (originalEvent) => {\n      const event = new FramerEvent(originalEvent, this.props.session);\n      this.props.session.mouseWheel(event);\n    };\n  }\n  render() {\n    return this.props.children;\n  }\n  componentDidMount() {\n    safeWindow.addEventListener(\"mousedown\", this.domMouseDown);\n    safeWindow.addEventListener(\"wheel\", this.domMouseWheel);\n  }\n  componentWillUnmount() {\n    safeWindow.removeEventListener(\"mousemove\", this.domMouseMove);\n    safeWindow.removeEventListener(\"mousedown\", this.domMouseDown);\n    safeWindow.removeEventListener(\"mouseup\", this.domMouseUp);\n    safeWindow.removeEventListener(\"wheel\", this.domMouseWheel);\n  }\n};\n\n// src/events/FramerEventListener.ts\nvar FramerEventListener = environment_exports.isTouch() ? TouchEventListener : MouseEventListener;\n\n// src/components/Navigation.tsx\n\n\n// src/components/NavigationTransitions.ts\nvar TransitionDefaults;\n(function(TransitionDefaults2) {\n  TransitionDefaults2.Fade = {\n    exit: { opacity: 0 },\n    enter: { opacity: 0 }\n  };\n  TransitionDefaults2.PushLeft = {\n    exit: { x: \"-30%\" },\n    enter: { x: \"100%\" }\n  };\n  TransitionDefaults2.PushRight = {\n    exit: { x: \"30%\" },\n    enter: { x: \"-100%\" }\n  };\n  TransitionDefaults2.PushUp = {\n    exit: { y: \"-30%\" },\n    enter: { y: \"100%\" }\n  };\n  TransitionDefaults2.PushDown = {\n    exit: { y: \"30%\" },\n    enter: { y: \"-100%\" }\n  };\n  TransitionDefaults2.Instant = {\n    animation: { type: false },\n    enter: { opacity: 0 }\n  };\n  TransitionDefaults2.Modal = {\n    overCurrentContext: true,\n    goBackOnTapOutside: true,\n    position: { center: true },\n    enter: { opacity: 0, scale: 1.2 }\n  };\n  TransitionDefaults2.OverlayLeft = {\n    overCurrentContext: true,\n    goBackOnTapOutside: true,\n    position: { right: 0, top: 0, bottom: 0 },\n    enter: { x: \"100%\" }\n  };\n  TransitionDefaults2.OverlayRight = {\n    overCurrentContext: true,\n    goBackOnTapOutside: true,\n    position: { left: 0, top: 0, bottom: 0 },\n    enter: { x: \"-100%\" }\n  };\n  TransitionDefaults2.OverlayUp = {\n    overCurrentContext: true,\n    goBackOnTapOutside: true,\n    position: { bottom: 0, left: 0, right: 0 },\n    enter: { y: \"100%\" }\n  };\n  TransitionDefaults2.OverlayDown = {\n    overCurrentContext: true,\n    goBackOnTapOutside: true,\n    position: { top: 0, left: 0, right: 0 },\n    enter: { y: \"-100%\" }\n  };\n  TransitionDefaults2.FlipLeft = {\n    backfaceVisible: false,\n    exit: { rotateY: -180 },\n    enter: { rotateY: 180 }\n  };\n  TransitionDefaults2.FlipRight = {\n    backfaceVisible: false,\n    exit: { rotateY: 180 },\n    enter: { rotateY: -180 }\n  };\n  TransitionDefaults2.FlipUp = {\n    backfaceVisible: false,\n    exit: { rotateX: 180 },\n    enter: { rotateX: -180 }\n  };\n  TransitionDefaults2.FlipDown = {\n    backfaceVisible: false,\n    exit: { rotateX: -180 },\n    enter: { rotateX: 180 }\n  };\n  TransitionDefaults2.MagicMotion = {\n    withMagicMotion: true\n  };\n})(TransitionDefaults || (TransitionDefaults = {}));\nfunction pushTransition(options) {\n  const side = options && options.appearsFrom ? options.appearsFrom : \"right\";\n  switch (side) {\n    case \"right\":\n      return TransitionDefaults.PushLeft;\n    case \"left\":\n      return TransitionDefaults.PushRight;\n    case \"bottom\":\n      return TransitionDefaults.PushUp;\n    case \"top\":\n      return TransitionDefaults.PushDown;\n  }\n}\nfunction overlayTransition(options) {\n  const side = options && options.appearsFrom ? options.appearsFrom : \"bottom\";\n  switch (side) {\n    case \"right\":\n      return TransitionDefaults.OverlayLeft;\n    case \"left\":\n      return TransitionDefaults.OverlayRight;\n    case \"bottom\":\n      return TransitionDefaults.OverlayUp;\n    case \"top\":\n      return TransitionDefaults.OverlayDown;\n  }\n}\nfunction flipTransition(options) {\n  const side = options && options.appearsFrom ? options.appearsFrom : \"bottom\";\n  switch (side) {\n    case \"right\":\n      return TransitionDefaults.FlipLeft;\n    case \"left\":\n      return TransitionDefaults.FlipRight;\n    case \"bottom\":\n      return TransitionDefaults.FlipUp;\n    case \"top\":\n      return TransitionDefaults.FlipDown;\n  }\n}\n\n// src/components/NavigationContainer.tsx\n\n\n\n// src/components/AnimateLayout/AnimateLayoutTrees.tsx\n\n\n// src/components/AnimateLayout/animation.ts\nfunction createAnimation(animation) {\n  const { shouldStackAnimate, transition, current, prevViewportBox, onComplete, prevParent } = animation;\n  const config = {\n    shouldStackAnimate,\n    transition,\n    current,\n    onComplete,\n    prevParent: prevParent ? prevParent : void 0\n  };\n  if (!shouldStackAnimate)\n    return config;\n  config.originBox = prevViewportBox;\n  return config;\n}\n\n// src/components/AnimateLayout/TreeContext.ts\n\nvar LayoutTreeContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  promoteTree: () => false,\n  markTreeAsSafeToRemove: () => {\n  }\n});\n\n// src/components/AnimateLayout/AnimateLayoutTrees.tsx\nvar syncContextStub = {\n  register: () => {\n  },\n  remove: () => {\n  },\n  add: () => {\n  },\n  flush: () => {\n  },\n  syncUpdate: () => {\n  }\n};\nvar TREE_ROOT_ID = \"____treeroot\";\nvar AnimateLayoutTrees = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor() {\n    super(...arguments);\n    this.scheduled = false;\n    this.resetScheduled = false;\n    this.layoutIdConfig = new Map();\n    this.treeContext = {\n      promoteTree: (...args) => this.promoteTree(...args),\n      markTreeAsSafeToRemove: (tree) => this.markTreeAsSafeToRemove(tree)\n    };\n    this.syncContext = {\n      ...syncContextStub,\n      forceUpdate: () => {\n        this.syncContext = {\n          ...this.syncContext\n        };\n        this.forceUpdate();\n      }\n    };\n    this.batch = createBatcher();\n    this.stackCrossfaders = new Map([[TREE_ROOT_ID, createCrossfader()]]);\n  }\n  promoteTree(tree, shouldAnimate, transition, resets) {\n    var _a, _b, _c;\n    if (tree === this.lead)\n      return false;\n    const prevFollow = this.follow;\n    this.follow = this.lead;\n    this.lead = tree;\n    if (resets)\n      this.resetScheduled = true;\n    if (!shouldAnimate) {\n      this.startCrossfade(new Map([[TREE_ROOT_ID, {}]]), { type: false });\n      return false;\n    }\n    this.layoutIdConfig.clear();\n    const currentStyle = {};\n    for (const [layoutId, lead] of this.lead.children) {\n      const follow = (_a = this.follow) == null ? void 0 : _a.children.get(layoutId);\n      snapshotRotate(layoutId, lead, follow, currentStyle);\n      follow && resetRotate2(follow);\n      resetRotate2(lead);\n    }\n    this.lead.childrenToResetTransform.forEach((child) => child.resetTransform());\n    for (const [layoutId, lead] of this.lead.children) {\n      const follow = (_b = this.follow) == null ? void 0 : _b.children.get(layoutId);\n      follow && snapshotViewportBox(follow);\n      snapshotViewportBox(lead);\n      const prevViewportBox = (follow == null ? void 0 : follow.prevViewportBox) ? copyAxisBox2(follow == null ? void 0 : follow.prevViewportBox) : void 0;\n      const config = {\n        lead,\n        current: currentStyle[layoutId],\n        transition,\n        prevViewportBox,\n        shouldStackAnimate: follow ? true : false,\n        prevParent: follow == null ? void 0 : follow.getProjectionParent()\n      };\n      this.layoutIdConfig.set(layoutId, config);\n    }\n    if (prevFollow !== this.lead && prevFollow !== this.follow) {\n      (_c = prevFollow == null ? void 0 : prevFollow.rootChild) == null ? void 0 : _c.setVisibility(false);\n    }\n    this.scheduled = true;\n    return true;\n  }\n  markTreeAsSafeToRemove(tree) {\n    this.safeToRemoveTree = tree;\n  }\n  markTreeChildrenAsSafeToRemove(tree) {\n    var _a;\n    if (!tree)\n      return;\n    for (const [_, child] of tree.children) {\n      (_a = child.layoutSafeToRemove) == null ? void 0 : _a.call(child);\n    }\n  }\n  componentDidUpdate() {\n    if (this.scheduled)\n      this.startLayoutAnimation(this.resetScheduled);\n    if (this.safeToRemoveTree)\n      this.markTreeChildrenAsSafeToRemove(this.safeToRemoveTree);\n    this.safeToRemoveTree = void 0;\n    this.scheduled = false;\n    this.resetScheduled = false;\n  }\n  componentWillUnmount() {\n    this.stopCrossfadeAnimation();\n  }\n  startLayoutAnimation(shouldReset) {\n    const { lead, follow } = this;\n    const leadChildren = lead == null ? void 0 : lead.children;\n    const followChildren = follow == null ? void 0 : follow.children;\n    const toCrossfade = new Map();\n    const handler = {\n      layoutReady: (child) => {\n        const layoutId = child.getLayoutId();\n        if (layoutId === void 0)\n          return;\n        const config = this.layoutIdConfig.get(layoutId);\n        if (!config)\n          return child.notifyLayoutReady({ shouldStackAnimate: false });\n        const followChild = followChildren == null ? void 0 : followChildren.get(layoutId);\n        const leadChild = leadChildren == null ? void 0 : leadChildren.get(layoutId);\n        child.pointTo(leadChild != null ? leadChild : child);\n        const isLead = Boolean(leadChildren && leadChild === child);\n        if (isLead) {\n          if (followChild && leadChild)\n            toCrossfade.set(layoutId, config);\n          child.notifyLayoutReady(createAnimation({\n            ...config,\n            onComplete: () => {\n              var _a;\n              (_a = followChild == null ? void 0 : followChild.layoutSafeToRemove) == null ? void 0 : _a.call(followChild);\n            }\n          }));\n        }\n      }\n    };\n    if (lead && leadChildren) {\n      for (const [_, child] of leadChildren)\n        this.batch.add(child);\n      lead.layoutMayBeMutated = false;\n    }\n    if (!shouldReset && follow && followChildren) {\n      for (const [_, child] of followChildren)\n        this.batch.add(child);\n      follow.layoutMayBeMutated = true;\n    }\n    this.batch.flush(handler);\n    this.startCrossfade(toCrossfade);\n  }\n  startCrossfade(toCrossfade, transition) {\n    var _a, _b, _c, _d, _e;\n    if (!((_a = this.lead) == null ? void 0 : _a.rootChild))\n      return;\n    const isExit = (_b = this.follow) == null ? void 0 : _b.isExiting;\n    let rootTransition = transition;\n    const leadRoot = (_c = this.lead) == null ? void 0 : _c.rootChild;\n    const followRoot = (_d = this.follow) == null ? void 0 : _d.rootChild;\n    leadRoot == null ? void 0 : leadRoot.setVisibility(true);\n    followRoot == null ? void 0 : followRoot.setVisibility(true);\n    const createCrossfadeAnimation = (config, id) => {\n      var _a2, _b2;\n      const followChild = (_a2 = this.follow) == null ? void 0 : _a2.children.get(id);\n      const leadChild = (_b2 = this.lead) == null ? void 0 : _b2.children.get(id);\n      if (leadChild === leadRoot || followChild === followRoot) {\n        if (leadChild === leadRoot)\n          rootTransition = config.transition;\n        return;\n      }\n      if (!this.stackCrossfaders.has(id)) {\n        this.stackCrossfaders.set(id, createCrossfader());\n      }\n      const crossfader = this.stackCrossfaders.get(id);\n      crossfader.setOptions({\n        lead: leadChild,\n        follow: followChild\n      });\n      leadChild == null ? void 0 : leadChild.setCrossfader(crossfader);\n      followChild == null ? void 0 : followChild.setCrossfader(crossfader);\n      crossfader.toLead(config == null ? void 0 : config.transition);\n    };\n    toCrossfade.forEach(createCrossfadeAnimation);\n    if (!leadRoot || !followRoot)\n      return;\n    const rootCrossfader = this.stackCrossfaders.get(TREE_ROOT_ID);\n    rootCrossfader.setOptions({\n      lead: leadRoot,\n      follow: followRoot,\n      preserveFollowOpacity: !isExit,\n      crossfadeOpacity: true\n    });\n    leadRoot.setCrossfader(rootCrossfader);\n    followRoot.setCrossfader(rootCrossfader);\n    const leadRootId = leadRoot.getLayoutId();\n    const leadTransition = leadRootId ? ((_e = this.layoutIdConfig.get(leadRootId)) == null ? void 0 : _e.transition) || rootTransition : rootTransition;\n    rootCrossfader.toLead(leadTransition);\n  }\n  stopCrossfadeAnimation() {\n    this.stackCrossfaders.forEach((crossfader) => crossfader.stop());\n  }\n  render() {\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(LayoutTreeContext.Provider, {\n      value: this.treeContext\n    }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(SharedLayoutContext.Provider, {\n      value: this.syncContext\n    }, this.props.children));\n  }\n};\nfunction copyAxisBox2(box) {\n  if (!box)\n    return void 0;\n  return {\n    x: { ...box.x },\n    y: { ...box.y }\n  };\n}\nfunction snapshotRotate(layoutId, lead, follow, styleMap) {\n  const followRotate = follow == null ? void 0 : follow.getValue(\"rotate\");\n  const leadRotate = lead.getValue(\"rotate\");\n  styleMap[layoutId] = { rotate: (leadRotate == null ? void 0 : leadRotate.isAnimating()) ? leadRotate.get() : (followRotate == null ? void 0 : followRotate.get()) || 0 };\n}\nvar transformAxes2 = [\"\", \"X\", \"Y\", \"Z\"];\nfunction resetRotate2(child) {\n  let hasRotate = false;\n  const resetValues = {};\n  transformAxes2.forEach((axis) => {\n    const key6 = \"rotate\" + axis;\n    if (!child.hasValue(key6))\n      return;\n    hasRotate = true;\n    resetValues[key6] = child.getStaticValue(key6);\n    child.setStaticValue(key6, 0);\n  });\n  if (!hasRotate)\n    return;\n  child.syncRender();\n  for (const key6 in resetValues) {\n    child.setStaticValue(key6, resetValues[key6]);\n  }\n  child.scheduleRender();\n}\n\n// src/components/AnimateLayout/SharedLayoutTree.tsx\n\nvar LayoutTree = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor() {\n    super(...arguments);\n    this.children = new Map();\n    this.childrenToResetTransform = new Set();\n    this.layoutMayBeMutated = false;\n    this.syncContext = {\n      add: () => {\n      },\n      flush: () => {\n      },\n      syncUpdate: (force) => {\n      },\n      forceUpdate: () => {\n        this.syncContext = { ...this.syncContext };\n        this.forceUpdate();\n      },\n      register: (child) => this.addChild(child),\n      remove: (child) => this.removeChild(child)\n    };\n  }\n  addChild(child) {\n    const layoutId = child.getLayoutId();\n    if (layoutId) {\n      this.children.set(layoutId, child);\n      this.setRootChild(child);\n    } else if (child.shouldResetTransform()) {\n      this.childrenToResetTransform.add(child);\n    }\n  }\n  setRootChild(child) {\n    if (!this.rootChild)\n      return this.rootChild = child;\n    this.rootChild = this.rootChild.depth < child.depth ? this.rootChild : child;\n  }\n  removeChild(child) {\n    const layoutId = child.getLayoutId();\n    if (layoutId) {\n      this.children.delete(layoutId);\n    } else {\n      this.childrenToResetTransform.delete(child);\n    }\n  }\n  componentDidMount() {\n    const { isLead, animatesLayout, transition } = this.props;\n    if (isLead !== void 0 && isLead)\n      this.props.treeContext.promoteTree(this, !!animatesLayout, transition);\n  }\n  shouldComponentUpdate({ isLead, isExiting, animatesLayout, transition }) {\n    this.isExiting = isExiting;\n    if (this.props.isLead === void 0)\n      return true;\n    const hasBecomeLead = !this.props.isLead && isLead;\n    const hasExitBeenCancelled = this.props.isExiting && !isExiting;\n    const shouldPromote = hasBecomeLead || hasExitBeenCancelled;\n    if (this.layoutMayBeMutated && shouldPromote && !animatesLayout) {\n      return this.props.treeContext.promoteTree(this, true, { type: false }, true);\n    } else if (shouldPromote) {\n      return this.props.treeContext.promoteTree(this, !!animatesLayout, transition);\n    } else if (isExiting && !animatesLayout) {\n      this.props.treeContext.markTreeAsSafeToRemove(this);\n    }\n    return false;\n  }\n  render() {\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FramerTreeLayoutContext.Provider, {\n      value: this.syncContext\n    }, this.props.children);\n  }\n};\nvar SharedLayoutTree = (props) => {\n  const treeContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LayoutTreeContext);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(LayoutTree, {\n    ...props,\n    treeContext\n  });\n};\n\n// src/components/NavigationTargetContext.tsx\n\n\n\n// src/components/utils/useConstant.ts\n\nfunction useConstant2(init) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  if (ref.current === null) {\n    ref.current = init();\n  }\n  return ref.current;\n}\n\n// src/components/utils/useMap.ts\nfunction newMap() {\n  return new Map();\n}\nfunction useMap() {\n  return useConstant2(newMap);\n}\n\n// src/components/NavigationTargetContext.tsx\nvar NavigationTargetContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({ register: () => {\n}, deregister: () => {\n} });\nvar NavigationTargetWrapper = ({ isCurrent, isOverlayed, children }) => {\n  const callbacks2 = useMap();\n  const register = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((fn) => {\n    if (callbacks2.has(fn)) {\n      console.warn(\"NavigationTargetWrapper: already registered\");\n      return;\n    }\n    callbacks2.set(fn, void 0);\n  }, [callbacks2]);\n  const deregister = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((fn) => {\n    const cleanup = callbacks2.get(fn);\n    cleanup == null ? void 0 : cleanup();\n    callbacks2.delete(fn);\n  }, [callbacks2]);\n  const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({ register, deregister }).current;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    callbacks2.forEach((_, cb2) => {\n      const newCleanup = cb2(isCurrent, isOverlayed);\n      callbacks2.set(cb2, isFunction(newCleanup) ? newCleanup : void 0);\n    });\n    return () => {\n      callbacks2.forEach((cleanup, cb2) => {\n        if (!cleanup)\n          return;\n        cleanup();\n        callbacks2.set(cb2, void 0);\n      });\n    };\n  }, [isCurrent, isOverlayed, callbacks2]);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(NavigationTargetContext.Provider, {\n    value\n  }, children);\n};\nfunction useOnCurrentTargetChange(callback, deps = []) {\n  const { register, deregister } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NavigationTargetContext);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!callback)\n      return;\n    register(callback);\n    return () => deregister(callback);\n  }, [register, deregister, ...deps]);\n}\n\n// src/components/NavigationContainer.tsx\nvar NavigationContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function NavigationContainer2({\n  isLayeredContainer,\n  isCurrent,\n  isPrevious,\n  isOverlayed = false,\n  visible,\n  transitionProps,\n  children,\n  backdropColor,\n  onTapBackdrop,\n  backfaceVisible,\n  exitBackfaceVisible,\n  animation,\n  exitAnimation,\n  instant,\n  initialProps,\n  exitProps,\n  position = { top: 0, right: 0, bottom: 0, left: 0 },\n  withMagicMotion,\n  index,\n  areMagicMotionLayersPresent,\n  id\n}) {\n  const animate4 = useAnimation();\n  const presence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PresenceContext);\n  const { persistLayoutIdCache } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LayoutIdContext);\n  const previousState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    wasCurrent: void 0,\n    wasPrevious: false,\n    wasBeingRemoved: false,\n    wasReset: true,\n    origins: getOriginProps({}, initialProps, transitionProps)\n  });\n  const isBeingRemoved = presence !== null && !presence.isPresent;\n  if (isCurrent && previousState.current.wasCurrent === void 0)\n    persistLayoutIdCache();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (isLayeredContainer || !animate4)\n      return;\n    if (isBeingRemoved) {\n      previousState.current = {\n        ...previousState.current,\n        wasBeingRemoved: isBeingRemoved\n      };\n      return;\n    }\n    const { wasPrevious, wasCurrent } = previousState.current;\n    const shouldAnimateIn = isCurrent && !wasCurrent || !isBeingRemoved && previousState.current.wasBeingRemoved && isCurrent;\n    const shouldAnimateOut = isPrevious && !wasPrevious;\n    const origins = getOriginProps(previousState.current.origins, initialProps, transitionProps);\n    let wasReset = previousState.current.wasReset;\n    if (shouldAnimateIn || shouldAnimateOut) {\n      animate4.stop();\n      animate4.start({\n        zIndex: index,\n        ...origins,\n        ...transitionProps\n      });\n      wasReset = false;\n    } else if (wasReset === false) {\n      animate4.stop();\n      animate4.set({ zIndex: index, ...allAnimatableProperties, opacity: 0 });\n      wasReset = true;\n    }\n    previousState.current = {\n      wasCurrent: !!isCurrent,\n      wasPrevious: !!isPrevious,\n      wasBeingRemoved: false,\n      wasReset,\n      origins\n    };\n  }, [isCurrent, isPrevious, isBeingRemoved]);\n  const transition = instant ? { type: false } : { ...animation, velocity: 0 };\n  const exitTransition = instant ? { type: false } : exitAnimation || animation;\n  const layout = { ...position };\n  if (layout.left === void 0 || layout.right === void 0)\n    layout.width = \"auto\";\n  if (layout.top === void 0 || layout.bottom === void 0)\n    layout.height = \"auto\";\n  const needsPerspective = contains3Dprops(transitionProps) || contains3Dprops(initialProps);\n  const perspective = needsPerspective && (isLayeredContainer || isCurrent || isPrevious) ? 1200 : void 0;\n  const identity = { ...allAnimatableProperties, ...previousState.current.origins };\n  const animations2 = isLayeredContainer ? {\n    initial: { ...identity, ...initialProps },\n    animate: { ...identity, ...transitionProps, transition },\n    exit: { ...identity, ...exitProps, transition: animate4 }\n  } : {\n    animate: animate4,\n    exit: { ...identity, ...exitProps, transition: exitTransition }\n  };\n  const isPresent2 = isBeingRemoved || areMagicMotionLayersPresent === false ? false : true;\n  const isCurrentTarget = !!isCurrent && isPresent2;\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FrameWithMotion, {\n    width: \"100%\",\n    height: \"100%\",\n    style: {\n      position: \"absolute\",\n      transformStyle: \"flat\",\n      backgroundColor: \"transparent\",\n      overflow: \"hidden\",\n      zIndex: isLayeredContainer || isBeingRemoved || isCurrent && withMagicMotion ? index : void 0,\n      pointerEvents: \"none\",\n      visibility: visible ? \"visible\" : \"hidden\",\n      perspective\n    }\n  }, isLayeredContainer && /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FrameWithMotion, {\n    width: \"100%\",\n    height: \"100%\",\n    transition: animation,\n    initial: { opacity: instant && visible ? 1 : 0 },\n    animate: { opacity: 1 },\n    exit: { opacity: 0 },\n    backgroundColor: backdropColor ? backdropColor : \"transparent\",\n    onTap: !isBeingRemoved ? onTapBackdrop : void 0\n  }), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FrameWithMotion, {\n    ...layout,\n    ...animations2,\n    transition: {\n      default: transition,\n      originX: { type: false },\n      originY: { type: false },\n      originZ: { type: false }\n    },\n    backgroundColor: \"transparent\",\n    backfaceVisible: !isBeingRemoved ? backfaceVisible : exitBackfaceVisible,\n    \"data-framer-component-type\": \"NavigationContainer\",\n    \"data-framer-is-current-navigation-target\": !!isCurrent,\n    style: {\n      pointerEvents: \"initial\",\n      opacity: isLayeredContainer || isCurrent && withMagicMotion ? 1 : 0\n    },\n    \"data-is-present\": isPresent2 ? void 0 : false\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(NavigationContainerContext.Provider, {\n    value: isCurrentTarget\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(NavigationTargetWrapper, {\n    isCurrent: isCurrentTarget,\n    isOverlayed\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(SharedLayoutTree, {\n    isLead: isCurrent,\n    animatesLayout: !!withMagicMotion,\n    transition,\n    isExiting: !isPresent2,\n    id\n  }, children)))));\n}, shouldUsePreviousValue);\nfunction shouldUsePreviousValue(prevProps, nextProps) {\n  if (nextProps.isCurrent === void 0)\n    return false;\n  if (prevProps.isCurrent !== nextProps.isCurrent)\n    return false;\n  if (prevProps.isPrevious !== nextProps.isPrevious)\n    return false;\n  if (nextProps.isCurrent && prevProps.isOverlayed !== nextProps.isOverlayed)\n    return false;\n  return true;\n}\nfunction getOriginProps(currentOriginProps, initialProps, transitionProps) {\n  const result = { ...currentOriginProps };\n  if (initialProps) {\n    if (isFiniteNumber(initialProps.originX))\n      result.originX = initialProps.originX;\n    if (isFiniteNumber(initialProps.originY))\n      result.originY = initialProps.originY;\n    if (isFiniteNumber(initialProps.originZ))\n      result.originZ = initialProps.originZ;\n  }\n  if (transitionProps) {\n    if (isFiniteNumber(transitionProps.originX))\n      result.originX = transitionProps.originX;\n    if (isFiniteNumber(transitionProps.originY))\n      result.originY = transitionProps.originY;\n    if (isFiniteNumber(transitionProps.originZ))\n      result.originZ = transitionProps.originZ;\n  }\n  return result;\n}\nfunction contains3Dprops(containerProps) {\n  var _a, _b, _c;\n  if (!containerProps)\n    return false;\n  const containsProps = \"rotateX\" in containerProps || \"rotateY\" in containerProps || \"z\" in containerProps;\n  if (!containsProps)\n    return false;\n  const toPropsContain3d = containerProps.rotateX !== 0 || containerProps.rotateY !== 0 || containerProps.z !== 0;\n  const fromPropsContain3d = ((_a = containerProps == null ? void 0 : containerProps.transition) == null ? void 0 : _a.rotateX.from) !== 0 || ((_b = containerProps == null ? void 0 : containerProps.transition) == null ? void 0 : _b.rotateY.from) !== 0 || ((_c = containerProps == null ? void 0 : containerProps.transition) == null ? void 0 : _c.z.from) !== 0;\n  return toPropsContain3d || fromPropsContain3d;\n}\nvar allAnimatableProperties = {\n  x: 0,\n  y: 0,\n  z: 0,\n  rotate: 0,\n  rotateX: 0,\n  rotateY: 0,\n  rotateZ: 0,\n  scale: 1,\n  scaleX: 1,\n  scaleY: 1,\n  scaleZ: 1,\n  skew: 0,\n  skewX: 0,\n  skewY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  originZ: 0,\n  opacity: 1\n};\n\n// src/components/NavigatorMock.tsx\nvar NavigatorMock = class {\n  constructor() {\n    this.warning = () => {\n      warnOnce(\"The Navigator API is only available inside of Framer: https://www.framer.com/\");\n    };\n    this.goBack = () => this.warning();\n    this.instant = () => this.warning();\n    this.fade = () => this.warning();\n    this.push = () => this.warning();\n    this.modal = () => this.warning();\n    this.overlay = () => this.warning();\n    this.flip = () => this.warning();\n    this.customTransition = () => this.warning();\n    this.magicMotion = () => this.warning();\n  }\n};\nvar navigatorMock = new NavigatorMock();\n\n// src/components/reduceNavigationStateForAction.ts\nvar defaultState = () => ({\n  current: -1,\n  previous: -1,\n  currentOverlay: -1,\n  previousOverlay: -1,\n  visualIndex: 0,\n  overlayItemId: 0,\n  historyItemId: 0,\n  history: [],\n  overlayStack: [],\n  containers: {},\n  containerIndex: {},\n  containerVisualIndex: {},\n  containerIsRemoved: {},\n  transitionForContainer: {},\n  previousTransition: null\n});\nfunction reduceNavigationStateForAction(state, action) {\n  switch (action.type) {\n    case \"addOverlay\":\n      return addOverlay(state, action.transition, action.component);\n    case \"removeOverlay\":\n      return removeOverlay(state);\n    case \"add\":\n      return add(state, action.key, action.transition, action.component);\n    case \"remove\":\n      return remove(state);\n    case \"update\":\n      return updateComponent(state, action.key, action.component);\n    default:\n      return;\n  }\n}\nfunction updateComponent(currentState, key6, component) {\n  return {\n    ...currentState,\n    containers: {\n      ...currentState.containers,\n      [key6]: component\n    }\n  };\n}\nfunction addOverlay(currentState, transition, component) {\n  const currentOverlay = currentState.overlayStack[currentState.currentOverlay];\n  if (currentOverlay && currentOverlay.component === component)\n    return;\n  const overlayItemId = currentState.overlayItemId + 1;\n  const overlayStack = [\n    ...currentState.overlayStack,\n    {\n      key: `stack-${overlayItemId}`,\n      component,\n      transition\n    }\n  ];\n  return {\n    ...currentState,\n    overlayStack,\n    overlayItemId,\n    currentOverlay: Math.max(0, Math.min(currentState.currentOverlay + 1, overlayStack.length - 1)),\n    previousOverlay: currentState.currentOverlay\n  };\n}\nfunction removeOverlay(currentState) {\n  return {\n    ...currentState,\n    overlayStack: [],\n    currentOverlay: -1,\n    previousOverlay: currentState.currentOverlay\n  };\n}\nfunction add(currentState, key6, transition, component) {\n  if (!currentState.containers[key6])\n    currentState.containers[key6] = component;\n  currentState.history = currentState.history.slice(0, currentState.current + 1);\n  currentState.visualIndex = Math.max(currentState.history.length, 0);\n  const currentItem = currentState.history[currentState.history.length - 1];\n  const isCurrentScreen = currentItem && currentItem.key === key6;\n  currentState.overlayStack = [];\n  if (isCurrentScreen && currentState.currentOverlay > -1) {\n    return {\n      ...currentState,\n      currentOverlay: -1,\n      previousOverlay: currentState.currentOverlay\n    };\n  }\n  if (isCurrentScreen)\n    return;\n  const shouldMoveForward = (currentItem == null ? void 0 : currentItem.key) && transition.withMagicMotion ? isNextTargetForward(key6, currentState.containerVisualIndex[key6], currentState.containerIsRemoved[key6], currentState.history) : true;\n  currentState.history.push({\n    key: key6,\n    transition,\n    visualIndex: shouldMoveForward ? Math.max(currentState.visualIndex, 0) : currentState.containerVisualIndex[key6]\n  });\n  const current = currentState.current + 1;\n  const previous = currentState.current;\n  for (const containerKey in currentState.containerIndex) {\n    if (currentState.containerIndex[containerKey] === current) {\n      currentState.containerIndex[containerKey] = findLatestHistoryIndex(containerKey, currentState.history);\n    }\n  }\n  currentState.containerIndex[key6] = current;\n  const { containerVisualIndex, containerIsRemoved } = magicMotionPropsForAdd(currentState, key6, currentItem == null ? void 0 : currentItem.key, shouldMoveForward);\n  const transitionForContainer = updateTransitions(current, previous, currentState.history, currentState.containerIndex, currentState.transitionForContainer);\n  return {\n    ...currentState,\n    current,\n    previous,\n    containerVisualIndex,\n    containerIsRemoved,\n    transitionForContainer,\n    previousTransition: null,\n    currentOverlay: -1,\n    historyItemId: currentState.historyItemId + 1,\n    previousOverlay: currentState.currentOverlay\n  };\n}\nfunction remove(currentState) {\n  const history = [...currentState.history.slice(0, currentState.current + 1)];\n  if (history.length === 1)\n    return;\n  const currentItem = history.pop();\n  if (!currentItem)\n    return;\n  const target = history[history.length - 1];\n  currentState.containerIndex[target.key] = history.length - 1;\n  const shouldRemoveContainer = history.every((item) => item.key !== currentItem.key);\n  if (shouldRemoveContainer) {\n    delete currentState.containers[currentItem.key];\n  }\n  const current = currentState.current - 1;\n  const previous = currentState.current;\n  const { containerIsRemoved, containerVisualIndex, previousTransition, visualIndex } = magicMotionPropsForRemove(currentState, target, currentItem);\n  const transitionForContainer = updateTransitions(current, previous, currentState.history, currentState.containerIndex, currentState.transitionForContainer);\n  return {\n    ...currentState,\n    current,\n    previous,\n    containerIsRemoved,\n    containerVisualIndex,\n    previousTransition,\n    visualIndex,\n    transitionForContainer\n  };\n}\nfunction magicMotionPropsForAdd(currentState, nextKey, currentKey, shouldMoveForward) {\n  const update = {\n    containerVisualIndex: { ...currentState.containerVisualIndex },\n    containerIsRemoved: { ...currentState.containerIsRemoved }\n  };\n  if (shouldMoveForward) {\n    update.containerVisualIndex[nextKey] = currentState.history.length - 1;\n    update.containerIsRemoved[nextKey] = false;\n  } else {\n    const nextVisualIndex = currentState.containerVisualIndex[nextKey];\n    for (const key6 in currentState.containerVisualIndex) {\n      if (currentState.containerVisualIndex[key6] > nextVisualIndex) {\n        update.containerIsRemoved[key6] = true;\n      }\n    }\n  }\n  return update;\n}\nfunction magicMotionPropsForRemove(currentState, target, currentItem) {\n  const { history } = globalThis;\n  const validTargets = [target.key, currentItem.key];\n  const nextValidTarget = history[history.length - 2];\n  const previousTransition = currentState.previousTransition === null ? null : { ...currentState.previousTransition };\n  const update = {\n    containerIsRemoved: { ...currentState.containerIsRemoved },\n    containerVisualIndex: { ...currentState.containerVisualIndex },\n    previousTransition,\n    visualIndex: currentState.visualIndex\n  };\n  if (nextValidTarget)\n    validTargets.push(nextValidTarget.key);\n  const shouldRemoveLastKey = currentState.containerVisualIndex[target.key] <= currentState.containerVisualIndex[currentItem.key] || target.visualIndex !== void 0 && target.visualIndex < history.length - 1;\n  const nextIndex = target.visualIndex;\n  if (shouldRemoveLastKey) {\n    update.containerIsRemoved[currentItem.key] = true;\n    update.containerVisualIndex[target.key] = nextIndex !== void 0 ? nextIndex : history.length - 1;\n  } else {\n    update.visualIndex = currentState.visualIndex + 1;\n    update.containerVisualIndex[target.key] = currentState.visualIndex + 1;\n  }\n  if (currentItem.transition.withMagicMotion)\n    update.previousTransition = currentItem.transition || null;\n  currentState.containerIsRemoved[target.key] = false;\n  return update;\n}\nfunction findLatestHistoryIndex(key6, history) {\n  for (let index = history.length; index > history.length; index--) {\n    if (history[index].key === key6)\n      return index;\n  }\n  return -1;\n}\nfunction updateTransitions(current, previous, history, containerIndex, transitionForContainer) {\n  const transitions = { ...transitionForContainer };\n  Object.keys(containerIndex).forEach((key6) => {\n    const transition = transitionForScreen(containerIndex[key6], { current, previous, history });\n    if (transition) {\n      transitions[key6] = transition;\n    }\n  });\n  return transitions;\n}\nfunction isNextTargetForward(key6, index, removed, history) {\n  if (removed)\n    return true;\n  if (index === 0)\n    return false;\n  const forwardHistory = history.slice(index, history.length);\n  if (forwardHistory.findIndex((item) => item.key === key6) > -1)\n    return true;\n  const backwardsHistory = history.slice(0, index - 1);\n  if (backwardsHistory.findIndex((item) => item.key === key6) > -1)\n    return false;\n  return true;\n}\nfunction transitionForScreen(screenIndex, stackState) {\n  const { current, previous, history } = stackState;\n  if (screenIndex !== current && screenIndex !== previous)\n    return void 0;\n  if (screenIndex === current && current > previous) {\n    const item = history[screenIndex];\n    return sequence(\"enter\", item.transition.enter, item.transition.animation);\n  }\n  if (screenIndex === previous && current > previous) {\n    const item = history[screenIndex + 1];\n    return sequence(\"exit\", item.transition.exit, item.transition.animation);\n  }\n  if (screenIndex === current && current < previous) {\n    const item = history[screenIndex + 1];\n    return sequence(\"enter\", item.transition.exit, item.transition.animation);\n  }\n  if (screenIndex === previous && current < previous) {\n    const item = history[screenIndex];\n    return sequence(\"exit\", item.transition.enter, item.transition.animation);\n  }\n}\nvar allAnimatableKeys = Object.keys(allAnimatableProperties);\nfunction sequence(direction, transition, animation) {\n  const value = {};\n  const from = {};\n  allAnimatableKeys.forEach((property) => {\n    value[property] = allAnimatableProperties[property];\n    from[property] = {\n      ...animation,\n      from: allAnimatableProperties[property]\n    };\n  });\n  if (transition) {\n    Object.keys(transition).forEach((property) => {\n      if (transition[property] === void 0)\n        return;\n      const transitionTo = transition[property];\n      const transitionFrom = typeof transition[property] === \"string\" ? `${allAnimatableProperties[property]}%` : allAnimatableProperties[property];\n      value[property] = direction === \"enter\" ? transitionFrom : transitionTo;\n      from[property] = {\n        ...animation,\n        from: direction === \"enter\" ? transitionTo : transitionFrom,\n        velocity: 0\n      };\n    });\n  }\n  return {\n    ...value,\n    transition: {\n      ...from\n    }\n  };\n}\n\n// src/components/Navigation.tsx\nvar NavigationContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(navigatorMock);\nvar NavigationConsumer = NavigationContext.Consumer;\nvar NavigationCallbackContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nvar NavigationCallbackProvider = NavigationCallbackContext.Provider;\nvar Navigation = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor() {\n    super(...arguments);\n    this.lastEventTimeStamp = null;\n    this.state = defaultState();\n    this.navigationAction = (action) => {\n      var _a;\n      if (!this.props.enabled && this.state.history.length > 0)\n        return;\n      const newState = reduceNavigationStateForAction(this.state, action);\n      if (newState) {\n        this.setState(newState);\n        const currentItem = newState.history[newState.current];\n        (_a = this.context) == null ? void 0 : _a.call(this, currentItem.key);\n      }\n    };\n    this.goBack = () => {\n      var _a;\n      if (this.isSameEventTransition())\n        return;\n      this.lastEventTimeStamp = ((_a = globalThis.event) == null ? void 0 : _a.timeStamp) || null;\n      if (this.state.currentOverlay !== -1)\n        return this.navigationAction({ type: \"removeOverlay\" });\n      return this.navigationAction({ type: \"remove\" });\n    };\n  }\n  componentDidMount() {\n    if (this.state.history.length === 0) {\n      this.transition(this.props.children, TransitionDefaults.Instant);\n    }\n    injectComponentCSSRules();\n  }\n  UNSAFE_componentWillReceiveProps(props) {\n    var _a;\n    const component = props[\"children\"];\n    if (!isReactChild(component) || !isReactElement(component))\n      return;\n    const key6 = (_a = component.key) == null ? void 0 : _a.toString();\n    if (!key6)\n      return;\n    if (this.state.history.length === 0) {\n      this.transition(component, TransitionDefaults.Instant);\n    } else {\n      this.navigationAction({ type: \"update\", key: key6, component });\n    }\n  }\n  getStackState(options) {\n    const { current, previous, currentOverlay, previousOverlay } = this.state;\n    if (options.overCurrentContext) {\n      return {\n        current: currentOverlay,\n        previous: previousOverlay,\n        history: this.state.overlayStack\n      };\n    }\n    return {\n      current,\n      previous,\n      history: this.state.history\n    };\n  }\n  isSameEventTransition() {\n    if (!globalThis.event)\n      return false;\n    return this.lastEventTimeStamp === globalThis.event.timeStamp;\n  }\n  transition(component, transitionTraits, transitionOptions) {\n    var _a, _b;\n    if (this.isSameEventTransition())\n      return;\n    this.lastEventTimeStamp = ((_a = globalThis.event) == null ? void 0 : _a.timeStamp) || null;\n    if (!component || !isReactChild(component) || !isReactElement(component))\n      return;\n    const transition = { ...transitionTraits, ...transitionOptions };\n    const overCurrentContext = !!transition.overCurrentContext;\n    if (overCurrentContext)\n      return this.navigationAction({ type: \"addOverlay\", transition, component });\n    const key6 = ((_b = component == null ? void 0 : component.key) == null ? void 0 : _b.toString()) || `stack-${this.state.historyItemId + 1}`;\n    this.navigationAction({ type: \"add\", key: key6, transition, component });\n  }\n  instant(component) {\n    this.transition(component, TransitionDefaults.Instant);\n  }\n  fade(component, options) {\n    this.transition(component, TransitionDefaults.Fade, options);\n  }\n  push(component, options) {\n    this.transition(component, pushTransition(options), options);\n  }\n  modal(component, options) {\n    this.transition(component, TransitionDefaults.Modal, options);\n  }\n  overlay(component, options) {\n    this.transition(component, overlayTransition(options), options);\n  }\n  flip(component, options) {\n    this.transition(component, flipTransition(options), options);\n  }\n  magicMotion(component, options) {\n    this.transition(component, TransitionDefaults.MagicMotion, options);\n  }\n  customTransition(component, transition) {\n    this.transition(component, transition);\n  }\n  render() {\n    const stackState = this.getStackState({ overCurrentContext: false });\n    const overlayStackState = this.getStackState({ overCurrentContext: true });\n    const activeOverlay = activeOverlayItem(overlayStackState);\n    const isOverlayVisible = overlayStackState.current > -1;\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FrameWithMotion, {\n      top: 0,\n      left: 0,\n      width: \"100%\",\n      height: \"100%\",\n      position: \"relative\",\n      style: { overflow: \"hidden\", backgroundColor: \"unset\", ...this.props.style }\n    }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(NavigationContext.Provider, {\n      value: this\n    }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(NavigationContainer, {\n      isLayeredContainer: true,\n      position: void 0,\n      initialProps: {},\n      instant: false,\n      transitionProps: transitionPropsForStackWrapper(activeOverlay),\n      animation: animationForStackWrapper(activeOverlay),\n      backfaceVisible: backfaceVisibleForStackWrapper(activeOverlay),\n      visible: true,\n      backdropColor: void 0,\n      onTapBackdrop: void 0,\n      index: 0\n    }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(LayoutIdProvider, null, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(AnimateLayoutTrees, null, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(AnimatePresence, {\n      presenceAffectsLayout: false\n    }, Object.keys(this.state.containers).map((key6) => {\n      var _a, _b, _c, _d, _e;\n      const component = this.state.containers[key6];\n      const index = this.state.containerIndex[key6];\n      const visualIndex = this.state.containerVisualIndex[key6];\n      const removed = this.state.containerIsRemoved[key6];\n      const historyItem = this.state.history[index];\n      const transitionProps = this.state.transitionForContainer[key6];\n      const isCurrent = index === this.state.current;\n      const isPrevious = index === this.state.previous;\n      const areMagicMotionLayersPresent = isCurrent ? false : removed;\n      const withMagicMotion = ((_a = historyItem == null ? void 0 : historyItem.transition) == null ? void 0 : _a.withMagicMotion) || isCurrent && !!this.state.previousTransition;\n      return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(NavigationContainer, {\n        key: key6,\n        id: key6,\n        index: visualIndex,\n        isCurrent,\n        isPrevious,\n        isOverlayed: isOverlayVisible,\n        visible: isCurrent || isPrevious,\n        position: (_b = historyItem == null ? void 0 : historyItem.transition) == null ? void 0 : _b.position,\n        instant: isInstantContainerTransition(index, stackState),\n        transitionProps,\n        animation: animationPropsForContainer(index, stackState),\n        backfaceVisible: getBackfaceVisibleForScreen(index, stackState),\n        exitAnimation: (_c = historyItem == null ? void 0 : historyItem.transition) == null ? void 0 : _c.animation,\n        exitBackfaceVisible: (_d = historyItem == null ? void 0 : historyItem.transition) == null ? void 0 : _d.backfaceVisible,\n        exitProps: (_e = historyItem == null ? void 0 : historyItem.transition) == null ? void 0 : _e.enter,\n        withMagicMotion,\n        areMagicMotionLayersPresent: areMagicMotionLayersPresent ? false : void 0\n      }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n        fallback: \"Loading...\"\n      }, containerContent({\n        component,\n        transition: historyItem == null ? void 0 : historyItem.transition\n      })));\n    }))))), /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(AnimatePresence, null, this.state.overlayStack.map((item, stackIndex) => {\n      return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(NavigationContainer, {\n        isLayeredContainer: true,\n        key: item.key,\n        isCurrent: stackIndex === this.state.currentOverlay,\n        position: item.transition.position,\n        initialProps: initialPropsForOverlay(stackIndex, overlayStackState),\n        transitionProps: transitionPropsForOverlay(stackIndex, overlayStackState),\n        instant: isInstantContainerTransition(stackIndex, overlayStackState, true),\n        animation: animationPropsForContainer(stackIndex, overlayStackState),\n        exitProps: item.transition.enter,\n        visible: containerIsVisible(stackIndex, overlayStackState),\n        backdropColor: backdropColorForTransition(item.transition),\n        backfaceVisible: getBackfaceVisibleForOverlay(stackIndex, overlayStackState),\n        onTapBackdrop: backdropTapAction(item.transition, this.goBack),\n        index: this.state.current + 1 + stackIndex\n      }, containerContent({ component: item.component, transition: item.transition }));\n    }))));\n  }\n};\nNavigation.defaultProps = {\n  enabled: true\n};\nNavigation.contextType = NavigationCallbackContext;\nvar animationDefault = {\n  stiffness: 500,\n  damping: 50,\n  restDelta: 1,\n  type: \"spring\"\n};\nfunction activeOverlayItem(overlayStack) {\n  let currentOverlayItem;\n  let previousOverlayItem;\n  if (overlayStack.current !== -1) {\n    currentOverlayItem = overlayStack.history[overlayStack.current];\n  } else {\n    previousOverlayItem = overlayStack.history[overlayStack.previous];\n  }\n  return { currentOverlayItem, previousOverlayItem };\n}\nfunction transitionPropsForStackWrapper({ currentOverlayItem }) {\n  return currentOverlayItem && currentOverlayItem.transition.exit;\n}\nfunction animationForStackWrapper({ currentOverlayItem, previousOverlayItem }) {\n  if (currentOverlayItem && currentOverlayItem.transition.animation) {\n    return currentOverlayItem.transition.animation;\n  }\n  if (previousOverlayItem && previousOverlayItem.transition.animation) {\n    return previousOverlayItem.transition.animation;\n  }\n  return animationDefault;\n}\nfunction backfaceVisibleForStackWrapper({ currentOverlayItem, previousOverlayItem }) {\n  if (currentOverlayItem)\n    return currentOverlayItem.transition.backfaceVisible;\n  return previousOverlayItem && previousOverlayItem.transition.backfaceVisible;\n}\nfunction backdropColorForTransition(transition) {\n  if (transition.backdropColor)\n    return transition.backdropColor;\n  if (transition.overCurrentContext)\n    return \"rgba(4,4,15,.4)\";\n  return void 0;\n}\nfunction getBackfaceVisibleForOverlay(containerIndex, stackState) {\n  const { current, history } = stackState;\n  if (containerIndex === current) {\n    const navigationItem = history[containerIndex];\n    if (navigationItem && navigationItem.transition) {\n      return navigationItem.transition.backfaceVisible;\n    }\n    return true;\n  } else if (containerIndex < current) {\n    const navigationItem = history[containerIndex + 1];\n    if (navigationItem && navigationItem.transition) {\n      return navigationItem.transition.backfaceVisible;\n    }\n    return true;\n  } else {\n    const navigationItem = history[containerIndex];\n    if (navigationItem && navigationItem.transition) {\n      return navigationItem.transition.backfaceVisible;\n    }\n    return true;\n  }\n}\nfunction initialPropsForOverlay(containerIndex, stackState) {\n  const navigationItem = stackState.history[containerIndex];\n  if (navigationItem)\n    return navigationItem.transition.enter;\n}\nfunction getBackfaceVisibleForScreen(screenIndex, stackState) {\n  var _a, _b, _c, _d;\n  const { current, previous, history } = stackState;\n  if (screenIndex === previous && current > previous || screenIndex === current && current < previous) {\n    return (_b = (_a = history[screenIndex + 1]) == null ? void 0 : _a.transition) == null ? void 0 : _b.backfaceVisible;\n  }\n  return (_d = (_c = history[screenIndex]) == null ? void 0 : _c.transition) == null ? void 0 : _d.backfaceVisible;\n}\nfunction transitionPropsForOverlay(overlayIndex, stackState) {\n  const { current, history } = stackState;\n  if (overlayIndex === current) {\n    return;\n  } else if (overlayIndex < current) {\n    const navigationItem = history[overlayIndex + 1];\n    if (navigationItem && navigationItem.transition) {\n      return navigationItem.transition.exit;\n    }\n  } else {\n    const navigationItem = history[overlayIndex];\n    if (navigationItem && navigationItem.transition) {\n      return navigationItem.transition.enter;\n    }\n  }\n}\nfunction animationPropsForContainer(containerIndex, stackState) {\n  const { current, previous, history } = stackState;\n  const containerCurrent = previous > current ? previous : current;\n  if (containerIndex < containerCurrent) {\n    const navigationItem = history[containerIndex + 1];\n    if (navigationItem && navigationItem.transition.animation) {\n      return navigationItem.transition.animation;\n    }\n  } else if (containerIndex !== containerCurrent) {\n    const navigationItem = history[containerIndex];\n    if (navigationItem && navigationItem.transition.animation) {\n      return navigationItem.transition.animation;\n    }\n  } else {\n    const navigationItem = history[containerIndex];\n    if (navigationItem.transition.animation) {\n      return navigationItem.transition.animation;\n    }\n  }\n  return animationDefault;\n}\nfunction isInstantContainerTransition(containerIndex, stackState, overCurrentContext) {\n  const { current, previous, history } = stackState;\n  if (overCurrentContext && history.length > 1)\n    return true;\n  if (containerIndex !== previous && containerIndex !== current)\n    return true;\n  if (current === previous)\n    return true;\n  return false;\n}\nfunction containerIsVisible(containerIndex, stackState) {\n  const { current, previous } = stackState;\n  if (containerIndex > current && containerIndex > previous)\n    return false;\n  if (containerIndex === current)\n    return true;\n  return false;\n}\nfunction containerContent(item) {\n  return react__WEBPACK_IMPORTED_MODULE_0__.Children.map(item.component, (child) => {\n    var _a;\n    if (!isReactChild(child) || !isReactElement(child) || !child.props) {\n      return child;\n    }\n    const props = {\n      style: child.props.style\n    };\n    const position = (_a = item == null ? void 0 : item.transition) == null ? void 0 : _a.position;\n    const shouldStretchWidth = !position || position.left !== void 0 && position.right !== void 0;\n    const shouldStretchHeight = !position || position.top !== void 0 && position.bottom !== void 0;\n    const canStretchStyle = \"style\" in child.props;\n    if (shouldStretchWidth) {\n      const canStretchWidth = \"width\" in child.props;\n      if (canStretchWidth)\n        props.width = \"100%\";\n      if (canStretchStyle && !canStretchWidth)\n        props.style.width = \"100%\";\n    }\n    if (shouldStretchHeight) {\n      const canStretchHeight = \"height\" in child.props;\n      if (canStretchHeight)\n        props.height = \"100%\";\n      if (canStretchStyle && !canStretchHeight)\n        props.style.height = \"100%\";\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(child, props);\n  });\n}\nfunction backdropTapAction(transition, goBackAction) {\n  if (transition.goBackOnTapOutside !== false)\n    return goBackAction;\n}\n\n// src/components/Page/EmulatedPage.tsx\n\n\n// src/components/Page/PageContainer.tsx\n\n\n// src/components/Stack/Stack.tsx\n\n\n// src/components/utils/paddingFromProps.ts\nfunction hasPaddingPerSide(props) {\n  const { paddingPerSide, paddingTop, paddingBottom, paddingLeft, paddingRight } = props;\n  return paddingPerSide !== false && (paddingTop !== void 0 || paddingBottom !== void 0 || paddingLeft !== void 0 || paddingRight !== void 0);\n}\nfunction paddingFromProps(props) {\n  const { padding = 0, paddingTop, paddingBottom, paddingLeft, paddingRight } = props;\n  if (hasPaddingPerSide(props)) {\n    return {\n      top: paddingTop !== void 0 ? paddingTop : padding,\n      bottom: paddingBottom !== void 0 ? paddingBottom : padding,\n      left: paddingLeft !== void 0 ? paddingLeft : padding,\n      right: paddingRight !== void 0 ? paddingRight : padding\n    };\n  }\n  return {\n    top: padding,\n    bottom: padding,\n    left: padding,\n    right: padding\n  };\n}\nfunction makePaddingString({\n  top,\n  left,\n  bottom,\n  right\n}) {\n  return `${top}px ${right}px ${bottom}px ${left}px`;\n}\n\n// src/components/Stack/Stack.tsx\nvar Stack = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)((0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function Stack2(stackProps, ref) {\n  var _a, _b;\n  const {\n    direction = \"vertical\",\n    distribution = \"start\",\n    alignment = \"center\",\n    gap = 10,\n    children,\n    style: styleProp,\n    className,\n    willChangeTransform,\n    __fromCodeComponentNode,\n    parentSize,\n    __contentWrapperStyle,\n    ...containerProps\n  } = stackProps;\n  injectComponentCSSRules();\n  const flexDirection = toFlexDirection(direction);\n  const isReverse = isReverseDirection(flexDirection);\n  const justifyContent = toJustifyOrAlignment(distribution);\n  const padding = hasPaddingPerSide(containerProps) || containerProps.padding ? makePaddingString(paddingFromProps(containerProps)) : void 0;\n  const style = { ...styleProp };\n  Layer.applyWillChange({ willChangeTransform }, style, true);\n  if (__fromCodeComponentNode && !constraintsEnabled(unwrapFrameProps(containerProps))) {\n    containerProps.width = \"100%\";\n    containerProps.height = \"100%\";\n    containerProps._constraints = { enabled: true };\n  }\n  const layoutId = useLayoutId2(stackProps);\n  const { children: _children, props } = processOverrideForwarding(containerProps, children);\n  const widthType = (_a = containerProps.widthType) != null ? _a : containerProps.width === \"auto\" ? DimensionType.Auto : DimensionType.FixedNumber;\n  const heightType = (_b = containerProps.heightType) != null ? _b : containerProps.height === \"auto\" ? DimensionType.Auto : DimensionType.FixedNumber;\n  const fractionChildren = handleFraction(_children, direction, widthType, heightType);\n  const gapChildren = wrapInGapElement(fractionChildren, gap, flexDirection, justifyContent);\n  const content = useProvideParentSize(gapChildren, parentSize != null ? parentSize : ParentSizeState.Disabled);\n  const attributes = {\n    \"data-framer-component-type\": \"Stack\"\n  };\n  if (containerProps.__fromCanvasComponent)\n    attributes[\"data-framer-generated\"] = true;\n  const contentWrapperStyle = {\n    display: \"flex\",\n    flexDirection,\n    justifyContent,\n    alignItems: toJustifyOrAlignment(alignment),\n    padding,\n    ...__contentWrapperStyle\n  };\n  if (contentWrapperStyle.width === void 0) {\n    contentWrapperStyle.width = widthType === DimensionType.Auto ? \"min-content\" : \"100%\";\n  }\n  if (contentWrapperStyle.height === void 0) {\n    contentWrapperStyle.height = heightType === DimensionType.Auto ? \"min-content\" : \"100%\";\n  }\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FrameWithMotion, {\n    background: \"none\",\n    ...props,\n    layoutId,\n    ref,\n    ...attributes,\n    style,\n    className\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(motion.div, {\n    \"data-framer-stack-content-wrapper\": true,\n    \"data-framer-stack-direction-reverse\": isReverse,\n    style: contentWrapperStyle\n  }, content));\n}));\nStack.displayName = \"Stack\";\nfunction isFractionDimension(dimension) {\n  return typeof dimension === \"string\" && dimension.endsWith(\"fr\");\n}\nfunction fraction(dimension) {\n  const value = parseFloat(dimension);\n  return isFiniteNumber(value) ? value : 0;\n}\nfunction handleFraction(children, direction, widthType, heightType) {\n  return react__WEBPACK_IMPORTED_MODULE_0__.Children.map(children, (child) => {\n    if (!isReactChild(child) || !isReactElement(child))\n      return;\n    const isVertical = direction === \"vertical\";\n    const style = {};\n    let hasFraction = false;\n    const { style: propsStyle, size: size2 } = child.props;\n    let { width, height } = child.props;\n    if (size2 !== void 0) {\n      if (width === void 0)\n        width = size2;\n      if (height === void 0)\n        height = size2;\n    }\n    let newWidth = width;\n    let newHeight = height;\n    if (isFractionDimension(width)) {\n      hasFraction = true;\n      hasFraction = true;\n      if (isVertical) {\n        if (widthType === DimensionType.Auto) {\n          style.alignSelf = \"stretch\";\n          newWidth = \"auto\";\n        } else {\n          newWidth = `${fraction(width) * 100}%`;\n        }\n      } else {\n        newWidth = 1;\n        style.flexGrow = fraction(width);\n        style.flexBasis = 0;\n      }\n      style.width = newWidth;\n    }\n    if (isFractionDimension(height)) {\n      hasFraction = true;\n      if (isVertical) {\n        newHeight = 1;\n        style.flexGrow = fraction(height);\n        style.flexBasis = 0;\n      } else {\n        if (heightType === DimensionType.Auto) {\n          style.alignSelf = \"stretch\";\n          newHeight = \"auto\";\n        } else {\n          newHeight = `${fraction(height) * 100}%`;\n        }\n      }\n      style.height = newHeight;\n    }\n    if (!hasFraction)\n      return child;\n    const nextStyle = { ...propsStyle, ...style };\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(child, {\n      width: newWidth,\n      height: newHeight,\n      style: nextStyle\n    });\n  });\n}\nfunction isGapEnabled(gap, justifyContent) {\n  if (!gap) {\n    return false;\n  }\n  if (justifyContent && [\"space-between\", \"space-around\", \"space-evenly\", \"stretch\"].includes(justifyContent)) {\n    return false;\n  }\n  return true;\n}\nfunction wrapInGapElement(children, gap, direction, justifyContent) {\n  if (!isGapEnabled(gap, justifyContent)) {\n    return children;\n  }\n  const isVertical = isVerticalDirection(direction);\n  const gapStyle = {\n    display: \"contents\",\n    [\"--stack-gap-x\"]: `${isVertical ? 0 : gap}px`,\n    [\"--stack-gap-y\"]: `${isVertical ? gap : 0}px`\n  };\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n    \"data-framer-stack-gap\": true,\n    style: gapStyle\n  }, children);\n}\nfunction toFlexDirection(direction) {\n  switch (direction) {\n    case \"vertical\":\n      return \"column\";\n    case \"horizontal\":\n      return \"row\";\n    default:\n      return direction;\n  }\n}\nfunction isVerticalDirection(direction) {\n  return direction === \"column\" || direction === \"column-reverse\";\n}\nfunction isReverseDirection(direction) {\n  switch (direction) {\n    case \"column-reverse\":\n    case \"row-reverse\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction toJustifyOrAlignment(distribution) {\n  switch (distribution) {\n    case \"start\":\n      return \"flex-start\";\n    case \"end\":\n      return \"flex-end\";\n    default:\n      return distribution;\n  }\n}\naddPropertyControls(Stack, {\n  direction: {\n    type: ControlType.SegmentedEnum,\n    options: [\"horizontal\", \"vertical\"],\n    title: \"Direction\",\n    defaultValue: \"vertical\"\n  },\n  distribution: {\n    type: ControlType.Enum,\n    options: [\"start\", \"center\", \"end\", \"space-between\", \"space-around\", \"space-evenly\"],\n    optionTitles: [\"Start\", \"Center\", \"End\", \"Space Between\", \"Space Around\", \"Space Evenly\"],\n    title: \"Distribute\",\n    defaultValue: \"space-around\"\n  },\n  alignment: {\n    type: ControlType.SegmentedEnum,\n    options: [\"start\", \"center\", \"end\"],\n    title: \"Align\",\n    defaultValue: \"center\"\n  },\n  gap: {\n    type: ControlType.Number,\n    min: 0,\n    title: \"Gap\",\n    hidden: (props) => {\n      return props.distribution !== void 0 && [\"space-between\", \"space-around\", \"space-evenly\"].includes(props.distribution);\n    },\n    defaultValue: 10\n  },\n  padding: {\n    type: ControlType.FusedNumber,\n    toggleKey: \"paddingPerSide\",\n    toggleTitles: [\"Padding\", \"Padding per side\"],\n    valueKeys: [\"paddingTop\", \"paddingRight\", \"paddingBottom\", \"paddingLeft\"],\n    valueLabels: [\"t\", \"r\", \"b\", \"l\"],\n    min: 0,\n    title: \"Padding\",\n    defaultValue: 0\n  }\n});\n\n// src/components/Page/PageContainer.tsx\nvar pageContentWrapperType = \"PageContentWrapper\";\nfunction PageContainer({\n  children,\n  effect,\n  dragEnabled,\n  direction,\n  contentHeight,\n  contentWidth,\n  alignment,\n  gap,\n  isLastPage,\n  contentOffsetRef,\n  constraintsRef,\n  directionLock,\n  onDragStart,\n  onDrag,\n  onDragEnd,\n  layoutId\n}) {\n  const isHorizontalDirection = direction === \"horizontal\";\n  const dragAxis = isHorizontalDirection ? \"x\" : \"y\";\n  const hasHorizontalGap = isHorizontalDirection && !isLastPage && gap;\n  const hasVerticalGap = !isHorizontalDirection && !isLastPage && gap;\n  const hasAutoWidth = contentWidth !== \"stretch\" && isHorizontalDirection;\n  const hasAutoHeight = contentHeight !== \"stretch\" && !isHorizontalDirection;\n  const wrapperWidth = hasAutoWidth ? \"auto\" : \"100%\";\n  const wrapperHeight = hasAutoHeight ? \"auto\" : \"100%\";\n  const containerWidth = hasHorizontalGap && wrapperWidth === \"100%\" ? `calc(100% + ${gap}px)` : wrapperWidth;\n  const containerHeight = hasVerticalGap && wrapperHeight === \"100%\" ? `calc(100% + ${gap}px)` : wrapperHeight;\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FrameWithMotion, {\n    position: \"relative\",\n    \"data-framer-component-type\": \"PageContainer\",\n    width: containerWidth,\n    height: containerHeight,\n    layoutId: layoutId ? `${layoutId}-container` : void 0,\n    backgroundColor: \"transparent\",\n    drag: dragEnabled ? dragAxis : false,\n    dragDirectionLock: directionLock,\n    _dragX: contentOffsetRef.current.x,\n    _dragY: contentOffsetRef.current.y,\n    dragConstraints: constraintsRef.current,\n    onDrag,\n    onDragStart,\n    onDragEnd,\n    preserve3d: true,\n    style: {\n      paddingRight: hasHorizontalGap ? gap : 0,\n      paddingBottom: hasVerticalGap ? gap : 0\n    }\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FrameWithMotion, {\n    position: \"relative\",\n    \"data-framer-component-type\": pageContentWrapperType,\n    width: wrapperWidth,\n    height: wrapperHeight,\n    preserve3d: false,\n    backgroundColor: \"transparent\",\n    _layoutResetTransform: true,\n    key: effect ? Object.keys(effect).join(\"\") : \"\",\n    style: {\n      ...effect,\n      display: \"flex\",\n      flexDirection: isHorizontalDirection ? \"row\" : \"column\",\n      alignItems: alignment && toJustifyOrAlignment(alignment)\n    }\n  }, children));\n}\n\n// src/components/Page/EmulatedPage.tsx\nvar Page = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function Page2(props, forwardedRef) {\n  const {\n    direction = \"horizontal\",\n    contentWidth = \"stretch\",\n    contentHeight = \"stretch\",\n    alignment = \"start\",\n    currentPage = 0,\n    animateCurrentPageUpdate = true,\n    gap: gapValue = 10,\n    padding = 0,\n    momentum = false,\n    dragEnabled = true,\n    defaultEffect = \"none\",\n    background = \"transparent\",\n    overflow = \"hidden\",\n    __fromCodeComponentNode,\n    effect,\n    children,\n    contentOffsetX,\n    contentOffsetY,\n    onChangePage,\n    onScrollStart,\n    onScroll,\n    onDragStart,\n    onDrag,\n    onDragEnd,\n    directionLock,\n    onScrollEnd,\n    onDirectionLock,\n    onUpdate,\n    wheelEnabled = false,\n    layoutId: specificLayoutId,\n    ...rest\n  } = props;\n  const layoutId = useLayoutId2(props, { specificLayoutId, postfix: \"page\" });\n  const containerProps = { ...rest, background };\n  const hasMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  const hasFixedSize = RenderTarget.hasRestrictions() && props.__fromCodeComponentNode && isFiniteNumber(containerProps.width) && isFiniteNumber(containerProps.height);\n  if (!hasFixedSize && __fromCodeComponentNode && !containerProps.__fromCanvasComponent) {\n    containerProps.width = \"100%\";\n    containerProps.height = \"100%\";\n    containerProps._constraints = { enabled: true };\n  }\n  const { initial, prev } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    initial: { x: 0, y: 0 },\n    prev: { x: 0, y: 0 }\n  }).current;\n  const isHorizontal = direction === \"horizontal\";\n  let gap = gapValue;\n  if (gap < 0) {\n    warnOnce(`The 'gap' property of Page component can not be negative, but is ${gapValue}.`);\n    gap = 0;\n  }\n  injectComponentCSSRules();\n  const pageCount = react__WEBPACK_IMPORTED_MODULE_0__.Children.count(children);\n  const maxOffsetRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n  const constraints = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({ top: 0, left: 0, right: 0, bottom: 0 });\n  const fallbackContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const containerRef = forwardedRef || fallbackContainerRef;\n  const scrollableRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const pageEffectValuesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n  const pageRectsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n  const internalX = useMotionValue(isMotionValue2(contentOffsetX) ? 0 : contentOffsetX != null ? contentOffsetX : 0);\n  const internalY = useMotionValue(isMotionValue2(contentOffsetY) ? 0 : contentOffsetY != null ? contentOffsetY : 0);\n  const contentOffsetRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    x: isMotionValue2(contentOffsetX) ? contentOffsetX : internalX,\n    y: isMotionValue2(contentOffsetY) ? contentOffsetY : internalY\n  });\n  const currentContentPageRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n  const propsBoundedCurrentPageRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n  const latestPropsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(props);\n  latestPropsRef.current = props;\n  const lastDirectionRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(props.direction);\n  const snapToPage = useSnapToPage(currentContentPageRef, contentOffsetRef, isHorizontal);\n  const [_, setForceUpdateCount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n  const containerSizeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({ width: 200, height: 200 });\n  if (hasFixedSize && isFiniteNumber(containerProps.width) && isFiniteNumber(containerProps.height)) {\n    containerSizeRef.current.width = containerProps.width;\n    containerSizeRef.current.height = containerProps.height;\n  }\n  const updateOnResize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    if (!hasFixedSize)\n      setForceUpdateCount((v) => v + 1);\n  }, [hasFixedSize]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (RenderTarget.current() !== RenderTarget.preview)\n      return;\n    globalThis.addEventListener(\"resize\", updateOnResize);\n    return () => {\n      globalThis.removeEventListener(\"resize\", updateOnResize);\n    };\n  }, [updateOnResize]);\n  const applyEffects = () => {\n    pageEffectValuesRef.current.forEach((effectDictionary, index) => {\n      const values = effectValues(index, latestPropsRef, pageRectsRef, contentOffsetRef, maxOffsetRef);\n      if (!effectDictionary || !values)\n        return;\n      for (const key6 in values) {\n        if (isMotionValue2(effectDictionary[key6])) {\n          effectDictionary[key6].set(values[key6]);\n        }\n      }\n    });\n  };\n  const updateMaxOffsetFromPageContents = (containerSize) => {\n    const newPageContentRects = getPageContentRects(containerRef, containerSize, direction, gap);\n    if (newPageContentRects)\n      pageRectsRef.current = newPageContentRects;\n    const newMaxOffset = getMaxOffset(containerSizeRef.current, pageRectsRef.current, direction, latestPropsRef.current);\n    if (newMaxOffset !== maxOffsetRef.current) {\n      maxOffsetRef.current = newMaxOffset;\n      constraints.current.top = -newMaxOffset;\n      constraints.current.left = -newMaxOffset;\n      if (RenderTarget.current() === RenderTarget.canvas)\n        setForceUpdateCount((v) => v + 1);\n    }\n  };\n  const measureContainerSize = () => {\n    const element = containerRef.current;\n    if (!element)\n      return null;\n    const { offsetWidth, offsetHeight } = element;\n    const currentSize = containerSizeRef.current;\n    if (offsetWidth !== currentSize.width || offsetHeight !== currentSize.height) {\n      containerSizeRef.current = {\n        width: offsetWidth,\n        height: offsetHeight\n      };\n      return containerSizeRef.current;\n    }\n    return null;\n  };\n  const updateAndSnapToPage = (newPage, mount = false) => {\n    const newBoundedCurrentPage = getBoundedCurrentPage(newPage, pageCount);\n    const boundedCurrentPageDidChange = newBoundedCurrentPage !== propsBoundedCurrentPageRef.current;\n    if (boundedCurrentPageDidChange) {\n      propsBoundedCurrentPageRef.current = newBoundedCurrentPage;\n      updateCurrentPage(newBoundedCurrentPage, currentContentPageRef, onChangePage);\n    }\n    const offset = offsetForPage(newBoundedCurrentPage, pageCount, pageRectsRef, isHorizontal, maxOffsetRef);\n    const animated = animateCurrentPageUpdate && RenderTarget.current() !== RenderTarget.canvas && !mount;\n    snapToPage(newBoundedCurrentPage, offset, { animated });\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    var _a;\n    if (hasMountedRef.current)\n      return;\n    currentContentPageRef.current = currentPage;\n    const contentOffset = contentOffsetRef.current;\n    contentOffset.x.onChange(applyEffects);\n    contentOffset.y.onChange(applyEffects);\n    applyEffects();\n    hasMountedRef.current = true;\n    const containerSize = (_a = measureContainerSize()) != null ? _a : containerSizeRef.current;\n    updateMaxOffsetFromPageContents(containerSize);\n    updateAndSnapToPage(currentContentPageRef.current, true);\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (currentPage !== currentContentPageRef.current)\n      updateAndSnapToPage(currentPage);\n  }, [currentPage]);\n  const handleMeasureLifecycle = () => {\n    const newContainerSize = measureContainerSize();\n    updateMaxOffsetFromPageContents(newContainerSize != null ? newContainerSize : containerSizeRef.current);\n    updateAndSnapToPage(currentContentPageRef.current);\n    if (newContainerSize || direction !== lastDirectionRef.current) {\n      if (direction === \"horizontal\") {\n        contentOffsetRef.current.y.set(0);\n      } else {\n        contentOffsetRef.current.x.set(0);\n      }\n      lastDirectionRef.current = direction;\n    }\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (RenderTarget.current() !== RenderTarget.canvas)\n      return;\n    handleMeasureLifecycle();\n  });\n  const onDragStartHandler = (event, info) => {\n    if (onScrollStart)\n      onScrollStart(info);\n    if (onDragStart)\n      onDragStart(event, info);\n    prev.x = initial.x = info.point.x;\n    prev.y = initial.y = info.point.y;\n  };\n  const onDragHandler = (event, info) => {\n    if (onScroll)\n      onScroll(info);\n    if (onDrag)\n      onDrag(event, info);\n    prev.x = info.point.x;\n    prev.y = info.point.y;\n  };\n  const onDragTransitionEnd = () => {\n    if (props.onDragTransitionEnd)\n      props.onDragTransitionEnd();\n    if (onScrollEnd) {\n      const { x, y } = contentOffsetRef.current;\n      const point = { x: x.get(), y: y.get() };\n      onScrollEnd({\n        point,\n        velocity: { x: x.getVelocity(), y: y.getVelocity() },\n        offset: { x: point.x - initial.x, y: point.y - initial.y },\n        delta: { x: point.x - prev.x, y: point.y - prev.y }\n      });\n    }\n  };\n  const onDragEndHandler = async (event, info) => {\n    const contentOffset = isHorizontal ? contentOffsetRef.current.x : contentOffsetRef.current.y;\n    contentOffset.stop();\n    const startPosition = contentOffset.get();\n    const axis = isHorizontal ? \"x\" : \"y\";\n    const velocity = info.velocity[axis];\n    let index = nearestPageIndex(pageRectsRef.current, startPosition, startPosition, isHorizontal, momentum);\n    if (velocity) {\n      inertia({\n        from: startPosition,\n        velocity,\n        modifyTarget: (endPosition) => {\n          index = nearestPageIndex(pageRectsRef.current, startPosition, endPosition, isHorizontal, momentum);\n          return endPosition;\n        }\n      }).stop();\n    }\n    updateCurrentPage(index, currentContentPageRef, onChangePage);\n    const offset = offsetForPage(index, pageCount, pageRectsRef, isHorizontal, maxOffsetRef);\n    if (onDragEnd)\n      onDragEnd(event, info);\n    const handler = contentOffsetRef.current[axis];\n    animate2(handler, offset, {\n      type: \"spring\",\n      from: startPosition,\n      velocity,\n      stiffness: 500,\n      damping: 50,\n      onComplete: onDragTransitionEnd\n    });\n  };\n  pageEffectValuesRef.current = [];\n  const childComponents = react__WEBPACK_IMPORTED_MODULE_0__.Children.map(children, (child, index) => {\n    var _a;\n    if (!isReactChild(child) || !isReactElement(child)) {\n      return child;\n    }\n    const update = {\n      right: void 0,\n      bottom: void 0,\n      top: void 0,\n      left: void 0,\n      _constraints: {\n        enabled: false\n      }\n    };\n    if (containerProps.__fromCanvasComponent) {\n      update.style = (_a = child.props.style) != null ? _a : {};\n      if (contentWidth === \"stretch\")\n        update.style.width = \"100%\";\n      if (contentHeight === \"stretch\")\n        update.style.height = \"100%\";\n    } else {\n      if (contentWidth === \"stretch\")\n        update.width = \"100%\";\n      if (contentHeight === \"stretch\")\n        update.height = \"100%\";\n    }\n    let effectDictionary;\n    const values = effectValues(index, latestPropsRef, pageRectsRef, contentOffsetRef, maxOffsetRef);\n    if (values) {\n      effectDictionary = {};\n      for (const key6 in values) {\n        effectDictionary[key6] = motionValue(values[key6]);\n      }\n    }\n    pageEffectValuesRef.current.push(effectDictionary);\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(PageContainer, {\n      key: index,\n      effect: effectDictionary,\n      dragEnabled,\n      direction,\n      contentHeight,\n      contentWidth,\n      alignment,\n      gap,\n      isLastPage: index === pageCount - 1,\n      contentOffsetRef,\n      constraintsRef: constraints,\n      directionLock,\n      onDragStart: onDragStartHandler,\n      onDrag: onDragHandler,\n      onDragEnd: onDragEndHandler,\n      layoutId: layoutId ? `${layoutId}-${index}` : void 0\n    }, (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(child, update));\n  });\n  useWheelScroll(scrollableRef, {\n    enabled: wheelEnabled,\n    initial,\n    prev,\n    direction,\n    constraints,\n    offsetX: contentOffsetRef.current.x,\n    offsetY: contentOffsetRef.current.y,\n    onScrollStart,\n    onScroll,\n    onScrollEnd\n  });\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FrameWithMotion, {\n    preserve3d: false,\n    perspective: hasEffect(props) ? 1200 : void 0,\n    overflow,\n    ...containerProps,\n    layoutId,\n    ref: containerRef,\n    onLayoutMeasure: handleMeasureLifecycle\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FrameWithMotion, {\n    \"data-framer-component-type\": \"Page\",\n    ref: scrollableRef,\n    background: null,\n    x: contentOffsetRef.current.x,\n    y: contentOffsetRef.current.y,\n    width: \"100%\",\n    height: \"100%\",\n    preserve3d: true,\n    layout: true,\n    layoutId: layoutId !== void 0 ? layoutId + \"-page\" : void 0,\n    style: {\n      padding: makePaddingString(paddingFromProps(props)),\n      display: \"flex\",\n      flexDirection: isHorizontal ? \"row\" : \"column\"\n    }\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(EmptyState, {\n    title: \"Page\",\n    description: \"Click and drag the connector to any frame on the canvas \\u2192\",\n    children,\n    size: containerSizeRef.current,\n    insideUserCodeComponent: !__fromCodeComponentNode\n  }), childComponents));\n});\nfunction cubeEffect(info) {\n  const { normalizedOffset, direction } = info;\n  const isHorizontal = direction === \"horizontal\";\n  return {\n    originX: normalizedOffset < 0 ? 1 : 0,\n    originY: normalizedOffset < 0 ? 1 : 0,\n    rotateY: isHorizontal ? Math.min(Math.max(-90, normalizedOffset * 90), 90) : 0,\n    rotateX: isHorizontal ? 0 : Math.min(Math.max(-90, normalizedOffset * -90), 90),\n    backfaceVisibility: \"hidden\",\n    WebkitBackfaceVisibility: \"hidden\"\n  };\n}\nfunction coverflowEffect(info) {\n  const { normalizedOffset, direction, size: size2 } = info;\n  const isHorizontal = direction === \"horizontal\";\n  return {\n    rotateY: isHorizontal ? Math.min(45, Math.max(-45, normalizedOffset * -45)) : 0,\n    rotateX: isHorizontal ? 0 : Math.min(45, Math.max(-45, normalizedOffset * 45)),\n    originX: isHorizontal ? normalizedOffset < 0 ? 0 : 1 : 0.5,\n    originY: isHorizontal ? 0.5 : normalizedOffset < 0 ? 0 : 1,\n    x: isHorizontal ? `${normalizedOffset * -25}%` : 0,\n    y: isHorizontal ? 0 : `${normalizedOffset * -25}%`,\n    z: -Math.abs(normalizedOffset),\n    scale: 1 - Math.abs(normalizedOffset / 10)\n  };\n}\nfunction calcPileAxisOffset(offset, length) {\n  return offset * length - offset * 8;\n}\nfunction pileEffect(info) {\n  const { normalizedOffset, direction, size: size2 } = info;\n  const isHorizontal = direction === \"horizontal\";\n  const absoluteOffset = Math.abs(normalizedOffset);\n  return {\n    x: normalizedOffset < 0 && isHorizontal ? calcPileAxisOffset(absoluteOffset, size2.width) : 0,\n    y: normalizedOffset < 0 && !isHorizontal ? calcPileAxisOffset(absoluteOffset, size2.height) : 0,\n    scale: normalizedOffset < 0 ? 1 - absoluteOffset / 50 : 1\n  };\n}\nfunction wheelEffect(info) {\n  const { normalizedOffset, direction, size: size2 } = info;\n  const isHorizontal = direction === \"horizontal\";\n  const originZ = (isHorizontal ? size2.width : size2.height) * 18 / (2 * Math.PI);\n  const rotateX = isHorizontal ? 0 : normalizedOffset * -20;\n  const rotateY = isHorizontal ? normalizedOffset * 20 : 0;\n  const y = isHorizontal ? 0 : normalizedOffset * -size2.height;\n  const x = isHorizontal ? normalizedOffset * -size2.width : 0;\n  return {\n    opacity: 1 - Math.abs(normalizedOffset) / 4,\n    transform: `translate(${x}px, ${y}px) translateZ(-${originZ}px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateZ(${originZ}px)`\n  };\n}\nfunction getDefaultEffect(type) {\n  switch (type) {\n    case \"cube\":\n      return cubeEffect;\n    case \"coverflow\":\n      return coverflowEffect;\n    case \"pile\":\n      return pileEffect;\n    case \"wheel\":\n      return wheelEffect;\n    default:\n      return null;\n  }\n}\nfunction nearestPageIndex(pageRects, startPosition, endPosition, isHorizontalDirection, allowSkippingPages) {\n  const distanceToStart = function(rect) {\n    const rectPosition = isHorizontalDirection ? rect.x : rect.y;\n    return Math.abs(rectPosition + startPosition);\n  };\n  const distanceToEnd = function(rect) {\n    const rectPosition = isHorizontalDirection ? rect.x : rect.y;\n    return Math.abs(rectPosition + endPosition);\n  };\n  if (allowSkippingPages) {\n    const closestPages = [...pageRects].sort((a2, b2) => distanceToEnd(a2) - distanceToEnd(b2));\n    return pageRects.indexOf(closestPages[0]);\n  } else {\n    const closestToStart = [...pageRects].sort((a2, b2) => distanceToStart(a2) - distanceToStart(b2));\n    if (closestToStart.length === 1)\n      return pageRects.indexOf(closestToStart[0]);\n    const pageA = closestToStart[0];\n    const pageB = closestToStart[1];\n    const closestPages = [pageA, pageB].sort((a2, b2) => distanceToEnd(a2) - distanceToEnd(b2));\n    return pageRects.indexOf(closestPages[0]);\n  }\n}\nfunction getPageContentRects(containerRef, containerSize, direction, gap) {\n  var _a;\n  const containerElement = containerRef.current;\n  if (!containerElement)\n    return;\n  const contentWrappers = [];\n  (_a = containerElement.firstChild) == null ? void 0 : _a.childNodes.forEach((node) => {\n    const childNode = node.firstChild;\n    if (!(childNode instanceof HTMLElement))\n      return;\n    const componentType = childNode.getAttribute(\"data-framer-component-type\");\n    if (componentType === pageContentWrapperType) {\n      contentWrappers.push(childNode);\n    }\n  });\n  const sizes = [];\n  contentWrappers.forEach((contentWrapper) => {\n    if (contentWrapper instanceof HTMLElement && contentWrapper.firstChild instanceof HTMLElement) {\n      let width = contentWrapper.firstChild.offsetWidth;\n      let height = contentWrapper.firstChild.offsetHeight;\n      if (false) {}\n      sizes.push({ width, height });\n    } else {\n      sizes.push(null);\n    }\n  });\n  let maxX = 0;\n  let maxY = 0;\n  const isHorizontal = direction === \"horizontal\";\n  return sizes.map((queriedSize) => {\n    const size2 = queriedSize || containerSize;\n    const x = maxX;\n    const y = maxY;\n    if (isHorizontal) {\n      maxX += size2.width + gap;\n    } else {\n      maxY += size2.height + gap;\n    }\n    return { ...size2, x, y };\n  });\n}\nfunction getMaxOffset(containerSize, pageContentRects, direction, paddingProps) {\n  const lastPageRect = pageContentRects[pageContentRects.length - 1];\n  if (!lastPageRect)\n    return 0;\n  const paddingSides = paddingFromProps(paddingProps);\n  const isHorizontal = direction === \"horizontal\";\n  const paddingStart = isHorizontal ? paddingSides.left : paddingSides.top;\n  const paddingEnd = isHorizontal ? paddingSides.right : paddingSides.bottom;\n  const pageWidth = isHorizontal ? lastPageRect.width : lastPageRect.height;\n  const containerWidth = isHorizontal ? containerSize.width : containerSize.height;\n  const freeSpace = containerWidth - paddingStart - paddingEnd - pageWidth;\n  const target = isHorizontal ? lastPageRect.x : lastPageRect.y;\n  if (freeSpace <= 0)\n    return Math.max(target, 0);\n  return Math.max(target - freeSpace, 0);\n}\nfunction offsetForPage(index, pageCount, pageRectsRef, isHorizontal, maxOffsetRef) {\n  const pageIndex = Math.max(0, Math.min(pageCount - 1, index));\n  const currentPageRect = pageRectsRef.current[pageIndex];\n  if (!currentPageRect) {\n    return 0;\n  }\n  if (isHorizontal) {\n    return -Math.min(currentPageRect.x, maxOffsetRef.current);\n  } else {\n    return -Math.min(currentPageRect.y, maxOffsetRef.current);\n  }\n}\nfunction useSnapToPage(currentContentPageRef, contentOffsetRef, isHorizontal) {\n  return (pageIndex, offset, options) => {\n    currentContentPageRef.current = pageIndex;\n    const contentOffset = isHorizontal ? contentOffsetRef.current.x : contentOffsetRef.current.y;\n    if (!options || !options.animated) {\n      contentOffset.set(offset);\n      return;\n    }\n    const axis = isHorizontal ? \"x\" : \"y\";\n    animate2(contentOffsetRef.current[axis], offset, {\n      type: \"spring\",\n      from: contentOffset.get(),\n      velocity: contentOffset.getVelocity(),\n      stiffness: 500,\n      damping: 50\n    });\n  };\n}\nfunction getBoundedCurrentPage(pageIndex, pageCount) {\n  return pageIndex >= 0 ? Math.min(pageIndex, pageCount - 1) : (pageIndex % pageCount + pageCount) % pageCount;\n}\nfunction effectValues(index, latestPropsRef, pageRectsRef, contentOffsetRef, maxOffsetRef) {\n  const {\n    direction: latestDirection = \"horizontal\",\n    defaultEffect: latestDefaultEffect,\n    effect: latestEffect,\n    gap: latestGap = 0\n  } = latestPropsRef.current;\n  const latestIsHorizontal = latestDirection === \"horizontal\";\n  const pageRect = pageRectsRef.current[index] || {\n    x: latestIsHorizontal ? index * 200 + latestGap : 0,\n    y: latestIsHorizontal ? 0 : index * 200 + latestGap,\n    width: 200,\n    height: 200\n  };\n  const effectFunction = latestEffect || getDefaultEffect(latestDefaultEffect);\n  if (!effectFunction)\n    return null;\n  let offset;\n  let normalizedOffset;\n  const contentOffset = contentOffsetRef.current;\n  const maxScrollOffset = maxOffsetRef.current;\n  if (latestIsHorizontal) {\n    offset = Math.min(pageRect.x, maxScrollOffset) + (contentOffset ? contentOffset.x.get() : 0);\n    normalizedOffset = offset / (pageRect.width + latestGap);\n  } else {\n    offset = Math.min(pageRect.y, maxScrollOffset) + (contentOffset ? contentOffset.y.get() : 0);\n    normalizedOffset = offset / (pageRect.height + latestGap);\n  }\n  const size2 = { width: pageRect.width, height: pageRect.height };\n  return effectFunction({\n    offset,\n    normalizedOffset,\n    size: size2,\n    index,\n    direction: latestDirection,\n    gap: latestGap,\n    pageCount: pageRectsRef.current.length\n  });\n}\nfunction hasEffect(props) {\n  return !!props.effect || !!getDefaultEffect(props.defaultEffect);\n}\nfunction updateCurrentPage(newPageIndex, currentContentPageRef, onChangePage) {\n  if (currentContentPageRef.current === newPageIndex)\n    return;\n  if (onChangePage)\n    onChangePage(newPageIndex, currentContentPageRef.current);\n  currentContentPageRef.current = newPageIndex;\n}\n\n// src/components/Page/Page.tsx\nvar ContentDimension;\n(function(ContentDimension2) {\n  ContentDimension2.Auto = \"auto\";\n  ContentDimension2.Stretch = \"stretch\";\n})(ContentDimension || (ContentDimension = {}));\nvar pageContentDimensionOptions = [ContentDimension.Auto, ContentDimension.Stretch];\nvar pageContentDimensionTitles = pageContentDimensionOptions.map((option) => {\n  switch (option) {\n    case ContentDimension.Auto:\n      return \"Auto\";\n    case ContentDimension.Stretch:\n      return \"Stretch\";\n  }\n});\nvar pageEffectOptions = [\"none\", \"cube\", \"coverflow\", \"wheel\", \"pile\"];\nvar pageEffectTitles = pageEffectOptions.map((option) => {\n  switch (option) {\n    case \"none\":\n      return \"None\";\n    case \"cube\":\n      return \"Cube\";\n    case \"coverflow\":\n      return \"Cover Flow\";\n    case \"wheel\":\n      return \"Wheel\";\n    case \"pile\":\n      return \"Pile\";\n  }\n});\nvar pageAlignmentOptions = [\"start\", \"center\", \"end\"];\nvar genericAlignmentTitles = pageAlignmentOptions.map((option) => {\n  switch (option) {\n    case \"start\":\n      return \"Start\";\n    case \"center\":\n      return \"Center\";\n    case \"end\":\n      return \"End\";\n  }\n});\naddPropertyControls(Page, {\n  direction: {\n    type: ControlType.Enum,\n    options: [\"horizontal\", \"vertical\"],\n    title: \"Direction\",\n    defaultValue: \"horizontal\",\n    displaySegmentedControl: true,\n    optionIcons: [\"direction-horizontal\", \"direction-vertical\"]\n  },\n  directionLock: {\n    type: ControlType.Boolean,\n    title: \"Lock\",\n    enabledTitle: \"1 Axis\",\n    disabledTitle: \"Off\",\n    defaultValue: true\n  },\n  contentWidth: {\n    type: ControlType.Enum,\n    options: pageContentDimensionOptions,\n    optionTitles: pageContentDimensionTitles,\n    title: \"Width\",\n    defaultValue: ContentDimension.Stretch,\n    displaySegmentedControl: true\n  },\n  contentHeight: {\n    type: ControlType.Enum,\n    options: pageContentDimensionOptions,\n    optionTitles: pageContentDimensionTitles,\n    title: \"Height\",\n    defaultValue: ContentDimension.Stretch,\n    displaySegmentedControl: true\n  },\n  alignment: {\n    type: ControlType.Enum,\n    options: pageAlignmentOptions,\n    optionTitles: genericAlignmentTitles,\n    title: \"Align\",\n    hidden(props) {\n      const { direction, contentWidth, contentHeight } = props;\n      const isHorizontalDirection = direction === \"horizontal\";\n      const crossDimension = isHorizontalDirection ? contentHeight : contentWidth;\n      return crossDimension === ContentDimension.Stretch;\n    },\n    defaultValue: \"start\",\n    displaySegmentedControl: true,\n    optionIcons: {\n      direction: {\n        horizontal: [\"align-top\", \"align-middle\", \"align-bottom\"],\n        vertical: [\"align-left\", \"align-center\", \"align-right\"]\n      }\n    }\n  },\n  gap: {\n    type: ControlType.Number,\n    min: 0,\n    title: \"Gap\",\n    defaultValue: 0\n  },\n  padding: {\n    type: ControlType.FusedNumber,\n    toggleKey: \"paddingPerSide\",\n    toggleTitles: [\"Padding\", \"Padding per side\"],\n    valueKeys: [\"paddingTop\", \"paddingRight\", \"paddingBottom\", \"paddingLeft\"],\n    valueLabels: [\"T\", \"R\", \"B\", \"L\"],\n    min: 0,\n    title: \"Padding\",\n    defaultValue: 0\n  },\n  currentPage: {\n    type: ControlType.Number,\n    min: 0,\n    title: \"Current\",\n    displayStepper: true,\n    defaultValue: 0\n  },\n  momentum: {\n    type: ControlType.Boolean,\n    enabledTitle: \"On\",\n    disabledTitle: \"Off\",\n    title: \"Momentum\",\n    defaultValue: false\n  },\n  dragEnabled: {\n    type: ControlType.Boolean,\n    title: \"Drag\",\n    enabledTitle: \"On\",\n    disabledTitle: \"Off\",\n    defaultValue: true\n  },\n  wheelEnabled: {\n    type: ControlType.Boolean,\n    title: \"Wheel\",\n    enabledTitle: \"On\",\n    disabledTitle: \"Off\",\n    defaultValue: false\n  },\n  defaultEffect: {\n    type: ControlType.Enum,\n    options: pageEffectOptions,\n    optionTitles: pageEffectTitles,\n    title: \"Effect\",\n    defaultValue: \"none\"\n  },\n  children: {\n    type: ControlType.Array,\n    title: \"Content\",\n    control: { type: ControlType.ComponentInstance, title: \"Page\" }\n  }\n});\nPage.supportsConstraints = true;\n\n// src/components/hoc/WithNavigator.tsx\n\n\n// src/render/types/NavigationLink.ts\nvar NavigateTo;\n(function(NavigateTo2) {\n  NavigateTo2[\"Previous\"] = \"@Previous\";\n})(NavigateTo || (NavigateTo = {}));\nvar NavigationTransitionType;\n(function(NavigationTransitionType2) {\n  NavigationTransitionType2[\"push\"] = \"push\";\n  NavigationTransitionType2[\"instant\"] = \"instant\";\n  NavigationTransitionType2[\"fade\"] = \"fade\";\n  NavigationTransitionType2[\"modal\"] = \"modal\";\n  NavigationTransitionType2[\"overlay\"] = \"overlay\";\n  NavigationTransitionType2[\"flip\"] = \"flip\";\n  NavigationTransitionType2[\"magicMotion\"] = \"magicMotion\";\n})(NavigationTransitionType || (NavigationTransitionType = {}));\n\n// src/components/hoc/WithNavigator.tsx\nvar hoistNonReactStatic3 = require_hoist_non_react_statics_cjs();\nfunction WithNavigator(BaseComponent, navigationTransition, navigationTransitionDirection, NavigationTarget2, navigationTransitionOptions) {\n  const InternalWithNavigator = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    render() {\n      return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(NavigationContext.Consumer, null, (navigation) => {\n        const navigate = () => {\n          if (navigationTransition === \"goBack\") {\n            navigation.goBack();\n            return;\n          }\n          if (!NavigationTarget2)\n            return;\n          const component = NavigationTarget2();\n          const appearsFrom = transitionDirectionToSide(navigationTransitionDirection);\n          switch (navigationTransition) {\n            case NavigationTransitionType.instant:\n              navigation.instant(component);\n              break;\n            case NavigationTransitionType.fade:\n              navigation.fade(component);\n              break;\n            case NavigationTransitionType.modal:\n              navigation.modal(component, navigationTransitionOptions);\n              break;\n            case NavigationTransitionType.push:\n              navigation.push(component, { appearsFrom });\n              break;\n            case NavigationTransitionType.overlay:\n              navigation.overlay(component, {\n                ...navigationTransitionOptions,\n                appearsFrom\n              });\n              break;\n            case NavigationTransitionType.flip:\n              navigation.flip(component, { appearsFrom });\n              break;\n            case NavigationTransitionType.magicMotion:\n              navigation.magicMotion(component, {});\n              break;\n          }\n        };\n        const { onTap, ...props } = this.props;\n        if (onTap) {\n          props.onTap = (...args) => {\n            onTap.apply(this, args);\n            navigate.apply(this, args);\n          };\n        } else {\n          props.onTap = navigate;\n        }\n        return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(BaseComponent, {\n          ...props\n        });\n      });\n    }\n  };\n  hoistNonReactStatic3(InternalWithNavigator, BaseComponent);\n  return InternalWithNavigator;\n}\nfunction transitionDirectionToSide(direction) {\n  switch (direction) {\n    case \"left\":\n      return \"right\";\n    case \"right\":\n      return \"left\";\n    case \"up\":\n      return \"bottom\";\n    case \"down\":\n      return \"top\";\n  }\n}\n\n// src/animation/Animators/PrecalculatedAnimator.ts\nvar Defaults2 = {\n  delta: 1 / 60,\n  maxValues: 1e4\n};\nvar PrecalculatedAnimator = class {\n  constructor(options) {\n    this.currentTime = 0;\n    this.options = { ...Defaults2, ...options };\n    this.animator = options.animator;\n  }\n  preCalculate() {\n    if (!this.animator.isReady()) {\n      return;\n    }\n    const { delta: delta2 } = this.options;\n    this.values = [];\n    while (!this.animator.isFinished() && this.values.length < this.options.maxValues) {\n      let value = this.animator.next(this.options.delta);\n      if (typeof value === \"object\" && value) {\n        const object = value;\n        const copy = { ...object };\n        value = copy;\n      }\n      this.values.push(value);\n    }\n    this.totalTime = this.values.length * delta2;\n  }\n  indexForTime(time3) {\n    return Math.max(0, Math.min(this.values.length - 1, Math.round(this.values.length * (time3 / this.totalTime)) - 1));\n  }\n  setFrom(value) {\n    this.animator.setFrom(value);\n    this.preCalculate();\n  }\n  setTo(end) {\n    this.animator.setTo(end);\n    this.preCalculate();\n  }\n  isReady() {\n    return this.values !== void 0 && this.values.length > 0 && this.totalTime > 0;\n  }\n  next(delta2) {\n    this.currentTime += delta2;\n    const index = this.indexForTime(this.currentTime);\n    return this.values[index];\n  }\n  isFinished() {\n    return this.totalTime === 0 || this.currentTime >= this.totalTime;\n  }\n  get endValue() {\n    this.preCalculate();\n    const index = this.indexForTime(this.totalTime);\n    return this.values.length > 0 ? this.values[index] : this.animator.next(0);\n  }\n};\n\n// src/animation/Animators/BezierAnimator.ts\nvar Bezier;\n(function(Bezier2) {\n  Bezier2[\"Linear\"] = \"linear\";\n  Bezier2[\"Ease\"] = \"ease\";\n  Bezier2[\"EaseIn\"] = \"ease-in\";\n  Bezier2[\"EaseOut\"] = \"ease-out\";\n  Bezier2[\"EaseInOut\"] = \"ease-in-out\";\n})(Bezier || (Bezier = {}));\nvar BezierDefaults = {\n  curve: Bezier.Ease,\n  duration: 1\n};\nfunction controlPointsForCurve(curve) {\n  switch (curve) {\n    case Bezier.Linear:\n      return [0, 0, 1, 1];\n    case Bezier.Ease:\n      return [0.25, 0.1, 0.25, 1];\n    case Bezier.EaseIn:\n      return [0.42, 0, 1, 1];\n    case Bezier.EaseOut:\n      return [0, 0, 0.58, 1];\n    case Bezier.EaseInOut:\n      return [0.42, 0, 0.58, 1];\n  }\n}\nvar BezierAnimator = class {\n  constructor(options, interpolation) {\n    this.interpolation = interpolation;\n    this.progress = 0;\n    this.next = (delta2) => {\n      const { duration } = this.options;\n      this.progress += delta2 / duration;\n      const value = this.unitBezier.solve(this.progress, this.solveEpsilon(duration));\n      this.current = this.interpolator(value);\n      return this.current;\n    };\n    this.options = { ...BezierDefaults, ...options };\n    let controlPoints;\n    if (typeof this.options.curve === \"string\") {\n      controlPoints = controlPointsForCurve(this.options.curve);\n    } else {\n      controlPoints = this.options.curve;\n    }\n    const [p1x, p1y, p2x, p2y] = controlPoints;\n    this.unitBezier = new UnitBezier(Point(p1x, p1y), Point(p2x, p2y));\n  }\n  setFrom(value) {\n    this.current = value;\n    this.updateInterpolator();\n  }\n  setTo(value) {\n    this.destination = value;\n    this.updateInterpolator();\n  }\n  isReady() {\n    return this.interpolator !== void 0;\n  }\n  updateInterpolator() {\n    if (this.current === void 0 || this.destination === void 0) {\n      return;\n    }\n    this.interpolator = this.interpolation.interpolate(this.current, this.destination);\n  }\n  isFinished() {\n    return this.progress >= 1;\n  }\n  solveEpsilon(duration) {\n    return 1 / (200 * duration);\n  }\n};\nvar UnitBezier = class {\n  constructor(point1, point2) {\n    this.c = Point.multiply(point1, 3);\n    this.b = Point.subtract(Point.multiply(Point.subtract(point2, point1), 3), this.c);\n    this.a = Point.subtract(Point.subtract(Point(1, 1), this.c), this.b);\n  }\n  solve(x, epsilon2) {\n    return this.sampleY(this.solveForT(x, epsilon2));\n  }\n  sampleX(t) {\n    return ((this.a.x * t + this.b.x) * t + this.c.x) * t;\n  }\n  sampleY(t) {\n    return ((this.a.y * t + this.b.y) * t + this.c.y) * t;\n  }\n  sampleDerivativeX(t) {\n    return (3 * this.a.x * t + 2 * this.b.x) * t + this.c.x;\n  }\n  solveForT(x, epsilon2) {\n    let t0, t1, t2, x2, d2, i;\n    t2 = x;\n    for (i = 0; i < 8; ++i) {\n      x2 = this.sampleX(t2) - x;\n      if (Math.abs(x2) < epsilon2)\n        return t2;\n      d2 = this.sampleDerivativeX(t2);\n      if (Math.abs(d2) < epsilon2)\n        break;\n      t2 = t2 - x2 / d2;\n    }\n    t0 = 0;\n    t1 = 1;\n    t2 = x;\n    if (t2 < t0)\n      return t0;\n    if (t2 > t1)\n      return t1;\n    while (t0 < t1) {\n      x2 = this.sampleX(t2);\n      if (Math.abs(x2 - x) < epsilon2)\n        return t2;\n      if (x > x2)\n        t0 = t2;\n      else\n        t1 = t2;\n      t2 = (t1 - t0) * 0.5 + t0;\n    }\n    return t2;\n  }\n};\n\n// src/animation/FramerAnimation.ts\nvar DefaultDeprecatedAnimationOptions = {\n  precalculate: false,\n  colorModel: ColorMixModelType.HUSL\n};\nvar FramerAnimation = class {\n  constructor(target, from, to, animatorClass, options, driverClass = MainLoopAnimationDriver) {\n    this.playStateSource = \"idle\";\n    this.readyPromise = Promise.resolve();\n    this.resetFinishedPromise();\n    const deprecatedAnimationOptions = { ...DefaultDeprecatedAnimationOptions };\n    const animatorOptions = {};\n    if (options) {\n      Object.assign(deprecatedAnimationOptions, options);\n      Object.assign(animatorOptions, options);\n    }\n    let interpolation;\n    if (deprecatedAnimationOptions.customInterpolation) {\n      interpolation = deprecatedAnimationOptions.customInterpolation;\n    } else {\n      interpolation = new ValueInterpolation(options);\n    }\n    let animator;\n    if (!animatorClass) {\n      animator = new BezierAnimator({}, interpolation);\n    } else {\n      animator = new animatorClass(animatorOptions, interpolation);\n    }\n    if (deprecatedAnimationOptions.precalculate) {\n      animator = new PrecalculatedAnimator({ animator });\n    }\n    animator.setFrom(from);\n    animator.setTo(to);\n    const updateCallback = (value) => {\n      FramerAnimation.driverCallbackHandler(target, value);\n    };\n    const finishedCallback = (isFinished) => {\n      if (isFinished) {\n        FramerAnimation.driverCallbackHandler(target, to);\n        if (this.playStateSource === \"running\") {\n          this.playStateValue = \"finished\";\n        }\n      }\n    };\n    this.driver = new driverClass(animator, updateCallback, finishedCallback);\n  }\n  static driverCallbackHandler(target, value) {\n    if (isAnimatable2(target) || isMotionValue2(target)) {\n      target.set(value);\n    } else {\n      const targetObject = target;\n      Animatable.transaction((update) => {\n        for (const key6 in targetObject) {\n          const targetValue = targetObject[key6];\n          if (isAnimatable2(targetValue)) {\n            update(targetValue, value[key6]);\n          } else {\n            targetObject[key6] = value[key6];\n          }\n        }\n      });\n    }\n  }\n  get playStateValue() {\n    return this.playStateSource;\n  }\n  set playStateValue(value) {\n    if (value !== this.playStateSource) {\n      const oldValue = value;\n      this.playStateSource = value;\n      switch (value) {\n        case \"idle\":\n          if (oldValue === \"running\") {\n            this.oncancel && this.oncancel();\n          }\n          this.readyResolve && this.readyResolve();\n          this.resetReadyPromise();\n          break;\n        case \"finished\":\n          if (oldValue === \"idle\") {\n            console.warn(\"Bad state transition\");\n            break;\n          }\n          this.onfinish && this.onfinish();\n          this.finishedResolve && this.finishedResolve();\n          break;\n        case \"running\":\n          this.resetReadyPromise();\n          break;\n      }\n      if (oldValue === \"finished\") {\n        this.resetFinishedPromise();\n      }\n      if (value === \"finished\") {\n        this.playStateValue = \"idle\";\n      }\n    }\n  }\n  get playState() {\n    return this.playStateValue;\n  }\n  resetReadyPromise() {\n    this.readyResolve = null;\n    this.readyPromise = new Promise((resolve, reject) => {\n      this.readyResolve = resolve;\n    });\n  }\n  get ready() {\n    return this.readyPromise;\n  }\n  resetFinishedPromise() {\n    this.finishedResolve = null;\n    this.finishedReject = null;\n    this.finishedPromise = new Promise((resolve, reject) => {\n      this.finishedResolve = resolve;\n      this.finishedReject = reject;\n    });\n    this.finishedPromise.catch((reason) => {\n    });\n  }\n  get finished() {\n    return this.finishedPromise;\n  }\n  play() {\n    this.playStateValue = \"running\";\n    this.driver.play();\n  }\n  cancel() {\n    if (this.playStateValue !== \"running\") {\n      return;\n    }\n    this.driver.cancel();\n    if (this.playState !== \"idle\") {\n      const reason = \"AbortError\";\n      this.finishedReject && this.finishedReject(reason);\n    }\n    this.playStateValue = \"idle\";\n  }\n  finish() {\n    if (this.playStateSource === \"running\") {\n      this.playStateValue = \"finished\";\n      this.driver.finish();\n    }\n  }\n  isFinished() {\n    return this.playStateValue === \"finished\";\n  }\n};\n\n// src/animation/animate.ts\nfunction deprecatedAnimate(from, to, animator, options) {\n  deprecationWarning(\"animate()\", \"2.0.0\", \"the new animation API (https://www.framer.com/api/animation/)\");\n  const target = from;\n  let fromValue;\n  if (isAnimatable2(from) || isMotionValue2(from)) {\n    fromValue = from.get();\n  } else {\n    fromValue = Animatable.objectToValues(from);\n  }\n  const animation = new FramerAnimation(target, fromValue, to, animator, options);\n  animation.play();\n  return animation;\n}\nfunction animate3(from, to, animatorOrTransition, options) {\n  return isAnimatable2(from) ? deprecatedAnimate(from, to, animatorOrTransition, options) : animate2(from, to, animatorOrTransition);\n}\n(function(animate4) {\n  function spring2(from, to, options) {\n    return animate4(from, to, SpringAnimator, options);\n  }\n  animate4.spring = spring2;\n  function bezier(from, to, options) {\n    return animate4(from, to, BezierAnimator, options);\n  }\n  animate4.bezier = bezier;\n  function linear2(from, to, options) {\n    return animate4.bezier(from, to, { ...options, curve: Bezier.Linear });\n  }\n  animate4.linear = linear2;\n  function ease(from, to, options) {\n    return animate4.bezier(from, to, { ...options, curve: Bezier.Ease });\n  }\n  animate4.ease = ease;\n  function easeIn2(from, to, options) {\n    return animate4.bezier(from, to, { ...options, curve: Bezier.EaseIn });\n  }\n  animate4.easeIn = easeIn2;\n  function easeOut2(from, to, options) {\n    return animate4.bezier(from, to, { ...options, curve: Bezier.EaseOut });\n  }\n  animate4.easeOut = easeOut2;\n  function easeInOut2(from, to, options) {\n    return animate4.bezier(from, to, { ...options, curve: Bezier.EaseInOut });\n  }\n  animate4.easeInOut = easeInOut2;\n})(animate3 || (animate3 = {}));\n\n// src/render/utils/getConfigFromURL.ts\nfunction getConfigFromPreviewURL(windowURLString = safeWindow.location.href) {\n  if (!windowURLString) {\n    throw new Error(`getConfigFromURL() called without url argument (location.href = \"${safeWindow.location.href}\")`);\n  }\n  const params = new URL(windowURLString).searchParams;\n  const imageBaseURL = params.get(\"imageBaseURL\") || \"\";\n  const projectURL = params.get(\"projectURL\") || \"\";\n  const showConsole = params.get(\"console\") === \"1\";\n  const disableDevice = params.get(\"device\") === \"0\";\n  return { imageBaseURL, projectURL, showConsole, disableDevice };\n}\nfunction getConfigFromVekterURL(windowURLString = safeWindow.location.href) {\n  if (!windowURLString) {\n    throw new Error(`getConfigFromURL() called without url argument (location.href = \"${safeWindow.location.href}\")`);\n  }\n  const hash2 = decodeURIComponent(new URL(windowURLString).hash.slice(1));\n  const [documentURL, imageBaseURL, projectURL] = hash2.split(\"#&#\");\n  return { documentURL, imageBaseURL, projectURL };\n}\n\n// src/render/assetResolver/serverURL.ts\nfunction parseURL(url, base) {\n  try {\n    return typeof base === \"undefined\" ? new URL(url) : new URL(url, base);\n  } catch (err) {\n    return null;\n  }\n}\nvar flatten = (arrays) => [].concat.apply([], arrays);\nfunction joinPaths(paths) {\n  let res = \"\";\n  for (const path of paths) {\n    if (!path)\n      continue;\n    if (res.length > 0 && !res.endsWith(\"/\")) {\n      res += \"/\";\n    }\n    if (Array.isArray(path)) {\n      res += joinPaths(path);\n    } else {\n      res += encodeURIComponent(path).replace(/%2F/g, \"/\");\n    }\n  }\n  return res;\n}\nfunction serverURL(...paths) {\n  const notEmptyPaths = flatten(paths).filter(Boolean);\n  if (notEmptyPaths.length === 1 && parseURL(notEmptyPaths[0])) {\n    return notEmptyPaths[0];\n  }\n  const path = joinPaths(paths);\n  const resolvedAsset = runtime.assetResolver(path, {\n    isFramerResourceURL: true,\n    isExport: RenderTarget.current() === RenderTarget.export\n  });\n  return resolvedAsset || \"\";\n}\n\n// src/utils/internalId.ts\nvar keys = new Map();\nvar InternalID = class {\n  constructor(id) {\n    this.id = id;\n    this._link = null;\n    this._urllink = null;\n  }\n  add(str) {\n    return InternalID.forKey(this.id + str);\n  }\n  toString() {\n    return this.id;\n  }\n  get link() {\n    const res = this._link;\n    if (res)\n      return res;\n    return this._link = \"#\" + this.id;\n  }\n  get urlLink() {\n    const res = this._urllink;\n    if (res)\n      return res;\n    return this._urllink = \"url(#\" + this.id + \")\";\n  }\n  static forKey(key6) {\n    let res = keys.get(key6);\n    if (res)\n      return res;\n    res = new InternalID(\"a\" + (1e3 + keys.size) + \"z\");\n    keys.set(key6, res);\n    return res;\n  }\n};\n\n// src/render/utils/elementPropertiesForGradient.ts\nfunction elementPropertiesForLinearGradient(gradient, id) {\n  return {\n    id: `id${id}g${LinearGradient.hash(gradient)}`,\n    angle: gradient.angle - 90,\n    stops: gradientColorStops(gradient).map((stop) => ({\n      color: stop.value,\n      alpha: ConvertColor.getAlpha(stop.value) * gradient.alpha,\n      position: stop.position\n    }))\n  };\n}\nfunction elementPropertiesForRadialGradient(gradient, id) {\n  return {\n    id: `id${id}g${RadialGradient.hash(gradient)}`,\n    widthFactor: gradient.widthFactor,\n    heightFactor: gradient.heightFactor,\n    centerAnchorX: gradient.centerAnchorX,\n    centerAnchorY: gradient.centerAnchorY,\n    stops: gradientColorStops(gradient).map((stop) => ({\n      color: stop.value,\n      alpha: ConvertColor.getAlpha(stop.value) * gradient.alpha,\n      position: stop.position\n    }))\n  };\n}\n\n// src/render/utils/dom.ts\nvar frameFromElement = (element) => {\n  const frame2 = Rect.fromRect(element.getBoundingClientRect());\n  frame2.x = frame2.x + safeWindow.scrollX;\n  frame2.y = frame2.y + safeWindow.scrollY;\n  return frame2;\n};\nvar frameFromElements = (elements) => {\n  return Rect.merge(...elements.map(frameFromElement));\n};\nvar convertToPageFrame = (frame2, element) => {\n  const point = convertToPagePoint(frame2, element);\n  return {\n    x: point.x,\n    y: point.y,\n    width: frame2.width,\n    height: frame2.height\n  };\n};\nvar convertFromPageFrame = (frame2, element) => {\n  const point = convertFromPagePoint(frame2, element);\n  return {\n    x: point.x,\n    y: point.y,\n    width: frame2.width,\n    height: frame2.height\n  };\n};\nvar getPageFrame = (element) => {\n  const rect = element.getBoundingClientRect();\n  return {\n    x: rect.left + safeWindow.scrollX,\n    y: rect.top + safeWindow.scrollY,\n    width: rect.width,\n    height: rect.height\n  };\n};\nvar fromEventForPage = (event) => {\n  return {\n    x: event.pageX,\n    y: event.pageY\n  };\n};\nvar fromEventForClient = (event) => {\n  return {\n    x: event.clientX,\n    y: event.clientY\n  };\n};\nvar convertToPagePoint = (point, element) => {\n  const frame2 = getPageFrame(element);\n  return {\n    x: point.x + frame2.x,\n    y: point.y + frame2.y\n  };\n};\nvar convertFromPagePoint = (point, element) => {\n  const frame2 = getPageFrame(element);\n  return {\n    x: point.x - frame2.x,\n    y: point.y - frame2.y\n  };\n};\nvar dispatchKeyDownEvent = (keyCode, options = {}) => {\n  const keyboardEvent = new KeyboardEvent(\"keydown\", {\n    bubbles: true,\n    keyCode,\n    ...options\n  });\n  const activeElement = document.activeElement;\n  if (activeElement) {\n    activeElement.dispatchEvent(keyboardEvent);\n  }\n};\nvar DOM = {\n  frameFromElement,\n  frameFromElements,\n  convertToPageFrame,\n  convertFromPageFrame,\n  getPageFrame,\n  fromEventForPage,\n  fromEventForClient,\n  convertToPagePoint,\n  convertFromPagePoint\n};\n\n// src/render/traits/Shape.ts\nvar key4 = \"calculatedPaths\";\nfunction withShape(target) {\n  return key4 in target;\n}\n\n// src/render/utils/gradientForShape.tsx\nfunction gradientForShape(nodeId, node) {\n  if (LinearGradient.isLinearGradient(node.fill)) {\n    return elementPropertiesForLinearGradient(node.fill, nodeId);\n  }\n  if (RadialGradient.isRadialGradient(node.fill)) {\n    return elementPropertiesForRadialGradient(node.fill, nodeId);\n  }\n  return void 0;\n}\n\n// src/render/utils/throttle.ts\nfunction throttle(fn, time3) {\n  let previous = 0;\n  let timeout;\n  const later = (...args) => {\n    previous = Date.now();\n    timeout = void 0;\n    fn(...args);\n  };\n  return (...args) => {\n    const now = Date.now();\n    const remaining = time3 - (now - previous);\n    if (remaining <= 0 || remaining > time3) {\n      if (timeout) {\n        safeWindow.clearTimeout(timeout);\n        timeout = void 0;\n      }\n      previous = now;\n      fn(...args);\n    } else if (!timeout) {\n      timeout = safeWindow.setTimeout(later, remaining, ...args);\n    }\n  };\n}\n\n// ../app/assets/src/assetReference.ts\nvar mediaType = \"framer/asset-reference,\";\nfunction isAssetReference(value) {\n  return value.startsWith(`data:${mediaType}`);\n}\n\n// src/render/utils/imageUrlForAsset.ts\nfunction imageUrlForAsset(asset, size2) {\n  var _a;\n  if (/^\\w+:/.test(asset) && !isAssetReference(asset))\n    return asset;\n  if (typeof size2 !== \"number\")\n    size2 = void 0;\n  else if (size2 <= 512)\n    size2 = 512;\n  else if (size2 <= 1024)\n    size2 = 1024;\n  else if (size2 <= 2048)\n    size2 = 2048;\n  else\n    size2 = 4096;\n  const isExport = RenderTarget.current() === RenderTarget.export;\n  return (_a = runtime.assetResolver(asset, { size: size2, isExport })) != null ? _a : \"\";\n}\n\n// src/render/utils/imagePatternPropsForFill.tsx\nfunction imagePatternPropsForFill(fill, frame2, id) {\n  fill = Animatable.get(fill, \"#09F\");\n  if (!BackgroundImage.isImageObject(fill))\n    return void 0;\n  if (!fill.pixelWidth || !fill.pixelHeight)\n    return void 0;\n  const imageWidth = fill.pixelWidth;\n  const imageHeight = fill.pixelHeight;\n  let transform2;\n  const { fit } = fill;\n  if (fit === \"fill\" || fit === \"fit\" || !fit) {\n    let scaleX = 1;\n    let scaleY = 1;\n    let offsetX = 0;\n    let offsetY = 0;\n    const imageRatio = imageWidth / imageHeight;\n    const realWidth = frame2.height * imageRatio;\n    const realHeight = frame2.width / imageRatio;\n    const validScaleX = realWidth / frame2.width;\n    const validScaleY = realHeight / frame2.height;\n    if (fit === \"fill\" || !fit ? validScaleY > validScaleX : validScaleY < validScaleX) {\n      scaleY = validScaleY;\n      offsetY = (1 - validScaleY) / 2;\n    } else {\n      scaleX = validScaleX;\n      offsetX = (1 - validScaleX) / 2;\n    }\n    transform2 = `translate(${offsetX}, ${offsetY}) scale(${scaleX}, ${scaleY})`;\n  }\n  const imageId = `id${id}g${\"-fillImage\"}`;\n  return { id: imageId, path: fill.src, transform: transform2 };\n}\n\n// src/render/componentLoader/definition.ts\nfunction isDesignDefinition(d) {\n  return d.type === \"master\";\n}\nfunction isOverride(d) {\n  return d.type === \"override\";\n}\nfunction isReactDefinition(d) {\n  return d.type !== \"master\";\n}\n\n// src/render/componentLoader/package.ts\nvar localPackageFallbackIdentifier = \"|local|\";\n\n// src/render/utils/annotateTypeOnStringify.ts\nfunction annotateTypeOnStringify(ctor, typeName) {\n  const existingToJSON = ctor.prototype.toJSON;\n  ctor.prototype.toJSON = function() {\n    const base = existingToJSON ? existingToJSON.apply(this) : this;\n    return Object.assign({}, base, { __type__: typeName });\n  };\n  return ctor;\n}\nfunction isOfAnnotatedType(object, typeName) {\n  return object && object.__type__ && object.__type__ === typeName;\n}\n\n// src/render/types/PathSegment.ts\nvar PathSegment = class {\n  constructor(value) {\n    this.__class = \"PathSegment\";\n    this.x = 0;\n    this.y = 0;\n    this.handleMirroring = \"straight\";\n    this.handleOutX = 0;\n    this.handleOutY = 0;\n    this.handleInX = 0;\n    this.handleInY = 0;\n    this.radius = 0;\n    if (value) {\n      Object.assign(this, value);\n    }\n  }\n  merge(value) {\n    return Object.assign(Object.create(Object.getPrototypeOf(this)), this, value);\n  }\n};\nPathSegment.displayName = \"WithClassDiscriminatorMixin(PathSegment)\";\nPathSegment.prototype.__class = \"PathSegment\";\n(function(PathSegment2) {\n  PathSegment2.point = (pathSegment) => {\n    return { x: pathSegment.x, y: pathSegment.y };\n  };\n  PathSegment2.handleOut = (pathSegment) => {\n    return { x: pathSegment.handleOutX, y: pathSegment.handleOutY };\n  };\n  PathSegment2.handleIn = (pathSegment) => {\n    return { x: pathSegment.handleInX, y: pathSegment.handleInY };\n  };\n  PathSegment2.calculatedHandleOut = (pathSegment) => {\n    switch (pathSegment.handleMirroring) {\n      case \"symmetric\":\n      case \"disconnected\":\n      case \"asymmetric\":\n        return Point.add(PathSegment2.point(pathSegment), PathSegment2.handleOut(pathSegment));\n      default:\n        return { x: pathSegment.x, y: pathSegment.y };\n    }\n  };\n  PathSegment2.calculatedHandleIn = (pathSegment) => {\n    switch (pathSegment.handleMirroring) {\n      case \"symmetric\":\n        return Point.subtract(PathSegment2.point(pathSegment), PathSegment2.handleOut(pathSegment));\n      case \"disconnected\":\n      case \"asymmetric\":\n        return Point.add(PathSegment2.point(pathSegment), PathSegment2.handleIn(pathSegment));\n      default:\n        return PathSegment2.point(pathSegment);\n    }\n  };\n  PathSegment2.curveDefault = (points, index) => {\n    if (points.length > 2) {\n      let pointBefore;\n      let pointAfter;\n      if (index === 0) {\n        pointBefore = points[points.length - 1];\n      } else {\n        pointBefore = points[index - 1];\n      }\n      if (index === points.length - 1) {\n        pointAfter = points[0];\n      } else {\n        pointAfter = points[index + 1];\n      }\n      const delta2 = Point.subtract(PathSegment2.point(pointAfter), PathSegment2.point(pointBefore));\n      return { x: delta2.x / 4, y: delta2.y / 4 };\n    }\n    return { x: 10, y: 10 };\n  };\n})(PathSegment || (PathSegment = {}));\n\n// src/render/traits/Path.ts\nvar key5 = \"pathSegments\";\nfunction withPath(target) {\n  return key5 in target;\n}\nvar pathDefaults = {\n  pathSegments: [],\n  pathClosed: false\n};\nfunction toSVGPath(withPaths, translate = { x: 0, y: 0 }, canvasMode = RenderTarget.canvas) {\n  let pathElements = [];\n  let paths = [];\n  if (Array.isArray(withPaths)) {\n    paths = withPaths;\n  } else {\n    paths = [withPaths];\n  }\n  paths.forEach((path, index) => {\n    const { pathClosed, pathSegments } = path;\n    const segmentCount = pathSegments.length;\n    if (segmentCount === 0)\n      return \"\";\n    for (let i = 0; i < segmentCount; i++) {\n      const segment = pathSegments[i];\n      let nextSegment;\n      let prevSegment;\n      const isFirstSegment = i === 0;\n      const isLastSegment = i === segmentCount - 1;\n      if (!isLastSegment) {\n        nextSegment = pathSegments[i + 1];\n      } else if (pathClosed) {\n        nextSegment = pathSegments[0];\n      }\n      if (!isFirstSegment) {\n        prevSegment = pathSegments[i - 1];\n      } else if (pathClosed) {\n        prevSegment = pathSegments[segmentCount - 1];\n      }\n      if (i === 0) {\n        pathElements.push(\"M\");\n      } else if (prevSegment && isStraightCurve(prevSegment, segment)) {\n        pathElements.push(\"L\");\n      }\n      pathElements.push(segment.x + translate.x, segment.y + translate.y);\n      if (nextSegment && !isStraightCurve(segment, nextSegment)) {\n        const handleOut = PathSegment.calculatedHandleOut(segment);\n        const handleIn = PathSegment.calculatedHandleIn(nextSegment);\n        pathElements.push(\"C\", handleOut.x + translate.x, handleOut.y + translate.y, handleIn.x + translate.x, handleIn.y + translate.y);\n      }\n      if (isLastSegment && nextSegment) {\n        if (isStraightCurve(segment, nextSegment)) {\n          pathElements.push(\"Z\");\n        } else {\n          pathElements.push(nextSegment.x + translate.x, nextSegment.y + translate.y, \"Z\");\n        }\n      }\n    }\n  });\n  if (canvasMode === RenderTarget.export || canvasMode === RenderTarget.preview) {\n    pathElements = pathElements.map((value) => isFiniteNumber(value) ? roundedNumberString(value, 3) : value);\n  }\n  return pathElements.join(\" \");\n}\nfunction isStraightCurve(fromSegment, toSegment) {\n  const fromStraight = fromSegment.handleMirroring === \"straight\" || fromSegment.handleOutX === 0 && fromSegment.handleOutY === 0;\n  const toStraight = toSegment.handleMirroring === \"straight\" || toSegment.handleInX === 0 && toSegment.handleInY === 0;\n  return fromStraight && toStraight;\n}\n\n// src/render/types/Size.ts\nfunction Size(width, height) {\n  return { width, height };\n}\n(function(Size2) {\n  Size2.equals = (sizeA, sizeB) => {\n    if (sizeA === sizeB)\n      return true;\n    if (!sizeA || !sizeB)\n      return false;\n    return sizeA.width === sizeB.width && sizeA.height === sizeB.height;\n  };\n  Size2.update = (fromSize, toSize, keepAspectRatio = false) => {\n    let { width, height } = fromSize;\n    const sizeRatio = width / height;\n    width = toSize.width !== void 0 ? toSize.width : width;\n    height = toSize.height !== void 0 ? toSize.height : height;\n    if (keepAspectRatio) {\n      if (toSize.width === void 0 && toSize.height !== void 0) {\n        width = toSize.height * sizeRatio;\n      }\n      if (toSize.width !== void 0 && toSize.height === void 0 && sizeRatio !== 0) {\n        height = toSize.width / sizeRatio;\n      }\n    }\n    return { width, height };\n  };\n  function subtract(sizeA, sizeB) {\n    return {\n      width: Math.max(0, sizeA.width - sizeB.width),\n      height: Math.max(0, sizeA.height - sizeB.height)\n    };\n  }\n  Size2.subtract = subtract;\n  Size2.zero = Size2(0, 0);\n  Size2.isZero = function(size2) {\n    return size2 === Size2.zero || size2.width === 0 && size2.height === 0;\n  };\n  Size2.defaultIfZero = function(width, height, size2) {\n    if (Size2.isZero(size2)) {\n      return Size2(width, height);\n    }\n    return size2;\n  };\n})(Size || (Size = {}));\n\n// src/render/types/Line.ts\nfunction Line(a2, b2) {\n  return { a: a2, b: b2 };\n}\n(function(Line2) {\n  function intersection(lineA, lineB) {\n    const x1 = lineA.a.x;\n    const y1 = lineA.a.y;\n    const x2 = lineA.b.x;\n    const y2 = lineA.b.y;\n    const x3 = lineB.a.x;\n    const y3 = lineB.a.y;\n    const x4 = lineB.b.x;\n    const y4 = lineB.b.y;\n    const d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d === 0) {\n      return null;\n    }\n    const xi = ((x3 - x4) * (x1 * y2 - y1 * x2) - (x1 - x2) * (x3 * y4 - y3 * x4)) / d;\n    const yi = ((y3 - y4) * (x1 * y2 - y1 * x2) - (y1 - y2) * (x3 * y4 - y3 * x4)) / d;\n    return { x: xi, y: yi };\n  }\n  Line2.intersection = intersection;\n  Line2.isOrthogonal = (line) => {\n    return line.a.x === line.b.x || line.a.y === line.b.y;\n  };\n  Line2.perpendicular = (line, pointOnLine) => {\n    const deltaX = line.a.x - line.b.x;\n    const deltaY = line.a.y - line.b.y;\n    const pointB = Point(pointOnLine.x - deltaY, pointOnLine.y + deltaX);\n    return Line2(pointB, pointOnLine);\n  };\n  function projectPoint(line, point) {\n    const perp = Line2.perpendicular(line, point);\n    return intersection(line, perp);\n  }\n  Line2.projectPoint = projectPoint;\n})(Line || (Line = {}));\n\n// src/render/presentation/Image.tsx\n\n\nvar Image2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function Image3(props, ref) {\n  const { background, children, ...rest } = props;\n  const style = { ...rest.style };\n  if (background) {\n    delete style.background;\n  }\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(motion.div, {\n    ...rest,\n    style,\n    ref\n  }, background && background.src ? /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(BackgroundImageComponent, {\n    image: background\n  }) : null, children);\n});\n\n// src/render/presentation/SVG.tsx\n\n\n// src/render/presentation/ImagePatternElement.tsx\n\nvar ImagePatternElement = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  render() {\n    const { id, path, transform: transform2 } = this.props;\n    const xlinkHref = imageUrlForAsset(path);\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"pattern\", {\n      id,\n      width: \"100%\",\n      height: \"100%\",\n      patternContentUnits: \"objectBoundingBox\"\n    }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"image\", {\n      key: xlinkHref,\n      width: 1,\n      height: 1,\n      xlinkHref,\n      preserveAspectRatio: \"none\",\n      transform: transform2\n    }));\n  }\n};\n\n// src/render/presentation/SVG.tsx\nfunction SVG(props) {\n  const parentSize = useParentSize();\n  const layoutId = useLayoutId2(props);\n  const layoutRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  useMeasureLayout(props, layoutRef);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(SVGComponent, {\n    ...props,\n    innerRef: layoutRef,\n    parentSize,\n    layoutId\n  });\n}\nfunction sizeSVG(container, props) {\n  var _a, _b;\n  const div = container.current;\n  if (!div)\n    return;\n  const { withExternalLayout, parentSize } = props;\n  const canUseCalculatedOnCanvasSize = !withExternalLayout && constraintsEnabled(props) && parentSize !== ParentSizeState.Disabled && parentSize !== ParentSizeState.DisabledForCurrentLevel;\n  if (canUseCalculatedOnCanvasSize)\n    return;\n  const svg = div.firstElementChild;\n  if (!svg || !(svg instanceof SVGSVGElement)) {\n    return;\n  }\n  const { intrinsicWidth, intrinsicHeight, _constraints } = props;\n  if (((_a = svg.viewBox.baseVal) == null ? void 0 : _a.width) === 0 && ((_b = svg.viewBox.baseVal) == null ? void 0 : _b.height) === 0 && isFiniteNumber(intrinsicWidth) && isFiniteNumber(intrinsicHeight)) {\n    svg.setAttribute(\"viewBox\", `0 0 ${intrinsicWidth} ${intrinsicHeight}`);\n  }\n  if (_constraints && _constraints.aspectRatio) {\n    svg.setAttribute(\"preserveAspectRatio\", \"\");\n  } else {\n    svg.setAttribute(\"preserveAspectRatio\", \"none\");\n  }\n  svg.setAttribute(\"width\", \"100%\");\n  svg.setAttribute(\"height\", \"100%\");\n}\nvar _SVGComponent = class extends Layer {\n  constructor() {\n    super(...arguments);\n    this.container = (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n    this.svgElement = (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n  }\n  static frame(props) {\n    return calculateRect(props, props.parentSize || ParentSizeState.Unknown);\n  }\n  getPrefixedSVG(svg, id) {\n    if (this.previouslyPrefixedSVG && svg === this.previouslyPrefixedSVG.svg && id === this.previouslyPrefixedSVG.id) {\n      return this.previouslyPrefixedSVGResult;\n    }\n    const prefixedSVG = prefixIdsInSVG(svg, id);\n    this.previouslyPrefixedSVGResult = prefixedSVG;\n    this.previouslyPrefixedSVG = { svg, id };\n    return prefixedSVG;\n  }\n  get frame() {\n    return calculateRect(this.props, this.props.parentSize || ParentSizeState.Unknown);\n  }\n  componentDidMount() {\n    sizeSVG(this.container, this.props);\n  }\n  componentDidUpdate(prevProps) {\n    super.componentDidUpdate(prevProps);\n    const { fill } = this.props;\n    if (BackgroundImage.isImageObject(fill) && BackgroundImage.isImageObject(prevProps.fill) && fill.src !== prevProps.fill.src) {\n      resetSetStyle(this.svgElement.current, \"fill\", null, false);\n    }\n    sizeSVG(this.container, this.props);\n  }\n  collectLayout(style, innerStyle) {\n    if (this.props.withExternalLayout) {\n      innerStyle.width = innerStyle.height = \"inherit\";\n      return;\n    }\n    const frame2 = this.frame;\n    const { rotation, intrinsicWidth, intrinsicHeight, width, height } = this.props;\n    const rotate = Animatable.getNumber(rotation);\n    style.opacity = isFiniteNumber(this.props.opacity) ? this.props.opacity : 1;\n    if (RenderTarget.hasRestrictions() && frame2) {\n      Object.assign(style, {\n        transform: `translate(${frame2.x}px, ${frame2.y}px) rotate(${rotate.toFixed(4)}deg)`,\n        width: `${frame2.width}px`,\n        height: `${frame2.height}px`\n      });\n      if (constraintsEnabled(this.props)) {\n        style.position = \"absolute\";\n      }\n      const xFactor = frame2.width / (intrinsicWidth || 1);\n      const yFactor = frame2.height / (intrinsicHeight || 1);\n      innerStyle.transformOrigin = \"top left\";\n      const { zoom, target } = RenderEnvironment;\n      if (target === RenderTarget.export) {\n        const zoomFactor = zoom > 1 ? zoom : 1;\n        innerStyle.transform = `scale(${xFactor * zoomFactor}, ${yFactor * zoomFactor})`;\n        innerStyle.zoom = 1 / zoomFactor;\n      } else {\n        innerStyle.transform = `scale(${xFactor}, ${yFactor})`;\n      }\n      if (intrinsicWidth && intrinsicHeight) {\n        innerStyle.width = intrinsicWidth;\n        innerStyle.height = intrinsicHeight;\n      }\n    } else {\n      const { left, right, top, bottom } = this.props;\n      Object.assign(style, {\n        left,\n        right,\n        top,\n        bottom,\n        width,\n        height,\n        rotate\n      });\n      Object.assign(innerStyle, {\n        left: 0,\n        top: 0,\n        bottom: 0,\n        right: 0,\n        position: \"absolute\"\n      });\n    }\n  }\n  render() {\n    var _a;\n    if (safeWindow[\"perf\"])\n      safeWindow[\"perf\"].nodeRender();\n    const {\n      id,\n      visible,\n      style,\n      fill,\n      svg,\n      intrinsicHeight,\n      intrinsicWidth,\n      layoutId,\n      className,\n      variants,\n      transition,\n      withExternalLayout,\n      innerRef\n    } = this.props;\n    if (!withExternalLayout && (!visible || !id))\n      return null;\n    const identifier = (_a = id != null ? id : layoutId) != null ? _a : \"svg\";\n    injectComponentCSSRules();\n    const frame2 = this.frame;\n    const size2 = frame2 || { width: intrinsicWidth || 100, height: intrinsicHeight || 100 };\n    const outerStyle = { ...style, imageRendering: \"pixelated\" };\n    const innerStyle = {};\n    this.collectLayout(outerStyle, innerStyle);\n    collectOpacityFromProps(this.props, outerStyle);\n    collectFiltersFromProps(this.props, outerStyle);\n    Layer.applyWillChange(this.props, outerStyle, false);\n    let fillElement = null;\n    if (typeof fill === \"string\" || Color.isColorObject(fill)) {\n      const fillColor = Color.isColorObject(fill) ? fill.initialValue || Color.toRgbString(fill) : fill;\n      outerStyle.fill = fillColor;\n      outerStyle.color = fillColor;\n    } else if (LinearGradient.isLinearGradient(fill)) {\n      const gradient = fill;\n      const gradientId = `${encodeURI(id || \"\")}g${LinearGradient.hash(gradient)}`;\n      outerStyle.fill = `url(#${gradientId})`;\n      const elementProperties = elementPropertiesForLinearGradient(gradient, identifier);\n      fillElement = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"svg\", {\n        ref: this.svgElement,\n        xmlns: \"http://www.w3.org/2000/svg\",\n        width: \"100%\",\n        height: \"100%\",\n        style: { position: \"absolute\" }\n      }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"linearGradient\", {\n        id: gradientId,\n        gradientTransform: `rotate(${elementProperties.angle}, 0.5, 0.5)`\n      }, elementProperties.stops.map((stop, idx) => {\n        return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"stop\", {\n          key: idx,\n          offset: stop.position,\n          stopColor: stop.color,\n          stopOpacity: stop.alpha\n        });\n      })));\n    } else if (RadialGradient.isRadialGradient(fill)) {\n      const gradient = fill;\n      const gradientId = `${encodeURI(id || \"\")}g${RadialGradient.hash(gradient)}`;\n      outerStyle.fill = `url(#${gradientId})`;\n      const elementProperties = elementPropertiesForRadialGradient(gradient, identifier);\n      fillElement = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"svg\", {\n        ref: this.svgElement,\n        xmlns: \"http://www.w3.org/2000/svg\",\n        width: \"100%\",\n        height: \"100%\",\n        style: { position: \"absolute\" }\n      }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"radialGradient\", {\n        id: gradientId,\n        cy: gradient.centerAnchorY,\n        cx: gradient.centerAnchorX,\n        r: gradient.widthFactor\n      }, elementProperties.stops.map((stop, idx) => {\n        return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"stop\", {\n          key: idx,\n          offset: stop.position,\n          stopColor: stop.color,\n          stopOpacity: stop.alpha\n        });\n      })));\n    } else if (BackgroundImage.isImageObject(fill)) {\n      const imagePattern = imagePatternPropsForFill(fill, size2, identifier);\n      if (imagePattern) {\n        outerStyle.fill = `url(#${imagePattern.id})`;\n        fillElement = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"svg\", {\n          ref: this.svgElement,\n          xmlns: \"http://www.w3.org/2000/svg\",\n          xmlnsXlink: \"http://www.w3.org/1999/xlink\",\n          width: \"100%\",\n          height: \"100%\",\n          style: { position: \"absolute\" }\n        }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"defs\", null, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ImagePatternElement, {\n          ...imagePattern\n        })));\n      }\n    }\n    const dataProps = {\n      \"data-framer-component-type\": \"SVG\"\n    };\n    const hasTransformTemplate = !frame2;\n    if (hasTransformTemplate) {\n      Object.assign(dataProps, layoutHintDataPropsForCenter(this.props.center));\n    }\n    const content = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, fillElement, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n      key: BackgroundImage.isImageObject(fill) ? fill.src : \"\",\n      className: \"svgContainer\",\n      style: innerStyle,\n      ref: this.container,\n      dangerouslySetInnerHTML: { __html: this.getPrefixedSVG(svg, identifier) }\n    }));\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(motion.div, {\n      ...dataProps,\n      layoutId,\n      transformTemplate: hasTransformTemplate ? transformTemplate(this.props.center) : void 0,\n      id,\n      ref: innerRef,\n      style: outerStyle,\n      className,\n      variants,\n      transition\n    }, content);\n  }\n};\nvar SVGComponent = _SVGComponent;\nSVGComponent.supportsConstraints = true;\nSVGComponent.defaultSVGProps = {\n  left: void 0,\n  right: void 0,\n  top: void 0,\n  bottom: void 0,\n  style: void 0,\n  _constraints: {\n    enabled: true,\n    aspectRatio: null\n  },\n  parentSize: ParentSizeState.Unknown,\n  rotation: 0,\n  visible: true,\n  svg: \"\",\n  shadows: []\n};\nSVGComponent.defaultProps = {\n  ...Layer.defaultProps,\n  ..._SVGComponent.defaultSVGProps\n};\nfunction prefixIdsInSVG(svg, prefix) {\n  const domParser = new DOMParser();\n  try {\n    const doc = domParser.parseFromString(svg, \"image/svg+xml\");\n    const el = doc.getElementsByTagName(\"svg\")[0];\n    if (!el)\n      return svg;\n    const sanitizedPrefix = sanitizeString(prefix);\n    recursivelyPrefixId(el, sanitizedPrefix);\n    return el.outerHTML;\n  } catch (error) {\n    throw Error(`Failed to parse SVG: ${error}`);\n  }\n}\nfunction sanitizeString(str) {\n  return str.replace(/[^a-z0-9\\-_:.]|^[^a-z]+/gi, \"\");\n}\nfunction recursivelyPrefixId(el, prefix) {\n  prefixId(el, prefix);\n  const childNodes = Array.from(el.children);\n  childNodes.forEach((node) => {\n    recursivelyPrefixId(node, prefix);\n  });\n}\nfunction prefixId(el, prefix) {\n  const attributes = el.getAttributeNames();\n  attributes.forEach((attr) => {\n    const value = el.getAttribute(attr);\n    if (!value)\n      return;\n    if (attr === \"id\") {\n      el.setAttribute(attr, `${prefix}_${value}`);\n    }\n    if (attr === \"href\" || attr === \"xlink:href\") {\n      const [base, fragmentIdentifier] = value.split(\"#\");\n      if (base)\n        return;\n      el.setAttribute(attr, `#${prefix}_${fragmentIdentifier}`);\n      return;\n    }\n    const URL_REF = \"url(#\";\n    if (value.includes(URL_REF)) {\n      const prefixedValue = value.replace(URL_REF, `${URL_REF}${prefix}_`);\n      el.setAttribute(attr, prefixedValue);\n    }\n  });\n}\n\n// src/render/presentation/Text.tsx\n\n\n\n// src/render/fonts/fonts.ts\nfunction convertToObject(descriptors) {\n  return Object.fromEntries(descriptors.map((descriptor) => [\n    descriptor[0],\n    Object.fromEntries(descriptor[1].map((member) => [\n      member[0],\n      {\n        selector: member[1],\n        weight: member[2]\n      }\n    ]))\n  ]));\n}\nvar safeFonts = {\n  Arial: {\n    Regular: { selector: \"Arial\", weight: void 0 },\n    Black: { selector: \"Arial-Black\", weight: void 0 },\n    Narrow: { selector: \"Arial Narrow\", weight: void 0 },\n    \"Rounded Bold\": { selector: \"Arial Rounded MT Bold\", weight: void 0 }\n  },\n  Avenir: {\n    Book: { selector: \"Avenir\", weight: void 0 },\n    Light: { selector: \"Avenir-Light\", weight: void 0 },\n    Medium: { selector: \"Avenir-Medium\", weight: void 0 },\n    Heavy: { selector: \"Avenir-Heavy\", weight: void 0 },\n    Black: { selector: \"Avenir-Black\", weight: void 0 }\n  },\n  \"Avenir Next\": {\n    Regular: { selector: \"Avenir Next\", weight: void 0 },\n    \"Ultra Light\": { selector: \"AvenirNext-UltraLight\", weight: void 0 },\n    Medium: { selector: \"AvenirNext-Medium\", weight: void 0 },\n    \"Demi Bold\": { selector: \"AvenirNext-DemiBold\", weight: void 0 },\n    Heavy: { selector: \"AvenirNext-Heavy\", weight: void 0 }\n  },\n  \"Avenir Next Condensed\": {\n    Regular: { selector: \"Avenir Next Condensed\", weight: void 0 },\n    \"Ultra Light\": { selector: \"AvenirNextCondensed-UltraLight\", weight: void 0 },\n    Medium: { selector: \"AvenirNextCondensed-Medium\", weight: void 0 },\n    \"Demi Bold\": { selector: \"AvenirNextCondensed-DemiBold\", weight: void 0 },\n    Heavy: { selector: \"AvenirNextCondensed-Heavy\", weight: void 0 }\n  },\n  Baskerville: {\n    Regular: { selector: \"Baskerville\", weight: void 0 },\n    \"Semi Bold\": { selector: \"Baskerville-SemiBold\", weight: void 0 }\n  },\n  \"Bodoni 72\": {\n    Book: { selector: \"Bodoni 72\", weight: void 0 },\n    Oldstyle: { selector: \"Bodoni 72 Oldstyle\", weight: void 0 },\n    Smallcaps: { selector: \"Bodoni 72 Smallcaps\", weight: void 0 }\n  },\n  Courier: { Regular: { selector: \"Courier\", weight: void 0 } },\n  \"Courier New\": { Regular: { selector: \"Courier New\", weight: void 0 } },\n  Futura: {\n    Medium: { selector: \"Futura\", weight: void 0 },\n    Condensed: { selector: \"Futura-CondensedMedium\", weight: void 0 },\n    \"Condensed ExtraBold\": { selector: \"Futura-CondensedExtraBold\", weight: void 0 }\n  },\n  Georgia: { Regular: { selector: \"Georgia\", weight: void 0 } },\n  \"Gill Sans\": {\n    Regular: { selector: \"Gill Sans\", weight: void 0 },\n    Light: { selector: \"GillSans-Light\", weight: void 0 },\n    SemiBold: { selector: \"GillSans-SemiBold\", weight: void 0 },\n    UltraBold: { selector: \"GillSans-UltraBold\", weight: void 0 }\n  },\n  Helvetica: {\n    Regular: { selector: \"Helvetica\", weight: void 0 },\n    Light: { selector: \"Helvetica-Light\", weight: void 0 },\n    Bold: { selector: \"Helvetica-Bold\", weight: void 0 },\n    Oblique: { selector: \"Helvetica-Oblique\", weight: void 0 },\n    \"Light Oblique\": { selector: \"Helvetica-LightOblique\", weight: void 0 },\n    \"Bold Oblique\": { selector: \"Helvetica-BoldOblique\", weight: void 0 }\n  },\n  \"Helvetica Neue\": {\n    Regular: { selector: \"Helvetica Neue\", weight: void 0 },\n    UltraLight: { selector: \"HelveticaNeue-UltraLight\", weight: void 0 },\n    Thin: { selector: \"HelveticaNeue-Thin\", weight: void 0 },\n    Light: { selector: \"HelveticaNeue-Light\", weight: void 0 },\n    Medium: { selector: \"HelveticaNeue-Medium\", weight: void 0 },\n    Bold: { selector: \"HelveticaNeue-Bold\", weight: void 0 },\n    Italic: { selector: \"HelveticaNeue-Italic\", weight: void 0 },\n    \"UltraLight Italic\": { selector: \"HelveticaNeue-UltraLightItalic\", weight: void 0 },\n    \"Thin Italic\": { selector: \"HelveticaNeue-ThinItalic\", weight: void 0 },\n    \"Light Italic\": { selector: \"HelveticaNeue-LightItalic\", weight: void 0 },\n    \"Medium Italic\": { selector: \"HelveticaNeue-MediumItalic\", weight: void 0 },\n    \"Bold Italic\": { selector: \"HelveticaNeue-BoldItalic\", weight: void 0 },\n    \"Condensed Bold\": { selector: \"HelveticaNeue-CondensedBold\", weight: void 0 },\n    \"Condensed Black\": { selector: \"HelveticaNeue-CondensedBlack\", weight: void 0 }\n  },\n  \"Hoefler Text\": { Regular: { selector: \"Hoefler Text\", weight: void 0 } },\n  Impact: { Regular: { selector: \"Impact\", weight: void 0 } },\n  \"Lucida Grande\": { Regular: { selector: \"Lucida Grande\", weight: void 0 } },\n  Menlo: { Regular: { selector: \"Menlo\", weight: void 0 } },\n  Monaco: { Regular: { selector: \"Monaco\", weight: void 0 } },\n  Optima: {\n    Regular: { selector: \"Optima\", weight: void 0 },\n    ExtraBlack: { selector: \"Optima-ExtraBlack\", weight: void 0 }\n  },\n  Palatino: { Regular: { selector: \"Palatino\", weight: void 0 } },\n  \"SF Pro Display\": {\n    Regular: { selector: \"__SF-UI-Display-Regular__\", weight: 400 },\n    Ultralight: { selector: \"__SF-UI-Display-Ultralight__\", weight: 100 },\n    Thin: { selector: \"__SF-UI-Display-Thin__\", weight: 200 },\n    Light: { selector: \"__SF-UI-Display-Light__\", weight: 300 },\n    Medium: { selector: \"__SF-UI-Display-Medium__\", weight: 500 },\n    Semibold: { selector: \"__SF-UI-Display-Semibold__\", weight: 600 },\n    Bold: { selector: \"__SF-UI-Display-Bold__\", weight: 700 },\n    Heavy: { selector: \"__SF-UI-Display-Heavy__\", weight: 800 },\n    Black: { selector: \"__SF-UI-Display-Black__\", weight: 900 },\n    Italic: { selector: \"__SF-UI-Display-Italic__\", weight: 400 },\n    \"Ultralight Italic\": { selector: \"__SF-UI-Display-Ultralight-Italic__\", weight: 100 },\n    \"Thin Italic\": { selector: \"__SF-UI-Display-Thin-Italic__\", weight: 200 },\n    \"Light Italic\": { selector: \"__SF-UI-Display-Light-Italic__\", weight: 300 },\n    \"Medium Italic\": { selector: \"__SF-UI-Display-Medium-Italic__\", weight: 500 },\n    \"Semibold Italic\": { selector: \"__SF-UI-Display-Semibold-Italic__\", weight: 600 },\n    \"Bold Italic\": { selector: \"__SF-UI-Display-Bold-Italic__\", weight: 700 },\n    \"Heavy Italic\": { selector: \"__SF-UI-Display-Heavy-Italic__\", weight: 800 },\n    \"Black Italic\": { selector: \"__SF-UI-Display-Black-Italic__\", weight: 900 }\n  },\n  \"SF Pro Display Condensed\": {\n    Regular: { selector: \"__SF-UI-Display-Condensed-Regular__\", weight: 400 },\n    Ultralight: { selector: \"__SF-UI-Display-Condensed-Ultralight__\", weight: 100 },\n    Thin: { selector: \"__SF-UI-Display-Condensed-Thin__\", weight: 200 },\n    Light: { selector: \"__SF-UI-Display-Condensed-Light__\", weight: 300 },\n    Medium: { selector: \"__SF-UI-Display-Condensed-Medium__\", weight: 500 },\n    Semibold: { selector: \"__SF-UI-Display-Condensed-Semibold__\", weight: 600 },\n    Bold: { selector: \"__SF-UI-Display-Condensed-Bold__\", weight: 700 },\n    Heavy: { selector: \"__SF-UI-Display-Condensed-Heavy__\", weight: 800 },\n    Black: { selector: \"__SF-UI-Display-Condensed-Black__\", weight: 900 }\n  },\n  \"SF Pro Text\": {\n    Regular: { selector: \"__SF-UI-Text-Regular__\", weight: 400 },\n    Light: { selector: \"__SF-UI-Text-Light__\", weight: 200 },\n    Medium: { selector: \"__SF-UI-Text-Medium__\", weight: 500 },\n    Semibold: { selector: \"__SF-UI-Text-Semibold__\", weight: 600 },\n    Bold: { selector: \"__SF-UI-Text-Bold__\", weight: 700 },\n    Heavy: { selector: \"__SF-UI-Text-Heavy__\", weight: 800 },\n    Italic: { selector: \"__SF-UI-Text-Italic__\", weight: 400 },\n    \"Light Italic\": { selector: \"__SF-UI-Text-Light-Italic__\", weight: 200 },\n    \"Medium Italic\": { selector: \"__SF-UI-Text-Medium-Italic__\", weight: 500 },\n    \"Semibold Italic\": { selector: \"__SF-UI-Text-Semibold-Italic__\", weight: 600 },\n    \"Bold Italic\": { selector: \"__SF-UI-Text-Bold-Italic__\", weight: 700 },\n    \"Heavy Italic\": { selector: \"__SF-UI-Text-Heavy-Italic__\", weight: 800 }\n  },\n  \"SF Pro Text Condensed\": {\n    Regular: { selector: \"__SF-UI-Text-Condensed-Regular__\", weight: 400 },\n    Light: { selector: \"__SF-UI-Text-Condensed-Light__\", weight: 200 },\n    Medium: { selector: \"__SF-UI-Text-Condensed-Medium__\", weight: 500 },\n    Semibold: { selector: \"__SF-UI-Text-Condensed-Semibold__\", weight: 600 },\n    Bold: { selector: \"__SF-UI-Text-Condensed-Bold__\", weight: 700 },\n    Heavy: { selector: \"__SF-UI-Text-Condensed-Heavy__\", weight: 800 }\n  },\n  Tahoma: { Regular: { selector: \"Tahoma\", weight: void 0 } },\n  Times: { Regular: { selector: \"Times\", weight: void 0 } },\n  \"Times New Roman\": { Regular: { selector: \"Times New Roman\", weight: void 0 } },\n  Trebuchet: { Regular: { selector: \"Trebuchet MS\", weight: void 0 } },\n  Verdana: { Regular: { selector: \"Verdana\", weight: void 0 } }\n};\nvar typefaceAliases = {\n  \"__SF-Compact-Display-Regular__\": \"SFCompactDisplay-Regular|.SFCompactDisplay-Regular\",\n  \"__SF-Compact-Display-Ultralight__\": \"SFCompactDisplay-Ultralight|.SFCompactDisplay-Ultralight\",\n  \"__SF-Compact-Display-Thin__\": \"SFCompactDisplay-Thin|.SFCompactDisplay-Thin\",\n  \"__SF-Compact-Display-Light__\": \"SFCompactDisplay-Light|.SFCompactDisplay-Light\",\n  \"__SF-Compact-Display-Medium__\": \"SFCompactDisplay-Medium|.SFCompactDisplay-Medium\",\n  \"__SF-Compact-Display-Semibold__\": \"SFCompactDisplay-Semibold|.SFCompactDisplay-Semibold\",\n  \"__SF-Compact-Display-Heavy__\": \"SFCompactDisplay-Heavy|.SFCompactDisplay-Heavy\",\n  \"__SF-Compact-Display-Black__\": \"SFCompactDisplay-Black|.SFCompactDisplay-Black\",\n  \"__SF-Compact-Display-Bold__\": \"SFCompactDisplay-Bold|.SFCompactDisplay-Bold\",\n  \"__SF-UI-Text-Regular__\": \".SFNSText|SFProText-Regular|SFUIText-Regular|.SFUIText\",\n  \"__SF-UI-Text-Light__\": \".SFNSText-Light|SFProText-Light|SFUIText-Light|.SFUIText-Light\",\n  \"__SF-UI-Text-Medium__\": \".SFNSText-Medium|SFProText-Medium|SFUIText-Medium|.SFUIText-Medium\",\n  \"__SF-UI-Text-Semibold__\": \".SFNSText-Semibold|SFProText-Semibold|SFUIText-Semibold|.SFUIText-Semibold\",\n  \"__SF-UI-Text-Bold__\": \".SFNSText-Bold|SFProText-Bold|SFUIText-Bold|.SFUIText-Bold\",\n  \"__SF-UI-Text-Heavy__\": \".SFNSText-Heavy|SFProText-Heavy|.SFUIText-Heavy\",\n  \"__SF-UI-Text-Italic__\": \".SFNSText-Italic|SFProText-Italic|SFUIText-Italic|.SFUIText-Italic\",\n  \"__SF-UI-Text-Light-Italic__\": \".SFNSText-LightItalic|SFProText-LightItalic|SFUIText-LightItalic|.SFUIText-LightItalic\",\n  \"__SF-UI-Text-Medium-Italic__\": \".SFNSText-MediumItalic|SFProText-MediumItalic|SFUIText-MediumItalic|.SFUIText-MediumItalic\",\n  \"__SF-UI-Text-Semibold-Italic__\": \".SFNSText-SemiboldItalic|SFProText-SemiboldItalic|SFUIText-SemiboldItalic|.SFUIText-SemiboldItalic\",\n  \"__SF-UI-Text-Bold-Italic__\": \".SFNSText-BoldItalic|SFProText-BoldItalic|SFUIText-BoldItalic|.SFUIText-BoldItalic\",\n  \"__SF-UI-Text-Heavy-Italic__\": \".SFNSText-HeavyItalic|SFProText-HeavyItalic|.SFUIText-HeavyItalic\",\n  \"__SF-Compact-Text-Regular__\": \"SFCompactText-Regular|.SFCompactText-Regular\",\n  \"__SF-Compact-Text-Light__\": \"SFCompactText-Light|.SFCompactText-Light\",\n  \"__SF-Compact-Text-Medium__\": \"SFCompactText-Medium|.SFCompactText-Medium\",\n  \"__SF-Compact-Text-Semibold__\": \"SFCompactText-Semibold|.SFCompactText-Semibold\",\n  \"__SF-Compact-Text-Bold__\": \"SFCompactText-Bold|.SFCompactText-Bold\",\n  \"__SF-Compact-Text-Heavy__\": \"SFCompactText-Heavy|.SFCompactText-Heavy\",\n  \"__SF-Compact-Text-Italic__\": \"SFCompactText-Italic|.SFCompactText-Italic\",\n  \"__SF-Compact-Text-Light-Italic__\": \"SFCompactText-LightItalic|.SFCompactText-LightItalic\",\n  \"__SF-Compact-Text-Medium-Italic__\": \"SFCompactText-MediumItalic|.SFCompactText-MediumItalic\",\n  \"__SF-Compact-Text-Semibold-Italic__\": \"SFCompactText-SemiboldItalic|.SFCompactText-SemiboldItalic\",\n  \"__SF-Compact-Text-Bold-Italic__\": \"SFCompactText-BoldItalic|.SFCompactText-BoldItalic\",\n  \"__SF-Compact-Text-Heavy-Italic__\": \"SFCompactText-HeavyItalic|.SFCompactText-HeavyItalic\",\n  \"__SF-UI-Display-Condensed-Regular__\": \".SFNSDisplayCondensed-Regular|SFUIDisplayCondensed-Regular|.SFUIDisplayCondensed-Regular\",\n  \"__SF-UI-Display-Condensed-Ultralight__\": \".SFNSDisplayCondensed-Ultralight|SFUIDisplayCondensed-Ultralight|.SFUIDisplayCondensed-Ultralight\",\n  \"__SF-UI-Display-Condensed-Thin__\": \".SFNSDisplayCondensed-Thin|SFUIDisplayCondensed-Thin|.SFUIDisplayCondensed-Thin\",\n  \"__SF-UI-Display-Condensed-Light__\": \".SFNSDisplayCondensed-Light|SFUIDisplayCondensed-Light|.SFUIDisplayCondensed-Light\",\n  \"__SF-UI-Display-Condensed-Medium__\": \".SFNSDisplayCondensed-Medium|SFUIDisplayCondensed-Medium|.SFUIDisplayCondensed-Medium\",\n  \"__SF-UI-Display-Condensed-Semibold__\": \".SFNSDisplayCondensed-Semibold|SFUIDisplayCondensed-Semibold|.SFUIDisplayCondensed-Semibold\",\n  \"__SF-UI-Display-Condensed-Bold__\": \".SFNSDisplayCondensed-Bold|SFUIDisplayCondensed-Bold|.SFUIDisplayCondensed-Bold\",\n  \"__SF-UI-Display-Condensed-Heavy__\": \".SFNSDisplayCondensed-Heavy|SFUIDisplayCondensed-Heavy|.SFUIDisplayCondensed-Heavy\",\n  \"__SF-UI-Display-Condensed-Black__\": \".SFNSDisplayCondensed-Black|.SFUIDisplayCondensed-Black\",\n  \"__SF-UI-Display-Regular__\": \".SFNSDisplay|SFProDisplay-Regular|SFUIDisplay-Regular|.SFUIDisplay\",\n  \"__SF-UI-Display-Ultralight__\": \".SFNSDisplay-Ultralight|SFProDisplay-Ultralight|SFUIDisplay-Ultralight|.SFUIDisplay-Ultralight\",\n  \"__SF-UI-Display-Thin__\": \".SFNSDisplay-Thin|SFProDisplay-Thin|SFUIDisplay-Thin|.SFUIDisplay-Thin\",\n  \"__SF-UI-Display-Light__\": \".SFNSDisplay-Light|SFProDisplay-Light|SFUIDisplay-Light|.SFUIDisplay-Light\",\n  \"__SF-UI-Display-Medium__\": \".SFNSDisplay-Medium|SFProDisplay-Medium|SFUIDisplay-Medium|.SFUIDisplay-Medium\",\n  \"__SF-UI-Display-Semibold__\": \".SFNSDisplay-Semibold|SFProDisplay-Semibold|SFUIDisplay-Semibold|.SFUIDisplay-Semibold\",\n  \"__SF-UI-Display-Bold__\": \".SFNSDisplay-Bold|SFProDisplay-Bold|SFUIDisplay-Bold|.SFUIDisplay-Bold\",\n  \"__SF-UI-Display-Heavy__\": \".SFNSDisplay-Heavy|SFProDisplay-Heavy|SFUIDisplay-Heavy|.SFUIDisplay-Heavy\",\n  \"__SF-UI-Display-Black__\": \".SFNSDisplay-Black|SFProDisplay-Black|.SFUIDisplay-Black\",\n  \"__SF-UI-Display-Italic__\": \".SFNSDisplay-Italic|SFProDisplay-Italic|SFUIDisplay-Italic\",\n  \"__SF-UI-Display-Ultralight-Italic__\": \".SFNSDisplay-UltralightItalic|SFProDisplay-UltralightItalic|SFUIDisplay-UltralightItalic|.SFUIDisplay-UltralightItalic\",\n  \"__SF-UI-Display-Thin-Italic__\": \".SFNSDisplay-ThinItalic|SFProDisplay-ThinItalic|SFUIDisplay-ThinItalic|.SFUIDisplay-ThinItalic\",\n  \"__SF-UI-Display-Light-Italic__\": \".SFNSDisplay-LightItalic|SFProDisplay-LightItalic|SFUIDisplay-LightItalic|.SFUIDisplay-LightItalic\",\n  \"__SF-UI-Display-Medium-Italic__\": \".SFNSDisplay-MediumItalic|SFProDisplay-MediumItalic|SFUIDisplay-MediumItalic|.SFUIDisplay-MediumItalic\",\n  \"__SF-UI-Display-Semibold-Italic__\": \".SFNSDisplay-SemiboldItalic|SFProDisplay-SemiboldItalic|SFUIDisplay-SemiboldItalic|.SFUIDisplay-SemiboldItalic\",\n  \"__SF-UI-Display-Bold-Italic__\": \".SFNSDisplay-BoldItalic|SFProDisplay-BoldItalic|SFUIDisplay-BoldItalic|.SFUIDisplay-BoldItalic\",\n  \"__SF-UI-Display-Heavy-Italic__\": \".SFNSDisplay-HeavyItalic|SFProDisplay-HeavyItalic|SFUIDisplay-HeavyItalic|.SFUIDisplay-HeavyItalic\",\n  \"__SF-UI-Display-Black-Italic__\": \".SFNSDisplay-BlackItalic|SFProDisplay-BlackItalic|.SFUIDisplay-BlackItalic\",\n  \"__SF-UI-Text-Condensed-Regular__\": \".SFNSTextCondensed-Regular|SFUITextCondensed-Regular|.SFUITextCondensed-Regular\",\n  \"__SF-UI-Text-Condensed-Light__\": \".SFNSTextCondensed-Light|SFUITextCondensed-Light|.SFUITextCondensed-Light\",\n  \"__SF-UI-Text-Condensed-Medium__\": \".SFNSTextCondensed-Medium|SFUITextCondensed-Medium|.SFUITextCondensed-Medium\",\n  \"__SF-UI-Text-Condensed-Semibold__\": \".SFNSTextCondensed-Semibold|SFUITextCondensed-Semibold|.SFUITextCondensed-Semibold\",\n  \"__SF-UI-Text-Condensed-Bold__\": \".SFNSTextCondensed-Bold|SFUITextCondensed-Bold|.SFUITextCondensed-Bold\",\n  \"__SF-UI-Text-Condensed-Heavy__\": \".SFNSTextCondensed-Heavy|.SFUITextCondensed-Heavy\",\n  \"__SF-Compact-Rounded-Regular__\": \"SFCompactRounded-Regular|.SFCompactRounded-Regular\",\n  \"__SF-Compact-Rounded-Ultralight__\": \"SFCompactRounded-Ultralight|.SFCompactRounded-Ultralight\",\n  \"__SF-Compact-Rounded-Thin__\": \"SFCompactRounded-Thin|.SFCompactRounded-Thin\",\n  \"__SF-Compact-Rounded-Light__\": \"SFCompactRounded-Light|.SFCompactRounded-Light\",\n  \"__SF-Compact-Rounded-Medium__\": \"SFCompactRounded-Medium|.SFCompactRounded-Medium\",\n  \"__SF-Compact-Rounded-Semibold__\": \"SFCompactRounded-Semibold|.SFCompactRounded-Semibold\",\n  \"__SF-Compact-Rounded-Bold__\": \"SFCompactRounded-Bold|.SFCompactRounded-Bold\",\n  \"__SF-Compact-Rounded-Heavy__\": \"SFCompactRounded-Heavy|.SFCompactRounded-Heavy\",\n  \"__SF-Compact-Rounded-Black__\": \"SFCompactRounded-Black|.SFCompactRounded-Black\"\n};\nvar typefaces = typeof safeWindow !== \"undefined\" && safeWindow[\"SystemTypefaceDescriptors\"] !== void 0 ? convertToObject(safeWindow[\"SystemTypefaceDescriptors\"]) : safeFonts;\nvar defaultFontSelector = typeof safeWindow !== \"undefined\" && typeof safeWindow[\"SystemTypefaceDefaultSelector\"] === \"string\" ? safeWindow[\"SystemTypefaceDefaultSelector\"] : \"Inter\";\n\n// src/render/fonts/types.ts\nvar TypefaceSourceNames;\n(function(TypefaceSourceNames2) {\n  TypefaceSourceNames2[\"Google\"] = \"google\";\n  TypefaceSourceNames2[\"Local\"] = \"local\";\n  TypefaceSourceNames2[\"Custom\"] = \"custom\";\n})(TypefaceSourceNames || (TypefaceSourceNames = {}));\n\n// src/render/fonts/GoogleFontSource.ts\nvar googleFontSelectorPrefix = \"GF;\";\nvar GoogleFontSource = class {\n  constructor() {\n    this.name = TypefaceSourceNames.Google;\n    this.typefaces = [];\n    this.byFamily = new Map();\n  }\n  getTypefaceByFamily(family) {\n    var _a;\n    return (_a = this.byFamily.get(family)) != null ? _a : null;\n  }\n  parseSelector(selector) {\n    if (!selector.startsWith(googleFontSelectorPrefix))\n      return null;\n    const tokens = selector.split(\"-\");\n    if (tokens.length !== 2)\n      return null;\n    const family = tokens[0].replace(googleFontSelectorPrefix, \"\");\n    const variant = tokens[1];\n    return { family, variant, source: this.name };\n  }\n  createTypeface(family) {\n    const typeface = { family, fonts: [], source: this.name };\n    this.addTypeface(typeface);\n    return typeface;\n  }\n  addTypeface(typeface) {\n    this.typefaces.push(typeface);\n    this.byFamily.set(typeface.family, typeface);\n  }\n  importFonts(webFonts) {\n    let fontLocators = [];\n    webFonts.forEach((webFont) => {\n      const locators = webFont.variants.map((variant) => ({\n        source: this.name,\n        variant,\n        family: webFont.family,\n        file: webFont.files[variant].replace(\"http://\", \"https://\")\n      }));\n      fontLocators = fontLocators.concat(locators);\n    });\n    return fontLocators;\n  }\n};\n\n// src/render/fonts/LocalFontSource.ts\nvar systemTypefaceName = \"System Default\";\nvar LocalFontSource = class {\n  constructor() {\n    this.name = TypefaceSourceNames.Local;\n    this.typefaces = [];\n    this.byFamily = new Map();\n    this.typefaceAliasBySelector = new Map();\n    this.typefaceAliases = new Map();\n    this.interTypefaceSelectors = new Set();\n  }\n  getTypefaceByFamily(family) {\n    var _a;\n    return (_a = this.byFamily.get(family)) != null ? _a : null;\n  }\n  createTypeface(family) {\n    const typeface = { family, fonts: [], source: this.name };\n    this.addTypeface(typeface);\n    return typeface;\n  }\n  addTypeface(typeface) {\n    this.typefaces.push(typeface);\n    this.byFamily.set(typeface.family, typeface);\n  }\n  importFonts() {\n    const fonts = [];\n    for (const family of Object.keys(typefaces)) {\n      const members = typefaces[family];\n      if (!members)\n        continue;\n      const typeface = this.createTypeface(family);\n      for (const variant of Object.keys(members)) {\n        const member = members[variant];\n        if (!member)\n          continue;\n        const { selector, weight } = member;\n        const font = {\n          variant,\n          selector,\n          weight,\n          typeface,\n          status: \"loaded\"\n        };\n        typeface.fonts.push(font);\n      }\n      fonts.push(...typeface.fonts);\n    }\n    for (const [key6, value] of Object.entries(typefaceAliases)) {\n      this.addTypefaceAlias(key6, value);\n    }\n    const { typeface: systemTypeface, aliases } = this.getSystemTypeface();\n    this.addTypeface(systemTypeface);\n    for (const [key6, value] of aliases) {\n      this.addTypefaceAlias(key6, value);\n    }\n    fonts.push(...systemTypeface.fonts);\n    const interTypeface = this.importInterTypeface();\n    fonts.push(...interTypeface.fonts);\n    return fonts;\n  }\n  importInterTypeface() {\n    const inter = [\n      [\"Regular\", \"Inter\", void 0],\n      [\"Thin\", \"Inter-Thin\", 100],\n      [\"Extra Light\", \"Inter-ExtraLight\", 200],\n      [\"Light\", \"Inter-Light\", 300],\n      [\"Medium\", \"Inter-Medium\", 500],\n      [\"Semibold\", \"Inter-SemiBold\", 600],\n      [\"Bold\", \"Inter-Bold\", 700],\n      [\"Extra Bold\", \"Inter-ExtraBold\", 800],\n      [\"Black\", \"Inter-Black\", 900],\n      [\"Thin Italic\", \"Inter-ThinItalic\", 100],\n      [\"Extra Light Italic\", \"Inter-ExtraLightItalic\", 300],\n      [\"Light Italic\", \"Inter-LightItalic\", 300],\n      [\"Italic\", \"Inter-Italic\", void 0],\n      [\"Medium Italic\", \"Inter-MediumItalic\", 500],\n      [\"Semibold Italic\", \"Inter-SemiBoldItalic\", 600],\n      [\"Bold Italic\", \"Inter-BoldItalic\", 700],\n      [\"Extra Bold Italic\", \"Inter-ExtraBoldItalic\", 800],\n      [\"Black Italic\", \"Inter-BlackItalic\", 900]\n    ];\n    const typeface = this.createTypeface(\"Inter\");\n    for (const entry of inter) {\n      const [variant, selector, weight] = entry;\n      const font = {\n        variant,\n        selector,\n        weight,\n        typeface,\n        style: /italic/i.test(selector) ? \"italic\" : void 0\n      };\n      typeface.fonts.push(font);\n    }\n    typeface.fonts.forEach((t) => this.interTypefaceSelectors.add(t.selector));\n    return typeface;\n  }\n  addTypefaceAlias(key6, value) {\n    this.typefaceAliases.set(key6, value);\n    this.typefaceAliasBySelector.set(value, key6);\n  }\n  getSystemTypeface() {\n    const fontFamilies = this.workaroundChrome81and82(\"system-ui|-apple-system|BlinkMacSystemFont|Segoe UI|Roboto|Oxygen|Ubuntu|Cantarell|Fira Sans|Droid Sans|Helvetica Neue|sans-serif\");\n    const typeface = { family: systemTypefaceName, fonts: [], source: this.name };\n    const aliases = new Map();\n    const weights = [400, 100, 200, 300, 500, 600, 700, 800, 900];\n    const styles = [\"normal\", \"italic\"];\n    for (const style of styles) {\n      for (const weight of weights) {\n        const variant = createVariantName(weight, style);\n        const alias = `__SystemDefault-${weight}-${style}__`;\n        const font = {\n          variant,\n          selector: alias,\n          style: style === \"normal\" ? void 0 : style,\n          weight: weight === 400 ? void 0 : weight,\n          typeface,\n          status: \"loaded\"\n        };\n        typeface.fonts.push(font);\n        aliases.set(alias, fontFamilies);\n      }\n    }\n    return { typeface, aliases };\n  }\n  getTypefaceAliasBySelector(selector) {\n    return this.typefaceAliasBySelector.get(selector) || null;\n  }\n  getTypefaceSelectorByAlias(alias) {\n    return this.typefaceAliases.get(alias) || null;\n  }\n  isTypefaceAlias(value) {\n    if (value && value.match(/^__.*__$/))\n      return true;\n    return false;\n  }\n  workaroundChrome81and82(s) {\n    const userAgent = navigator.userAgent;\n    if (!userAgent.includes(\"Mac OS X 10_15\"))\n      return s;\n    if (!userAgent.includes(\"Chrome/81\") && !userAgent.includes(\"Chrome/82\"))\n      return s;\n    return `Inter|${s}`;\n  }\n};\nvar fontWeightNames = {\n  \"100\": \"Thin\",\n  \"200\": \"Extra Light\",\n  \"300\": \"Light\",\n  \"400\": \"Normal\",\n  \"500\": \"Medium\",\n  \"600\": \"Semi Bold\",\n  \"700\": \"Bold\",\n  \"800\": \"Extra Bold\",\n  \"900\": \"Black\"\n};\nfunction createVariantName(weight, style) {\n  const friendlyStyle = style === \"normal\" ? \"Regular\" : \"Italic\";\n  if (weight === 400) {\n    return friendlyStyle;\n  }\n  if (style !== \"normal\") {\n    return `${fontWeightNames[weight]} ${friendlyStyle}`;\n  }\n  return `${fontWeightNames[weight]}`;\n}\n\n// src/render/fonts/utils.ts\nfunction parseVariant(variant) {\n  if (variant === \"regular\")\n    return { style: \"normal\", weight: 400 };\n  const res = /([0-9]*)([a-z]*)/.exec(variant);\n  if (!res)\n    return null;\n  const weight = parseInt(res[1] || \"400\");\n  const style = res[2] || \"normal\";\n  return { weight, style };\n}\n\n// src/render/fonts/CustomFontSource.ts\nvar customFontSelectorPrefix = \"CUSTOM;\";\nfunction getCustomFontName(fileName, properties) {\n  if (!properties)\n    return fileName.substring(0, fileName.lastIndexOf(\".\"));\n  const fontFamily = properties.font.preferredFamily === \"\" ? properties.font.fontFamily : properties.font.preferredFamily;\n  const variant = properties.font.preferredSubFamily === \"\" ? properties.font.fontSubFamily : properties.font.preferredSubFamily;\n  return `${fontFamily} ${variant}`;\n}\nvar CustomFontSource = class {\n  constructor() {\n    this.name = TypefaceSourceNames.Custom;\n    this.typefaces = [];\n    this.byFamily = new Map();\n    this.assetsByFamily = new Map();\n  }\n  importFonts(assets) {\n    this.typefaces.length = 0;\n    this.byFamily.clear();\n    this.assetsByFamily.clear();\n    const fonts = [];\n    assets.forEach((asset) => {\n      var _a;\n      if (!this.isValidCustomFontAsset(asset)) {\n        return;\n      }\n      const fontName = getCustomFontName(asset.name, asset.properties);\n      const typeface = this.createTypeface(fontName);\n      const font = {\n        typeface,\n        selector: `${customFontSelectorPrefix}${fontName}`,\n        variant: this.inferVariantName(fontName),\n        postscriptName: (_a = asset.properties) == null ? void 0 : _a.font.postscriptName,\n        file: asset.url\n      };\n      typeface.fonts.push(font);\n      typeface.owner = asset.ownerType === \"team\" ? \"team\" : \"project\";\n      this.assetsByFamily.set(fontName, asset);\n      fonts.push(...typeface.fonts);\n    });\n    return fonts;\n  }\n  isValidCustomFontAsset(asset) {\n    var _a, _b;\n    return asset.mimeType.startsWith(\"font/\") && asset.properties && \"font\" in asset.properties && ((_a = asset.properties) == null ? void 0 : _a.kind) === \"font\" && \"fontFamily\" in ((_b = asset.properties) == null ? void 0 : _b.font);\n  }\n  inferVariantName(family) {\n    const possibleValues = [\n      \"thin\",\n      \"ultra light\",\n      \"extra light\",\n      \"light\",\n      \"normal\",\n      \"medium\",\n      \"semi bold\",\n      \"bold\",\n      \"extra bold\",\n      \"black\"\n    ];\n    const possibleValuesWithItalics = [...possibleValues.map((value) => `${value} italic`), ...possibleValues];\n    const lowerCaseFamily = family.toLowerCase();\n    const tokens = [...lowerCaseFamily.split(\" \"), ...lowerCaseFamily.split(\"-\"), ...lowerCaseFamily.split(\"_\")];\n    const foundToken = possibleValuesWithItalics.find((value) => tokens.includes(value) || tokens.includes(value.replace(/\\s+/g, \"\")));\n    if (foundToken)\n      return foundToken.replace(/(^\\w|\\s\\w)/g, (char) => char.toUpperCase());\n    return \"Regular\";\n  }\n  createTypeface(family) {\n    const existingTypeface = this.byFamily.get(family);\n    if (existingTypeface)\n      return existingTypeface;\n    const typeface = {\n      source: this.name,\n      family,\n      fonts: []\n    };\n    this.addTypeface(typeface);\n    return typeface;\n  }\n  addTypeface(typeface) {\n    this.typefaces.push(typeface);\n    this.byFamily.set(typeface.family, typeface);\n  }\n  parseSelector(selector) {\n    if (!selector.startsWith(customFontSelectorPrefix))\n      return null;\n    const tokens = selector.split(customFontSelectorPrefix);\n    const locator = { source: \"custom\", family: tokens[1] };\n    return locator;\n  }\n  getFontBySelector(selector, createFont = true) {\n    const locator = this.parseSelector(selector);\n    if (!locator)\n      return null;\n    if (!createFont && !this.byFamily.get(locator.family))\n      return null;\n    return this.getTypefaceByFamily(locator.family).fonts[0];\n  }\n  getTypefaceByFamily(family) {\n    const foundTypeface = this.byFamily.get(family);\n    if (foundTypeface)\n      return foundTypeface;\n    const typeface = {\n      source: \"custom\",\n      family,\n      fonts: []\n    };\n    typeface.fonts.push({\n      selector: `${customFontSelectorPrefix}${family}`,\n      variant: this.inferVariantName(family),\n      typeface\n    });\n    return typeface;\n  }\n};\n\n// src/render/fonts/loadFont.ts\nvar import_fontfaceobserver = __toModule(require_fontfaceobserver_standalone());\nvar FONT_LOADING_TIMEOUT = 5e3;\nvar MAX_RETRIES = 3;\nvar FontLoadingError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"FontLoadingError\";\n  }\n};\nvar fontRequests = new Map();\nvar fontReadyPromises = new Map();\nvar loadFont = (data, doc) => loadFontWithRetries(data, doc);\nasync function loadFontWithRetries(data, doc, attempt = 0) {\n  const { family, url } = data;\n  const weight = data.weight || 500;\n  const style = data.style || \"normal\";\n  const requestId = `${family}-${style}-${weight}-${url}`;\n  if (!fontRequests.has(requestId) || attempt > 0) {\n    const fontFace = new FontFace(family, `url(${url})`, {\n      weight: weight == null ? void 0 : weight.toString(),\n      style\n    });\n    const readyPromise = fontFace.load().then(() => {\n      doc.fonts.add(fontFace);\n      return isFontReady(family, style, weight);\n    }).catch((e) => {\n      if (e.name !== \"NetworkError\") {\n        throw e;\n      }\n      if (attempt < MAX_RETRIES) {\n        return loadFontWithRetries(data, doc, attempt + 1);\n      }\n      throw new FontLoadingError(`Font loading failed after ${attempt} retries due to network error`);\n    });\n    fontRequests.set(requestId, readyPromise);\n  }\n  await fontRequests.get(requestId);\n}\nasync function isFontReady(family, style, weight) {\n  const readyPromiseId = `${family}-${style}-${weight}`;\n  if (!fontReadyPromises.has(readyPromiseId)) {\n    const observer = new import_fontfaceobserver.default(family, {\n      style,\n      weight\n    });\n    const readyPromise = observer.load(null, FONT_LOADING_TIMEOUT);\n    fontReadyPromises.set(readyPromiseId, readyPromise);\n  }\n  try {\n    await fontReadyPromises.get(readyPromiseId);\n  } catch (e) {\n    throw new FontLoadingError(`Failed to check if font is ready (${FONT_LOADING_TIMEOUT}ms timeout exceeded)`);\n  }\n}\n\n// src/render/fonts/fontStore.ts\nvar LoadFontResult;\n(function(LoadFontResult2) {\n  LoadFontResult2[LoadFontResult2[\"AlreadyLoaded\"] = 0] = \"AlreadyLoaded\";\n  LoadFontResult2[LoadFontResult2[\"Loaded\"] = 1] = \"Loaded\";\n})(LoadFontResult || (LoadFontResult = {}));\nvar FontStore = class {\n  constructor() {\n    this.bySelector = new Map();\n    this.loadedSelectors = new Set();\n    this.createGoogleFont = (locator) => {\n      const { source, family, variant, file } = locator;\n      let typeface = this.getTypeface(locator);\n      if (!typeface) {\n        typeface = this[source].createTypeface(family);\n      }\n      const variantInfo = parseVariant(variant) || {};\n      const { weight, style } = variantInfo;\n      const selector = `GF;${family}-${variant}`;\n      const font = {\n        typeface,\n        variant,\n        selector,\n        weight,\n        style,\n        file\n      };\n      typeface.fonts.push(font);\n      return font;\n    };\n    this.local = new LocalFontSource();\n    this.google = new GoogleFontSource();\n    this.custom = new CustomFontSource();\n    this.bySelector = new Map();\n    this.importLocalFonts();\n    this.defaultFont = this.getFontBySelector(defaultFontSelector);\n    if (this.defaultFont) {\n      this.loadFont(this.defaultFont);\n    }\n  }\n  addFont(font) {\n    this.bySelector.set(font.selector, font);\n  }\n  getAvailableFonts() {\n    return Array.from(this.bySelector.values());\n  }\n  importLocalFonts() {\n    this.local.importFonts().forEach((font) => {\n      this.addFont(font);\n      if (!this.local.interTypefaceSelectors.has(font.selector)) {\n        this.loadFont(font);\n      }\n    });\n  }\n  async importGoogleFonts() {\n    if (!this.getGoogleFontsListPromise) {\n      this.getGoogleFontsListPromise = runtime.fetchGoogleFontsList();\n      const googleFonts = await this.getGoogleFontsListPromise;\n      this.google.importFonts(googleFonts).forEach((locator) => {\n        const font = this.createGoogleFont(locator);\n        this.addFont(font);\n      });\n    }\n    return this.getGoogleFontsListPromise;\n  }\n  importCustomFonts(assets) {\n    this.bySelector.forEach((_, key6) => {\n      if (key6.startsWith(customFontSelectorPrefix)) {\n        this.bySelector.delete(key6);\n      }\n    });\n    this.custom.importFonts(assets).forEach((font) => this.addFont(font));\n  }\n  getTypeface(info) {\n    const typeface = this[info.source].getTypefaceByFamily(info.family);\n    return typeface;\n  }\n  getFontBySelector(selector, createFont = true) {\n    if (selector.startsWith(customFontSelectorPrefix)) {\n      return this.custom.getFontBySelector(selector, createFont);\n    }\n    return this.bySelector.get(selector) || null;\n  }\n  getDraftPropertiesBySelector(selector) {\n    const font = this.getFontBySelector(selector);\n    if (font) {\n      return {\n        style: font.style,\n        weight: font.weight,\n        variant: font.variant,\n        family: font.typeface.family,\n        source: font.typeface.source\n      };\n    }\n    const locator = this.google.parseSelector(selector);\n    if (locator) {\n      const fontVariant = parseVariant(locator.variant);\n      if (fontVariant) {\n        return {\n          style: fontVariant.style,\n          weight: fontVariant.weight,\n          variant: locator.variant,\n          family: locator.family,\n          source: TypefaceSourceNames.Google\n        };\n      }\n    }\n    return null;\n  }\n  isSelectorLoaded(selector) {\n    return this.loadedSelectors.has(selector);\n  }\n  async loadTypeface(typeface) {\n    await Promise.all(typeface.fonts.map((f) => this.loadFont(f)));\n  }\n  async loadFont(font) {\n    if (this.isSelectorLoaded(font.selector)) {\n      return 0;\n    }\n    if (font.typeface.source === TypefaceSourceNames.Local) {\n      if (this.local.interTypefaceSelectors.has(font.selector) && true) {\n        await isFontReady(font.typeface.family, font.style, font.weight);\n      }\n      this.loadedSelectors.add(font.selector);\n      return 1;\n    }\n    if (!font.file) {\n      return Promise.reject(`Unable to load font: ${font.selector}`);\n    }\n    await loadFont({\n      family: font.typeface.family,\n      url: font.file,\n      weight: font.weight,\n      style: font.style\n    }, document);\n    this.loadedSelectors.add(font.selector);\n    return 1;\n  }\n  async loadWebFontsFromSelectors(selectors) {\n    if (selectors.some((s) => s.startsWith(googleFontSelectorPrefix))) {\n      await this.importGoogleFonts();\n    }\n    const fonts = selectors.map((s) => this.bySelector.get(s)).filter((f) => !!f);\n    return Promise.allSettled(fonts.map((f) => this.loadFont(f)));\n  }\n};\nvar fontStore = new FontStore();\nPromise.allSettled = Promise.allSettled || ((promises) => Promise.all(promises.map((p) => p.then((v) => ({ status: \"fulfilled\", value: v })).catch((e) => ({ status: \"rejected\", reason: e })))));\n\n// src/render/utils/isShallowEqualArray.ts\nfunction isShallowEqualArray(a2, b2) {\n  return a2.length === b2.length && a2.every((v, i) => v === b2[i]);\n}\n\n// src/render/presentation/Text.tsx\nfunction Text(props) {\n  var _a;\n  const parentSize = useParentSize();\n  const layoutId = useLayoutId2(props);\n  const layoutRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  useMeasureLayout(props, layoutRef);\n  const { fonts, __fromCanvasComponent } = props;\n  const prevFontsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n  const fontsDidChange = !isShallowEqualArray((_a = prevFontsRef.current) != null ? _a : [], fonts != null ? fonts : []);\n  prevFontsRef.current = fonts;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!fontsDidChange || !fonts)\n      return;\n    fontStore.loadWebFontsFromSelectors(fonts).then((results) => {\n      if (!__fromCanvasComponent || !layoutRef.current || RenderTarget.current() !== RenderTarget.canvas)\n        return;\n      const didLoadNewFonts = results.some((result) => result.status === \"fulfilled\" && result.value === LoadFontResult.Loaded);\n      if (!didLoadNewFonts)\n        return;\n      measureClosestComponentContainer(layoutRef.current);\n    });\n  }, [fonts]);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(TextComponent, {\n    ...props,\n    innerRef: layoutRef,\n    layoutId,\n    parentSize\n  });\n}\nvar _TextComponent = class extends Layer {\n  constructor() {\n    super(...arguments);\n    this.renderMain = (inCodeComponent) => {\n      if (safeWindow[\"perf\"])\n        safeWindow[\"perf\"].nodeRender();\n      const {\n        font,\n        visible,\n        alignment,\n        willChangeTransform,\n        opacity,\n        id,\n        layoutId,\n        className,\n        transition,\n        variants,\n        name,\n        innerRef,\n        __fromCanvasComponent,\n        widthType,\n        heightType,\n        _usesDOMRect,\n        autoSize,\n        style: styleProp\n      } = this.props;\n      const frame2 = this.frame;\n      if (!visible) {\n        return null;\n      }\n      injectComponentCSSRules();\n      const isHidden2 = this.props.isEditable && this.props.environment() === RenderTarget.canvas;\n      const justifyContent = convertVerticalAlignment(this.props.verticalAlignment);\n      const style = {\n        outline: \"none\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        justifyContent,\n        opacity: isHidden2 ? 0 : opacity,\n        flexShrink: 0\n      };\n      const dataProps = {\n        \"data-framer-component-type\": \"Text\",\n        \"data-framer-name\": name\n      };\n      if (autoSize) {\n        dataProps[\"data-framer-component-text-autosized\"] = \"true\";\n      }\n      this.collectLayout(style, inCodeComponent);\n      collectFiltersFromProps(this.props, style);\n      collectTextShadowsForProps(this.props, style);\n      if (style.opacity === 1 || style.opacity === void 0) {\n        delete style.opacity;\n      }\n      if (willChangeTransform) {\n        forceLayerBackingWithCSSProperties(style);\n      }\n      let rawHTML = this.props.rawHTML;\n      const text = this.getOverrideText() || this.props.text;\n      if (isString2(text)) {\n        if (rawHTML) {\n          rawHTML = replaceDraftHTMLWithText(rawHTML, text);\n        } else {\n          rawHTML = `<p style=\"font: ${font}\">${text}</p>`;\n        }\n      }\n      if (this.props.style) {\n        Object.assign(style, this.props.style);\n      }\n      const isDOMLayoutAutoSized = _usesDOMRect && (widthType === DimensionType.Auto || heightType === DimensionType.Auto);\n      const hasTransformTemplate = !frame2 || !RenderTarget.hasRestrictions() || __fromCanvasComponent || isDOMLayoutAutoSized;\n      if (hasTransformTemplate) {\n        Object.assign(dataProps, layoutHintDataPropsForCenter(this.props.center));\n      }\n      if (rawHTML) {\n        style.textAlign = alignment;\n        style.lineHeight = \"1px\";\n        style.fontSize = \"0px\";\n        return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(motion.div, {\n          layoutId,\n          id,\n          ...dataProps,\n          style: { ...style, ...styleProp },\n          transformTemplate: hasTransformTemplate ? transformTemplate(this.props.center) : void 0,\n          dangerouslySetInnerHTML: { __html: rawHTML },\n          \"data-center\": this.props.center,\n          className,\n          transition,\n          variants,\n          ref: innerRef\n        });\n      }\n    };\n  }\n  get frame() {\n    return calculateRect(this.props, this.props.parentSize || ParentSizeState.Unknown, false);\n  }\n  getOverrideText() {\n    const { _forwardedOverrideId, _forwardedOverrides, id } = this.props;\n    const forwardedOverrideId = _forwardedOverrideId != null ? _forwardedOverrideId : id;\n    if (forwardedOverrideId && _forwardedOverrides) {\n      const text = _forwardedOverrides[forwardedOverrideId];\n      if (isString2(text)) {\n        return text;\n      }\n    }\n  }\n  render() {\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ComponentContainerContext.Consumer, null, this.renderMain);\n  }\n  collectLayout(style, inCodeComponent) {\n    if (this.props.withExternalLayout)\n      return;\n    const frame2 = this.frame;\n    const {\n      rotation,\n      autoSize,\n      positionSticky,\n      positionStickyTop,\n      positionStickyRight,\n      positionStickyBottom,\n      positionStickyLeft,\n      width: externalWidth,\n      height: externalHeight,\n      _usesDOMRect\n    } = this.props;\n    const rotate = Animatable.getNumber(rotation);\n    const isDOMLayoutAutoSized = _usesDOMRect && (externalWidth === \"auto\" || externalHeight === \"auto\");\n    if (frame2 && !isDOMLayoutAutoSized && RenderTarget.hasRestrictions()) {\n      Object.assign(style, {\n        transform: `translate(${frame2.x}px, ${frame2.y}px) rotate(${rotate.toFixed(4)}deg)`,\n        width: autoSize ? \"auto\" : `${frame2.width}px`,\n        minWidth: `${frame2.width}px`,\n        height: `${frame2.height}px`\n      });\n    } else {\n      const { left, right, top, bottom } = this.props;\n      let width;\n      let height;\n      if (autoSize) {\n        width = \"auto\";\n        height = \"auto\";\n      } else {\n        if (!isFiniteNumber(left) || !isFiniteNumber(right)) {\n          width = externalWidth;\n        }\n        if (!isFiniteNumber(top) || !isFiniteNumber(bottom)) {\n          height = externalHeight;\n        }\n      }\n      Object.assign(style, {\n        left,\n        right,\n        top,\n        bottom,\n        width,\n        height,\n        rotate\n      });\n    }\n    if (positionSticky) {\n      const onCanvas = RenderTarget.current() === RenderTarget.canvas;\n      if (!onCanvas || inCodeComponent) {\n        style.position = \"sticky\";\n        style.willChange = \"transform\";\n        style.zIndex = 1;\n        style.top = positionStickyTop;\n        style.right = positionStickyRight;\n        style.bottom = positionStickyBottom;\n        style.left = positionStickyLeft;\n      }\n    }\n  }\n};\nvar TextComponent = _TextComponent;\nTextComponent.supportsConstraints = true;\nTextComponent.defaultTextProps = {\n  opacity: void 0,\n  left: void 0,\n  right: void 0,\n  top: void 0,\n  bottom: void 0,\n  _constraints: {\n    enabled: true,\n    aspectRatio: null\n  },\n  rotation: 0,\n  visible: true,\n  alignment: void 0,\n  verticalAlignment: \"top\",\n  shadows: [],\n  font: \"16px \" + deviceFont()\n};\nTextComponent.defaultProps = {\n  ...Layer.defaultProps,\n  ..._TextComponent.defaultTextProps,\n  isEditable: false,\n  environment: RenderTarget.current,\n  withExternalLayout: false\n};\nvar textContentRegex = /(<span [^>]+>).*<\\/span>/s;\nfunction replaceDraftHTMLWithText(rawHTML, text) {\n  return rawHTML.replace(textContentRegex, (_, span) => span + text + \"</span>\");\n}\nfunction convertVerticalAlignment(verticalAlignment) {\n  switch (verticalAlignment) {\n    case \"top\":\n      return \"flex-start\";\n    case \"center\":\n      return \"center\";\n    case \"bottom\":\n      return \"flex-end\";\n  }\n}\n\n// src/render/presentation/Vector.tsx\n\n\n// src/render/utils/transformString.ts\nfunction transformString(transform2) {\n  if (transform2 === void 0) {\n    return void 0;\n  }\n  const { x, y, rotation, width, height } = transform2;\n  let result;\n  if (x !== 0 || y !== 0) {\n    result = `translate(${roundedNumberString(x, 3)} ${roundedNumberString(y, 3)})`;\n  }\n  if (rotation !== 0) {\n    const roundedRotation = roundedNumberString(rotation, 4);\n    const roundedWidth = roundedNumberString(width / 2, 3);\n    const roundedHeight = roundedNumberString(height / 2, 3);\n    const rotationString = `rotate(${roundedRotation} ${roundedWidth} ${roundedHeight})`;\n    result = result ? `${result} ${rotationString}` : rotationString;\n  }\n  return result;\n}\n\n// src/render/presentation/SVGRoot.tsx\n\nvar SVGRoot = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  render() {\n    const { children, frame: frame2 } = this.props;\n    const { width, height } = frame2;\n    const fx = Math.floor(frame2.x);\n    const fy = Math.floor(frame2.y);\n    const svgStyle = {\n      position: \"absolute\",\n      width: Math.ceil(width),\n      height: Math.ceil(height),\n      overflow: \"visible\",\n      display: \"block\",\n      transform: `translate(${fx}px, ${fy}px)`\n    };\n    Layer.applyWillChange(this.props, svgStyle, false);\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"svg\", {\n      width: \"100%\",\n      height: \"100%\",\n      xmlns: \"http://www.w3.org/2000/svg\",\n      xmlnsXlink: \"http://www.w3.org/1999/xlink\",\n      style: svgStyle\n    }, children);\n  }\n};\n\n// src/render/presentation/GradientElement.tsx\n\nvar LinearGradientElement = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  render() {\n    const { id, angle, stops } = this.props;\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"linearGradient\", {\n      id,\n      gradientTransform: `rotate(${angle}, 0.5, 0.5)`\n    }, stops.map((stop, idx) => {\n      return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"stop\", {\n        key: idx,\n        offset: stop.position,\n        stopColor: stop.color,\n        stopOpacity: stop.alpha\n      });\n    }));\n  }\n};\nvar RadialGradientElement = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  render() {\n    const { centerAnchorX, centerAnchorY, id, widthFactor, heightFactor, stops } = this.props;\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"radialGradient\", {\n      id,\n      cy: centerAnchorY,\n      cx: centerAnchorX,\n      r: widthFactor,\n      gradientTransform: `translate(${centerAnchorX}, ${centerAnchorY}) scale(1 ${heightFactor / widthFactor}) translate(-${centerAnchorX}, -${centerAnchorY})`\n    }, stops.map((stop, idx) => {\n      return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"stop\", {\n        key: idx,\n        offset: stop.position,\n        stopColor: stop.color,\n        stopOpacity: stop.alpha\n      });\n    }));\n  }\n};\n\n// src/render/utils/createTransformValues.ts\nfunction createTransformValues(baseTransform, mode) {\n  let { x, y } = baseTransform;\n  const { width, height, rotation } = baseTransform;\n  if (mode === \"resetXYKeepFraction\") {\n    x = x - Math.floor(x);\n    y = y - Math.floor(y);\n  } else if (mode === \"resetXY\") {\n    x = 0;\n    y = 0;\n  }\n  return { x, y, width, height, rotation };\n}\nfunction getTransformMode(isRootVectorNode, includeTransform) {\n  if (includeTransform !== void 0) {\n    if (includeTransform) {\n      return \"asIs\";\n    }\n  } else {\n    if (!isRootVectorNode) {\n      return \"asIs\";\n    }\n  }\n  if (isRootVectorNode) {\n    return \"resetXYKeepFraction\";\n  } else {\n    return \"resetXY\";\n  }\n}\nfunction transformValues2(rect, rotation, isRootVectorNode, includeTransform) {\n  const transformMode = getTransformMode(isRootVectorNode, includeTransform);\n  const baseTransform = { ...rect, rotation };\n  const transform2 = createTransformValues(baseTransform, transformMode);\n  return transform2;\n}\n\n// src/render/types/svgElementAttributeDefaults.ts\nvar svgElementAttributeDefaults = {\n  stroke: \"none\",\n  strokeWidth: 1,\n  strokeLinecap: \"butt\",\n  strokeLinejoin: \"miter\",\n  strokeMiterlimit: 4,\n  strokeDasharray: \"0\",\n  strokeDashoffset: 0,\n  strokeOpacity: 1,\n  fill: \"black\",\n  fillRule: \"nonzero\",\n  fillOpacity: 1\n};\n\n// src/render/presentation/Vector.tsx\nvar _Vector = class extends Layer {\n  render() {\n    var _a, _b;\n    if (safeWindow[\"perf\"])\n      safeWindow[\"perf\"].nodeRender();\n    const {\n      opacity,\n      calculatedPath,\n      d,\n      insideStroke,\n      shapeId,\n      strokeEnabled,\n      strokeClipId,\n      strokeWidth,\n      idAttribute,\n      rect,\n      shadows,\n      strokeAlpha,\n      name,\n      includeTransform,\n      isRootVectorNode,\n      rotation,\n      id,\n      lineCap,\n      lineJoin,\n      strokeColor,\n      strokeMiterLimit,\n      strokeDashArray,\n      strokeDashOffset,\n      fill,\n      variants,\n      transition\n    } = this.props;\n    if (!id || !shapeId || !strokeClipId)\n      return null;\n    const rotate = (_b = (_a = this.props.rotate) != null ? _a : rotation) != null ? _b : 0;\n    const { target } = RenderEnvironment;\n    const transform2 = transformValues2(rect, rotate, isRootVectorNode, includeTransform);\n    let vectorFill;\n    let fillAlpha = 0;\n    let imagePattern;\n    let linearGradient;\n    let radialGradient;\n    if (typeof fill === \"string\" || Color.isColorObject(fill)) {\n      const fillColor = Color.isColorObject(fill) ? fill.initialValue || Color.toRgbString(fill) : fill;\n      if (fillColor !== \"transparent\") {\n        vectorFill = fillColor;\n        fillAlpha = ConvertColor.getAlpha(vectorFill);\n      }\n    } else if (LinearGradient.isLinearGradient(fill)) {\n      linearGradient = elementPropertiesForLinearGradient(fill, id);\n      vectorFill = `url(#${linearGradient.id})`;\n      fillAlpha = 1;\n    } else if (RadialGradient.isRadialGradient(fill)) {\n      radialGradient = elementPropertiesForRadialGradient(fill, id);\n      vectorFill = `url(#${radialGradient.id})`;\n      fillAlpha = 1;\n    } else if (BackgroundImage.isImageObject(fill)) {\n      imagePattern = imagePatternPropsForFill(fill, transform2, id);\n      if (imagePattern) {\n        vectorFill = `url(#${imagePattern.id})`;\n        fillAlpha = 1;\n      }\n    }\n    if (vectorFill === svgElementAttributeDefaults.fill) {\n      vectorFill = void 0;\n    }\n    if (vectorFill === void 0) {\n      vectorFill = \"transparent\";\n    }\n    const fillEnabled = vectorFill !== void 0 && vectorFill !== \"transparent\" && fillAlpha !== 0;\n    if (!fillEnabled && !strokeEnabled) {\n      fillAlpha = 1;\n    }\n    let mainElement;\n    let strokeClipPath = null;\n    let shapeReference = null;\n    let strokeElement = null;\n    let pathTranslate;\n    let elementTransform;\n    const translatePaths = target === RenderTarget.export;\n    if (transform2.rotation === 0 && translatePaths) {\n      pathTranslate = transform2;\n    } else {\n      pathTranslate = { x: 0, y: 0 };\n      elementTransform = transformString(transform2);\n    }\n    const pathAttributes = {\n      d: d != null ? d : toSVGPath(calculatedPath, pathTranslate, target),\n      transform: elementTransform\n    };\n    const svgStrokeAttributes = {};\n    if (strokeEnabled && strokeWidth !== 0) {\n      svgStrokeAttributes.strokeWidth = strokeWidth;\n      svgStrokeAttributes.stroke = strokeColor;\n      svgStrokeAttributes.strokeLinecap = lineCap;\n      svgStrokeAttributes.strokeLinejoin = lineJoin;\n      if (lineJoin === \"miter\") {\n        svgStrokeAttributes.strokeMiterlimit = strokeMiterLimit;\n      }\n      svgStrokeAttributes.strokeDasharray = strokeDashArray;\n      if (strokeDashOffset !== 0) {\n        svgStrokeAttributes.strokeDashoffset = strokeDashOffset;\n      }\n    }\n    for (const key6 in svgElementAttributeDefaults) {\n      if (svgStrokeAttributes[key6] === svgElementAttributeDefaults[key6]) {\n        svgStrokeAttributes[key6] = void 0;\n      }\n    }\n    const internalShapeId = InternalID.forKey(shapeId);\n    const internalStrokeClipId = InternalID.forKey(strokeClipId);\n    const shadow = shadowForShape(shadows, rect, internalShapeId, fillAlpha, strokeAlpha, strokeWidth, internalStrokeClipId, svgStrokeAttributes);\n    const currentName = target === RenderTarget.preview ? name || void 0 : void 0;\n    if (shadow.insetElement !== null || shadow.outsetElement !== null || insideStroke) {\n      pathAttributes.id = internalShapeId.id;\n      shapeReference = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(motion.path, {\n        ...{ ...pathAttributes },\n        variants,\n        transition\n      });\n      if (shadow.needsStrokeClip || insideStroke) {\n        strokeClipPath = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"clipPath\", {\n          id: internalStrokeClipId.id\n        }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"use\", {\n          xlinkHref: internalShapeId.link\n        }));\n      }\n      if (shadow.insetElement !== null && strokeEnabled && strokeWidth && strokeWidth > 0) {\n        mainElement = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"use\", {\n          xlinkHref: internalShapeId.link,\n          fill: vectorFill,\n          strokeOpacity: \"0\",\n          name: currentName\n        });\n        strokeElement = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"use\", {\n          xlinkHref: internalShapeId.link,\n          clipPath: internalStrokeClipId.urlLink,\n          fill: \"transparent\",\n          ...svgStrokeAttributes,\n          strokeWidth\n        });\n      } else {\n        mainElement = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"use\", {\n          xlinkHref: internalShapeId.link,\n          fill: vectorFill,\n          clipPath: internalStrokeClipId.urlLink,\n          ...svgStrokeAttributes,\n          strokeWidth,\n          name: currentName\n        });\n      }\n    } else {\n      pathAttributes.id = idAttribute;\n      mainElement = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(motion.path, {\n        ...{\n          ...pathAttributes,\n          fill: vectorFill,\n          ...svgStrokeAttributes\n        },\n        name: currentName,\n        variants,\n        transition\n      });\n    }\n    const imagePatternElement = imagePattern ? /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ImagePatternElement, {\n      ...imagePattern\n    }) : void 0;\n    let gradient;\n    if (linearGradient) {\n      gradient = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(LinearGradientElement, {\n        ...linearGradient\n      });\n    } else if (radialGradient) {\n      gradient = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(RadialGradientElement, {\n        ...radialGradient\n      });\n    }\n    let defs = null;\n    if (shapeReference || strokeClipPath || shadow.definition && shadow.definition.length || gradient || imagePatternElement) {\n      defs = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"defs\", null, shapeReference, strokeClipPath, shadow.definition, gradient, imagePatternElement);\n    }\n    const opacityValue = opacity != null ? opacity : variants ? 1 : void 0;\n    if (defs === null && shadow.outsetElement === null && shadow.insetElement === null && strokeElement === null) {\n      mainElement = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(motion.path, {\n        ...{\n          ...pathAttributes,\n          fill: vectorFill,\n          ...svgStrokeAttributes\n        },\n        opacity: opacityValue,\n        variants,\n        transition,\n        name: currentName\n      });\n      return this.renderElement(mainElement);\n    } else {\n      return this.renderElement(/* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(motion.g, {\n        opacity: opacityValue,\n        variants,\n        transition\n      }, defs, shadow.outsetElement, mainElement, shadow.insetElement, strokeElement));\n    }\n  }\n  renderElement(element) {\n    var _a, _b;\n    const { isRootVectorNode, width, height, rect, willChangeTransform } = this.props;\n    const frame2 = (_b = (_a = this.props.frame) != null ? _a : rect) != null ? _b : { x: 0, y: 0, width: 100, height: 100 };\n    if (!isRootVectorNode)\n      return element;\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(SVGRoot, {\n      ...{ frame: frame2, width, height, willChangeTransform }\n    }, element);\n  }\n};\nvar Vector = _Vector;\nVector.defaultVectorProps = {\n  isRootVectorNode: false,\n  name: null,\n  includeTransform: void 0,\n  defaultFillColor: void 0,\n  defaultStrokeColor: void 0,\n  defaultStrokeWidth: void 0,\n  defaultStrokeAlignment: \"center\",\n  width: 100,\n  height: 100,\n  rotation: 0,\n  rotate: void 0,\n  frame: void 0,\n  opacity: void 0,\n  calculatedPath: [],\n  d: void 0,\n  shapeId: void 0,\n  insideStroke: false,\n  strokeEnabled: true,\n  strokeClipId: void 0,\n  strokeWidth: void 0,\n  idAttribute: void 0,\n  transition: void 0,\n  shadows: [],\n  strokeAlpha: 1,\n  rect: { x: 0, y: 0, width: 0, height: 0 },\n  lineCap: \"butt\",\n  strokeColor: \"#0AF\",\n  lineJoin: \"miter\",\n  strokeMiterLimit: 4,\n  strokeDashArray: \"0\",\n  strokeDashOffset: 0,\n  fill: \"rgba(0,170,255,0.5)\"\n};\nVector.defaultProps = {\n  ...Layer.defaultProps,\n  ..._Vector.defaultVectorProps\n};\n\n// src/render/presentation/VectorGroup.tsx\n\nvar _VectorGroup = class extends Layer {\n  render() {\n    if (safeWindow[\"perf\"])\n      safeWindow[\"perf\"].nodeRender();\n    const {\n      id,\n      name: nameProp,\n      opacity,\n      visible,\n      targetName,\n      defaultName,\n      children,\n      includeTransform,\n      x,\n      y,\n      width,\n      height,\n      rotation,\n      isRootVectorNode\n    } = this.props;\n    if (!visible)\n      return null;\n    const { target } = RenderEnvironment;\n    const rect = { x, y, width, height };\n    const transform2 = transformValues2(rect, rotation, isRootVectorNode, includeTransform);\n    const addNames = target === RenderTarget.preview;\n    let name = void 0;\n    if (addNames) {\n      if (targetName) {\n        name = targetName;\n      } else if (nameProp) {\n        name = nameProp;\n      } else {\n        name = defaultName;\n      }\n    }\n    return this.renderElement(/* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"g\", {\n      transform: transformString(transform2),\n      ...{ id, name, opacity }\n    }, children));\n  }\n  renderElement(element) {\n    const { isRootVectorNode, width, height, frame: frame2, willChangeTransform } = this.props;\n    if (!isRootVectorNode) {\n      return element;\n    }\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(SVGRoot, {\n      ...{ frame: frame2, width, height, willChangeTransform }\n    }, element);\n  }\n};\nvar VectorGroup = _VectorGroup;\nVectorGroup.defaultVectorGroupProps = {\n  name: void 0,\n  opacity: void 0,\n  visible: true,\n  x: 0,\n  y: 0,\n  rotation: 0,\n  width: 100,\n  height: 100,\n  targetName: void 0,\n  defaultName: \"\",\n  isRootVectorNode: false,\n  includeTransform: void 0,\n  frame: { x: 0, y: 0, width: 100, height: 100 }\n};\nVectorGroup.defaultProps = {\n  ...Layer.defaultProps,\n  ..._VectorGroup.defaultVectorGroupProps\n};\n\n// src/render/presentation/DeprecatedComponentContainer.tsx\n\nvar _DeprecatedComponentContainer = class extends Layer {\n  constructor() {\n    super(...arguments);\n    this.state = {};\n  }\n  componentDidCatch(error, info) {\n    let stack = info.componentStack.split(\"\\n\").filter((line) => line.length !== 0);\n    let currentIndex = 0;\n    for (const line of stack) {\n      if (line.startsWith(`    in ${this.constructor.name}`)) {\n        break;\n      }\n      currentIndex++;\n    }\n    stack = stack.slice(0, currentIndex);\n    this.setState({\n      lastError: {\n        children: this.props.children,\n        name: error.name,\n        message: error.message,\n        componentStack: stack\n      }\n    });\n  }\n  renderErrorPlaceholder(file, error) {\n    const { RenderPlaceholder } = runtime;\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FrameWithMotion, {\n      ...this.props,\n      background: null\n    }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(RenderPlaceholder, {\n      error: { error, file }\n    }));\n  }\n  render() {\n    var _a, _b;\n    if (safeWindow[\"perf\"])\n      safeWindow[\"perf\"].nodeRender();\n    let { children } = this.props;\n    const { componentIdentifier, innerRef } = this.props;\n    const { lastError: error } = this.state;\n    const noChildren = !children || Array.isArray(children) && children.filter((c2) => c2).length === 0;\n    if (noChildren) {\n      const errorComponent = runtime.componentLoader.errorForIdentifier(componentIdentifier);\n      if (errorComponent) {\n        return this.renderErrorPlaceholder(errorComponent.file, errorComponent.error);\n      }\n    }\n    if (error && error.children === children) {\n      const component = runtime.componentLoader.componentForIdentifier(componentIdentifier);\n      const file = component ? component.file : \"???\";\n      return this.renderErrorPlaceholder(file, error.message);\n    }\n    (_b = (_a = safeWindow)[\"__checkComponentBudget__\"]) == null ? void 0 : _b.call(_a);\n    let frameProps = this.props;\n    if (RenderTarget.current() !== RenderTarget.canvas) {\n      const {\n        left,\n        right,\n        top,\n        bottom,\n        center,\n        centerX,\n        centerY,\n        aspectRatio,\n        parentSize,\n        width,\n        height,\n        rotation,\n        opacity,\n        visible,\n        _constraints,\n        _initialStyle,\n        name,\n        positionSticky,\n        positionStickyTop,\n        positionStickyRight,\n        positionStickyBottom,\n        positionStickyLeft,\n        componentIdentifier: originalComponentIdentifier,\n        children: originalChildren,\n        style,\n        duplicatedFrom,\n        widthType,\n        heightType,\n        ...childProps\n      } = frameProps;\n      children = react__WEBPACK_IMPORTED_MODULE_0__.Children.map(originalChildren, (child) => {\n        var _a2;\n        if (!isReactChild(child) || !isReactElement(child)) {\n          return child;\n        }\n        if (!isPageOrScroll(originalComponentIdentifier)) {\n          return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(LayoutGroupContext.Provider, {\n            value: (_a2 = this.props.__layoutId) != null ? _a2 : null\n          }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(AnimateSharedLayout, null, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(AutomaticLayoutIds, {\n            enabled: false\n          }, (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(child, childProps))));\n        }\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(child, childProps);\n      });\n      frameProps = {\n        style,\n        _constraints,\n        _initialStyle,\n        left,\n        right,\n        top,\n        bottom,\n        center,\n        centerX,\n        centerY,\n        aspectRatio,\n        parentSize,\n        width,\n        height,\n        rotation,\n        visible,\n        name,\n        duplicatedFrom,\n        id: frameProps.id,\n        layoutId: this.props.__layoutId,\n        widthType,\n        heightType,\n        positionSticky,\n        positionStickyTop,\n        positionStickyRight,\n        positionStickyBottom,\n        positionStickyLeft\n      };\n    }\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ComponentContainerContext.Provider, {\n      value: true\n    }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FrameWithMotion, {\n      \"data-framer-component-container\": true,\n      background: null,\n      overflow: \"visible\",\n      ref: innerRef,\n      ...frameProps\n    }, children));\n  }\n};\nvar DeprecatedComponentContainer = _DeprecatedComponentContainer;\nDeprecatedComponentContainer.supportsConstraints = true;\nDeprecatedComponentContainer.defaultComponentContainerProps = {\n  style: {},\n  visible: true,\n  componentIdentifier: \"\"\n};\nDeprecatedComponentContainer.defaultProps = {\n  ...Layer.defaultProps,\n  ..._DeprecatedComponentContainer.defaultComponentContainerProps\n};\nDeprecatedComponentContainer.contextType = ComponentContainerContext;\nfunction isPageOrScroll(identifier) {\n  if (!identifier)\n    return false;\n  if (identifier === \"framer/Page\")\n    return true;\n  if (identifier === \"framer/Scroll\")\n    return true;\n  return false;\n}\n\n// src/render/presentation/PresentationTree.ts\nfunction convertPresentationTree(node, converter, componentDefinitionProvider, getCachedNode, skipCodeComponentPropsCache = false) {\n  const cachedNode = getCachedNode && getCachedNode(node);\n  if (cachedNode)\n    return cachedNode;\n  let children;\n  if (isCodeComponentContainerPresentation(node)) {\n    children = convertCodeComponentContainer(componentDefinitionProvider, node, converter, getCachedNode, skipCodeComponentPropsCache);\n  } else if (node.children) {\n    children = node.children.map((n) => convertPresentationTree(n, converter, componentDefinitionProvider, getCachedNode, skipCodeComponentPropsCache));\n  }\n  return converter(node, children);\n}\nfunction isCodeComponentContainerPresentation(value) {\n  return !!value.codeComponentIdentifier;\n}\nfunction convertCodeComponentContainer(componentDefinitionProvider, node, converter, getCachedNode, skipCodeComponentPropsCache = false) {\n  const codeComponentChildren = node.getComponentChildren ? node.getComponentChildren(componentDefinitionProvider) : [];\n  const codeComponentSlots = node.getComponentSlotChildren ? node.getComponentSlotChildren(componentDefinitionProvider) : {};\n  let codeComponentPresentation;\n  const props = node.getCodeComponentProps ? node.getCodeComponentProps(componentDefinitionProvider, { skipCache: skipCodeComponentPropsCache }) : void 0;\n  if (node.cache.codeComponentPresentation) {\n    codeComponentPresentation = node.cache.codeComponentPresentation;\n    if (!isShallowEqualArray(codeComponentPresentation.children, codeComponentChildren)) {\n      codeComponentPresentation.cache.reactElement = null;\n      codeComponentPresentation.children = codeComponentChildren;\n    }\n    if (!isEqual(codeComponentPresentation.props, props)) {\n      codeComponentPresentation.cache.reactElement = null;\n      codeComponentPresentation.cache.props = null;\n      codeComponentPresentation.props = props;\n    }\n  } else {\n    const { id: containerId, codeComponentIdentifier: identifier, codeComponentPackageVersion } = node;\n    node.cache.codeComponentPresentation = codeComponentPresentation = new CodeComponentPresentation(containerId + identifier, identifier, codeComponentPackageVersion, props, codeComponentChildren);\n  }\n  codeComponentPresentation.props.placeholders = node.cache.placeholders;\n  const slotKeys = Object.keys(codeComponentSlots);\n  if (slotKeys.length) {\n    codeComponentPresentation.props = { ...codeComponentPresentation.props };\n    codeComponentPresentation.props.__slotKeys = slotKeys;\n    for (const slotKey of slotKeys) {\n      const slotChildren = codeComponentSlots[slotKey].map((child) => convertPresentationTree(child, converter, componentDefinitionProvider, getCachedNode, skipCodeComponentPropsCache));\n      codeComponentPresentation.props[slotKey] = slotChildren;\n    }\n  }\n  return [\n    converter(codeComponentPresentation, codeComponentPresentation.children.map((child) => convertPresentationTree(child, converter, componentDefinitionProvider, getCachedNode, skipCodeComponentPropsCache)))\n  ];\n}\nvar CodeComponentPresentation = class {\n  constructor(id, componentIdentifier, packageVersion, props, children, codeOverrideIdentifier) {\n    this.id = id;\n    this.componentIdentifier = componentIdentifier;\n    this.packageVersion = packageVersion;\n    this.props = props;\n    this.children = children;\n    this.codeOverrideIdentifier = codeOverrideIdentifier;\n    this.cache = {};\n  }\n  getProps() {\n    return {\n      ...this.props,\n      id: this.id,\n      key: this.id\n    };\n  }\n  rect(parentSize) {\n    return { x: 0, y: 0, width: 0, height: 0 };\n  }\n};\n\n// src/components/useNavigation.ts\n\nfunction useNavigation() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NavigationContext);\n}\n\n// src/render/style/getCSSTextColorFromStyle.ts\nfunction _getCSSTextColorFromStyle(css) {\n  let color2;\n  if (typeof css[\"webkitTextFillColor\"] === \"string\") {\n    color2 = css[\"webkitTextFillColor\"];\n  }\n  if (typeof css.WebkitTextFillColor === \"string\") {\n    color2 = css.WebkitTextFillColor;\n  }\n  if (typeof css.color === \"string\") {\n    color2 = css.color;\n  }\n  if (color2) {\n    return ConvertColor.toRgbString(color2);\n  }\n}\n\n// src/render/DesignComponentWrapper.tsx\n\n\n// src/deprecated/WithOverride.tsx\n\n\n\n// src/deprecated/DataObserver.tsx\n\n\n// src/data/Data.ts\nfunction Data(initial = {}) {\n  const data = ObservableObject(initial, false, false);\n  Data.addData(data);\n  return data;\n}\n(function(Data2) {\n  Data2._stores = [];\n  function addData(data) {\n    Data2._stores.push(data);\n  }\n  Data2.addData = addData;\n  function reset() {\n    Data2._stores.forEach((target) => ObservableObject.resetObject(target));\n  }\n  Data2.reset = reset;\n  function addObserver(target, observer) {\n    return ObservableObject.addObserver(target, observer);\n  }\n  Data2.addObserver = addObserver;\n})(Data || (Data = {}));\n\n// src/deprecated/DataObserver.tsx\nvar initialState = { update: 0 };\nvar DataObserverContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(initialState);\nfunction useObserveData() {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DataObserverContext);\n}\nvar DataObserver = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor() {\n    super(...arguments);\n    this.observers = [];\n    this.state = initialState;\n    this.taskAdded = false;\n    this.frameTask = () => {\n      this.setState({ update: this.state.update + 1 });\n      this.taskAdded = false;\n    };\n    this.observer = () => {\n      if (this.taskAdded)\n        return;\n      this.taskAdded = true;\n      MainLoop.addFrameTask(this.frameTask);\n    };\n  }\n  componentWillUnmount() {\n    this.observers.map((cancel) => cancel());\n    Data.reset();\n  }\n  render() {\n    const { children } = this.props;\n    this.observers.map((cancel) => cancel());\n    this.observers = [];\n    Data._stores.forEach((d) => {\n      const observer = Data.addObserver(d, this.observer);\n      this.observers.push(observer);\n    });\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(DataObserverContext.Provider, {\n      value: { ...this.state }\n    }, children);\n  }\n};\n\n// src/deprecated/convertColorProps.ts\nfunction convertColorObject(prop) {\n  if (typeof prop === \"string\" || isMotionValue2(prop)) {\n    return prop;\n  } else if (LinearGradient.isLinearGradient(prop)) {\n    return LinearGradient.toCSS(prop);\n  } else if (RadialGradient.isRadialGradient(prop)) {\n    return RadialGradient.toCSS(prop);\n  } else if (Color.isColorObject(prop)) {\n    return Color.toRgbString(prop);\n  }\n  return prop;\n}\nfunction convertColorProps(props) {\n  if (props.background || props.color) {\n    const converted = Object.assign({}, props);\n    if (props.background) {\n      converted.background = convertColorObject(props.background);\n    }\n    if (props.color) {\n      converted.color = convertColorObject(props.color);\n    }\n    return converted;\n  }\n  return props;\n}\n\n// src/deprecated/WithOverride.tsx\nvar hoistNonReactStatic4 = require_hoist_non_react_statics_cjs();\nfunction WithOverride(Component19, override) {\n  const useOverride = typeof override === \"function\" ? (props) => override(convertColorProps(props)) : () => convertColorProps(override);\n  const ComponentWithOverride = function(props) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DataObserverContext);\n    const overrideProps = useOverride(props);\n    const { style, ...rest } = props;\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Component19, {\n      ...rest,\n      ...overrideProps,\n      _initialStyle: style\n    });\n  };\n  hoistNonReactStatic4(ComponentWithOverride, Component19);\n  ComponentWithOverride[\"displayName\"] = `WithOverride(${Component19.displayName || Component19.name})`;\n  return ComponentWithOverride;\n}\n\n// src/render/DesignComponentWrapper.tsx\nvar _CanvasStore = class {\n  constructor() {\n    this.canvas = { children: [] };\n    this.listeners = [];\n    this.ids = [];\n  }\n  static shared(data) {\n    if (data) {\n      const store = new _CanvasStore();\n      store.setCanvas(data);\n      return store;\n    }\n    if (!_CanvasStore.__shared) {\n      _CanvasStore.__shared = new _CanvasStore();\n    }\n    return _CanvasStore.__shared;\n  }\n  updateNode(presentationNode) {\n    const id = presentationNode.props.id;\n    let children = this.canvas.children;\n    if (!children) {\n      this.canvas.children = children = [];\n    }\n    let found = false;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.props.id === id) {\n        found = true;\n        children[i] = presentationNode;\n        break;\n      }\n    }\n    if (!found) {\n      children.push(presentationNode);\n    }\n    this.setCanvas(this.canvas);\n  }\n  setCanvas(canvas) {\n    if (!canvas.children)\n      return;\n    this.canvas = canvas;\n    this.listeners.forEach((l, at) => {\n      const id = this.ids[at];\n      const data = findNodeFor(canvas, id);\n      l.setState({ data });\n    });\n  }\n  registerListener(listener, idOrName) {\n    this.listeners.push(listener);\n    this.ids.push(idOrName);\n    return findNodeFor(this.canvas, idOrName);\n  }\n  removeListener(listener) {\n    const at = this.listeners.indexOf(listener);\n    if (at === -1)\n      return;\n    this.listeners.splice(at, 1);\n    this.ids.splice(at, 1);\n  }\n};\nvar CanvasStore = _CanvasStore;\nCanvasStore.__shared = null;\nvar builtInComponents = { Frame, Vector, Stack, VectorGroup, SVG, Text, DeprecatedComponentContainer };\nvar DesignComponent = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  _typeForName(name) {\n    const builtIn = builtInComponents[name];\n    if (builtIn)\n      return builtIn;\n    const codeComponent = runtime.componentLoader.componentForIdentifier(name);\n    if (codeComponent && isReactDefinition(codeComponent)) {\n      return codeComponent.class;\n    }\n    return Frame;\n  }\n  _renderData(presentation, componentProps, topLevelProps) {\n    safeWindow[\"__checkBudget__\"]();\n    const { componentClass, name } = presentation;\n    let { props, children } = presentation;\n    props = { ...props, _constraints: { enabled: false } };\n    const type = this._typeForName(componentClass);\n    if (!type)\n      return null;\n    if (topLevelProps) {\n      const { style, ...rest } = props;\n      props = { ...rest, ...topLevelProps, _initialStyle: style };\n    }\n    if (!props.size && props._sizeOfMasterOnCanvas) {\n      if (!props.width) {\n        props.width = props._sizeOfMasterOnCanvas.width;\n      }\n      if (!props.height) {\n        props.height = props._sizeOfMasterOnCanvas.height;\n      }\n    }\n    if (name && componentProps.hasOwnProperty(name)) {\n      if (componentClass === \"Text\") {\n        const text = componentProps[name];\n        if (text) {\n          props = { ...props, text: componentProps[name] };\n        }\n      } else {\n        const orig = props.background;\n        const background = { src: componentProps[name], fit: orig.fit };\n        props = { ...props, background };\n      }\n    }\n    const c2 = children && children.map((child) => this._renderData(child, componentProps, void 0));\n    children = children ? c2 : [];\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(type, props, children);\n  }\n  render() {\n    safeWindow[\"__checkBudget__\"]();\n    const data = this.state.data;\n    if (!data) {\n      throw new Error(\"Unable to connect to canvas data store.\");\n    }\n    return this._renderData(this.state.data, this.props, this.props);\n  }\n};\nfunction isNode2(id, presentation) {\n  const { name, props } = presentation;\n  return props && props.id === id || name === id;\n}\nfunction findNodeFor(presentation, id) {\n  if (!presentation)\n    return null;\n  if (isNode2(id, presentation)) {\n    return presentation;\n  }\n  const { children } = presentation;\n  if (!children || !isArray(children))\n    return null;\n  for (const child of children) {\n    if (isNode2(id, child)) {\n      return child;\n    }\n  }\n  for (const child of children) {\n    const result = findNodeFor(child, id);\n    if (result)\n      return result;\n  }\n  return null;\n}\nfunction createDesignComponent(canvasStore, id, propertyControls, width = 200, height = 200) {\n  var _a;\n  return _a = class extends DesignComponent {\n    static rect(props) {\n      const constraintValues = ConstraintValues.fromProperties(props);\n      return ConstraintValues.toRect(constraintValues, props.parentSize || null, null);\n    }\n    static minSize(props, parentSize) {\n      const constraintValues = ConstraintValues.fromProperties(props);\n      return ConstraintValues.toMinSize(constraintValues, parentSize || null);\n    }\n    static size(props, parentSize, freeSpace) {\n      const constraintValues = ConstraintValues.fromProperties(props);\n      return ConstraintValues.toSize(constraintValues, parentSize || null, null, freeSpace);\n    }\n    constructor(props, context) {\n      super(props, context);\n      const data = canvasStore.registerListener(this, id);\n      this.state = { data };\n    }\n    render() {\n      const maybeRenderWithProvider = (renderNode) => {\n        const nodeId = nodeIdFromString(id);\n        if (!this.state.data && renderNode) {\n          safeWindow[\"__checkBudget__\"]();\n          const el = renderNode(nodeId);\n          if (el && (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(el) && typeof el.type !== \"string\") {\n            return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(WithOverride(el.type, this.props), el.props);\n          }\n        }\n        return super.render();\n      };\n      return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(RenderNodeContext.Consumer, null, maybeRenderWithProvider);\n    }\n    componentWillUnmount() {\n      canvasStore.removeListener(this);\n    }\n  }, _a.displayName = `DesignComponent(${id})`, _a.propertyControls = propertyControls, _a.supportsConstraints = true, _a.defaultProps = {\n    _sizeOfMasterOnCanvas: {\n      width,\n      height\n    }\n  }, _a;\n}\nvar RenderNodeContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar RenderNodeProvider = RenderNodeContext.Provider;\n\n// src/render/utils/withGeneratedLayoutId.tsx\n\nvar withGeneratedLayoutId = (Component19) => (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref) => {\n  const layoutId = useLayoutId2(props);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Component19, {\n    layoutId,\n    ...props,\n    layoutIdKey: void 0,\n    duplicatedFrom: void 0,\n    ref\n  });\n});\n\n// src/data/useData/index.ts\n\n\n// src/data/useData/store.ts\nfunction bindActionsToStore(get, set, actions) {\n  const boundActions = {};\n  for (const key6 in actions) {\n    boundActions[key6] = (data) => set(actions[key6](get(), data));\n  }\n  return boundActions;\n}\nfunction createStore(initialState2, unboundActions) {\n  let state = initialState2;\n  let version2 = 0;\n  const subscribers = new Set();\n  const notifySubscriber = (sub) => sub(version2);\n  const get = () => state;\n  const set = (latestState) => {\n    version2++;\n    state = latestState;\n    subscribers.forEach(notifySubscriber);\n  };\n  const actions = unboundActions ? bindActionsToStore(get, set, unboundActions) : set;\n  return {\n    get,\n    set,\n    getVersion: () => version2,\n    getActions: () => actions,\n    subscribe: (sub) => {\n      subscribers.add(sub);\n      return () => subscribers.delete(sub);\n    }\n  };\n}\n\n// src/data/useData/index.ts\nvar defaultId = Symbol(\"default\");\nvar DataContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(defaultId);\nfunction createData(defaultState2, actions) {\n  const stores = new Map();\n  const useData = (id, initialState2) => {\n    const contextId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DataContext);\n    id = id || contextId;\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n      if (!stores.has(id)) {\n        stores.set(id, createStore(initialState2 || defaultState2, actions));\n      }\n      return stores.get(id);\n    }, [id]);\n    const [, notifyUpdates] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(store.getVersion());\n    const storeValueAtHookCallTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => store.get(), [store]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      const unsubscribe = store.subscribe(notifyUpdates);\n      if (storeValueAtHookCallTime !== store.get())\n        notifyUpdates(store.getVersion());\n      return unsubscribe;\n    }, [store, storeValueAtHookCallTime]);\n    return [store.get(), store.getActions()];\n  };\n  return useData;\n}\n\n// src/utils/addActionControls.ts\nfunction addActionControls(action, title, controls) {\n  runtime.addActionControls(action, title, controls);\n}\n\n// src/data/PropertyStore.ts\nfunction PropertyStore(initial = {}, makeAnimatables = false) {\n  deprecationWarning(\"PropertyStore\", \"1.0.0\", \"Data() or ObservableObject()\");\n  return ObservableObject(initial, makeAnimatables);\n}\n(function(PropertyStore2) {\n  function addObserver(target, observer) {\n    return ObservableObject.addObserver(target, observer);\n  }\n  PropertyStore2.addObserver = addObserver;\n})(PropertyStore || (PropertyStore = {}));\n\n// src/utils/network.ts\nfunction loadJSON(url) {\n  return fetch(url, { mode: \"cors\" }).then((res) => res.json());\n}\n\n// src/utils/inspectObjectType.ts\nfunction inspectObjectType(item) {\n  let className;\n  if ((item.constructor !== null ? item.constructor.name : void 0) !== null && (item.constructor !== null ? item.constructor.name : void 0) !== \"Object\") {\n    return item.constructor.name;\n  }\n  const extract = function(str) {\n    if (!str) {\n      return null;\n    }\n    const regex = /\\[object (\\w+)\\]/;\n    const match = regex.exec(str);\n    if (match) {\n      return match[1];\n    }\n    return null;\n  };\n  if (item.toString) {\n    className = extract(item.toString());\n    if (className) {\n      return className;\n    }\n  }\n  if (item.constructor !== null ? item.constructor.toString : void 0) {\n    className = extract(item.constructor !== null ? item.constructor.toString() : void 0);\n    if (className) {\n      return className.replace(\"Constructor\", \"\");\n    }\n  }\n  return \"Object\";\n}\n\n// src/utils/inspect.ts\nfunction inspect(item, max, l) {\n  if (max === void 0) {\n    max = 5;\n  }\n  if (l === void 0) {\n    l = 0;\n  }\n  if (item === null) {\n    return \"null\";\n  }\n  if (item === void 0) {\n    return \"undefined\";\n  }\n  if (isFunction(item.toInspect)) {\n    return item.toInspect();\n  }\n  if (isString2(item)) {\n    return `\"${item}\"`;\n  }\n  if (isNumber(item)) {\n    return `${item}`;\n  }\n  if (isFunction(item)) {\n    let code = item.toString().slice(\"function \".length).replace(/\\n/g, \"\").replace(/\\s+/g, \" \");\n    const limit = 50;\n    if (code.length > limit && l > 0) {\n      code = `${code.slice(0, +limit + 1 || void 0).trim()}\\u2026 }`;\n    }\n    return `<Function ${code}>`;\n  }\n  if (isArray(item)) {\n    if (l > max) {\n      return \"[...]\";\n    }\n    return `[${item.map((i) => inspect(i, max, (l || 0) + 1)).join(\", \")}]`;\n  }\n  if (isObject(item)) {\n    let objectInfo;\n    const objectType = inspectObjectType(item);\n    if (/HTML\\w+?Element/.test(objectType)) {\n      return `<${objectType}>`;\n    }\n    if (l > max) {\n      objectInfo = \"{...}\";\n    } else {\n      const itemKeys = Object.keys(item);\n      objectInfo = `{${itemKeys.map((k) => `${k}:${inspect(item[k], max, (l || 0) + 1)}`).join(\", \")}}`;\n    }\n    if (objectType === \"Object\") {\n      return objectInfo;\n    }\n    return `<${objectType} ${objectInfo}>`;\n  }\n  return `${item}`;\n}\n\n// src/utils/print.ts\nfunction print(...args) {\n  const line = args.map((arg) => {\n    return inspect(arg);\n  }).join(\", \");\n  console.log(line);\n}\n\n// src/utils/addFonts.ts\nfunction addFonts(component, fonts) {\n  Object.assign(component, { fonts });\n}\nfunction getFonts(component) {\n  const fonts = component.fonts;\n  return fonts || [];\n}\n\n// src/version.ts\nvar version = \"1.3.6\";\n\n// src/animation/Motion/MotionSetup.tsx\n\n\n// src/animation/Motion/autoValueHandlers.ts\nvar correctBorderScale = (axis) => ({\n  process: (latest, { delta: delta2, treeScale }) => {\n    if (typeof latest === \"string\")\n      latest = parseFloat(latest);\n    if (latest === 0)\n      return \"0px\";\n    let corrected = Math.round(latest / delta2[axis].scale / treeScale[axis]);\n    corrected = Math.max(corrected, 1);\n    return corrected + \"px\";\n  }\n});\n\n// src/animation/Motion/MotionSetup.tsx\naddScaleCorrection({\n  borderTopWidth: correctBorderScale(\"y\"),\n  borderLeftWidth: correctBorderScale(\"x\"),\n  borderRightWidth: correctBorderScale(\"x\"),\n  borderBottomWidth: correctBorderScale(\"y\")\n});\nfunction MotionSetup({ children }) {\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, children);\n}\n\n// src/animation/Motion/startAnimation.ts\nfunction startAnimation2(_key, value, target, transition = {}) {\n  warnOnce(`\"startAnimation\" is unsupported. Use \"animate\" instead: https://www.framer.com/api/motion/utilities/#animate`);\n  return new Promise((resolve) => {\n    animate2(value, target, {\n      ...transition,\n      onComplete: () => resolve()\n    });\n  });\n}\n\n// src/modules/useAddVariantProps.ts\n\nfunction useAddVariantProps(baseVariant, gestureVariant, variantProps2) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id) => {\n    var _a, _b, _c;\n    if (!variantProps2)\n      return {};\n    if (!baseVariant)\n      return {};\n    if (gestureVariant) {\n      return Object.assign({}, (_a = variantProps2[baseVariant]) == null ? void 0 : _a[id], (_b = variantProps2[gestureVariant]) == null ? void 0 : _b[id]);\n    }\n    return ((_c = variantProps2[baseVariant]) == null ? void 0 : _c[id]) || {};\n  }, [baseVariant, gestureVariant, variantProps2]);\n}\n\n// src/modules/useVariantState.ts\n\nfunction createGestureVariant(variant, type) {\n  return `${variant}-${type}`;\n}\nfunction nextVariant(allVariants, currentVariant) {\n  const index = allVariants.indexOf(currentVariant);\n  let nextIndex = index + 1;\n  if (nextIndex >= allVariants.length) {\n    nextIndex = 0;\n  }\n  return allVariants[nextIndex];\n}\nvar VariantSelector;\n(function(VariantSelector2) {\n  VariantSelector2[\"Variant\"] = \"v\";\n})(VariantSelector || (VariantSelector = {}));\nfunction getGesture(enabledGestures, isHovered, isPressed) {\n  const { hover, pressed } = enabledGestures || {};\n  if (pressed && isPressed)\n    return \"pressed\";\n  if (hover && isHovered)\n    return \"hover\";\n}\nfunction createVariantClassName(baseVariant, variantClassNames) {\n  const mappedClassName = variantClassNames[baseVariant];\n  if (mappedClassName)\n    return mappedClassName;\n  return `framer-${VariantSelector.Variant}-${baseVariant}`;\n}\nvar CycleVariantState = Symbol(\"cycle\");\nfunction useVariantState({\n  variant,\n  defaultVariant: externalDefaultVariant,\n  transitions: externalTransitions,\n  enabledGestures: externalEnabledGestures,\n  cycleOrder: externalCycleOrder = [],\n  variantProps: variantProps2 = {},\n  variantClassNames = {}\n}) {\n  const forceUpdate = useForceUpdate2();\n  const internalState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    isHovered: false,\n    isPressed: false,\n    baseVariant: variant != null ? variant : externalDefaultVariant,\n    gestureVariant: void 0,\n    defaultVariant: externalDefaultVariant,\n    enabledGestures: externalEnabledGestures,\n    cycleOrder: externalCycleOrder,\n    transitions: externalTransitions\n  });\n  const resolveNextVariant = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nextBaseVariant = internalState.current.defaultVariant) => {\n    const {\n      baseVariant: baseVariant2,\n      gestureVariant: gestureVariant2,\n      isPressed: isPressed2,\n      isHovered: isHovered2,\n      defaultVariant: defaultVariant2,\n      enabledGestures: enabledGestures2\n    } = internalState.current;\n    const gesture = getGesture(enabledGestures2 == null ? void 0 : enabledGestures2[nextBaseVariant], isHovered2, isPressed2);\n    const nextGestureVariant = gesture ? createGestureVariant(nextBaseVariant, gesture) : void 0;\n    if (nextBaseVariant !== baseVariant2 || nextGestureVariant !== gestureVariant2) {\n      internalState.current.baseVariant = nextBaseVariant || defaultVariant2;\n      internalState.current.gestureVariant = nextGestureVariant;\n      forceUpdate();\n    }\n  }, [forceUpdate]);\n  const setGestureState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ isHovered: isHovered2, isPressed: isPressed2 }) => {\n    if (isHovered2 !== void 0)\n      internalState.current.isHovered = isHovered2;\n    if (isPressed2 !== void 0)\n      internalState.current.isPressed = isPressed2;\n    resolveNextVariant(internalState.current.baseVariant);\n  }, [resolveNextVariant]);\n  const setVariant = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((proposedVariant) => {\n    const { defaultVariant: defaultVariant2, cycleOrder, baseVariant: baseVariant2 } = internalState.current;\n    const nextBaseVariant = proposedVariant === CycleVariantState ? nextVariant(cycleOrder || [], baseVariant2 || defaultVariant2) : proposedVariant;\n    resolveNextVariant(nextBaseVariant || defaultVariant2);\n  }, [resolveNextVariant]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (variant !== internalState.current.baseVariant)\n      setVariant(variant);\n  }, [variant, setVariant]);\n  const { baseVariant } = internalState.current;\n  const transition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const { transitions } = internalState.current;\n    if (!transitions)\n      return void 0;\n    if (baseVariant) {\n      const variantTransition = transitions[baseVariant];\n      if (variantTransition)\n        return variantTransition;\n    }\n    return transitions.default;\n  }, [baseVariant]);\n  const variants = [];\n  const { gestureVariant, defaultVariant, enabledGestures, isHovered, isPressed } = internalState.current;\n  if (baseVariant && baseVariant !== defaultVariant)\n    variants.push(baseVariant);\n  if (gestureVariant)\n    variants.push(gestureVariant);\n  const addVariantProps = useAddVariantProps(baseVariant, gestureVariant, variantProps2);\n  return {\n    variants,\n    baseVariant,\n    gestureVariant,\n    transition,\n    setVariant,\n    setGestureState,\n    addVariantProps,\n    classNames: cx(createVariantClassName(baseVariant, variantClassNames), getGesture(enabledGestures == null ? void 0 : enabledGestures[baseVariant], isHovered, isPressed))\n  };\n}\n\n// src/modules/withCSS.tsx\n\nvar withCSS = (Component19, escapedCSS) => (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref) => {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    const css = Array.isArray(escapedCSS) ? escapedCSS : escapedCSS.split(\"\\n\");\n    css.forEach((rule) => rule && setDocumentStyles(rule));\n  }, []);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Component19, {\n    ...props,\n    ref\n  });\n});\n\n// src/modules/Container.tsx\n\nfunction Providers({ children, layoutId, ...props }) {\n  const context = useConstant2(createBatcher);\n  const outerLayoutId = useConstant2(() => layoutId ? `${layoutId}-container` : void 0);\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(motion.div, {\n    layoutId: outerLayoutId,\n    ...props\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(ComponentContainerContext.Provider, {\n    value: true\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(SharedLayoutContext.Provider, {\n    value: context\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(AutomaticLayoutIds, {\n    enabled: false\n  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(LayoutGroupContext.Provider, {\n    value: layoutId != null ? layoutId : null\n  }, react__WEBPACK_IMPORTED_MODULE_0__.Children.map(children, (child) => {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(child) ? (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(child, { layoutId }) : child;\n  }))))));\n}\nvar Container = withGeneratedLayoutId(Providers);\n\n// src/modules/callEach.ts\nvar callEach = (...fns) => fns.forEach((fn) => fn && fn());\n\n// src/modules/useOnVariantChange.ts\n\n\n// src/modules/useIsOnFramerCanvas.ts\nfunction useIsOnFramerCanvas() {\n  return RenderTarget.current() === RenderTarget.canvas;\n}\n\n// src/modules/useOnVariantChange.ts\nfunction callbackForVariant(map, variant) {\n  if (map[variant])\n    return map[variant];\n  if (variant in map)\n    return void 0;\n  return map.default;\n}\nfunction useOnVariantChange(variant, callbackMap) {\n  const isOnFramerCanvas = useIsOnFramerCanvas();\n  if (isOnFramerCanvas)\n    return;\n  const isInCurrentTargetRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n  useOnCurrentTargetChange((isInTarget) => {\n    if (!isInCurrentTargetRef.current && isInTarget) {\n      const callback = callbackForVariant(callbackMap, variant);\n      if (callback)\n        callback();\n    }\n    isInCurrentTargetRef.current = isInTarget;\n  }, [callbackMap]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (isInCurrentTargetRef.current) {\n      const callback = callbackForVariant(callbackMap, variant);\n      if (callback)\n        callback();\n    }\n  }, [variant, callbackMap]);\n}\nfunction useOnAppear(callback) {\n  useOnVariantChange(\"default\", { default: callback });\n}\n\n// src/modules/useActiveVariantCallback.ts\n\nfunction rejectPending(pendingTimers, pendingPromises) {\n  pendingTimers.forEach((t) => clearTimeout(t));\n  pendingTimers.clear();\n  pendingPromises.forEach((reject) => reject && reject(\"Callback cancelled by variant change\"));\n  pendingPromises.clear();\n}\nfunction createSet() {\n  return new Set();\n}\nfunction useActiveVariantCallback(baseVariant) {\n  const pendingPromises = useConstant2(createSet);\n  const pendingTimers = useConstant2(createSet);\n  useOnCurrentTargetChange(() => {\n    return () => rejectPending(pendingTimers, pendingPromises);\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    return () => rejectPending(pendingTimers, pendingPromises);\n  }, [pendingPromises, pendingTimers]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    rejectPending(pendingTimers, pendingPromises);\n  }, [baseVariant, pendingPromises, pendingTimers]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    activeVariantCallback: (callback) => (...args) => {\n      return new Promise((resolve, reject) => {\n        pendingPromises.add(reject);\n        return callback(...args).then(resolve);\n      }).catch(() => {\n      });\n    },\n    delay: async (callback, msDelay) => {\n      await new Promise((resolve) => pendingTimers.add(globalThis.setTimeout(() => resolve(true), msDelay)));\n      callback();\n    }\n  }).current;\n}\nfunction useActiveTargetCallback() {\n  const value = useActiveVariantCallback(void 0);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    activeTargetCallback: value.activeVariantCallback,\n    delay: value.delay\n  }).current;\n}\n\n// src/modules/useNavigate.tsx\n\nfunction lazy2(factory) {\n  const LazyComponent = (0,react__WEBPACK_IMPORTED_MODULE_0__.lazy)(factory);\n  let factoryPromise;\n  let LoadedComponent;\n  const Component19 = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function LazyWithPreload(props, ref) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(LoadedComponent != null ? LoadedComponent : LazyComponent, Object.assign(ref ? { ref } : {}, props));\n  });\n  Component19.preload = () => {\n    if (!factoryPromise) {\n      factoryPromise = factory().then((module) => {\n        LoadedComponent = module.default;\n      });\n    }\n    return factoryPromise;\n  };\n  return Component19;\n}\nfunction useNavigate({ preload } = {}) {\n  const navigation = useNavigation();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!navigation)\n      return;\n    preload == null ? void 0 : preload.forEach((component) => \"preload\" in component && component.preload());\n  }, []);\n  if (!navigation)\n    return () => {\n    };\n  return async (target, options = {}) => {\n    if (target === \"previous\") {\n      navigation.goBack();\n      return false;\n    }\n    const { appearsFrom, backdropColor, animation } = options;\n    if (!target)\n      return;\n    switch (options.transition) {\n      case \"instant\":\n        navigation.instant(target);\n        break;\n      case \"fade\":\n        navigation.fade(target, { animation });\n        break;\n      case \"push\":\n        navigation.push(target, { appearsFrom, animation });\n        break;\n      case \"modal\":\n        navigation.modal(target, { backdropColor, animation });\n        break;\n      case \"overlay\":\n        navigation.overlay(target, { appearsFrom, backdropColor, animation });\n        break;\n      case \"flip\":\n        navigation.flip(target, { appearsFrom, animation });\n        break;\n      case \"magicMotion\":\n        navigation.magicMotion(target, { animation });\n        break;\n    }\n    return false;\n  };\n}\n\n// src/modules/LayoutGroup.tsx\n\n\nvar LayoutGroup = ({\n  id,\n  children\n}) => {\n  const parentLayoutId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LayoutGroupContext);\n  if (!id)\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, children);\n  const combinedLayoutId = parentLayoutId && parentLayoutId !== id ? `${parentLayoutId}-${id}` : id;\n  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(LayoutGroupContext.Provider, {\n    value: combinedLayoutId\n  }, children);\n};\n\n// src/modules/useHotkey.ts\n\nvar modifierDefaults = {\n  altKey: false,\n  ctrlKey: false,\n  metaKey: false,\n  shiftKey: false\n};\nfunction createShortcutDefinition(shortcut) {\n  const keys2 = shortcut.split(\"+\");\n  const key6 = keys2.pop();\n  if (!key6)\n    return void 0;\n  const modifiers = {};\n  for (const modifier of keys2) {\n    modifiers[`${modifier}Key`] = true;\n  }\n  return {\n    ...modifierDefaults,\n    ...modifiers,\n    key: key6\n  };\n}\nfunction useHotkey(shortcut, callback) {\n  const inTarget = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n  const shortcutDefinition = useConstant2(() => createShortcutDefinition(shortcut));\n  useOnCurrentTargetChange((isCurrentTarget, isOverlayed) => {\n    inTarget.current = isCurrentTarget && !isOverlayed;\n    return () => inTarget.current = false;\n  });\n  const eventHandler = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {\n    if (!shortcutDefinition)\n      return;\n    if (!inTarget.current)\n      return;\n    if (!Object.keys(shortcutDefinition).every((key6) => shortcutDefinition[key6] === event[key6]))\n      return;\n    event.preventDefault();\n    callback();\n  }, [shortcutDefinition, callback]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    document.addEventListener(\"keydown\", eventHandler);\n    return () => document.removeEventListener(\"keydown\", eventHandler);\n  }, [eventHandler]);\n}\n\n// src/modules/useGamepad.ts\n\nfunction isFramerGamepadKeydownData(value) {\n  return isObject(value) && value.mapping !== void 0;\n}\nfunction createGamepadPoller() {\n  const callbacks2 = new Set();\n  let isConnected = false;\n  let isPolling = null;\n  let lastKey = null;\n  const startPolling = () => {\n    const input = getFirstAvailableGamepadInput();\n    if (!input)\n      return;\n    const { gamepad, key: key6 } = input;\n    const { mapping, id } = gamepad;\n    if (key6 && lastKey !== key6)\n      callbacks2.forEach((callback) => callback({ key: key6, mapping, id }));\n    lastKey = key6;\n    isPolling = window.requestAnimationFrame(startPolling);\n  };\n  const handleConnection = () => {\n    if (isConnected || isPolling)\n      return;\n    startPolling();\n    isConnected = true;\n  };\n  const stopPolling = () => {\n    if (!isPolling)\n      return;\n    window.cancelAnimationFrame(isPolling);\n    isPolling = null;\n  };\n  const handleDisconnection = () => {\n    if (!isConnected)\n      return;\n    stopPolling();\n    isConnected = false;\n  };\n  const setupAndStartPolling = () => {\n    if (isPolling)\n      return;\n    const gamepad = getFirstAvailableGamepadInput();\n    if (!gamepad) {\n      window.addEventListener(\"gamepadconnected\", handleConnection);\n      return;\n    }\n    window.addEventListener(\"gamepaddisconnected\", handleDisconnection);\n    isConnected = true;\n    startPolling();\n  };\n  const cleanupAndStopPolling = () => {\n    if (!isPolling)\n      return;\n    window.removeEventListener(\"gamepadconnected\", handleConnection);\n    window.removeEventListener(\"gamepaddisconnected\", handleDisconnection);\n    stopPolling();\n  };\n  return {\n    register(callback) {\n      if (callbacks2.size === 0)\n        setupAndStartPolling();\n      callbacks2.add(callback);\n    },\n    unregister(callback) {\n      callbacks2.delete(callback);\n      if (callbacks2.size === 0)\n        cleanupAndStopPolling();\n    }\n  };\n}\nvar GamepadContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(createGamepadPoller());\nfunction getFirstAvailableGamepadInput() {\n  let firstConnectedGamepad = null;\n  const gamepads = navigator.getGamepads();\n  for (const gamepad of gamepads) {\n    if (!gamepad)\n      continue;\n    if (!firstConnectedGamepad) {\n      firstConnectedGamepad = gamepad;\n    }\n    const axis = scanPressedAxis(gamepad);\n    if (axis !== null)\n      return { gamepad, key: axis };\n    const button = scanPressedButton(gamepad);\n    if (button !== null)\n      return { gamepad, key: button };\n  }\n  if (firstConnectedGamepad)\n    return { gamepad: firstConnectedGamepad, key: null };\n  return null;\n}\nfunction scanPressedAxis(gamepad) {\n  for (const [idx, axis] of gamepad.axes.entries()) {\n    if (idx > 3)\n      return null;\n    if (axis <= -0.5)\n      return `Axis ${idx}-`;\n    if (axis > 0.5)\n      return `Axis ${idx}+`;\n  }\n  return null;\n}\nfunction scanPressedButton(gamepad) {\n  for (const [idx, button] of gamepad.buttons.entries()) {\n    if (isButtonPressed(button))\n      return `Button ${idx}`;\n  }\n  return null;\n}\nfunction isButtonPressed(button) {\n  return button.pressed === true || button.value > 0;\n}\nfunction useGamepad(key6, callback, options = { mapping: \"standard\" }) {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(GamepadContext);\n  const mapping = useConstant2(() => options.mapping);\n  const cb2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((input) => {\n    if (key6 === input.key && mapping === input.mapping)\n      callback();\n  }, [key6, mapping, callback]);\n  useOnCurrentTargetChange((isInTarget, isOverlayed) => {\n    const isActive = isInTarget && !isOverlayed;\n    if (isActive) {\n      context.register(cb2);\n    } else {\n      context.unregister(cb2);\n    }\n    return () => context.unregister(cb2);\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    return () => context.unregister(cb2);\n  }, [cb2, context]);\n}\n\n// src/index.ts\nif (false) {}\n\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n//# sourceMappingURL=framer.debug.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mcmFtZXIvYnVpbGQvZXNtL2ZyYW1lci5kZWJ1Zy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0EsdURBQXVELGFBQWE7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtHQUFrRztBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxvRUFBb0UsOENBQThDLElBQUksaUNBQWlDO0FBQ3hQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0JBQVU7QUFDcEQ7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxhQUFhO0FBQ3pFLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxREFBcUQsZ0JBQWdCO0FBQ3JFO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxjQUFjO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFNBQVMscUJBQXFCO0FBQzlCLHFCQUFxQixvREFBb0Q7QUFDekU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxXQUFXO0FBQ1gsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixnQkFBZ0I7QUFDaEIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsUUFBUTtBQUM5RDtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JELDZEQUE2RCxRQUFRO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFFBQVE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0MsaURBQWlEO0FBQ2pGLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSEFBbUg7QUFDbkg7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDRCQUE0QjtBQUMxRSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGFBQWE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGFBQWE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0RBQWdEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELE9BQU87QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFNBQVM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGlFQUFpRSxZQUFZO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHFCQUFxQixrQkFBa0IsWUFBWSxXQUFXLGdCQUFnQixlQUFlO0FBQzVJLCtDQUErQyxxQkFBcUIsa0JBQWtCLFlBQVksV0FBVyxnQkFBZ0IsZUFBZTtBQUM1SSwrQ0FBK0MscUJBQXFCLGtCQUFrQixZQUFZLFdBQVcsZ0JBQWdCLGVBQWU7QUFDNUkscURBQXFELFdBQVcsWUFBWSxlQUFlLGVBQWU7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGVBQWUsZ0JBQWdCLHFCQUFxQixnQkFBZ0Isa0JBQWtCLFdBQVcsU0FBUyxVQUFVLFdBQVcsbUJBQW1CLG9CQUFvQixnQkFBZ0I7QUFDbk87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUllO0FBQytDOztBQUU5RDtBQUdlO0FBQ29COztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3NDO0FBQ3RDLGtCQUFrQixvREFBYSxHQUFHLGVBQWU7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaURBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFhLHlCQUF5QixhQUFhLFdBQVcsK0JBQStCO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3dEO0FBQ3hELDBCQUEwQixvREFBYztBQUN4QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNtRjtBQUNuRixvQkFBb0Isb0RBQWMsR0FBRztBQUNyQztBQUNBLFNBQVMsaURBQVc7QUFDcEI7O0FBRUE7QUFDOEY7O0FBRTlGO0FBQ3dEO0FBQ3hELHNCQUFzQixvREFBYzs7QUFFcEM7QUFDNkQ7O0FBRTdEO0FBQytCO0FBQy9CO0FBQ0EsWUFBWSw2Q0FBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdEQUFTO0FBQ1g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDd0Q7QUFDeEQseUJBQXlCLG9EQUFjOztBQUV2QztBQUNpRTs7QUFFakU7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxrREFBZSxHQUFHLDRDQUFVOztBQUV4RTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaURBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBVztBQUMxQixvQkFBb0IsaURBQVc7QUFDL0I7QUFDQSx3QkFBd0IsaURBQVc7QUFDbkM7QUFDQSx5QkFBeUIsNkNBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQVksVUFBVTtBQUN2RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQscUJBQXFCLFVBQVU7QUFDeEY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ29DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxrREFBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUMyRDs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsaURBQVc7QUFDcEQsU0FBUyw4Q0FBTztBQUNoQixhQUFhO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9EQUFjLENBQUMsMkNBQVEsUUFBUSxvREFBYywyQkFBMkIsZ0JBQWdCO0FBQ25HO0FBQ0EsU0FBUyxpREFBVTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUN3RDs7QUFFeEQ7QUFDNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixFQUFFLFdBQVcsRUFBRSxjQUFjLEVBQUUsRUFBRSxJQUFJLGtDQUFrQyxJQUFJO0FBQ3hHLG9DQUFvQyxFQUFFLGNBQWMsRUFBRSxFQUFFLElBQUksa0NBQWtDLElBQUk7QUFDbEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYSx3QkFBd0I7QUFDckUsZ0NBQWdDLGFBQWEsWUFBWTs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixFQUFFO0FBQ3RCLHFCQUFxQixFQUFFO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDhCQUE4QixhQUFhLHVCQUF1Qjs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWSxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixpQkFBaUI7QUFDakI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4Q0FBUTtBQUNqQjtBQUNBLDBEQUEwRCx1Q0FBdUM7QUFDakc7QUFDQSwrQkFBK0I7QUFDL0IsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QixXQUFXO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsOENBQVE7QUFDNUI7QUFDQSx3REFBd0QsbUNBQW1DO0FBQzNGLCtCQUErQixrQkFBa0Isa0JBQWtCLGdCQUFnQjtBQUNuRixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxtQ0FBbUMsS0FBSztBQUM1RixXQUFXLG9EQUFjO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2tEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlEQUFXO0FBQzdCLDBCQUEwQixpREFBVztBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLG1DQUFtQztBQUNwRztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7O0FBRXZDO0FBQ2dEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnREFBVTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzBDOztBQUUxQztBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDLElBQUk7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxjQUFjLFVBQVU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsK0JBQStCLCtFQUErRTtBQUM5RztBQUNBO0FBQ0Esa0JBQWtCLDJDQUEyQztBQUM3RCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1DQUFtQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRUFBbUU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2Q0FBTztBQUMxQixrQ0FBa0MsNkNBQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMkU7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxvQkFBb0IsSUFBSTtBQUN4Qjs7QUFFQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdILDREQUE0RCxtRUFBbUU7QUFDL087QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsNERBQTREO0FBQzNJO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1RkFBdUY7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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a0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSSxvQkFBb0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUNBQXFDLGdDQUFnQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlEQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsNENBQTRDLFlBQVksb0JBQW9CO0FBQzVFLEVBQUUsZ0RBQVU7QUFDWjtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFVO0FBQ1o7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZDQUFPO0FBQzFCLDJCQUEyQixpREFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdEQUFVO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBSWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlDQUFpQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVix5RkFBeUYsYUFBYSxZQUFZO0FBQ2xILFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyw0Q0FBUztBQUNYO0FBQ0E7QUFDQSxTQUFTLG9EQUFjLHFCQUFxQixXQUFXLGNBQWM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDbUU7O0FBRW5FO0FBQ3dEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLG9EQUFjO0FBQ3hDLDhCQUE4QixvREFBYztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsd0RBQXdCO0FBQzFCO0FBQ0EsbUJBQW1CLGlEQUFZO0FBQy9CLHlCQUF5QixpREFBWTtBQUNyQyxTQUFTLDBEQUE0QixxQkFBcUIsV0FBVyw4QkFBOEI7QUFDbkc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLFlBQVk7O0FBRTlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9EQUFvRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsa0JBQWtCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsYUFBYTtBQUNiLElBQUk7QUFDSixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esd0hBQXdIO0FBQ3hIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLG1FQUFtRSxtQ0FBbUMsaUNBQWlDLGtDQUFrQztBQUN6Szs7QUFFQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkRBQTZELDJCQUEyQjtBQUN4Rjs7QUFFQTtBQUNBOztBQUVBO0FBSWU7QUFDK0Y7O0FBRTlHO0FBQ2lGO0FBQ2pGO0FBQ0EscUJBQXFCLDZDQUFPO0FBQzVCLGtCQUFrQiwrQ0FBUTtBQUMxQjtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsa0RBQVk7QUFDckI7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFJZTtBQUM2QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsOENBQVE7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxFQUFFLGdEQUFVO0FBQ1o7QUFDQSxHQUFHO0FBQ0gsU0FBUyxvREFBYyw2QkFBNkIsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsS0FBSSxlQUFlLENBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMkNBQVE7QUFDVixRQUFRLHFEQUFjO0FBQ3RCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaURBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZDQUFPO0FBQy9CO0FBQ0Esd0JBQXdCLDZDQUFPO0FBQy9CLG9CQUFvQiw2Q0FBTztBQUMzQixnQkFBZ0IsNkNBQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBYyxDQUFDLDJDQUFTO0FBQ25DLGFBQWEsb0RBQWMsa0JBQWtCLG9HQUFvRztBQUNqSixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvREFBYyxrQkFBa0Isa0dBQWtHO0FBQ2pMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsdUNBQXVDLG9EQUFjLGtCQUFrQixpRUFBaUU7QUFDeEksR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxvREFBYyxDQUFDLDJDQUFTO0FBQ2pDLFdBQVcsbURBQVk7QUFDdkIsR0FBRztBQUNIOztBQUVBO0FBSWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaUJBQWlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxLQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFO0FBQ0EsS0FBSztBQUNMLHFDQUFxQztBQUNyQztBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQzs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxnREFBZ0Q7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFPZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSyxJQUFJLFlBQVk7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNCQUFzQjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBDQUEwQztBQUNsRCxRQUFRLDBDQUEwQztBQUNsRCxRQUFRLDBDQUEwQztBQUNsRCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlLDBCQUEwQixzQkFBc0I7QUFDM0UsWUFBWSxlQUFlLDBCQUEwQixtQ0FBbUM7QUFDeEYsWUFBWSxlQUFlLDBCQUEwQixpREFBaUQ7QUFDdEcsWUFBWSxlQUFlLDBCQUEwQixvQ0FBb0M7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE9BQU8sTUFBTSxPQUFPO0FBQ2xELGdCQUFnQixXQUFXO0FBQzNCLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDRCQUE0QixNQUFNLElBQUksWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtRkFBbUY7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUNBQW1DO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEIsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhEQUE4RDtBQUN4RSxRQUFRLGdCQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdCQUF3QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDLHlCQUF5QixvREFBYyxHQUFHLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlEQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdUJBQXVCO0FBQ2pDO0FBQ0EsZ0JBQWdCLDhDQUFRLFVBQVUsa0JBQWtCO0FBQ3BEO0FBQ0Esc0NBQXNDLG9EQUFlLENBQUMsMkNBQVM7QUFDL0Q7QUFDQSx5QkFBeUIsb0RBQWU7QUFDeEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFlO0FBQ3hDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHdCQUF3QjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsRUFBRTtBQUNGLEVBQUU7QUFDRixFQUFFO0FBQ0YsRUFBRTtBQUNGLEVBQUU7QUFDRixFQUFFO0FBQ0YsRUFBRTtBQUNGLEVBQUU7QUFDRixFQUFFO0FBQ0YsRUFBRTtBQUNGLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUtlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhLDJDQUFTO0FBQ3RCLFNBQVMscURBQWU7QUFDeEI7QUFDQSxXQUFXLG1EQUFhLFVBQVUscUJBQXFCO0FBQ3ZELEdBQUc7QUFDSCxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUU7QUFDM0QseUJBQXlCLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRTtBQUMzRCwyQkFBMkIsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRTtBQUM3RSwyQkFBMkIsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRTtBQUM3RTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTLEVBQUUsU0FBUztBQUNoRCw0QkFBNEIsU0FBUyxFQUFFLFNBQVM7QUFDaEQsNEJBQTRCLFNBQVMsRUFBRSxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTLEVBQUUsU0FBUztBQUNoRCw0QkFBNEIsU0FBUyxFQUFFLFNBQVM7QUFDaEQsNEJBQTRCLFNBQVMsRUFBRSxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCLElBQUksVUFBVSxJQUFJLFVBQVUsSUFBSSxVQUFVLElBQUksU0FBUztBQUNqRyxNQUFNO0FBQ04saUJBQWlCLHlCQUF5QixHQUFHLGFBQWE7QUFDMUQsTUFBTTtBQUNOLGlCQUFpQix5QkFBeUIsSUFBSSxVQUFVLElBQUksVUFBVSxJQUFJLFVBQVUsSUFBSSxTQUFTO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlDQUFpQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQ0FBZ0MsSUFBSTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw0QkFBNEI7QUFDMUUsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHVCQUF1QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFHZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3FFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDLDBDQUEwQyxJQUFJLDBDQUEwQyxJQUFJO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQiw0Q0FBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDREQUE0RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILDZDQUE2Qyx5QkFBeUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtCQUErQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNB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QWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUtlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHlCQUF5QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4REFBOEQ7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0Isb0RBQWUsR0FBRyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBLHlDQUF5Qyw0Q0FBVTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBLGlDQUFpQztBQUNqQyx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBTWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMEQ7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTs7QUFFQTtBQUtlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHVCQUF1QixLQUFLLG9CQUFvQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsS0FBSztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUdlO0FBQ2YsdUNBQXVDLDRDQUFVO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBR2U7QUFDZix1Q0FBdUMsNENBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFRZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QixhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixhQUFhO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOEJBQThCO0FBQzlDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFJZTtBQUNrRjs7QUFFakc7QUFJZTs7QUFFZjtBQUNBO0FBQ0EsVUFBVSxtRkFBbUY7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBR2U7QUFDZix3QkFBd0Isb0RBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNENBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTyxhQUFhO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMkJBQTJCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlDQUF5QztBQUN2RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxVQUFVO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0NBQWdDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrQ0FBa0M7QUFDekU7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG1DQUFtQztBQUMxRTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMscUNBQXFDO0FBQzVFO0FBQ0E7QUFDQSxDQUFDLDRCQUE0Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLHlCQUF5QjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLHlCQUF5QjtBQUNqSDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUcsR0FBRyw4QkFBOEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRyxHQUFHLDhCQUE4QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVU7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUc7QUFDSCxFQUFFLGdEQUFXO0FBQ2I7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxJQUFJLEtBQXNCLEVBQUUsRUFFM0I7QUErTkM7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvemlib24vRG9jdW1lbnRzL1ZpYmUvQ3Vyc29yL0ZyYW1lciBXb3Jrc2hvcC9mcmFtZXItd29ya3Nob3Avbm9kZV9tb2R1bGVzL2ZyYW1lci9idWlsZC9lc20vZnJhbWVyLmRlYnVnLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2NvbW1vbkpTID0gKGNiMiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiMltPYmplY3Qua2V5cyhjYjIpWzBdXSkoKG1vZCA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kKSwgbW9kLmV4cG9ydHM7XG59O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZSAmJiB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleTYgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXk2KSAmJiBrZXk2ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5NiwgeyBnZXQ6ICgpID0+IG1vZHVsZVtrZXk2XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUsIGtleTYpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZSAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZSkpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlID8geyBnZXQ6ICgpID0+IG1vZHVsZS5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUpO1xufTtcbnZhciBfX2FjY2Vzc0NoZWNrID0gKG9iaiwgbWVtYmVyLCBtc2cyKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZzIpO1xufTtcbnZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpO1xuICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKTtcbn07XG52YXIgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufTtcbnZhciBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpO1xuICBzZXR0ZXIgPyBzZXR0ZXIuY2FsbChvYmosIHZhbHVlKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5qc1xudmFyIHJlcXVpcmVfdHNsaWIgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICB2YXIgX19leHRlbmRzMjtcbiAgICB2YXIgX19hc3NpZ24yO1xuICAgIHZhciBfX3Jlc3QyO1xuICAgIHZhciBfX2RlY29yYXRlMjtcbiAgICB2YXIgX19wYXJhbTI7XG4gICAgdmFyIF9fbWV0YWRhdGEyO1xuICAgIHZhciBfX2F3YWl0ZXIyO1xuICAgIHZhciBfX2dlbmVyYXRvcjI7XG4gICAgdmFyIF9fZXhwb3J0U3RhcjI7XG4gICAgdmFyIF9fdmFsdWVzMjtcbiAgICB2YXIgX19yZWFkMjtcbiAgICB2YXIgX19zcHJlYWQyO1xuICAgIHZhciBfX3NwcmVhZEFycmF5czI7XG4gICAgdmFyIF9fc3ByZWFkQXJyYXkyO1xuICAgIHZhciBfX2F3YWl0MjtcbiAgICB2YXIgX19hc3luY0dlbmVyYXRvcjI7XG4gICAgdmFyIF9fYXN5bmNEZWxlZ2F0b3IyO1xuICAgIHZhciBfX2FzeW5jVmFsdWVzMjtcbiAgICB2YXIgX19tYWtlVGVtcGxhdGVPYmplY3QyO1xuICAgIHZhciBfX2ltcG9ydFN0YXIyO1xuICAgIHZhciBfX2ltcG9ydERlZmF1bHQyO1xuICAgIHZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MjtcbiAgICB2YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldDI7XG4gICAgdmFyIF9fY3JlYXRlQmluZGluZzI7XG4gICAgKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAgIHZhciByb290ID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHR5cGVvZiB0aGlzID09PSBcIm9iamVjdFwiID8gdGhpcyA6IHt9O1xuICAgICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShcInRzbGliXCIsIFtcImV4cG9ydHNcIl0sIGZ1bmN0aW9uKGV4cG9ydHMyKSB7XG4gICAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihleHBvcnRzMikpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIobW9kdWxlLmV4cG9ydHMpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QpKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMyLCBwcmV2aW91cykge1xuICAgICAgICBpZiAoZXhwb3J0czIgIT09IHJvb3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhwb3J0czIuX19lc01vZHVsZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpZCwgdikge1xuICAgICAgICAgIHJldHVybiBleHBvcnRzMltpZF0gPSBwcmV2aW91cyA/IHByZXZpb3VzKGlkLCB2KSA6IHY7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSkoZnVuY3Rpb24oZXhwb3J0ZXIpIHtcbiAgICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24oZCwgYjIpIHtcbiAgICAgICAgZC5fX3Byb3RvX18gPSBiMjtcbiAgICAgIH0gfHwgZnVuY3Rpb24oZCwgYjIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiMilcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIyLCBwKSlcbiAgICAgICAgICAgIGRbcF0gPSBiMltwXTtcbiAgICAgIH07XG4gICAgICBfX2V4dGVuZHMyID0gZnVuY3Rpb24oZCwgYjIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiMiAhPT0gXCJmdW5jdGlvblwiICYmIGIyICE9PSBudWxsKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIyKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYjIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHtcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgICAgICAgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIyID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiMikgOiAoX18ucHJvdG90eXBlID0gYjIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgICB9O1xuICAgICAgX19hc3NpZ24yID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBzKVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9O1xuICAgICAgX19yZXN0MiA9IGZ1bmN0aW9uKHMsIGUpIHtcbiAgICAgICAgdmFyIHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKVxuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfTtcbiAgICAgIF9fZGVjb3JhdGUyID0gZnVuY3Rpb24oZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXk2LCBkZXNjKSB7XG4gICAgICAgIHZhciBjMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjMiA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXk2KSA6IGRlc2MsIGQ7XG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5NiwgZGVzYyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGlmIChkID0gZGVjb3JhdG9yc1tpXSlcbiAgICAgICAgICAgICAgciA9IChjMiA8IDMgPyBkKHIpIDogYzIgPiAzID8gZCh0YXJnZXQsIGtleTYsIHIpIDogZCh0YXJnZXQsIGtleTYpKSB8fCByO1xuICAgICAgICByZXR1cm4gYzIgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5NiwgciksIHI7XG4gICAgICB9O1xuICAgICAgX19wYXJhbTIgPSBmdW5jdGlvbihwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwga2V5Nikge1xuICAgICAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleTYsIHBhcmFtSW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIF9fbWV0YWRhdGEyID0gZnVuY3Rpb24obWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xuICAgICAgfTtcbiAgICAgIF9fYXdhaXRlcjIgPSBmdW5jdGlvbih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIF9fZ2VuZXJhdG9yMiA9IGZ1bmN0aW9uKHRoaXNBcmcsIGJvZHkpIHtcbiAgICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodFswXSAmIDEpXG4gICAgICAgICAgICB0aHJvdyB0WzFdO1xuICAgICAgICAgIHJldHVybiB0WzFdO1xuICAgICAgICB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgICAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pLCBnO1xuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXAoW24sIHZdKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgICBpZiAoZilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICAgIHdoaWxlIChfKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgIGlmICh5ID0gMCwgdClcbiAgICAgICAgICAgICAgICBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgICB5ID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICBvcCA9IFswXTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgIG9wID0gXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgXyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCBvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkge1xuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzFdO1xuICAgICAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMl07XG4gICAgICAgICAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICh0WzJdKVxuICAgICAgICAgICAgICAgICAgICBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBvcCA9IFs2LCBlXTtcbiAgICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBmID0gdCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wWzBdICYgNSlcbiAgICAgICAgICAgIHRocm93IG9wWzFdO1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfX2V4cG9ydFN0YXIyID0gZnVuY3Rpb24obTIsIG8pIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBtMilcbiAgICAgICAgICBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSlcbiAgICAgICAgICAgIF9fY3JlYXRlQmluZGluZzIobywgbTIsIHApO1xuICAgICAgfTtcbiAgICAgIF9fY3JlYXRlQmluZGluZzIgPSBPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24obywgbTIsIGssIGsyKSB7XG4gICAgICAgIGlmIChrMiA9PT0gdm9pZCAwKVxuICAgICAgICAgIGsyID0gaztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG0yW2tdO1xuICAgICAgICB9IH0pO1xuICAgICAgfSA6IGZ1bmN0aW9uKG8sIG0yLCBrLCBrMikge1xuICAgICAgICBpZiAoazIgPT09IHZvaWQgMClcbiAgICAgICAgICBrMiA9IGs7XG4gICAgICAgIG9bazJdID0gbTJba107XG4gICAgICB9O1xuICAgICAgX192YWx1ZXMyID0gZnVuY3Rpb24obykge1xuICAgICAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0yID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICAgICAgaWYgKG0yKVxuICAgICAgICAgIHJldHVybiBtMi5jYWxsKG8pO1xuICAgICAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICB9O1xuICAgICAgX19yZWFkMiA9IGZ1bmN0aW9uKG8sIG4pIHtcbiAgICAgICAgdmFyIG0yID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgICAgaWYgKCFtMilcbiAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgdmFyIGkgPSBtMi5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKVxuICAgICAgICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBlID0geyBlcnJvciB9O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtMiA9IGlbXCJyZXR1cm5cIl0pKVxuICAgICAgICAgICAgICBtMi5jYWxsKGkpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgICAgdGhyb3cgZS5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgfTtcbiAgICAgIF9fc3ByZWFkMiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQyKGFyZ3VtZW50c1tpXSkpO1xuICAgICAgICByZXR1cm4gYXI7XG4gICAgICB9O1xuICAgICAgX19zcHJlYWRBcnJheXMyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKylcbiAgICAgICAgICBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgICBmb3IgKHZhciBhMiA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYTIubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGEyW2pdO1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH07XG4gICAgICBfX3NwcmVhZEFycmF5MiA9IGZ1bmN0aW9uKHRvLCBmcm9tKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxuICAgICAgICAgIHRvW2pdID0gZnJvbVtpXTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgfTtcbiAgICAgIF9fYXdhaXQyID0gZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQyID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQyKHYpO1xuICAgICAgfTtcbiAgICAgIF9fYXN5bmNHZW5lcmF0b3IyID0gZnVuY3Rpb24odGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgICAgICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSwgaTtcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgICAgICAgaWYgKGdbbl0pXG4gICAgICAgICAgICBpW25dID0gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oYTIsIGIyKSB7XG4gICAgICAgICAgICAgICAgcS5wdXNoKFtuLCB2LCBhMiwgYjJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RlcChnW25dKHYpKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBzZXR0bGUocVswXVszXSwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocikge1xuICAgICAgICAgIHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0MiA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7XG4gICAgICAgICAgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7XG4gICAgICAgICAgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7XG4gICAgICAgICAgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpXG4gICAgICAgICAgICByZXN1bWUocVswXVswXSwgcVswXVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfX2FzeW5jRGVsZWdhdG9yMiA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgdmFyIGksIHA7XG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSwgaTtcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7XG4gICAgICAgICAgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0MihvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2O1xuICAgICAgICAgIH0gOiBmO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX19hc3luY1ZhbHVlczIgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgdmFyIG0yID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XG4gICAgICAgIHJldHVybiBtMiA/IG0yLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlczIgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzMihvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sIGkpO1xuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgICBpW25dID0gb1tuXSAmJiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgIHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7XG4gICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odjIpIHtcbiAgICAgICAgICAgIHJlc29sdmUoeyB2YWx1ZTogdjIsIGRvbmU6IGQgfSk7XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9fbWFrZVRlbXBsYXRlT2JqZWN0MiA9IGZ1bmN0aW9uKGNvb2tlZCwgcmF3KSB7XG4gICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29va2VkLnJhdyA9IHJhdztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29va2VkO1xuICAgICAgfTtcbiAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24obywgdikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG4gICAgICB9IDogZnVuY3Rpb24obywgdikge1xuICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICB9O1xuICAgICAgX19pbXBvcnRTdGFyMiA9IGZ1bmN0aW9uKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKVxuICAgICAgICAgIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSB7XG4gICAgICAgICAgZm9yICh2YXIgayBpbiBtb2QpXG4gICAgICAgICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpXG4gICAgICAgICAgICAgIF9fY3JlYXRlQmluZGluZzIocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICB9XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgX19pbXBvcnREZWZhdWx0MiA9IGZ1bmN0aW9uKG1vZCkge1xuICAgICAgICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG4gICAgICB9O1xuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldDIgPSBmdW5jdGlvbihyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG4gICAgICB9O1xuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldDIgPSBmdW5jdGlvbihyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgICAgIGlmIChraW5kID09PSBcIm1cIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgICAgICByZXR1cm4ga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSwgdmFsdWU7XG4gICAgICB9O1xuICAgICAgZXhwb3J0ZXIoXCJfX2V4dGVuZHNcIiwgX19leHRlbmRzMik7XG4gICAgICBleHBvcnRlcihcIl9fYXNzaWduXCIsIF9fYXNzaWduMik7XG4gICAgICBleHBvcnRlcihcIl9fcmVzdFwiLCBfX3Jlc3QyKTtcbiAgICAgIGV4cG9ydGVyKFwiX19kZWNvcmF0ZVwiLCBfX2RlY29yYXRlMik7XG4gICAgICBleHBvcnRlcihcIl9fcGFyYW1cIiwgX19wYXJhbTIpO1xuICAgICAgZXhwb3J0ZXIoXCJfX21ldGFkYXRhXCIsIF9fbWV0YWRhdGEyKTtcbiAgICAgIGV4cG9ydGVyKFwiX19hd2FpdGVyXCIsIF9fYXdhaXRlcjIpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2dlbmVyYXRvclwiLCBfX2dlbmVyYXRvcjIpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2V4cG9ydFN0YXJcIiwgX19leHBvcnRTdGFyMik7XG4gICAgICBleHBvcnRlcihcIl9fY3JlYXRlQmluZGluZ1wiLCBfX2NyZWF0ZUJpbmRpbmcyKTtcbiAgICAgIGV4cG9ydGVyKFwiX192YWx1ZXNcIiwgX192YWx1ZXMyKTtcbiAgICAgIGV4cG9ydGVyKFwiX19yZWFkXCIsIF9fcmVhZDIpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3NwcmVhZFwiLCBfX3NwcmVhZDIpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3NwcmVhZEFycmF5c1wiLCBfX3NwcmVhZEFycmF5czIpO1xuICAgICAgZXhwb3J0ZXIoXCJfX3NwcmVhZEFycmF5XCIsIF9fc3ByZWFkQXJyYXkyKTtcbiAgICAgIGV4cG9ydGVyKFwiX19hd2FpdFwiLCBfX2F3YWl0Mik7XG4gICAgICBleHBvcnRlcihcIl9fYXN5bmNHZW5lcmF0b3JcIiwgX19hc3luY0dlbmVyYXRvcjIpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2FzeW5jRGVsZWdhdG9yXCIsIF9fYXN5bmNEZWxlZ2F0b3IyKTtcbiAgICAgIGV4cG9ydGVyKFwiX19hc3luY1ZhbHVlc1wiLCBfX2FzeW5jVmFsdWVzMik7XG4gICAgICBleHBvcnRlcihcIl9fbWFrZVRlbXBsYXRlT2JqZWN0XCIsIF9fbWFrZVRlbXBsYXRlT2JqZWN0Mik7XG4gICAgICBleHBvcnRlcihcIl9faW1wb3J0U3RhclwiLCBfX2ltcG9ydFN0YXIyKTtcbiAgICAgIGV4cG9ydGVyKFwiX19pbXBvcnREZWZhdWx0XCIsIF9faW1wb3J0RGVmYXVsdDIpO1xuICAgICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0XCIsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQyKTtcbiAgICAgIGV4cG9ydGVyKFwiX19jbGFzc1ByaXZhdGVGaWVsZFNldFwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0Mik7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vbWVtb2l6ZS9kaXN0L21lbW9pemUuYnJvd3Nlci5janMuanNcbnZhciByZXF1aXJlX21lbW9pemVfYnJvd3Nlcl9janMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vbWVtb2l6ZS9kaXN0L21lbW9pemUuYnJvd3Nlci5janMuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGZ1bmN0aW9uIG1lbW9pemUyKGZuKSB7XG4gICAgICB2YXIgY2FjaGU0ID0ge307XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIGlmIChjYWNoZTRbYXJnXSA9PT0gdm9pZCAwKVxuICAgICAgICAgIGNhY2hlNFthcmddID0gZm4oYXJnKTtcbiAgICAgICAgcmV0dXJuIGNhY2hlNFthcmddO1xuICAgICAgfTtcbiAgICB9XG4gICAgZXhwb3J0cy5kZWZhdWx0ID0gbWVtb2l6ZTI7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vaXMtcHJvcC12YWxpZC9kaXN0L2lzLXByb3AtdmFsaWQuYnJvd3Nlci5janMuanNcbnZhciByZXF1aXJlX2lzX3Byb3BfdmFsaWRfYnJvd3Nlcl9janMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vaXMtcHJvcC12YWxpZC9kaXN0L2lzLXByb3AtdmFsaWQuYnJvd3Nlci5janMuanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdChleCkge1xuICAgICAgcmV0dXJuIGV4ICYmIHR5cGVvZiBleCA9PT0gXCJvYmplY3RcIiAmJiBcImRlZmF1bHRcIiBpbiBleCA/IGV4W1wiZGVmYXVsdFwiXSA6IGV4O1xuICAgIH1cbiAgICB2YXIgbWVtb2l6ZTIgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZV9tZW1vaXplX2Jyb3dzZXJfY2pzKCkpO1xuICAgIHZhciByZWFjdFByb3BzUmVnZXggPSAvXigoY2hpbGRyZW58ZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUx8a2V5fHJlZnxhdXRvRm9jdXN8ZGVmYXVsdFZhbHVlfGRlZmF1bHRDaGVja2VkfGlubmVySFRNTHxzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmd8c3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nfHZhbHVlTGlua3xhY2NlcHR8YWNjZXB0Q2hhcnNldHxhY2Nlc3NLZXl8YWN0aW9ufGFsbG93fGFsbG93VXNlck1lZGlhfGFsbG93UGF5bWVudFJlcXVlc3R8YWxsb3dGdWxsU2NyZWVufGFsbG93VHJhbnNwYXJlbmN5fGFsdHxhc3luY3xhdXRvQ29tcGxldGV8YXV0b1BsYXl8Y2FwdHVyZXxjZWxsUGFkZGluZ3xjZWxsU3BhY2luZ3xjaGFsbGVuZ2V8Y2hhclNldHxjaGVja2VkfGNpdGV8Y2xhc3NJRHxjbGFzc05hbWV8Y29sc3xjb2xTcGFufGNvbnRlbnR8Y29udGVudEVkaXRhYmxlfGNvbnRleHRNZW51fGNvbnRyb2xzfGNvbnRyb2xzTGlzdHxjb29yZHN8Y3Jvc3NPcmlnaW58ZGF0YXxkYXRlVGltZXxkZWNvZGluZ3xkZWZhdWx0fGRlZmVyfGRpcnxkaXNhYmxlZHxkaXNhYmxlUGljdHVyZUluUGljdHVyZXxkb3dubG9hZHxkcmFnZ2FibGV8ZW5jVHlwZXxmb3JtfGZvcm1BY3Rpb258Zm9ybUVuY1R5cGV8Zm9ybU1ldGhvZHxmb3JtTm9WYWxpZGF0ZXxmb3JtVGFyZ2V0fGZyYW1lQm9yZGVyfGhlYWRlcnN8aGVpZ2h0fGhpZGRlbnxoaWdofGhyZWZ8aHJlZkxhbmd8aHRtbEZvcnxodHRwRXF1aXZ8aWR8aW5wdXRNb2RlfGludGVncml0eXxpc3xrZXlQYXJhbXN8a2V5VHlwZXxraW5kfGxhYmVsfGxhbmd8bGlzdHxsb2FkaW5nfGxvb3B8bG93fG1hcmdpbkhlaWdodHxtYXJnaW5XaWR0aHxtYXh8bWF4TGVuZ3RofG1lZGlhfG1lZGlhR3JvdXB8bWV0aG9kfG1pbnxtaW5MZW5ndGh8bXVsdGlwbGV8bXV0ZWR8bmFtZXxub25jZXxub1ZhbGlkYXRlfG9wZW58b3B0aW11bXxwYXR0ZXJufHBsYWNlaG9sZGVyfHBsYXlzSW5saW5lfHBvc3RlcnxwcmVsb2FkfHByb2ZpbGV8cmFkaW9Hcm91cHxyZWFkT25seXxyZWZlcnJlclBvbGljeXxyZWx8cmVxdWlyZWR8cmV2ZXJzZWR8cm9sZXxyb3dzfHJvd1NwYW58c2FuZGJveHxzY29wZXxzY29wZWR8c2Nyb2xsaW5nfHNlYW1sZXNzfHNlbGVjdGVkfHNoYXBlfHNpemV8c2l6ZXN8c2xvdHxzcGFufHNwZWxsQ2hlY2t8c3JjfHNyY0RvY3xzcmNMYW5nfHNyY1NldHxzdGFydHxzdGVwfHN0eWxlfHN1bW1hcnl8dGFiSW5kZXh8dGFyZ2V0fHRpdGxlfHR5cGV8dXNlTWFwfHZhbHVlfHdpZHRofHdtb2RlfHdyYXB8YWJvdXR8ZGF0YXR5cGV8aW5saXN0fHByZWZpeHxwcm9wZXJ0eXxyZXNvdXJjZXx0eXBlb2Z8dm9jYWJ8YXV0b0NhcGl0YWxpemV8YXV0b0NvcnJlY3R8YXV0b1NhdmV8Y29sb3J8aW5lcnR8aXRlbVByb3B8aXRlbVNjb3BlfGl0ZW1UeXBlfGl0ZW1JRHxpdGVtUmVmfG9ufHJlc3VsdHN8c2VjdXJpdHl8dW5zZWxlY3RhYmxlfGFjY2VudEhlaWdodHxhY2N1bXVsYXRlfGFkZGl0aXZlfGFsaWdubWVudEJhc2VsaW5lfGFsbG93UmVvcmRlcnxhbHBoYWJldGljfGFtcGxpdHVkZXxhcmFiaWNGb3JtfGFzY2VudHxhdHRyaWJ1dGVOYW1lfGF0dHJpYnV0ZVR5cGV8YXV0b1JldmVyc2V8YXppbXV0aHxiYXNlRnJlcXVlbmN5fGJhc2VsaW5lU2hpZnR8YmFzZVByb2ZpbGV8YmJveHxiZWdpbnxiaWFzfGJ5fGNhbGNNb2RlfGNhcEhlaWdodHxjbGlwfGNsaXBQYXRoVW5pdHN8Y2xpcFBhdGh8Y2xpcFJ1bGV8Y29sb3JJbnRlcnBvbGF0aW9ufGNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnN8Y29sb3JQcm9maWxlfGNvbG9yUmVuZGVyaW5nfGNvbnRlbnRTY3JpcHRUeXBlfGNvbnRlbnRTdHlsZVR5cGV8Y3Vyc29yfGN4fGN5fGR8ZGVjZWxlcmF0ZXxkZXNjZW50fGRpZmZ1c2VDb25zdGFudHxkaXJlY3Rpb258ZGlzcGxheXxkaXZpc29yfGRvbWluYW50QmFzZWxpbmV8ZHVyfGR4fGR5fGVkZ2VNb2RlfGVsZXZhdGlvbnxlbmFibGVCYWNrZ3JvdW5kfGVuZHxleHBvbmVudHxleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkfGZpbGx8ZmlsbE9wYWNpdHl8ZmlsbFJ1bGV8ZmlsdGVyfGZpbHRlclJlc3xmaWx0ZXJVbml0c3xmbG9vZENvbG9yfGZsb29kT3BhY2l0eXxmb2N1c2FibGV8Zm9udEZhbWlseXxmb250U2l6ZXxmb250U2l6ZUFkanVzdHxmb250U3RyZXRjaHxmb250U3R5bGV8Zm9udFZhcmlhbnR8Zm9udFdlaWdodHxmb3JtYXR8ZnJvbXxmcnxmeHxmeXxnMXxnMnxnbHlwaE5hbWV8Z2x5cGhPcmllbnRhdGlvbkhvcml6b250YWx8Z2x5cGhPcmllbnRhdGlvblZlcnRpY2FsfGdseXBoUmVmfGdyYWRpZW50VHJhbnNmb3JtfGdyYWRpZW50VW5pdHN8aGFuZ2luZ3xob3JpekFkdlh8aG9yaXpPcmlnaW5YfGlkZW9ncmFwaGljfGltYWdlUmVuZGVyaW5nfGlufGluMnxpbnRlcmNlcHR8a3xrMXxrMnxrM3xrNHxrZXJuZWxNYXRyaXh8a2VybmVsVW5pdExlbmd0aHxrZXJuaW5nfGtleVBvaW50c3xrZXlTcGxpbmVzfGtleVRpbWVzfGxlbmd0aEFkanVzdHxsZXR0ZXJTcGFjaW5nfGxpZ2h0aW5nQ29sb3J8bGltaXRpbmdDb25lQW5nbGV8bG9jYWx8bWFya2VyRW5kfG1hcmtlck1pZHxtYXJrZXJTdGFydHxtYXJrZXJIZWlnaHR8bWFya2VyVW5pdHN8bWFya2VyV2lkdGh8bWFza3xtYXNrQ29udGVudFVuaXRzfG1hc2tVbml0c3xtYXRoZW1hdGljYWx8bW9kZXxudW1PY3RhdmVzfG9mZnNldHxvcGFjaXR5fG9wZXJhdG9yfG9yZGVyfG9yaWVudHxvcmllbnRhdGlvbnxvcmlnaW58b3ZlcmZsb3d8b3ZlcmxpbmVQb3NpdGlvbnxvdmVybGluZVRoaWNrbmVzc3xwYW5vc2UxfHBhaW50T3JkZXJ8cGF0aExlbmd0aHxwYXR0ZXJuQ29udGVudFVuaXRzfHBhdHRlcm5UcmFuc2Zvcm18cGF0dGVyblVuaXRzfHBvaW50ZXJFdmVudHN8cG9pbnRzfHBvaW50c0F0WHxwb2ludHNBdFl8cG9pbnRzQXRafHByZXNlcnZlQWxwaGF8cHJlc2VydmVBc3BlY3RSYXRpb3xwcmltaXRpdmVVbml0c3xyfHJhZGl1c3xyZWZYfHJlZll8cmVuZGVyaW5nSW50ZW50fHJlcGVhdENvdW50fHJlcGVhdER1cnxyZXF1aXJlZEV4dGVuc2lvbnN8cmVxdWlyZWRGZWF0dXJlc3xyZXN0YXJ0fHJlc3VsdHxyb3RhdGV8cnh8cnl8c2NhbGV8c2VlZHxzaGFwZVJlbmRlcmluZ3xzbG9wZXxzcGFjaW5nfHNwZWN1bGFyQ29uc3RhbnR8c3BlY3VsYXJFeHBvbmVudHxzcGVlZHxzcHJlYWRNZXRob2R8c3RhcnRPZmZzZXR8c3RkRGV2aWF0aW9ufHN0ZW1ofHN0ZW12fHN0aXRjaFRpbGVzfHN0b3BDb2xvcnxzdG9wT3BhY2l0eXxzdHJpa2V0aHJvdWdoUG9zaXRpb258c3RyaWtldGhyb3VnaFRoaWNrbmVzc3xzdHJpbmd8c3Ryb2tlfHN0cm9rZURhc2hhcnJheXxzdHJva2VEYXNob2Zmc2V0fHN0cm9rZUxpbmVjYXB8c3Ryb2tlTGluZWpvaW58c3Ryb2tlTWl0ZXJsaW1pdHxzdHJva2VPcGFjaXR5fHN0cm9rZVdpZHRofHN1cmZhY2VTY2FsZXxzeXN0ZW1MYW5ndWFnZXx0YWJsZVZhbHVlc3x0YXJnZXRYfHRhcmdldFl8dGV4dEFuY2hvcnx0ZXh0RGVjb3JhdGlvbnx0ZXh0UmVuZGVyaW5nfHRleHRMZW5ndGh8dG98dHJhbnNmb3JtfHUxfHUyfHVuZGVybGluZVBvc2l0aW9ufHVuZGVybGluZVRoaWNrbmVzc3x1bmljb2RlfHVuaWNvZGVCaWRpfHVuaWNvZGVSYW5nZXx1bml0c1BlckVtfHZBbHBoYWJldGljfHZIYW5naW5nfHZJZGVvZ3JhcGhpY3x2TWF0aGVtYXRpY2FsfHZhbHVlc3x2ZWN0b3JFZmZlY3R8dmVyc2lvbnx2ZXJ0QWR2WXx2ZXJ0T3JpZ2luWHx2ZXJ0T3JpZ2luWXx2aWV3Qm94fHZpZXdUYXJnZXR8dmlzaWJpbGl0eXx3aWR0aHN8d29yZFNwYWNpbmd8d3JpdGluZ01vZGV8eHx4SGVpZ2h0fHgxfHgyfHhDaGFubmVsU2VsZWN0b3J8eGxpbmtBY3R1YXRlfHhsaW5rQXJjcm9sZXx4bGlua0hyZWZ8eGxpbmtSb2xlfHhsaW5rU2hvd3x4bGlua1RpdGxlfHhsaW5rVHlwZXx4bWxCYXNlfHhtbG5zfHhtbG5zWGxpbmt8eG1sTGFuZ3x4bWxTcGFjZXx5fHkxfHkyfHlDaGFubmVsU2VsZWN0b3J8enx6b29tQW5kUGFufGZvcnxjbGFzc3xhdXRvZm9jdXMpfCgoW0RkXVtBYV1bVHRdW0FhXXxbQWFdW1JyXVtJaV1bQWFdfHgpLS4qKSkkLztcbiAgICB2YXIgaW5kZXggPSBtZW1vaXplMihmdW5jdGlvbihwcm9wKSB7XG4gICAgICByZXR1cm4gcmVhY3RQcm9wc1JlZ2V4LnRlc3QocHJvcCkgfHwgcHJvcC5jaGFyQ29kZUF0KDApID09PSAxMTEgJiYgcHJvcC5jaGFyQ29kZUF0KDEpID09PSAxMTAgJiYgcHJvcC5jaGFyQ29kZUF0KDIpIDwgOTE7XG4gICAgfSk7XG4gICAgZXhwb3J0cy5kZWZhdWx0ID0gaW5kZXg7XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvaHNsdXYvaHNsdXYuanNcbnZhciByZXF1aXJlX2hzbHV2ID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2hzbHV2L2hzbHV2LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgdmFyIGhzbHV2ID0gaHNsdXYgfHwge307XG4gICAgaHNsdXYuR2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcbiAgICB9O1xuICAgIGhzbHV2Lkdlb21ldHJ5LmludGVyc2VjdExpbmVMaW5lID0gZnVuY3Rpb24oYTIsIGIyKSB7XG4gICAgICB2YXIgeCA9IChhMi5pbnRlcmNlcHQgLSBiMi5pbnRlcmNlcHQpIC8gKGIyLnNsb3BlIC0gYTIuc2xvcGUpO1xuICAgICAgdmFyIHkgPSBhMi5zbG9wZSAqIHggKyBhMi5pbnRlcmNlcHQ7XG4gICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbiAgICBoc2x1di5HZW9tZXRyeS5kaXN0YW5jZUZyb21PcmlnaW4gPSBmdW5jdGlvbihwb2ludCkge1xuICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwb2ludC54LCAyKSArIE1hdGgucG93KHBvaW50LnksIDIpKTtcbiAgICB9O1xuICAgIGhzbHV2Lkdlb21ldHJ5LmRpc3RhbmNlTGluZUZyb21PcmlnaW4gPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnMobGluZS5pbnRlcmNlcHQpIC8gTWF0aC5zcXJ0KE1hdGgucG93KGxpbmUuc2xvcGUsIDIpICsgMSk7XG4gICAgfTtcbiAgICBoc2x1di5HZW9tZXRyeS5wZXJwZW5kaWN1bGFyVGhyb3VnaFBvaW50ID0gZnVuY3Rpb24obGluZSwgcG9pbnQpIHtcbiAgICAgIHZhciBzbG9wZSA9IC0xIC8gbGluZS5zbG9wZTtcbiAgICAgIHZhciBpbnRlcmNlcHQgPSBwb2ludC55IC0gc2xvcGUgKiBwb2ludC54O1xuICAgICAgcmV0dXJuIHsgc2xvcGUsIGludGVyY2VwdCB9O1xuICAgIH07XG4gICAgaHNsdXYuR2VvbWV0cnkuYW5nbGVGcm9tT3JpZ2luID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgIHJldHVybiBNYXRoLmF0YW4yKHBvaW50LnksIHBvaW50LngpO1xuICAgIH07XG4gICAgaHNsdXYuR2VvbWV0cnkubm9ybWFsaXplQW5nbGUgPSBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgdmFyIG0yID0gMiAqIE1hdGguUEk7XG4gICAgICByZXR1cm4gKGFuZ2xlICUgbTIgKyBtMikgJSBtMjtcbiAgICB9O1xuICAgIGhzbHV2Lkdlb21ldHJ5Lmxlbmd0aE9mUmF5VW50aWxJbnRlcnNlY3QgPSBmdW5jdGlvbih0aGV0YSwgbGluZSkge1xuICAgICAgcmV0dXJuIGxpbmUuaW50ZXJjZXB0IC8gKE1hdGguc2luKHRoZXRhKSAtIGxpbmUuc2xvcGUgKiBNYXRoLmNvcyh0aGV0YSkpO1xuICAgIH07XG4gICAgaHNsdXYuSHNsdXYgPSBmdW5jdGlvbigpIHtcbiAgICB9O1xuICAgIGhzbHV2LkhzbHV2LmdldEJvdW5kcyA9IGZ1bmN0aW9uKEwpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciBzdWIxID0gTWF0aC5wb3coTCArIDE2LCAzKSAvIDE1NjA4OTY7XG4gICAgICB2YXIgc3ViMiA9IHN1YjEgPiBoc2x1di5Ic2x1di5lcHNpbG9uID8gc3ViMSA6IEwgLyBoc2x1di5Ic2x1di5rYXBwYTtcbiAgICAgIHZhciBfZyA9IDA7XG4gICAgICB3aGlsZSAoX2cgPCAzKSB7XG4gICAgICAgIHZhciBjMiA9IF9nKys7XG4gICAgICAgIHZhciBtMSA9IGhzbHV2LkhzbHV2Lm1bYzJdWzBdO1xuICAgICAgICB2YXIgbTIgPSBoc2x1di5Ic2x1di5tW2MyXVsxXTtcbiAgICAgICAgdmFyIG0zID0gaHNsdXYuSHNsdXYubVtjMl1bMl07XG4gICAgICAgIHZhciBfZzEgPSAwO1xuICAgICAgICB3aGlsZSAoX2cxIDwgMikge1xuICAgICAgICAgIHZhciB0ID0gX2cxKys7XG4gICAgICAgICAgdmFyIHRvcDEgPSAoMjg0NTE3ICogbTEgLSA5NDgzOSAqIG0zKSAqIHN1YjI7XG4gICAgICAgICAgdmFyIHRvcDIgPSAoODM4NDIyICogbTMgKyA3Njk4NjAgKiBtMiArIDczMTcxOCAqIG0xKSAqIEwgKiBzdWIyIC0gNzY5ODYwICogdCAqIEw7XG4gICAgICAgICAgdmFyIGJvdHRvbSA9ICg2MzIyNjAgKiBtMyAtIDEyNjQ1MiAqIG0yKSAqIHN1YjIgKyAxMjY0NTIgKiB0O1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHsgc2xvcGU6IHRvcDEgLyBib3R0b20sIGludGVyY2VwdDogdG9wMiAvIGJvdHRvbSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIGhzbHV2LkhzbHV2Lm1heFNhZmVDaHJvbWFGb3JMID0gZnVuY3Rpb24oTCkge1xuICAgICAgdmFyIGJvdW5kcyA9IGhzbHV2LkhzbHV2LmdldEJvdW5kcyhMKTtcbiAgICAgIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgICAgIHZhciBfZyA9IDA7XG4gICAgICB3aGlsZSAoX2cgPCBib3VuZHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBib3VuZCA9IGJvdW5kc1tfZ107XG4gICAgICAgICsrX2c7XG4gICAgICAgIHZhciBsZW5ndGggPSBoc2x1di5HZW9tZXRyeS5kaXN0YW5jZUxpbmVGcm9tT3JpZ2luKGJvdW5kKTtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBsZW5ndGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1pbjtcbiAgICB9O1xuICAgIGhzbHV2LkhzbHV2Lm1heENocm9tYUZvckxIID0gZnVuY3Rpb24oTCwgSCkge1xuICAgICAgdmFyIGhyYWQgPSBIIC8gMzYwICogTWF0aC5QSSAqIDI7XG4gICAgICB2YXIgYm91bmRzID0gaHNsdXYuSHNsdXYuZ2V0Qm91bmRzKEwpO1xuICAgICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgICAgdmFyIF9nID0gMDtcbiAgICAgIHdoaWxlIChfZyA8IGJvdW5kcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGJvdW5kID0gYm91bmRzW19nXTtcbiAgICAgICAgKytfZztcbiAgICAgICAgdmFyIGxlbmd0aCA9IGhzbHV2Lkdlb21ldHJ5Lmxlbmd0aE9mUmF5VW50aWxJbnRlcnNlY3QoaHJhZCwgYm91bmQpO1xuICAgICAgICBpZiAobGVuZ3RoID49IDApIHtcbiAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtaW47XG4gICAgfTtcbiAgICBoc2x1di5Ic2x1di5kb3RQcm9kdWN0ID0gZnVuY3Rpb24oYTIsIGIyKSB7XG4gICAgICB2YXIgc3VtID0gMDtcbiAgICAgIHZhciBfZzEgPSAwO1xuICAgICAgdmFyIF9nID0gYTIubGVuZ3RoO1xuICAgICAgd2hpbGUgKF9nMSA8IF9nKSB7XG4gICAgICAgIHZhciBpID0gX2cxKys7XG4gICAgICAgIHN1bSArPSBhMltpXSAqIGIyW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1bTtcbiAgICB9O1xuICAgIGhzbHV2LkhzbHV2LmZyb21MaW5lYXIgPSBmdW5jdGlvbihjMikge1xuICAgICAgaWYgKGMyIDw9IDMxMzA4ZS03KSB7XG4gICAgICAgIHJldHVybiAxMi45MiAqIGMyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDEuMDU1ICogTWF0aC5wb3coYzIsIDAuNDE2NjY2NjY2NjY2NjY2NykgLSAwLjA1NTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGhzbHV2LkhzbHV2LnRvTGluZWFyID0gZnVuY3Rpb24oYzIpIHtcbiAgICAgIGlmIChjMiA+IDAuMDQwNDUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KChjMiArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGMyIC8gMTIuOTI7XG4gICAgICB9XG4gICAgfTtcbiAgICBoc2x1di5Ic2x1di54eXpUb1JnYiA9IGZ1bmN0aW9uKHR1cGxlKSB7XG4gICAgICByZXR1cm4gW2hzbHV2LkhzbHV2LmZyb21MaW5lYXIoaHNsdXYuSHNsdXYuZG90UHJvZHVjdChoc2x1di5Ic2x1di5tWzBdLCB0dXBsZSkpLCBoc2x1di5Ic2x1di5mcm9tTGluZWFyKGhzbHV2LkhzbHV2LmRvdFByb2R1Y3QoaHNsdXYuSHNsdXYubVsxXSwgdHVwbGUpKSwgaHNsdXYuSHNsdXYuZnJvbUxpbmVhcihoc2x1di5Ic2x1di5kb3RQcm9kdWN0KGhzbHV2LkhzbHV2Lm1bMl0sIHR1cGxlKSldO1xuICAgIH07XG4gICAgaHNsdXYuSHNsdXYucmdiVG9YeXogPSBmdW5jdGlvbih0dXBsZSkge1xuICAgICAgdmFyIHJnYmwgPSBbaHNsdXYuSHNsdXYudG9MaW5lYXIodHVwbGVbMF0pLCBoc2x1di5Ic2x1di50b0xpbmVhcih0dXBsZVsxXSksIGhzbHV2LkhzbHV2LnRvTGluZWFyKHR1cGxlWzJdKV07XG4gICAgICByZXR1cm4gW2hzbHV2LkhzbHV2LmRvdFByb2R1Y3QoaHNsdXYuSHNsdXYubWludlswXSwgcmdibCksIGhzbHV2LkhzbHV2LmRvdFByb2R1Y3QoaHNsdXYuSHNsdXYubWludlsxXSwgcmdibCksIGhzbHV2LkhzbHV2LmRvdFByb2R1Y3QoaHNsdXYuSHNsdXYubWludlsyXSwgcmdibCldO1xuICAgIH07XG4gICAgaHNsdXYuSHNsdXYueVRvTCA9IGZ1bmN0aW9uKFkpIHtcbiAgICAgIGlmIChZIDw9IGhzbHV2LkhzbHV2LmVwc2lsb24pIHtcbiAgICAgICAgcmV0dXJuIFkgLyBoc2x1di5Ic2x1di5yZWZZICogaHNsdXYuSHNsdXYua2FwcGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTE2ICogTWF0aC5wb3coWSAvIGhzbHV2LkhzbHV2LnJlZlksIDAuMzMzMzMzMzMzMzMzMzMzMykgLSAxNjtcbiAgICAgIH1cbiAgICB9O1xuICAgIGhzbHV2LkhzbHV2LmxUb1kgPSBmdW5jdGlvbihMKSB7XG4gICAgICBpZiAoTCA8PSA4KSB7XG4gICAgICAgIHJldHVybiBoc2x1di5Ic2x1di5yZWZZICogTCAvIGhzbHV2LkhzbHV2LmthcHBhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGhzbHV2LkhzbHV2LnJlZlkgKiBNYXRoLnBvdygoTCArIDE2KSAvIDExNiwgMyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBoc2x1di5Ic2x1di54eXpUb0x1diA9IGZ1bmN0aW9uKHR1cGxlKSB7XG4gICAgICB2YXIgWCA9IHR1cGxlWzBdO1xuICAgICAgdmFyIFkgPSB0dXBsZVsxXTtcbiAgICAgIHZhciBaID0gdHVwbGVbMl07XG4gICAgICB2YXIgZGl2aWRlciA9IFggKyAxNSAqIFkgKyAzICogWjtcbiAgICAgIHZhciB2YXJVID0gNCAqIFg7XG4gICAgICB2YXIgdmFyViA9IDkgKiBZO1xuICAgICAgaWYgKGRpdmlkZXIgIT0gMCkge1xuICAgICAgICB2YXJVIC89IGRpdmlkZXI7XG4gICAgICAgIHZhclYgLz0gZGl2aWRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhclUgPSBOYU47XG4gICAgICAgIHZhclYgPSBOYU47XG4gICAgICB9XG4gICAgICB2YXIgTCA9IGhzbHV2LkhzbHV2LnlUb0woWSk7XG4gICAgICBpZiAoTCA9PSAwKSB7XG4gICAgICAgIHJldHVybiBbMCwgMCwgMF07XG4gICAgICB9XG4gICAgICB2YXIgVSA9IDEzICogTCAqICh2YXJVIC0gaHNsdXYuSHNsdXYucmVmVSk7XG4gICAgICB2YXIgViA9IDEzICogTCAqICh2YXJWIC0gaHNsdXYuSHNsdXYucmVmVik7XG4gICAgICByZXR1cm4gW0wsIFUsIFZdO1xuICAgIH07XG4gICAgaHNsdXYuSHNsdXYubHV2VG9YeXogPSBmdW5jdGlvbih0dXBsZSkge1xuICAgICAgdmFyIEwgPSB0dXBsZVswXTtcbiAgICAgIHZhciBVID0gdHVwbGVbMV07XG4gICAgICB2YXIgViA9IHR1cGxlWzJdO1xuICAgICAgaWYgKEwgPT0gMCkge1xuICAgICAgICByZXR1cm4gWzAsIDAsIDBdO1xuICAgICAgfVxuICAgICAgdmFyIHZhclUgPSBVIC8gKDEzICogTCkgKyBoc2x1di5Ic2x1di5yZWZVO1xuICAgICAgdmFyIHZhclYgPSBWIC8gKDEzICogTCkgKyBoc2x1di5Ic2x1di5yZWZWO1xuICAgICAgdmFyIFkgPSBoc2x1di5Ic2x1di5sVG9ZKEwpO1xuICAgICAgdmFyIFggPSAwIC0gOSAqIFkgKiB2YXJVIC8gKCh2YXJVIC0gNCkgKiB2YXJWIC0gdmFyVSAqIHZhclYpO1xuICAgICAgdmFyIFogPSAoOSAqIFkgLSAxNSAqIHZhclYgKiBZIC0gdmFyViAqIFgpIC8gKDMgKiB2YXJWKTtcbiAgICAgIHJldHVybiBbWCwgWSwgWl07XG4gICAgfTtcbiAgICBoc2x1di5Ic2x1di5sdXZUb0xjaCA9IGZ1bmN0aW9uKHR1cGxlKSB7XG4gICAgICB2YXIgTCA9IHR1cGxlWzBdO1xuICAgICAgdmFyIFUgPSB0dXBsZVsxXTtcbiAgICAgIHZhciBWID0gdHVwbGVbMl07XG4gICAgICB2YXIgQyA9IE1hdGguc3FydChVICogVSArIFYgKiBWKTtcbiAgICAgIHZhciBIO1xuICAgICAgaWYgKEMgPCAxZS04KSB7XG4gICAgICAgIEggPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIEhyYWQgPSBNYXRoLmF0YW4yKFYsIFUpO1xuICAgICAgICBIID0gSHJhZCAqIDE4MCAvIE1hdGguUEk7XG4gICAgICAgIGlmIChIIDwgMCkge1xuICAgICAgICAgIEggPSAzNjAgKyBIO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW0wsIEMsIEhdO1xuICAgIH07XG4gICAgaHNsdXYuSHNsdXYubGNoVG9MdXYgPSBmdW5jdGlvbih0dXBsZSkge1xuICAgICAgdmFyIEwgPSB0dXBsZVswXTtcbiAgICAgIHZhciBDID0gdHVwbGVbMV07XG4gICAgICB2YXIgSCA9IHR1cGxlWzJdO1xuICAgICAgdmFyIEhyYWQgPSBIIC8gMzYwICogMiAqIE1hdGguUEk7XG4gICAgICB2YXIgVSA9IE1hdGguY29zKEhyYWQpICogQztcbiAgICAgIHZhciBWID0gTWF0aC5zaW4oSHJhZCkgKiBDO1xuICAgICAgcmV0dXJuIFtMLCBVLCBWXTtcbiAgICB9O1xuICAgIGhzbHV2LkhzbHV2LmhzbHV2VG9MY2ggPSBmdW5jdGlvbih0dXBsZSkge1xuICAgICAgdmFyIEggPSB0dXBsZVswXTtcbiAgICAgIHZhciBTID0gdHVwbGVbMV07XG4gICAgICB2YXIgTCA9IHR1cGxlWzJdO1xuICAgICAgaWYgKEwgPiA5OS45OTk5OTk5KSB7XG4gICAgICAgIHJldHVybiBbMTAwLCAwLCBIXTtcbiAgICAgIH1cbiAgICAgIGlmIChMIDwgMWUtOCkge1xuICAgICAgICByZXR1cm4gWzAsIDAsIEhdO1xuICAgICAgfVxuICAgICAgdmFyIG1heCA9IGhzbHV2LkhzbHV2Lm1heENocm9tYUZvckxIKEwsIEgpO1xuICAgICAgdmFyIEMgPSBtYXggLyAxMDAgKiBTO1xuICAgICAgcmV0dXJuIFtMLCBDLCBIXTtcbiAgICB9O1xuICAgIGhzbHV2LkhzbHV2LmxjaFRvSHNsdXYgPSBmdW5jdGlvbih0dXBsZSkge1xuICAgICAgdmFyIEwgPSB0dXBsZVswXTtcbiAgICAgIHZhciBDID0gdHVwbGVbMV07XG4gICAgICB2YXIgSCA9IHR1cGxlWzJdO1xuICAgICAgaWYgKEwgPiA5OS45OTk5OTk5KSB7XG4gICAgICAgIHJldHVybiBbSCwgMCwgMTAwXTtcbiAgICAgIH1cbiAgICAgIGlmIChMIDwgMWUtOCkge1xuICAgICAgICByZXR1cm4gW0gsIDAsIDBdO1xuICAgICAgfVxuICAgICAgdmFyIG1heCA9IGhzbHV2LkhzbHV2Lm1heENocm9tYUZvckxIKEwsIEgpO1xuICAgICAgdmFyIFMgPSBDIC8gbWF4ICogMTAwO1xuICAgICAgcmV0dXJuIFtILCBTLCBMXTtcbiAgICB9O1xuICAgIGhzbHV2LkhzbHV2LmhwbHV2VG9MY2ggPSBmdW5jdGlvbih0dXBsZSkge1xuICAgICAgdmFyIEggPSB0dXBsZVswXTtcbiAgICAgIHZhciBTID0gdHVwbGVbMV07XG4gICAgICB2YXIgTCA9IHR1cGxlWzJdO1xuICAgICAgaWYgKEwgPiA5OS45OTk5OTk5KSB7XG4gICAgICAgIHJldHVybiBbMTAwLCAwLCBIXTtcbiAgICAgIH1cbiAgICAgIGlmIChMIDwgMWUtOCkge1xuICAgICAgICByZXR1cm4gWzAsIDAsIEhdO1xuICAgICAgfVxuICAgICAgdmFyIG1heCA9IGhzbHV2LkhzbHV2Lm1heFNhZmVDaHJvbWFGb3JMKEwpO1xuICAgICAgdmFyIEMgPSBtYXggLyAxMDAgKiBTO1xuICAgICAgcmV0dXJuIFtMLCBDLCBIXTtcbiAgICB9O1xuICAgIGhzbHV2LkhzbHV2LmxjaFRvSHBsdXYgPSBmdW5jdGlvbih0dXBsZSkge1xuICAgICAgdmFyIEwgPSB0dXBsZVswXTtcbiAgICAgIHZhciBDID0gdHVwbGVbMV07XG4gICAgICB2YXIgSCA9IHR1cGxlWzJdO1xuICAgICAgaWYgKEwgPiA5OS45OTk5OTk5KSB7XG4gICAgICAgIHJldHVybiBbSCwgMCwgMTAwXTtcbiAgICAgIH1cbiAgICAgIGlmIChMIDwgMWUtOCkge1xuICAgICAgICByZXR1cm4gW0gsIDAsIDBdO1xuICAgICAgfVxuICAgICAgdmFyIG1heCA9IGhzbHV2LkhzbHV2Lm1heFNhZmVDaHJvbWFGb3JMKEwpO1xuICAgICAgdmFyIFMgPSBDIC8gbWF4ICogMTAwO1xuICAgICAgcmV0dXJuIFtILCBTLCBMXTtcbiAgICB9O1xuICAgIGhzbHV2LkhzbHV2LnJnYlRvSGV4ID0gZnVuY3Rpb24odHVwbGUpIHtcbiAgICAgIHZhciBoID0gXCIjXCI7XG4gICAgICB2YXIgX2cgPSAwO1xuICAgICAgd2hpbGUgKF9nIDwgMykge1xuICAgICAgICB2YXIgaSA9IF9nKys7XG4gICAgICAgIHZhciBjaGFuID0gdHVwbGVbaV07XG4gICAgICAgIHZhciBjMiA9IE1hdGgucm91bmQoY2hhbiAqIDI1NSk7XG4gICAgICAgIHZhciBkaWdpdDIgPSBjMiAlIDE2O1xuICAgICAgICB2YXIgZGlnaXQxID0gKGMyIC0gZGlnaXQyKSAvIDE2IHwgMDtcbiAgICAgICAgaCArPSBoc2x1di5Ic2x1di5oZXhDaGFycy5jaGFyQXQoZGlnaXQxKSArIGhzbHV2LkhzbHV2LmhleENoYXJzLmNoYXJBdChkaWdpdDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGg7XG4gICAgfTtcbiAgICBoc2x1di5Ic2x1di5oZXhUb1JnYiA9IGZ1bmN0aW9uKGhleDIpIHtcbiAgICAgIGhleDIgPSBoZXgyLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcmV0ID0gW107XG4gICAgICB2YXIgX2cgPSAwO1xuICAgICAgd2hpbGUgKF9nIDwgMykge1xuICAgICAgICB2YXIgaSA9IF9nKys7XG4gICAgICAgIHZhciBkaWdpdDEgPSBoc2x1di5Ic2x1di5oZXhDaGFycy5pbmRleE9mKGhleDIuY2hhckF0KGkgKiAyICsgMSkpO1xuICAgICAgICB2YXIgZGlnaXQyID0gaHNsdXYuSHNsdXYuaGV4Q2hhcnMuaW5kZXhPZihoZXgyLmNoYXJBdChpICogMiArIDIpKTtcbiAgICAgICAgdmFyIG4gPSBkaWdpdDEgKiAxNiArIGRpZ2l0MjtcbiAgICAgICAgcmV0LnB1c2gobiAvIDI1NSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaHNsdXYuSHNsdXYubGNoVG9SZ2IgPSBmdW5jdGlvbih0dXBsZSkge1xuICAgICAgcmV0dXJuIGhzbHV2LkhzbHV2Lnh5elRvUmdiKGhzbHV2LkhzbHV2Lmx1dlRvWHl6KGhzbHV2LkhzbHV2LmxjaFRvTHV2KHR1cGxlKSkpO1xuICAgIH07XG4gICAgaHNsdXYuSHNsdXYucmdiVG9MY2ggPSBmdW5jdGlvbih0dXBsZSkge1xuICAgICAgcmV0dXJuIGhzbHV2LkhzbHV2Lmx1dlRvTGNoKGhzbHV2LkhzbHV2Lnh5elRvTHV2KGhzbHV2LkhzbHV2LnJnYlRvWHl6KHR1cGxlKSkpO1xuICAgIH07XG4gICAgaHNsdXYuSHNsdXYuaHNsdXZUb1JnYiA9IGZ1bmN0aW9uKHR1cGxlKSB7XG4gICAgICByZXR1cm4gaHNsdXYuSHNsdXYubGNoVG9SZ2IoaHNsdXYuSHNsdXYuaHNsdXZUb0xjaCh0dXBsZSkpO1xuICAgIH07XG4gICAgaHNsdXYuSHNsdXYucmdiVG9Ic2x1diA9IGZ1bmN0aW9uKHR1cGxlKSB7XG4gICAgICByZXR1cm4gaHNsdXYuSHNsdXYubGNoVG9Ic2x1dihoc2x1di5Ic2x1di5yZ2JUb0xjaCh0dXBsZSkpO1xuICAgIH07XG4gICAgaHNsdXYuSHNsdXYuaHBsdXZUb1JnYiA9IGZ1bmN0aW9uKHR1cGxlKSB7XG4gICAgICByZXR1cm4gaHNsdXYuSHNsdXYubGNoVG9SZ2IoaHNsdXYuSHNsdXYuaHBsdXZUb0xjaCh0dXBsZSkpO1xuICAgIH07XG4gICAgaHNsdXYuSHNsdXYucmdiVG9IcGx1diA9IGZ1bmN0aW9uKHR1cGxlKSB7XG4gICAgICByZXR1cm4gaHNsdXYuSHNsdXYubGNoVG9IcGx1dihoc2x1di5Ic2x1di5yZ2JUb0xjaCh0dXBsZSkpO1xuICAgIH07XG4gICAgaHNsdXYuSHNsdXYuaHNsdXZUb0hleCA9IGZ1bmN0aW9uKHR1cGxlKSB7XG4gICAgICByZXR1cm4gaHNsdXYuSHNsdXYucmdiVG9IZXgoaHNsdXYuSHNsdXYuaHNsdXZUb1JnYih0dXBsZSkpO1xuICAgIH07XG4gICAgaHNsdXYuSHNsdXYuaHBsdXZUb0hleCA9IGZ1bmN0aW9uKHR1cGxlKSB7XG4gICAgICByZXR1cm4gaHNsdXYuSHNsdXYucmdiVG9IZXgoaHNsdXYuSHNsdXYuaHBsdXZUb1JnYih0dXBsZSkpO1xuICAgIH07XG4gICAgaHNsdXYuSHNsdXYuaGV4VG9Ic2x1diA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiBoc2x1di5Ic2x1di5yZ2JUb0hzbHV2KGhzbHV2LkhzbHV2LmhleFRvUmdiKHMpKTtcbiAgICB9O1xuICAgIGhzbHV2LkhzbHV2LmhleFRvSHBsdXYgPSBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gaHNsdXYuSHNsdXYucmdiVG9IcGx1dihoc2x1di5Ic2x1di5oZXhUb1JnYihzKSk7XG4gICAgfTtcbiAgICBoc2x1di5Ic2x1di5tID0gW1szLjI0MDk2OTk0MTkwNDUyMSwgLTEuNTM3MzgzMTc3NTcwMDkzLCAtMC40OTg2MTA3NjAyOTNdLCBbLTAuOTY5MjQzNjM2MjgwODcsIDEuODc1OTY3NTAxNTA3NzIsIDAuMDQxNTU1MDU3NDA3MTc1XSwgWzAuMDU1NjMwMDc5Njk2OTkzLCAtMC4yMDM5NzY5NTg4ODg5NywgMS4wNTY5NzE1MTQyNDI4NzhdXTtcbiAgICBoc2x1di5Ic2x1di5taW52ID0gW1swLjQxMjM5MDc5OTI2NTk1LCAwLjM1NzU4NDMzOTM4Mzg3LCAwLjE4MDQ4MDc4ODQwMTgzXSwgWzAuMjEyNjM5MDA1ODcxNTEsIDAuNzE1MTY4Njc4NzY3NzUsIDAuMDcyMTkyMzE1MzYwNzMzXSwgWzAuMDE5MzMwODE4NzE1NTkxLCAwLjExOTE5NDc3OTc5NDYyLCAwLjk1MDUzMjE1MjI0OTY2XV07XG4gICAgaHNsdXYuSHNsdXYucmVmWSA9IDE7XG4gICAgaHNsdXYuSHNsdXYucmVmVSA9IDAuMTk3ODMwMDA2NjQyODM7XG4gICAgaHNsdXYuSHNsdXYucmVmViA9IDAuNDY4MzE5OTk0OTM4Nzk7XG4gICAgaHNsdXYuSHNsdXYua2FwcGEgPSA5MDMuMjk2Mjk2MjtcbiAgICBoc2x1di5Ic2x1di5lcHNpbG9uID0gMC4wMDg4NTY0NTE2O1xuICAgIGhzbHV2LkhzbHV2LmhleENoYXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gICAgdmFyIHJvb3QgPSB7XG4gICAgICBcImhzbHV2VG9SZ2JcIjogaHNsdXYuSHNsdXYuaHNsdXZUb1JnYixcbiAgICAgIFwicmdiVG9Ic2x1dlwiOiBoc2x1di5Ic2x1di5yZ2JUb0hzbHV2LFxuICAgICAgXCJocGx1dlRvUmdiXCI6IGhzbHV2LkhzbHV2LmhwbHV2VG9SZ2IsXG4gICAgICBcInJnYlRvSHBsdXZcIjogaHNsdXYuSHNsdXYucmdiVG9IcGx1dixcbiAgICAgIFwiaHNsdXZUb0hleFwiOiBoc2x1di5Ic2x1di5oc2x1dlRvSGV4LFxuICAgICAgXCJoZXhUb0hzbHV2XCI6IGhzbHV2LkhzbHV2LmhleFRvSHNsdXYsXG4gICAgICBcImhwbHV2VG9IZXhcIjogaHNsdXYuSHNsdXYuaHBsdXZUb0hleCxcbiAgICAgIFwiaGV4VG9IcGx1dlwiOiBoc2x1di5Ic2x1di5oZXhUb0hwbHV2LFxuICAgICAgXCJsY2hUb0hwbHV2XCI6IGhzbHV2LkhzbHV2LmxjaFRvSHBsdXYsXG4gICAgICBcImhwbHV2VG9MY2hcIjogaHNsdXYuSHNsdXYuaHBsdXZUb0xjaCxcbiAgICAgIFwibGNoVG9Ic2x1dlwiOiBoc2x1di5Ic2x1di5sY2hUb0hzbHV2LFxuICAgICAgXCJoc2x1dlRvTGNoXCI6IGhzbHV2LkhzbHV2LmhzbHV2VG9MY2gsXG4gICAgICBcImxjaFRvTHV2XCI6IGhzbHV2LkhzbHV2LmxjaFRvTHV2LFxuICAgICAgXCJsdXZUb0xjaFwiOiBoc2x1di5Ic2x1di5sdXZUb0xjaCxcbiAgICAgIFwieHl6VG9MdXZcIjogaHNsdXYuSHNsdXYueHl6VG9MdXYsXG4gICAgICBcImx1dlRvWHl6XCI6IGhzbHV2LkhzbHV2Lmx1dlRvWHl6LFxuICAgICAgXCJ4eXpUb1JnYlwiOiBoc2x1di5Ic2x1di54eXpUb1JnYixcbiAgICAgIFwicmdiVG9YeXpcIjogaHNsdXYuSHNsdXYucmdiVG9YeXosXG4gICAgICBcImxjaFRvUmdiXCI6IGhzbHV2LkhzbHV2LmxjaFRvUmdiLFxuICAgICAgXCJyZ2JUb0xjaFwiOiBoc2x1di5Ic2x1di5yZ2JUb0xjaFxuICAgIH07XG4gICAgbW9kdWxlLmV4cG9ydHMgPSByb290O1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanNcbnZhciByZXF1aXJlX2V2ZW50ZW1pdHRlcjMgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICAgIHZhciBwcmVmaXggPSBcIn5cIjtcbiAgICBmdW5jdGlvbiBFdmVudHMoKSB7XG4gICAgfVxuICAgIGlmIChPYmplY3QuY3JlYXRlKSB7XG4gICAgICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXylcbiAgICAgICAgcHJlZml4ID0gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gICAgICB0aGlzLmZuID0gZm47XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICB9XG4gICAgICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSksIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKVxuICAgICAgICBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICAgICAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKVxuICAgICAgICBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIGVsc2VcbiAgICAgICAgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcbiAgICAgIHJldHVybiBlbWl0dGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICAgICAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIyKCkge1xuICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgIH1cbiAgICBFdmVudEVtaXR0ZXIyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgICAgIHZhciBuYW1lczIgPSBbXSwgZXZlbnRzMiwgbmFtZTtcbiAgICAgIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgcmV0dXJuIG5hbWVzMjtcbiAgICAgIGZvciAobmFtZSBpbiBldmVudHMyID0gdGhpcy5fZXZlbnRzKSB7XG4gICAgICAgIGlmIChoYXMuY2FsbChldmVudHMyLCBuYW1lKSlcbiAgICAgICAgICBuYW1lczIucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICByZXR1cm4gbmFtZXMyLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50czIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYW1lczI7XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50LCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuICAgICAgaWYgKCFoYW5kbGVycylcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgaWYgKGhhbmRsZXJzLmZuKVxuICAgICAgICByZXR1cm4gW2hhbmRsZXJzLmZuXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgICAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVlO1xuICAgIH07XG4gICAgRXZlbnRFbWl0dGVyMi5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICAgIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50LCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcbiAgICAgIGlmICghbGlzdGVuZXJzKVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGlmIChsaXN0ZW5lcnMuZm4pXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gICAgICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncywgaTtcbiAgICAgIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICAgICAgaWYgKGxpc3RlbmVycy5vbmNlKVxuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdm9pZCAwLCB0cnVlKTtcbiAgICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGgsIGo7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSlcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdm9pZCAwLCB0cnVlKTtcbiAgICAgICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKCFhcmdzKVxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xuICAgIH07XG4gICAgRXZlbnRFbWl0dGVyMi5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlcjIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gICAgICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgaWYgKCFmbikge1xuICAgICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuICAgICAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgICAgICBpZiAobGlzdGVuZXJzLmZuID09PSBmbiAmJiAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dCkpIHtcbiAgICAgICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMyID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8IG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlIHx8IGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpIHtcbiAgICAgICAgICAgIGV2ZW50czIucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRzMi5sZW5ndGgpXG4gICAgICAgICAgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMyLmxlbmd0aCA9PT0gMSA/IGV2ZW50czJbMF0gOiBldmVudHMyO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgIHZhciBldnQ7XG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKVxuICAgICAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbiAgICBFdmVudEVtaXR0ZXIyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlcjIucHJvdG90eXBlLm9uO1xuICAgIEV2ZW50RW1pdHRlcjIucHJlZml4ZWQgPSBwcmVmaXg7XG4gICAgRXZlbnRFbWl0dGVyMi5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXIyO1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjI7XG4gICAgfVxuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2Rpc3QvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MuY2pzLmpzXG52YXIgcmVxdWlyZV9ob2lzdF9ub25fcmVhY3Rfc3RhdGljc19janMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvZGlzdC9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy5janMuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgICAgIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICAgICAgY29udGV4dFR5cGVzOiB0cnVlLFxuICAgICAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICAgICAgZGlzcGxheU5hbWU6IHRydWUsXG4gICAgICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IHRydWUsXG4gICAgICBtaXhpbnM6IHRydWUsXG4gICAgICBwcm9wVHlwZXM6IHRydWUsXG4gICAgICB0eXBlOiB0cnVlXG4gICAgfTtcbiAgICB2YXIgS05PV05fU1RBVElDUyA9IHtcbiAgICAgIG5hbWU6IHRydWUsXG4gICAgICBsZW5ndGg6IHRydWUsXG4gICAgICBwcm90b3R5cGU6IHRydWUsXG4gICAgICBjYWxsZXI6IHRydWUsXG4gICAgICBjYWxsZWU6IHRydWUsXG4gICAgICBhcmd1bWVudHM6IHRydWUsXG4gICAgICBhcml0eTogdHJ1ZVxuICAgIH07XG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICAgIHZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG4gICAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4gICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgdmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICAgIHZhciBvYmplY3RQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZiAmJiBnZXRQcm90b3R5cGVPZihPYmplY3QpO1xuICAgIGZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBibGFja2xpc3QpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgICB2YXIgaW5oZXJpdGVkQ29tcG9uZW50ID0gZ2V0UHJvdG90eXBlT2Yoc291cmNlQ29tcG9uZW50KTtcbiAgICAgICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgICAgICBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIGluaGVyaXRlZENvbXBvbmVudCwgYmxhY2tsaXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleXMyID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuICAgICAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgICAga2V5czIgPSBrZXlzMi5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5czIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIga2V5NiA9IGtleXMyW2ldO1xuICAgICAgICAgIGlmICghUkVBQ1RfU1RBVElDU1trZXk2XSAmJiAhS05PV05fU1RBVElDU1trZXk2XSAmJiAoIWJsYWNrbGlzdCB8fCAhYmxhY2tsaXN0W2tleTZdKSkge1xuICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlQ29tcG9uZW50LCBrZXk2KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldENvbXBvbmVudCwga2V5NiwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGhvaXN0Tm9uUmVhY3RTdGF0aWNzO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZvbnRmYWNlb2JzZXJ2ZXIvZm9udGZhY2VvYnNlcnZlci5zdGFuZGFsb25lLmpzXG52YXIgcmVxdWlyZV9mb250ZmFjZW9ic2VydmVyX3N0YW5kYWxvbmUgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvZm9udGZhY2VvYnNlcnZlci9mb250ZmFjZW9ic2VydmVyLnN0YW5kYWxvbmUuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBsKGEyLCBiMikge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyID8gYTIuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBiMiwgZmFsc2UpIDogYTIuYXR0YWNoRXZlbnQoXCJzY3JvbGxcIiwgYjIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbTIoYTIpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keSA/IGEyKCkgOiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyID8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24gYzIoKSB7XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgYzIpO1xuICAgICAgICAgIGEyKCk7XG4gICAgICAgIH0pIDogZG9jdW1lbnQuYXR0YWNoRXZlbnQoXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiwgZnVuY3Rpb24gaygpIHtcbiAgICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSBcImludGVyYWN0aXZlXCIgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSBcImNvbXBsZXRlXCIpXG4gICAgICAgICAgICBkb2N1bWVudC5kZXRhY2hFdmVudChcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLCBrKSwgYTIoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICA7XG4gICAgICBmdW5jdGlvbiB0KGEyKSB7XG4gICAgICAgIHRoaXMuYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuYS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIHRoaXMuYS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhMikpO1xuICAgICAgICB0aGlzLmIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgdGhpcy5jID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHRoaXMuaCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICB0aGlzLmYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgdGhpcy5nID0gLTE7XG4gICAgICAgIHRoaXMuYi5zdHlsZS5jc3NUZXh0ID0gXCJtYXgtd2lkdGg6bm9uZTtkaXNwbGF5OmlubGluZS1ibG9jaztwb3NpdGlvbjphYnNvbHV0ZTtoZWlnaHQ6MTAwJTt3aWR0aDoxMDAlO292ZXJmbG93OnNjcm9sbDtmb250LXNpemU6MTZweDtcIjtcbiAgICAgICAgdGhpcy5jLnN0eWxlLmNzc1RleHQgPSBcIm1heC13aWR0aDpub25lO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO2hlaWdodDoxMDAlO3dpZHRoOjEwMCU7b3ZlcmZsb3c6c2Nyb2xsO2ZvbnQtc2l6ZToxNnB4O1wiO1xuICAgICAgICB0aGlzLmYuc3R5bGUuY3NzVGV4dCA9IFwibWF4LXdpZHRoOm5vbmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJTtvdmVyZmxvdzpzY3JvbGw7Zm9udC1zaXplOjE2cHg7XCI7XG4gICAgICAgIHRoaXMuaC5zdHlsZS5jc3NUZXh0ID0gXCJkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDoyMDAlO2hlaWdodDoyMDAlO2ZvbnQtc2l6ZToxNnB4O21heC13aWR0aDpub25lO1wiO1xuICAgICAgICB0aGlzLmIuYXBwZW5kQ2hpbGQodGhpcy5oKTtcbiAgICAgICAgdGhpcy5jLmFwcGVuZENoaWxkKHRoaXMuZik7XG4gICAgICAgIHRoaXMuYS5hcHBlbmRDaGlsZCh0aGlzLmIpO1xuICAgICAgICB0aGlzLmEuYXBwZW5kQ2hpbGQodGhpcy5jKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHUoYTIsIGIyKSB7XG4gICAgICAgIGEyLmEuc3R5bGUuY3NzVGV4dCA9IFwibWF4LXdpZHRoOm5vbmU7bWluLXdpZHRoOjIwcHg7bWluLWhlaWdodDoyMHB4O2Rpc3BsYXk6aW5saW5lLWJsb2NrO292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDphdXRvO21hcmdpbjowO3BhZGRpbmc6MDt0b3A6LTk5OXB4O3doaXRlLXNwYWNlOm5vd3JhcDtmb250LXN5bnRoZXNpczpub25lO2ZvbnQ6XCIgKyBiMiArIFwiO1wiO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24geihhMikge1xuICAgICAgICB2YXIgYjIgPSBhMi5hLm9mZnNldFdpZHRoLCBjMiA9IGIyICsgMTAwO1xuICAgICAgICBhMi5mLnN0eWxlLndpZHRoID0gYzIgKyBcInB4XCI7XG4gICAgICAgIGEyLmMuc2Nyb2xsTGVmdCA9IGMyO1xuICAgICAgICBhMi5iLnNjcm9sbExlZnQgPSBhMi5iLnNjcm9sbFdpZHRoICsgMTAwO1xuICAgICAgICByZXR1cm4gYTIuZyAhPT0gYjIgPyAoYTIuZyA9IGIyLCB0cnVlKSA6IGZhbHNlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gQShhMiwgYjIpIHtcbiAgICAgICAgZnVuY3Rpb24gYzIoKSB7XG4gICAgICAgICAgdmFyIGEzID0gaztcbiAgICAgICAgICB6KGEzKSAmJiBhMy5hLnBhcmVudE5vZGUgJiYgYjIoYTMuZyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGsgPSBhMjtcbiAgICAgICAgbChhMi5iLCBjMik7XG4gICAgICAgIGwoYTIuYywgYzIpO1xuICAgICAgICB6KGEyKTtcbiAgICAgIH1cbiAgICAgIDtcbiAgICAgIGZ1bmN0aW9uIEIoYTIsIGIyKSB7XG4gICAgICAgIHZhciBjMiA9IGIyIHx8IHt9O1xuICAgICAgICB0aGlzLmZhbWlseSA9IGEyO1xuICAgICAgICB0aGlzLnN0eWxlID0gYzIuc3R5bGUgfHwgXCJub3JtYWxcIjtcbiAgICAgICAgdGhpcy53ZWlnaHQgPSBjMi53ZWlnaHQgfHwgXCJub3JtYWxcIjtcbiAgICAgICAgdGhpcy5zdHJldGNoID0gYzIuc3RyZXRjaCB8fCBcIm5vcm1hbFwiO1xuICAgICAgfVxuICAgICAgdmFyIEMgPSBudWxsLCBEID0gbnVsbCwgRSA9IG51bGwsIEYgPSBudWxsO1xuICAgICAgZnVuY3Rpb24gRygpIHtcbiAgICAgICAgaWYgKEQgPT09IG51bGwpXG4gICAgICAgICAgaWYgKEooKSAmJiAvQXBwbGUvLnRlc3Qod2luZG93Lm5hdmlnYXRvci52ZW5kb3IpKSB7XG4gICAgICAgICAgICB2YXIgYTIgPSAvQXBwbGVXZWJLaXRcXC8oWzAtOV0rKSg/OlxcLihbMC05XSspKSg/OlxcLihbMC05XSspKS8uZXhlYyh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgICAgICBEID0gISFhMiAmJiA2MDMgPiBwYXJzZUludChhMlsxXSwgMTApO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgRCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gRDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIEooKSB7XG4gICAgICAgIEYgPT09IG51bGwgJiYgKEYgPSAhIWRvY3VtZW50LmZvbnRzKTtcbiAgICAgICAgcmV0dXJuIEY7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBLKCkge1xuICAgICAgICBpZiAoRSA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhciBhMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGEyLnN0eWxlLmZvbnQgPSBcImNvbmRlbnNlZCAxMDBweCBzYW5zLXNlcmlmXCI7XG4gICAgICAgICAgfSBjYXRjaCAoYjIpIHtcbiAgICAgICAgICB9XG4gICAgICAgICAgRSA9IGEyLnN0eWxlLmZvbnQgIT09IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBMKGEyLCBiMikge1xuICAgICAgICByZXR1cm4gW2EyLnN0eWxlLCBhMi53ZWlnaHQsIEsoKSA/IGEyLnN0cmV0Y2ggOiBcIlwiLCBcIjEwMHB4XCIsIGIyXS5qb2luKFwiIFwiKTtcbiAgICAgIH1cbiAgICAgIEIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbihhMiwgYjIpIHtcbiAgICAgICAgdmFyIGMyID0gdGhpcywgayA9IGEyIHx8IFwiQkVTYnN3eVwiLCByID0gMCwgbiA9IGIyIHx8IDNlMywgSCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oYTMsIGIzKSB7XG4gICAgICAgICAgaWYgKEooKSAmJiAhRygpKSB7XG4gICAgICAgICAgICB2YXIgTSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKGE0LCBiNCkge1xuICAgICAgICAgICAgICBmdW5jdGlvbiBlKCkge1xuICAgICAgICAgICAgICAgIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gSCA+PSBuID8gYjQoRXJyb3IoXCJcIiArIG4gKyBcIm1zIHRpbWVvdXQgZXhjZWVkZWRcIikpIDogZG9jdW1lbnQuZm9udHMubG9hZChMKGMyLCAnXCInICsgYzIuZmFtaWx5ICsgJ1wiJyksIGspLnRoZW4oZnVuY3Rpb24oYzMpIHtcbiAgICAgICAgICAgICAgICAgIDEgPD0gYzMubGVuZ3RoID8gYTQoKSA6IHNldFRpbWVvdXQoZSwgMjUpO1xuICAgICAgICAgICAgICAgIH0sIGI0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlKCk7XG4gICAgICAgICAgICB9KSwgTiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKGE0LCBjMykge1xuICAgICAgICAgICAgICByID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjMyhFcnJvcihcIlwiICsgbiArIFwibXMgdGltZW91dCBleGNlZWRlZFwiKSk7XG4gICAgICAgICAgICAgIH0sIG4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBQcm9taXNlLnJhY2UoW04sIE1dKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocik7XG4gICAgICAgICAgICAgIGEzKGMyKTtcbiAgICAgICAgICAgIH0sIGIzKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIG0yKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBmdW5jdGlvbiB2KCkge1xuICAgICAgICAgICAgICAgIHZhciBiNDtcbiAgICAgICAgICAgICAgICBpZiAoYjQgPSBmICE9IC0xICYmIGcgIT0gLTEgfHwgZiAhPSAtMSAmJiBoICE9IC0xIHx8IGcgIT0gLTEgJiYgaCAhPSAtMSlcbiAgICAgICAgICAgICAgICAgIChiNCA9IGYgIT0gZyAmJiBmICE9IGggJiYgZyAhPSBoKSB8fCAoQyA9PT0gbnVsbCAmJiAoYjQgPSAvQXBwbGVXZWJLaXRcXC8oWzAtOV0rKSg/OlxcLihbMC05XSspKS8uZXhlYyh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCksIEMgPSAhIWI0ICYmICg1MzYgPiBwYXJzZUludChiNFsxXSwgMTApIHx8IHBhcnNlSW50KGI0WzFdLCAxMCkgPT09IDUzNiAmJiAxMSA+PSBwYXJzZUludChiNFsyXSwgMTApKSksIGI0ID0gQyAmJiAoZiA9PSB3ICYmIGcgPT0gdyAmJiBoID09IHcgfHwgZiA9PSB4ICYmIGcgPT0geCAmJiBoID09IHggfHwgZiA9PSB5ICYmIGcgPT0geSAmJiBoID09IHkpKSwgYjQgPSAhYjQ7XG4gICAgICAgICAgICAgICAgYjQgJiYgKGQucGFyZW50Tm9kZSAmJiBkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCksIGNsZWFyVGltZW91dChyKSwgYTMoYzIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdW5jdGlvbiBJKCkge1xuICAgICAgICAgICAgICAgIGlmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIEggPj0gbilcbiAgICAgICAgICAgICAgICAgIGQucGFyZW50Tm9kZSAmJiBkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCksIGIzKEVycm9yKFwiXCIgKyBuICsgXCJtcyB0aW1lb3V0IGV4Y2VlZGVkXCIpKTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhNCA9IGRvY3VtZW50LmhpZGRlbjtcbiAgICAgICAgICAgICAgICAgIGlmIChhNCA9PT0gdHJ1ZSB8fCBhNCA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgICAgICBmID0gZS5hLm9mZnNldFdpZHRoLCBnID0gcC5hLm9mZnNldFdpZHRoLCBoID0gcS5hLm9mZnNldFdpZHRoLCB2KCk7XG4gICAgICAgICAgICAgICAgICByID0gc2V0VGltZW91dChJLCA1MCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBlID0gbmV3IHQoayksIHAgPSBuZXcgdChrKSwgcSA9IG5ldyB0KGspLCBmID0gLTEsIGcgPSAtMSwgaCA9IC0xLCB3ID0gLTEsIHggPSAtMSwgeSA9IC0xLCBkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgZC5kaXIgPSBcImx0clwiO1xuICAgICAgICAgICAgICB1KGUsIEwoYzIsIFwic2Fucy1zZXJpZlwiKSk7XG4gICAgICAgICAgICAgIHUocCwgTChjMiwgXCJzZXJpZlwiKSk7XG4gICAgICAgICAgICAgIHUocSwgTChjMiwgXCJtb25vc3BhY2VcIikpO1xuICAgICAgICAgICAgICBkLmFwcGVuZENoaWxkKGUuYSk7XG4gICAgICAgICAgICAgIGQuYXBwZW5kQ2hpbGQocC5hKTtcbiAgICAgICAgICAgICAgZC5hcHBlbmRDaGlsZChxLmEpO1xuICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGQpO1xuICAgICAgICAgICAgICB3ID0gZS5hLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICB4ID0gcC5hLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICB5ID0gcS5hLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICBJKCk7XG4gICAgICAgICAgICAgIEEoZSwgZnVuY3Rpb24oYTQpIHtcbiAgICAgICAgICAgICAgICBmID0gYTQ7XG4gICAgICAgICAgICAgICAgdigpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdShlLCBMKGMyLCAnXCInICsgYzIuZmFtaWx5ICsgJ1wiLHNhbnMtc2VyaWYnKSk7XG4gICAgICAgICAgICAgIEEocCwgZnVuY3Rpb24oYTQpIHtcbiAgICAgICAgICAgICAgICBnID0gYTQ7XG4gICAgICAgICAgICAgICAgdigpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdShwLCBMKGMyLCAnXCInICsgYzIuZmFtaWx5ICsgJ1wiLHNlcmlmJykpO1xuICAgICAgICAgICAgICBBKHEsIGZ1bmN0aW9uKGE0KSB7XG4gICAgICAgICAgICAgICAgaCA9IGE0O1xuICAgICAgICAgICAgICAgIHYoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHUocSwgTChjMiwgJ1wiJyArIGMyLmZhbWlseSArICdcIixtb25vc3BhY2UnKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzID0gQiA6ICh3aW5kb3cuRm9udEZhY2VPYnNlcnZlciA9IEIsIHdpbmRvdy5Gb250RmFjZU9ic2VydmVyLnByb3RvdHlwZS5sb2FkID0gQi5wcm90b3R5cGUubG9hZCk7XG4gICAgfSkoKTtcbiAgfVxufSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy90c2xpYi9tb2R1bGVzL2luZGV4LmpzXG52YXIgaW1wb3J0X3RzbGliID0gX190b01vZHVsZShyZXF1aXJlX3RzbGliKCkpO1xudmFyIHtcbiAgX19leHRlbmRzLFxuICBfX2Fzc2lnbixcbiAgX19yZXN0LFxuICBfX2RlY29yYXRlLFxuICBfX3BhcmFtLFxuICBfX21ldGFkYXRhLFxuICBfX2F3YWl0ZXIsXG4gIF9fZ2VuZXJhdG9yLFxuICBfX2V4cG9ydFN0YXIsXG4gIF9fY3JlYXRlQmluZGluZyxcbiAgX192YWx1ZXMsXG4gIF9fcmVhZCxcbiAgX19zcHJlYWQsXG4gIF9fc3ByZWFkQXJyYXlzLFxuICBfX3NwcmVhZEFycmF5LFxuICBfX2F3YWl0LFxuICBfX2FzeW5jR2VuZXJhdG9yLFxuICBfX2FzeW5jRGVsZWdhdG9yLFxuICBfX2FzeW5jVmFsdWVzLFxuICBfX21ha2VUZW1wbGF0ZU9iamVjdCxcbiAgX19pbXBvcnRTdGFyLFxuICBfX2ltcG9ydERlZmF1bHQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRHZXQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRTZXRcbn0gPSBpbXBvcnRfdHNsaWIuZGVmYXVsdDtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vaW5kZXguanNcbmltcG9ydCB7XG4gIEZyYWdtZW50LFxuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQyXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0NiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy91c2UtZmVhdHVyZXMuanNcbmltcG9ydCB7XG4gIGNyZWF0ZUVsZW1lbnRcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2RlZmluaXRpb25zLmpzXG52YXIgY3JlYXRlRGVmaW5pdGlvbiA9IGZ1bmN0aW9uKHByb3BOYW1lcykge1xuICByZXR1cm4ge1xuICAgIGlzRW5hYmxlZDogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgIHJldHVybiBwcm9wTmFtZXMuc29tZShmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiAhIXByb3BzW25hbWVdO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcbnZhciBmZWF0dXJlRGVmaW5pdGlvbnMgPSB7XG4gIG1lYXN1cmVMYXlvdXQ6IGNyZWF0ZURlZmluaXRpb24oW1xuICAgIFwibGF5b3V0XCIsXG4gICAgXCJsYXlvdXRJZFwiLFxuICAgIFwiZHJhZ1wiLFxuICAgIFwiX2xheW91dFJlc2V0VHJhbnNmb3JtXCJcbiAgXSksXG4gIGFuaW1hdGlvbjogY3JlYXRlRGVmaW5pdGlvbihbXG4gICAgXCJhbmltYXRlXCIsXG4gICAgXCJleGl0XCIsXG4gICAgXCJ2YXJpYW50c1wiLFxuICAgIFwid2hpbGVIb3ZlclwiLFxuICAgIFwid2hpbGVUYXBcIixcbiAgICBcIndoaWxlRm9jdXNcIixcbiAgICBcIndoaWxlRHJhZ1wiXG4gIF0pLFxuICBleGl0OiBjcmVhdGVEZWZpbml0aW9uKFtcImV4aXRcIl0pLFxuICBkcmFnOiBjcmVhdGVEZWZpbml0aW9uKFtcImRyYWdcIiwgXCJkcmFnQ29udHJvbHNcIl0pLFxuICBmb2N1czogY3JlYXRlRGVmaW5pdGlvbihbXCJ3aGlsZUZvY3VzXCJdKSxcbiAgaG92ZXI6IGNyZWF0ZURlZmluaXRpb24oW1wid2hpbGVIb3ZlclwiLCBcIm9uSG92ZXJTdGFydFwiLCBcIm9uSG92ZXJFbmRcIl0pLFxuICB0YXA6IGNyZWF0ZURlZmluaXRpb24oW1wid2hpbGVUYXBcIiwgXCJvblRhcFwiLCBcIm9uVGFwU3RhcnRcIiwgXCJvblRhcENhbmNlbFwiXSksXG4gIHBhbjogY3JlYXRlRGVmaW5pdGlvbihbXG4gICAgXCJvblBhblwiLFxuICAgIFwib25QYW5TdGFydFwiLFxuICAgIFwib25QYW5TZXNzaW9uU3RhcnRcIixcbiAgICBcIm9uUGFuRW5kXCJcbiAgXSksXG4gIGxheW91dEFuaW1hdGlvbjogY3JlYXRlRGVmaW5pdGlvbihbXCJsYXlvdXRcIiwgXCJsYXlvdXRJZFwiXSlcbn07XG5mdW5jdGlvbiBsb2FkRmVhdHVyZXMoZmVhdHVyZXMpIHtcbiAgZm9yICh2YXIga2V5NiBpbiBmZWF0dXJlcykge1xuICAgIHZhciBDb21wb25lbnQxOSA9IGZlYXR1cmVzW2tleTZdO1xuICAgIGlmIChDb21wb25lbnQxOSAhPT0gbnVsbClcbiAgICAgIGZlYXR1cmVEZWZpbml0aW9uc1trZXk2XS5Db21wb25lbnQgPSBDb21wb25lbnQxOTtcbiAgfVxufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvaGV5LWxpc3Rlbi9kaXN0L2hleS1saXN0ZW4uZXMuanNcbnZhciB3YXJuaW5nID0gZnVuY3Rpb24oKSB7XG59O1xudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKCkge1xufTtcbmlmICh0cnVlKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjaGVjaywgbWVzc2FnZSkge1xuICAgIGlmICghY2hlY2sgJiYgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gIH07XG4gIGludmFyaWFudCA9IGZ1bmN0aW9uKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFjaGVjaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L0xhenlDb250ZXh0LmpzXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgTGF6eUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHsgc3RyaWN0OiBmYWxzZSB9KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvdXNlLWZlYXR1cmVzLmpzXG52YXIgZmVhdHVyZU5hbWVzID0gT2JqZWN0LmtleXMoZmVhdHVyZURlZmluaXRpb25zKTtcbnZhciBudW1GZWF0dXJlcyA9IGZlYXR1cmVOYW1lcy5sZW5ndGg7XG5mdW5jdGlvbiB1c2VGZWF0dXJlcyhwcm9wcywgdmlzdWFsRWxlbWVudDIsIHByZWxvYWRlZEZlYXR1cmVzKSB7XG4gIHZhciBmZWF0dXJlcyA9IFtdO1xuICB2YXIgbGF6eUNvbnRleHQgPSB1c2VDb250ZXh0KExhenlDb250ZXh0KTtcbiAgaWYgKCF2aXN1YWxFbGVtZW50MilcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKHByZWxvYWRlZEZlYXR1cmVzICYmIGxhenlDb250ZXh0LnN0cmljdCkge1xuICAgIGludmFyaWFudChmYWxzZSwgXCJZb3UgaGF2ZSByZW5kZXJlZCBhIGBtb3Rpb25gIGNvbXBvbmVudCB3aXRoaW4gYSBgTGF6eU1vdGlvbmAgY29tcG9uZW50LiBUaGlzIHdpbGwgYnJlYWsgdHJlZSBzaGFraW5nLiBJbXBvcnQgYW5kIHJlbmRlciBhIGBtYCBjb21wb25lbnQgaW5zdGVhZC5cIik7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1GZWF0dXJlczsgaSsrKSB7XG4gICAgdmFyIG5hbWVfMSA9IGZlYXR1cmVOYW1lc1tpXTtcbiAgICB2YXIgX2EgPSBmZWF0dXJlRGVmaW5pdGlvbnNbbmFtZV8xXSwgaXNFbmFibGVkID0gX2EuaXNFbmFibGVkLCBDb21wb25lbnQxOSA9IF9hLkNvbXBvbmVudDtcbiAgICBpZiAoaXNFbmFibGVkKHByb3BzKSAmJiBDb21wb25lbnQxOSkge1xuICAgICAgZmVhdHVyZXMucHVzaChjcmVhdGVFbGVtZW50KENvbXBvbmVudDE5LCBfX2Fzc2lnbih7IGtleTogbmFtZV8xIH0sIHByb3BzLCB7IHZpc3VhbEVsZW1lbnQ6IHZpc3VhbEVsZW1lbnQyIH0pKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmZWF0dXJlcztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L01vdGlvbkNvbmZpZ0NvbnRleHQuanNcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDIgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBNb3Rpb25Db25maWdDb250ZXh0ID0gY3JlYXRlQ29udGV4dDIoe1xuICB0cmFuc2Zvcm1QYWdlUG9pbnQ6IGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gcDtcbiAgfSxcbiAgaXNTdGF0aWM6IGZhbHNlXG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L01vdGlvbkNvbnRleHQvaW5kZXguanNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDIsIGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDMgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBNb3Rpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dDMoe30pO1xuZnVuY3Rpb24gdXNlVmlzdWFsRWxlbWVudENvbnRleHQoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0MihNb3Rpb25Db250ZXh0KS52aXN1YWxFbGVtZW50O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy91c2UtdmlzdWFsLWVsZW1lbnQuanNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDQsIHVzZVJlZiBhcyB1c2VSZWYyLCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MyB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvUHJlc2VuY2VDb250ZXh0LmpzXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQ0IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgUHJlc2VuY2VDb250ZXh0ID0gY3JlYXRlQ29udGV4dDQobnVsbCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29tcG9uZW50cy9BbmltYXRlUHJlc2VuY2UvdXNlLXByZXNlbmNlLmpzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQzLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy91c2UtY29uc3RhbnQuanNcbmltcG9ydCB7IHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlQ29uc3RhbnQoaW5pdCkge1xuICB2YXIgcmVmID0gdXNlUmVmKG51bGwpO1xuICBpZiAocmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICByZWYuY3VycmVudCA9IGluaXQoKTtcbiAgfVxuICByZXR1cm4gcmVmLmN1cnJlbnQ7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29tcG9uZW50cy9BbmltYXRlUHJlc2VuY2UvdXNlLXByZXNlbmNlLmpzXG5mdW5jdGlvbiB1c2VQcmVzZW5jZSgpIHtcbiAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0MyhQcmVzZW5jZUNvbnRleHQpO1xuICBpZiAoY29udGV4dCA9PT0gbnVsbClcbiAgICByZXR1cm4gW3RydWUsIG51bGxdO1xuICB2YXIgaXNQcmVzZW50MiA9IGNvbnRleHQuaXNQcmVzZW50LCBvbkV4aXRDb21wbGV0ZSA9IGNvbnRleHQub25FeGl0Q29tcGxldGUsIHJlZ2lzdGVyID0gY29udGV4dC5yZWdpc3RlcjtcbiAgdmFyIGlkID0gdXNlVW5pcXVlSWQoKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiByZWdpc3RlcihpZCk7XG4gIH0sIFtdKTtcbiAgdmFyIHNhZmVUb1JlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBvbkV4aXRDb21wbGV0ZSA9PT0gbnVsbCB8fCBvbkV4aXRDb21wbGV0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25FeGl0Q29tcGxldGUoaWQpO1xuICB9O1xuICByZXR1cm4gIWlzUHJlc2VudDIgJiYgb25FeGl0Q29tcGxldGUgPyBbZmFsc2UsIHNhZmVUb1JlbW92ZV0gOiBbdHJ1ZV07XG59XG5mdW5jdGlvbiB1c2VJc1ByZXNlbnQoKSB7XG4gIHJldHVybiBpc1ByZXNlbnQodXNlQ29udGV4dDMoUHJlc2VuY2VDb250ZXh0KSk7XG59XG5mdW5jdGlvbiBpc1ByZXNlbnQoY29udGV4dCkge1xuICByZXR1cm4gY29udGV4dCA9PT0gbnVsbCA/IHRydWUgOiBjb250ZXh0LmlzUHJlc2VudDtcbn1cbnZhciBjb3VudGVyID0gMDtcbnZhciBpbmNyZW1lbnRJZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gY291bnRlcisrO1xufTtcbnZhciB1c2VVbmlxdWVJZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdXNlQ29uc3RhbnQoaW5jcmVtZW50SWQpO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L0xheW91dEdyb3VwQ29udGV4dC5qc1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0NSB9IGZyb20gXCJyZWFjdFwiO1xudmFyIExheW91dEdyb3VwQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ1KG51bGwpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3VzZS1pc29tb3JwaGljLWVmZmVjdC5qc1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL2lzLWJyb3dzZXIuanNcbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3VzZS1pc29tb3JwaGljLWVmZmVjdC5qc1xudmFyIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSBpc0Jyb3dzZXIgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3QyO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy91c2UtdmlzdWFsLWVsZW1lbnQuanNcbmZ1bmN0aW9uIHVzZUxheW91dElkKF9hKSB7XG4gIHZhciBsYXlvdXRJZCA9IF9hLmxheW91dElkO1xuICB2YXIgbGF5b3V0R3JvdXBJZCA9IHVzZUNvbnRleHQ0KExheW91dEdyb3VwQ29udGV4dCk7XG4gIHJldHVybiBsYXlvdXRHcm91cElkICYmIGxheW91dElkICE9PSB2b2lkIDAgPyBsYXlvdXRHcm91cElkICsgXCItXCIgKyBsYXlvdXRJZCA6IGxheW91dElkO1xufVxuZnVuY3Rpb24gdXNlVmlzdWFsRWxlbWVudChDb21wb25lbnQxOSwgdmlzdWFsU3RhdGUsIHByb3BzLCBjcmVhdGVWaXN1YWxFbGVtZW50KSB7XG4gIHZhciBjb25maWcgPSB1c2VDb250ZXh0NChNb3Rpb25Db25maWdDb250ZXh0KTtcbiAgdmFyIGxhenlDb250ZXh0ID0gdXNlQ29udGV4dDQoTGF6eUNvbnRleHQpO1xuICB2YXIgcGFyZW50ID0gdXNlVmlzdWFsRWxlbWVudENvbnRleHQoKTtcbiAgdmFyIHByZXNlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQ0KFByZXNlbmNlQ29udGV4dCk7XG4gIHZhciBsYXlvdXRJZCA9IHVzZUxheW91dElkKHByb3BzKTtcbiAgdmFyIHZpc3VhbEVsZW1lbnRSZWYgPSB1c2VSZWYyKHZvaWQgMCk7XG4gIGlmICghY3JlYXRlVmlzdWFsRWxlbWVudClcbiAgICBjcmVhdGVWaXN1YWxFbGVtZW50ID0gbGF6eUNvbnRleHQucmVuZGVyZXI7XG4gIGlmICghdmlzdWFsRWxlbWVudFJlZi5jdXJyZW50ICYmIGNyZWF0ZVZpc3VhbEVsZW1lbnQpIHtcbiAgICB2aXN1YWxFbGVtZW50UmVmLmN1cnJlbnQgPSBjcmVhdGVWaXN1YWxFbGVtZW50KENvbXBvbmVudDE5LCB7XG4gICAgICB2aXN1YWxTdGF0ZSxcbiAgICAgIHBhcmVudCxcbiAgICAgIHByb3BzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJvcHMpLCB7IGxheW91dElkIH0pLFxuICAgICAgcHJlc2VuY2VJZDogcHJlc2VuY2VDb250ZXh0ID09PSBudWxsIHx8IHByZXNlbmNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJlc2VuY2VDb250ZXh0LmlkLFxuICAgICAgYmxvY2tJbml0aWFsQW5pbWF0aW9uOiAocHJlc2VuY2VDb250ZXh0ID09PSBudWxsIHx8IHByZXNlbmNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJlc2VuY2VDb250ZXh0LmluaXRpYWwpID09PSBmYWxzZVxuICAgIH0pO1xuICB9XG4gIHZhciB2aXN1YWxFbGVtZW50MiA9IHZpc3VhbEVsZW1lbnRSZWYuY3VycmVudDtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbigpIHtcbiAgICBpZiAoIXZpc3VhbEVsZW1lbnQyKVxuICAgICAgcmV0dXJuO1xuICAgIHZpc3VhbEVsZW1lbnQyLnNldFByb3BzKF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBjb25maWcpLCBwcm9wcyksIHsgbGF5b3V0SWQgfSkpO1xuICAgIHZpc3VhbEVsZW1lbnQyLmlzUHJlc2VudCA9IGlzUHJlc2VudChwcmVzZW5jZUNvbnRleHQpO1xuICAgIHZpc3VhbEVsZW1lbnQyLmlzUHJlc2VuY2VSb290ID0gIXBhcmVudCB8fCBwYXJlbnQucHJlc2VuY2VJZCAhPT0gKHByZXNlbmNlQ29udGV4dCA9PT0gbnVsbCB8fCBwcmVzZW5jZUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXNlbmNlQ29udGV4dC5pZCk7XG4gICAgdmlzdWFsRWxlbWVudDIuc3luY1JlbmRlcigpO1xuICB9KTtcbiAgdXNlRWZmZWN0MyhmdW5jdGlvbigpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF2aXN1YWxFbGVtZW50MilcbiAgICAgIHJldHVybjtcbiAgICAoX2EgPSB2aXN1YWxFbGVtZW50Mi5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFuaW1hdGVDaGFuZ2VzKCk7XG4gIH0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2aXN1YWxFbGVtZW50MiA9PT0gbnVsbCB8fCB2aXN1YWxFbGVtZW50MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlzdWFsRWxlbWVudDIubm90aWZ5VW5tb3VudCgpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHZpc3VhbEVsZW1lbnQyO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy91c2UtbW90aW9uLXJlZi5qc1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9pcy1yZWYtb2JqZWN0LmpzXG5mdW5jdGlvbiBpc1JlZk9iamVjdChyZWYpIHtcbiAgcmV0dXJuIHR5cGVvZiByZWYgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlZiwgXCJjdXJyZW50XCIpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy91c2UtbW90aW9uLXJlZi5qc1xuZnVuY3Rpb24gdXNlTW90aW9uUmVmKHZpc3VhbFN0YXRlLCB2aXN1YWxFbGVtZW50MiwgZXh0ZXJuYWxSZWYpIHtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrKGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgdmFyIF9hO1xuICAgIGluc3RhbmNlICYmICgoX2EgPSB2aXN1YWxTdGF0ZS5tb3VudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodmlzdWFsU3RhdGUsIGluc3RhbmNlKSk7XG4gICAgaWYgKHZpc3VhbEVsZW1lbnQyKSB7XG4gICAgICBpbnN0YW5jZSA/IHZpc3VhbEVsZW1lbnQyLm1vdW50KGluc3RhbmNlKSA6IHZpc3VhbEVsZW1lbnQyLnVubW91bnQoKTtcbiAgICB9XG4gICAgaWYgKGV4dGVybmFsUmVmKSB7XG4gICAgICBpZiAodHlwZW9mIGV4dGVybmFsUmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZXh0ZXJuYWxSZWYoaW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIGlmIChpc1JlZk9iamVjdChleHRlcm5hbFJlZikpIHtcbiAgICAgICAgZXh0ZXJuYWxSZWYuY3VycmVudCA9IGluc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW3Zpc3VhbEVsZW1lbnQyXSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9Nb3Rpb25Db250ZXh0L2NyZWF0ZS5qc1xuaW1wb3J0IHsgdXNlTWVtbywgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0NSB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy92YXJpYW50cy5qc1xuZnVuY3Rpb24gaXNWYXJpYW50TGFiZWxzKHYpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodik7XG59XG5mdW5jdGlvbiBpc1ZhcmlhbnRMYWJlbCh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiB8fCBpc1ZhcmlhbnRMYWJlbHModik7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50KHZpc3VhbEVsZW1lbnQyKSB7XG4gIHZhciBjdXJyZW50ID0ge307XG4gIHZpc3VhbEVsZW1lbnQyLmZvckVhY2hWYWx1ZShmdW5jdGlvbih2YWx1ZSwga2V5Nikge1xuICAgIHJldHVybiBjdXJyZW50W2tleTZdID0gdmFsdWUuZ2V0KCk7XG4gIH0pO1xuICByZXR1cm4gY3VycmVudDtcbn1cbmZ1bmN0aW9uIGdldFZlbG9jaXR5KHZpc3VhbEVsZW1lbnQyKSB7XG4gIHZhciB2ZWxvY2l0eSA9IHt9O1xuICB2aXN1YWxFbGVtZW50Mi5mb3JFYWNoVmFsdWUoZnVuY3Rpb24odmFsdWUsIGtleTYpIHtcbiAgICByZXR1cm4gdmVsb2NpdHlba2V5Nl0gPSB2YWx1ZS5nZXRWZWxvY2l0eSgpO1xuICB9KTtcbiAgcmV0dXJuIHZlbG9jaXR5O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHMocHJvcHMsIGRlZmluaXRpb24sIGN1c3RvbSwgY3VycmVudFZhbHVlcywgY3VycmVudFZlbG9jaXR5KSB7XG4gIHZhciBfYTtcbiAgaWYgKGN1cnJlbnRWYWx1ZXMgPT09IHZvaWQgMCkge1xuICAgIGN1cnJlbnRWYWx1ZXMgPSB7fTtcbiAgfVxuICBpZiAoY3VycmVudFZlbG9jaXR5ID09PSB2b2lkIDApIHtcbiAgICBjdXJyZW50VmVsb2NpdHkgPSB7fTtcbiAgfVxuICBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICBkZWZpbml0aW9uID0gKF9hID0gcHJvcHMudmFyaWFudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtkZWZpbml0aW9uXTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IGRlZmluaXRpb24oY3VzdG9tICE9PSBudWxsICYmIGN1c3RvbSAhPT0gdm9pZCAwID8gY3VzdG9tIDogcHJvcHMuY3VzdG9tLCBjdXJyZW50VmFsdWVzLCBjdXJyZW50VmVsb2NpdHkpIDogZGVmaW5pdGlvbjtcbn1cbmZ1bmN0aW9uIHJlc29sdmVWYXJpYW50KHZpc3VhbEVsZW1lbnQyLCBkZWZpbml0aW9uLCBjdXN0b20pIHtcbiAgdmFyIHByb3BzID0gdmlzdWFsRWxlbWVudDIuZ2V0UHJvcHMoKTtcbiAgcmV0dXJuIHJlc29sdmVWYXJpYW50RnJvbVByb3BzKHByb3BzLCBkZWZpbml0aW9uLCBjdXN0b20gIT09IG51bGwgJiYgY3VzdG9tICE9PSB2b2lkIDAgPyBjdXN0b20gOiBwcm9wcy5jdXN0b20sIGdldEN1cnJlbnQodmlzdWFsRWxlbWVudDIpLCBnZXRWZWxvY2l0eSh2aXN1YWxFbGVtZW50MikpO1xufVxuZnVuY3Rpb24gY2hlY2tJZkNvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gdHlwZW9mICgoX2EgPSBwcm9wcy5hbmltYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnQpID09PSBcImZ1bmN0aW9uXCIgfHwgaXNWYXJpYW50TGFiZWwocHJvcHMuaW5pdGlhbCkgfHwgaXNWYXJpYW50TGFiZWwocHJvcHMuYW5pbWF0ZSkgfHwgaXNWYXJpYW50TGFiZWwocHJvcHMud2hpbGVIb3ZlcikgfHwgaXNWYXJpYW50TGFiZWwocHJvcHMud2hpbGVEcmFnKSB8fCBpc1ZhcmlhbnRMYWJlbChwcm9wcy53aGlsZVRhcCkgfHwgaXNWYXJpYW50TGFiZWwocHJvcHMud2hpbGVGb2N1cykgfHwgaXNWYXJpYW50TGFiZWwocHJvcHMuZXhpdCk7XG59XG5mdW5jdGlvbiBjaGVja0lmVmFyaWFudE5vZGUocHJvcHMpIHtcbiAgcmV0dXJuIEJvb2xlYW4oY2hlY2tJZkNvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpIHx8IHByb3BzLnZhcmlhbnRzKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L01vdGlvbkNvbnRleHQvdXRpbHMuanNcbmZ1bmN0aW9uIGdldEN1cnJlbnRUcmVlVmFyaWFudHMocHJvcHMsIGNvbnRleHQpIHtcbiAgaWYgKGNoZWNrSWZDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKSkge1xuICAgIHZhciBpbml0aWFsID0gcHJvcHMuaW5pdGlhbCwgYW5pbWF0ZTQgPSBwcm9wcy5hbmltYXRlO1xuICAgIHJldHVybiB7XG4gICAgICBpbml0aWFsOiBpbml0aWFsID09PSBmYWxzZSB8fCBpc1ZhcmlhbnRMYWJlbChpbml0aWFsKSA/IGluaXRpYWwgOiB2b2lkIDAsXG4gICAgICBhbmltYXRlOiBpc1ZhcmlhbnRMYWJlbChhbmltYXRlNCkgPyBhbmltYXRlNCA6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHByb3BzLmluaGVyaXQgIT09IGZhbHNlID8gY29udGV4dCA6IHt9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvTW90aW9uQ29udGV4dC9jcmVhdGUuanNcbmZ1bmN0aW9uIHVzZUNyZWF0ZU1vdGlvbkNvbnRleHQocHJvcHMsIGlzU3RhdGljKSB7XG4gIHZhciBfYSA9IGdldEN1cnJlbnRUcmVlVmFyaWFudHMocHJvcHMsIHVzZUNvbnRleHQ1KE1vdGlvbkNvbnRleHQpKSwgaW5pdGlhbCA9IF9hLmluaXRpYWwsIGFuaW1hdGU0ID0gX2EuYW5pbWF0ZTtcbiAgcmV0dXJuIHVzZU1lbW8oZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHsgaW5pdGlhbCwgYW5pbWF0ZTogYW5pbWF0ZTQgfTtcbiAgfSwgaXNTdGF0aWMgPyBbXG4gICAgdmFyaWFudExhYmVsc0FzRGVwZW5kZW5jeShpbml0aWFsKSxcbiAgICB2YXJpYW50TGFiZWxzQXNEZXBlbmRlbmN5KGFuaW1hdGU0KVxuICBdIDogW10pO1xufVxuZnVuY3Rpb24gdmFyaWFudExhYmVsc0FzRGVwZW5kZW5jeShwcm9wKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHByb3ApID8gcHJvcC5qb2luKFwiIFwiKSA6IHByb3A7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2luZGV4LmpzXG5mdW5jdGlvbiBjcmVhdGVNb3Rpb25Db21wb25lbnQoX2EpIHtcbiAgdmFyIHByZWxvYWRlZEZlYXR1cmVzID0gX2EucHJlbG9hZGVkRmVhdHVyZXMsIGNyZWF0ZVZpc3VhbEVsZW1lbnQgPSBfYS5jcmVhdGVWaXN1YWxFbGVtZW50LCB1c2VSZW5kZXIgPSBfYS51c2VSZW5kZXIsIHVzZVZpc3VhbFN0YXRlMiA9IF9hLnVzZVZpc3VhbFN0YXRlLCBDb21wb25lbnQxOSA9IF9hLkNvbXBvbmVudDtcbiAgcHJlbG9hZGVkRmVhdHVyZXMgJiYgbG9hZEZlYXR1cmVzKHByZWxvYWRlZEZlYXR1cmVzKTtcbiAgZnVuY3Rpb24gTW90aW9uQ29tcG9uZW50KHByb3BzLCBleHRlcm5hbFJlZikge1xuICAgIHZhciBpc1N0YXRpYyA9IHVzZUNvbnRleHQ2KE1vdGlvbkNvbmZpZ0NvbnRleHQpLmlzU3RhdGljO1xuICAgIHZhciBmZWF0dXJlcyA9IG51bGw7XG4gICAgdmFyIGNvbnRleHQgPSB1c2VDcmVhdGVNb3Rpb25Db250ZXh0KHByb3BzLCBpc1N0YXRpYyk7XG4gICAgdmFyIHZpc3VhbFN0YXRlID0gdXNlVmlzdWFsU3RhdGUyKHByb3BzLCBpc1N0YXRpYyk7XG4gICAgaWYgKCFpc1N0YXRpYyAmJiBpc0Jyb3dzZXIpIHtcbiAgICAgIGNvbnRleHQudmlzdWFsRWxlbWVudCA9IHVzZVZpc3VhbEVsZW1lbnQoQ29tcG9uZW50MTksIHZpc3VhbFN0YXRlLCBwcm9wcywgY3JlYXRlVmlzdWFsRWxlbWVudCk7XG4gICAgICBmZWF0dXJlcyA9IHVzZUZlYXR1cmVzKHByb3BzLCBjb250ZXh0LnZpc3VhbEVsZW1lbnQsIHByZWxvYWRlZEZlYXR1cmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQyKEZyYWdtZW50LCBudWxsLCBjcmVhdGVFbGVtZW50MihNb3Rpb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0IH0sIHVzZVJlbmRlcihDb21wb25lbnQxOSwgcHJvcHMsIHVzZU1vdGlvblJlZih2aXN1YWxTdGF0ZSwgY29udGV4dC52aXN1YWxFbGVtZW50LCBleHRlcm5hbFJlZiksIHZpc3VhbFN0YXRlLCBpc1N0YXRpYykpLCBmZWF0dXJlcyk7XG4gIH1cbiAgcmV0dXJuIGZvcndhcmRSZWYoTW90aW9uQ29tcG9uZW50KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL21vdGlvbi1wcm94eS5qc1xuZnVuY3Rpb24gY3JlYXRlTW90aW9uUHJveHkoY3JlYXRlQ29uZmlnKSB7XG4gIGZ1bmN0aW9uIGN1c3RvbShDb21wb25lbnQxOSwgY3VzdG9tTW90aW9uQ29tcG9uZW50Q29uZmlnKSB7XG4gICAgaWYgKGN1c3RvbU1vdGlvbkNvbXBvbmVudENvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgICBjdXN0b21Nb3Rpb25Db21wb25lbnRDb25maWcgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZU1vdGlvbkNvbXBvbmVudChjcmVhdGVDb25maWcoQ29tcG9uZW50MTksIGN1c3RvbU1vdGlvbkNvbXBvbmVudENvbmZpZykpO1xuICB9XG4gIHZhciBjb21wb25lbnRDYWNoZSA9IG5ldyBNYXAoKTtcbiAgcmV0dXJuIG5ldyBQcm94eShjdXN0b20sIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKF90YXJnZXQsIGtleTYpIHtcbiAgICAgIGlmICghY29tcG9uZW50Q2FjaGUuaGFzKGtleTYpKSB7XG4gICAgICAgIGNvbXBvbmVudENhY2hlLnNldChrZXk2LCBjdXN0b20oa2V5NikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbXBvbmVudENhY2hlLmdldChrZXk2KTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvbG93ZXJjYXNlLWVsZW1lbnRzLmpzXG52YXIgbG93ZXJjYXNlU1ZHRWxlbWVudHMgPSBbXG4gIFwiYW5pbWF0ZVwiLFxuICBcImNpcmNsZVwiLFxuICBcImRlZnNcIixcbiAgXCJkZXNjXCIsXG4gIFwiZWxsaXBzZVwiLFxuICBcImdcIixcbiAgXCJpbWFnZVwiLFxuICBcImxpbmVcIixcbiAgXCJmaWx0ZXJcIixcbiAgXCJtYXJrZXJcIixcbiAgXCJtYXNrXCIsXG4gIFwibWV0YWRhdGFcIixcbiAgXCJwYXRoXCIsXG4gIFwicGF0dGVyblwiLFxuICBcInBvbHlnb25cIixcbiAgXCJwb2x5bGluZVwiLFxuICBcInJlY3RcIixcbiAgXCJzdG9wXCIsXG4gIFwic3ZnXCIsXG4gIFwic3dpdGNoXCIsXG4gIFwic3ltYm9sXCIsXG4gIFwidGV4dFwiLFxuICBcInRzcGFuXCIsXG4gIFwidXNlXCIsXG4gIFwidmlld1wiXG5dO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvaXMtc3ZnLWNvbXBvbmVudC5qc1xuZnVuY3Rpb24gaXNTVkdDb21wb25lbnQoQ29tcG9uZW50MTkpIHtcbiAgaWYgKHR5cGVvZiBDb21wb25lbnQxOSAhPT0gXCJzdHJpbmdcIiB8fCBDb21wb25lbnQxOS5pbmNsdWRlcyhcIi1cIikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAobG93ZXJjYXNlU1ZHRWxlbWVudHMuaW5kZXhPZihDb21wb25lbnQxOSkgPiAtMSB8fCAvW0EtWl0vLnRlc3QoQ29tcG9uZW50MTkpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXNlLXJlbmRlci5qc1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCBhcyBjcmVhdGVFbGVtZW50MyB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3VzZS1wcm9wcy5qc1xuaW1wb3J0IHsgdXNlTWVtbyBhcyB1c2VNZW1vMiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vcHJvamVjdGlvbi9zY2FsZS1jb3JyZWN0aW9uLmpzXG52YXIgdmFsdWVTY2FsZUNvcnJlY3Rpb24gPSB7fTtcbmZ1bmN0aW9uIGFkZFNjYWxlQ29ycmVjdGlvbihjb3JyZWN0b3JzKSB7XG4gIGZvciAodmFyIGtleTYgaW4gY29ycmVjdG9ycykge1xuICAgIHZhbHVlU2NhbGVDb3JyZWN0aW9uW2tleTZdID0gY29ycmVjdG9yc1trZXk2XTtcbiAgfVxufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3V0aWxzL3RyYW5zZm9ybS5qc1xudmFyIHRyYW5zZm9ybUF4ZXMgPSBbXCJcIiwgXCJYXCIsIFwiWVwiLCBcIlpcIl07XG52YXIgb3JkZXIgPSBbXCJ0cmFuc2xhdGVcIiwgXCJzY2FsZVwiLCBcInJvdGF0ZVwiLCBcInNrZXdcIl07XG52YXIgdHJhbnNmb3JtUHJvcHMgPSBbXCJ0cmFuc2Zvcm1QZXJzcGVjdGl2ZVwiLCBcInhcIiwgXCJ5XCIsIFwielwiXTtcbm9yZGVyLmZvckVhY2goZnVuY3Rpb24ob3BlcmF0aW9uS2V5KSB7XG4gIHJldHVybiB0cmFuc2Zvcm1BeGVzLmZvckVhY2goZnVuY3Rpb24oYXhlc0tleSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9wcy5wdXNoKG9wZXJhdGlvbktleSArIGF4ZXNLZXkpO1xuICB9KTtcbn0pO1xuZnVuY3Rpb24gc29ydFRyYW5zZm9ybVByb3BzKGEyLCBiMikge1xuICByZXR1cm4gdHJhbnNmb3JtUHJvcHMuaW5kZXhPZihhMikgLSB0cmFuc2Zvcm1Qcm9wcy5pbmRleE9mKGIyKTtcbn1cbnZhciB0cmFuc2Zvcm1Qcm9wU2V0ID0gbmV3IFNldCh0cmFuc2Zvcm1Qcm9wcyk7XG5mdW5jdGlvbiBpc1RyYW5zZm9ybVByb3Aoa2V5Nikge1xuICByZXR1cm4gdHJhbnNmb3JtUHJvcFNldC5oYXMoa2V5Nik7XG59XG52YXIgdHJhbnNmb3JtT3JpZ2luUHJvcHMgPSBuZXcgU2V0KFtcIm9yaWdpblhcIiwgXCJvcmlnaW5ZXCIsIFwib3JpZ2luWlwiXSk7XG5mdW5jdGlvbiBpc1RyYW5zZm9ybU9yaWdpblByb3Aoa2V5Nikge1xuICByZXR1cm4gdHJhbnNmb3JtT3JpZ2luUHJvcHMuaGFzKGtleTYpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy9pcy1mb3JjZWQtbW90aW9uLXZhbHVlLmpzXG5mdW5jdGlvbiBpc0ZvcmNlZE1vdGlvblZhbHVlKGtleTYsIF9hKSB7XG4gIHZhciBsYXlvdXQgPSBfYS5sYXlvdXQsIGxheW91dElkID0gX2EubGF5b3V0SWQ7XG4gIHJldHVybiBpc1RyYW5zZm9ybVByb3Aoa2V5NikgfHwgaXNUcmFuc2Zvcm1PcmlnaW5Qcm9wKGtleTYpIHx8IChsYXlvdXQgfHwgbGF5b3V0SWQgIT09IHZvaWQgMCkgJiYgKCEhdmFsdWVTY2FsZUNvcnJlY3Rpb25ba2V5Nl0gfHwga2V5NiA9PT0gXCJvcGFjaXR5XCIpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3V0aWxzL2lzLW1vdGlvbi12YWx1ZS5qc1xudmFyIGlzTW90aW9uVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlLmdldFZlbG9jaXR5O1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91dGlscy9idWlsZC10cmFuc2Zvcm0uanNcbnZhciB0cmFuc2xhdGVBbGlhcyA9IHtcbiAgeDogXCJ0cmFuc2xhdGVYXCIsXG4gIHk6IFwidHJhbnNsYXRlWVwiLFxuICB6OiBcInRyYW5zbGF0ZVpcIixcbiAgdHJhbnNmb3JtUGVyc3BlY3RpdmU6IFwicGVyc3BlY3RpdmVcIlxufTtcbmZ1bmN0aW9uIGJ1aWxkVHJhbnNmb3JtKF9hLCBfYiwgdHJhbnNmb3JtSXNEZWZhdWx0LCB0cmFuc2Zvcm1UZW1wbGF0ZTIpIHtcbiAgdmFyIHRyYW5zZm9ybTIgPSBfYS50cmFuc2Zvcm0sIHRyYW5zZm9ybUtleXMyID0gX2EudHJhbnNmb3JtS2V5cztcbiAgdmFyIF9jID0gX2IuZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb24sIGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYywgX2QgPSBfYi5hbGxvd1RyYW5zZm9ybU5vbmUsIGFsbG93VHJhbnNmb3JtTm9uZSA9IF9kID09PSB2b2lkIDAgPyB0cnVlIDogX2Q7XG4gIHZhciB0cmFuc2Zvcm1TdHJpbmcyID0gXCJcIjtcbiAgdHJhbnNmb3JtS2V5czIuc29ydChzb3J0VHJhbnNmb3JtUHJvcHMpO1xuICB2YXIgdHJhbnNmb3JtSGFzWiA9IGZhbHNlO1xuICB2YXIgbnVtVHJhbnNmb3JtS2V5cyA9IHRyYW5zZm9ybUtleXMyLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UcmFuc2Zvcm1LZXlzOyBpKyspIHtcbiAgICB2YXIga2V5NiA9IHRyYW5zZm9ybUtleXMyW2ldO1xuICAgIHRyYW5zZm9ybVN0cmluZzIgKz0gKHRyYW5zbGF0ZUFsaWFzW2tleTZdIHx8IGtleTYpICsgXCIoXCIgKyB0cmFuc2Zvcm0yW2tleTZdICsgXCIpIFwiO1xuICAgIGlmIChrZXk2ID09PSBcInpcIilcbiAgICAgIHRyYW5zZm9ybUhhc1ogPSB0cnVlO1xuICB9XG4gIGlmICghdHJhbnNmb3JtSGFzWiAmJiBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbikge1xuICAgIHRyYW5zZm9ybVN0cmluZzIgKz0gXCJ0cmFuc2xhdGVaKDApXCI7XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNmb3JtU3RyaW5nMiA9IHRyYW5zZm9ybVN0cmluZzIudHJpbSgpO1xuICB9XG4gIGlmICh0cmFuc2Zvcm1UZW1wbGF0ZTIpIHtcbiAgICB0cmFuc2Zvcm1TdHJpbmcyID0gdHJhbnNmb3JtVGVtcGxhdGUyKHRyYW5zZm9ybTIsIHRyYW5zZm9ybUlzRGVmYXVsdCA/IFwiXCIgOiB0cmFuc2Zvcm1TdHJpbmcyKTtcbiAgfSBlbHNlIGlmIChhbGxvd1RyYW5zZm9ybU5vbmUgJiYgdHJhbnNmb3JtSXNEZWZhdWx0KSB7XG4gICAgdHJhbnNmb3JtU3RyaW5nMiA9IFwibm9uZVwiO1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm1TdHJpbmcyO1xufVxuZnVuY3Rpb24gYnVpbGRUcmFuc2Zvcm1PcmlnaW4oX2EpIHtcbiAgdmFyIF9iID0gX2Eub3JpZ2luWCwgb3JpZ2luWCA9IF9iID09PSB2b2lkIDAgPyBcIjUwJVwiIDogX2IsIF9jID0gX2Eub3JpZ2luWSwgb3JpZ2luWSA9IF9jID09PSB2b2lkIDAgPyBcIjUwJVwiIDogX2MsIF9kID0gX2Eub3JpZ2luWiwgb3JpZ2luWiA9IF9kID09PSB2b2lkIDAgPyAwIDogX2Q7XG4gIHJldHVybiBvcmlnaW5YICsgXCIgXCIgKyBvcmlnaW5ZICsgXCIgXCIgKyBvcmlnaW5aO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvaXMtY3NzLXZhcmlhYmxlLmpzXG5mdW5jdGlvbiBpc0NTU1ZhcmlhYmxlKGtleTYpIHtcbiAgcmV0dXJuIGtleTYuc3RhcnRzV2l0aChcIi0tXCIpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvZ2V0LWFzLXR5cGUuanNcbnZhciBnZXRWYWx1ZUFzVHlwZSA9IGZ1bmN0aW9uKHZhbHVlLCB0eXBlKSB7XG4gIHJldHVybiB0eXBlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiA/IHR5cGUudHJhbnNmb3JtKHZhbHVlKSA6IHZhbHVlO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLXZhbHVlLXR5cGVzL2Rpc3QvZXMvdXRpbHMuanNcbnZhciBjbGFtcCA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHYsIG1heCksIG1pbik7XG4gIH07XG59O1xudmFyIHNhbml0aXplID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gdiAlIDEgPyBOdW1iZXIodi50b0ZpeGVkKDUpKSA6IHY7XG59O1xudmFyIGZsb2F0UmVnZXggPSAvKC0pPyhbXFxkXSpcXC4/W1xcZF0pKy9nO1xudmFyIGNvbG9yUmVnZXggPSAvKCNbMC05YS1mXXs2fXwjWzAtOWEtZl17M318Iyg/OlswLTlhLWZdezJ9KXsyLDR9fChyZ2J8aHNsKWE/XFwoKC0/W1xcZFxcLl0rJT9bLFxcc10rKXsyLDN9XFxzKlxcLypcXHMqW1xcZFxcLl0rJT9cXCkpL2dpO1xudmFyIHNpbmdsZUNvbG9yUmVnZXggPSAvXigjWzAtOWEtZl17M318Iyg/OlswLTlhLWZdezJ9KXsyLDR9fChyZ2J8aHNsKWE/XFwoKC0/W1xcZFxcLl0rJT9bLFxcc10rKXsyLDN9XFxzKlxcLypcXHMqW1xcZFxcLl0rJT9cXCkpJC9pO1xuZnVuY3Rpb24gaXNTdHJpbmcodikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCI7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS12YWx1ZS10eXBlcy9kaXN0L2VzL251bWJlcnMvaW5kZXguanNcbnZhciBudW1iZXIgPSB7XG4gIHRlc3Q6IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCI7XG4gIH0sXG4gIHBhcnNlOiBwYXJzZUZsb2F0LFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxufTtcbnZhciBhbHBoYSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBudW1iZXIpLCB7IHRyYW5zZm9ybTogY2xhbXAoMCwgMSkgfSk7XG52YXIgc2NhbGUgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbnVtYmVyKSwgeyBkZWZhdWx0OiAxIH0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9udW1iZXJzL3VuaXRzLmpzXG52YXIgY3JlYXRlVW5pdFR5cGUgPSBmdW5jdGlvbih1bml0KSB7XG4gIHJldHVybiB7XG4gICAgdGVzdDogZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIGlzU3RyaW5nKHYpICYmIHYuZW5kc1dpdGgodW5pdCkgJiYgdi5zcGxpdChcIiBcIikubGVuZ3RoID09PSAxO1xuICAgIH0sXG4gICAgcGFyc2U6IHBhcnNlRmxvYXQsXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gXCJcIiArIHYgKyB1bml0O1xuICAgIH1cbiAgfTtcbn07XG52YXIgZGVncmVlcyA9IGNyZWF0ZVVuaXRUeXBlKFwiZGVnXCIpO1xudmFyIHBlcmNlbnQgPSBjcmVhdGVVbml0VHlwZShcIiVcIik7XG52YXIgcHggPSBjcmVhdGVVbml0VHlwZShcInB4XCIpO1xudmFyIHZoID0gY3JlYXRlVW5pdFR5cGUoXCJ2aFwiKTtcbnZhciB2dyA9IGNyZWF0ZVVuaXRUeXBlKFwidndcIik7XG52YXIgcHJvZ3Jlc3NQZXJjZW50YWdlID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHBlcmNlbnQpLCB7IHBhcnNlOiBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBwZXJjZW50LnBhcnNlKHYpIC8gMTAwO1xufSwgdHJhbnNmb3JtOiBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBwZXJjZW50LnRyYW5zZm9ybSh2ICogMTAwKTtcbn0gfSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS12YWx1ZS10eXBlcy9kaXN0L2VzL2NvbG9yL3V0aWxzLmpzXG52YXIgaXNDb2xvclN0cmluZyA9IGZ1bmN0aW9uKHR5cGUsIHRlc3RQcm9wKSB7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oaXNTdHJpbmcodikgJiYgc2luZ2xlQ29sb3JSZWdleC50ZXN0KHYpICYmIHYuc3RhcnRzV2l0aCh0eXBlKSB8fCB0ZXN0UHJvcCAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodiwgdGVzdFByb3ApKTtcbiAgfTtcbn07XG52YXIgc3BsaXRDb2xvciA9IGZ1bmN0aW9uKGFOYW1lLCBiTmFtZSwgY05hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFpc1N0cmluZyh2KSlcbiAgICAgIHJldHVybiB2O1xuICAgIHZhciBfYiA9IHYubWF0Y2goZmxvYXRSZWdleCksIGEyID0gX2JbMF0sIGIyID0gX2JbMV0sIGMyID0gX2JbMl0sIGFscGhhMiA9IF9iWzNdO1xuICAgIHJldHVybiBfYSA9IHt9LCBfYVthTmFtZV0gPSBwYXJzZUZsb2F0KGEyKSwgX2FbYk5hbWVdID0gcGFyc2VGbG9hdChiMiksIF9hW2NOYW1lXSA9IHBhcnNlRmxvYXQoYzIpLCBfYS5hbHBoYSA9IGFscGhhMiAhPT0gdm9pZCAwID8gcGFyc2VGbG9hdChhbHBoYTIpIDogMSwgX2E7XG4gIH07XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb2xvci9oc2xhLmpzXG52YXIgaHNsYSA9IHtcbiAgdGVzdDogaXNDb2xvclN0cmluZyhcImhzbFwiLCBcImh1ZVwiKSxcbiAgcGFyc2U6IHNwbGl0Q29sb3IoXCJodWVcIiwgXCJzYXR1cmF0aW9uXCIsIFwibGlnaHRuZXNzXCIpLFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uKF9hKSB7XG4gICAgdmFyIGh1ZSA9IF9hLmh1ZSwgc2F0dXJhdGlvbiA9IF9hLnNhdHVyYXRpb24sIGxpZ2h0bmVzcyA9IF9hLmxpZ2h0bmVzcywgX2IgPSBfYS5hbHBoYSwgYWxwaGEkMSA9IF9iID09PSB2b2lkIDAgPyAxIDogX2I7XG4gICAgcmV0dXJuIFwiaHNsYShcIiArIE1hdGgucm91bmQoaHVlKSArIFwiLCBcIiArIHBlcmNlbnQudHJhbnNmb3JtKHNhbml0aXplKHNhdHVyYXRpb24pKSArIFwiLCBcIiArIHBlcmNlbnQudHJhbnNmb3JtKHNhbml0aXplKGxpZ2h0bmVzcykpICsgXCIsIFwiICsgc2FuaXRpemUoYWxwaGEudHJhbnNmb3JtKGFscGhhJDEpKSArIFwiKVwiO1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb2xvci9yZ2JhLmpzXG52YXIgY2xhbXBSZ2JVbml0ID0gY2xhbXAoMCwgMjU1KTtcbnZhciByZ2JVbml0ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG51bWJlciksIHsgdHJhbnNmb3JtOiBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKGNsYW1wUmdiVW5pdCh2KSk7XG59IH0pO1xudmFyIHJnYmEgPSB7XG4gIHRlc3Q6IGlzQ29sb3JTdHJpbmcoXCJyZ2JcIiwgXCJyZWRcIiksXG4gIHBhcnNlOiBzcGxpdENvbG9yKFwicmVkXCIsIFwiZ3JlZW5cIiwgXCJibHVlXCIpLFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uKF9hKSB7XG4gICAgdmFyIHJlZCA9IF9hLnJlZCwgZ3JlZW4gPSBfYS5ncmVlbiwgYmx1ZSA9IF9hLmJsdWUsIF9iID0gX2EuYWxwaGEsIGFscGhhJDEgPSBfYiA9PT0gdm9pZCAwID8gMSA6IF9iO1xuICAgIHJldHVybiBcInJnYmEoXCIgKyByZ2JVbml0LnRyYW5zZm9ybShyZWQpICsgXCIsIFwiICsgcmdiVW5pdC50cmFuc2Zvcm0oZ3JlZW4pICsgXCIsIFwiICsgcmdiVW5pdC50cmFuc2Zvcm0oYmx1ZSkgKyBcIiwgXCIgKyBzYW5pdGl6ZShhbHBoYS50cmFuc2Zvcm0oYWxwaGEkMSkpICsgXCIpXCI7XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS12YWx1ZS10eXBlcy9kaXN0L2VzL2NvbG9yL2hleC5qc1xuZnVuY3Rpb24gcGFyc2VIZXgodikge1xuICB2YXIgciA9IFwiXCI7XG4gIHZhciBnID0gXCJcIjtcbiAgdmFyIGIyID0gXCJcIjtcbiAgdmFyIGEyID0gXCJcIjtcbiAgaWYgKHYubGVuZ3RoID4gNSkge1xuICAgIHIgPSB2LnN1YnN0cigxLCAyKTtcbiAgICBnID0gdi5zdWJzdHIoMywgMik7XG4gICAgYjIgPSB2LnN1YnN0cig1LCAyKTtcbiAgICBhMiA9IHYuc3Vic3RyKDcsIDIpO1xuICB9IGVsc2Uge1xuICAgIHIgPSB2LnN1YnN0cigxLCAxKTtcbiAgICBnID0gdi5zdWJzdHIoMiwgMSk7XG4gICAgYjIgPSB2LnN1YnN0cigzLCAxKTtcbiAgICBhMiA9IHYuc3Vic3RyKDQsIDEpO1xuICAgIHIgKz0gcjtcbiAgICBnICs9IGc7XG4gICAgYjIgKz0gYjI7XG4gICAgYTIgKz0gYTI7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZWQ6IHBhcnNlSW50KHIsIDE2KSxcbiAgICBncmVlbjogcGFyc2VJbnQoZywgMTYpLFxuICAgIGJsdWU6IHBhcnNlSW50KGIyLCAxNiksXG4gICAgYWxwaGE6IGEyID8gcGFyc2VJbnQoYTIsIDE2KSAvIDI1NSA6IDFcbiAgfTtcbn1cbnZhciBoZXggPSB7XG4gIHRlc3Q6IGlzQ29sb3JTdHJpbmcoXCIjXCIpLFxuICBwYXJzZTogcGFyc2VIZXgsXG4gIHRyYW5zZm9ybTogcmdiYS50cmFuc2Zvcm1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS12YWx1ZS10eXBlcy9kaXN0L2VzL2NvbG9yL2luZGV4LmpzXG52YXIgY29sb3IgPSB7XG4gIHRlc3Q6IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gcmdiYS50ZXN0KHYpIHx8IGhleC50ZXN0KHYpIHx8IGhzbGEudGVzdCh2KTtcbiAgfSxcbiAgcGFyc2U6IGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAocmdiYS50ZXN0KHYpKSB7XG4gICAgICByZXR1cm4gcmdiYS5wYXJzZSh2KTtcbiAgICB9IGVsc2UgaWYgKGhzbGEudGVzdCh2KSkge1xuICAgICAgcmV0dXJuIGhzbGEucGFyc2Uodik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBoZXgucGFyc2Uodik7XG4gICAgfVxuICB9LFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gaXNTdHJpbmcodikgPyB2IDogdi5oYXNPd25Qcm9wZXJ0eShcInJlZFwiKSA/IHJnYmEudHJhbnNmb3JtKHYpIDogaHNsYS50cmFuc2Zvcm0odik7XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS12YWx1ZS10eXBlcy9kaXN0L2VzL2NvbXBsZXgvaW5kZXguanNcbnZhciBjb2xvclRva2VuID0gXCIke2N9XCI7XG52YXIgbnVtYmVyVG9rZW4gPSBcIiR7bn1cIjtcbmZ1bmN0aW9uIHRlc3Qodikge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIHJldHVybiBpc05hTih2KSAmJiBpc1N0cmluZyh2KSAmJiAoKF9iID0gKF9hID0gdi5tYXRjaChmbG9hdFJlZ2V4KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCkgKyAoKF9kID0gKF9jID0gdi5tYXRjaChjb2xvclJlZ2V4KSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxlbmd0aCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMCkgPiAwO1xufVxuZnVuY3Rpb24gYW5hbHlzZSh2KSB7XG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIG51bUNvbG9ycyA9IDA7XG4gIHZhciBjb2xvcnMgPSB2Lm1hdGNoKGNvbG9yUmVnZXgpO1xuICBpZiAoY29sb3JzKSB7XG4gICAgbnVtQ29sb3JzID0gY29sb3JzLmxlbmd0aDtcbiAgICB2ID0gdi5yZXBsYWNlKGNvbG9yUmVnZXgsIGNvbG9yVG9rZW4pO1xuICAgIHZhbHVlcy5wdXNoLmFwcGx5KHZhbHVlcywgY29sb3JzLm1hcChjb2xvci5wYXJzZSkpO1xuICB9XG4gIHZhciBudW1iZXJzID0gdi5tYXRjaChmbG9hdFJlZ2V4KTtcbiAgaWYgKG51bWJlcnMpIHtcbiAgICB2ID0gdi5yZXBsYWNlKGZsb2F0UmVnZXgsIG51bWJlclRva2VuKTtcbiAgICB2YWx1ZXMucHVzaC5hcHBseSh2YWx1ZXMsIG51bWJlcnMubWFwKG51bWJlci5wYXJzZSkpO1xuICB9XG4gIHJldHVybiB7IHZhbHVlcywgbnVtQ29sb3JzLCB0b2tlbmlzZWQ6IHYgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlKHYpIHtcbiAgcmV0dXJuIGFuYWx5c2UodikudmFsdWVzO1xufVxuZnVuY3Rpb24gY3JlYXRlVHJhbnNmb3JtZXIodikge1xuICB2YXIgX2EgPSBhbmFseXNlKHYpLCB2YWx1ZXMgPSBfYS52YWx1ZXMsIG51bUNvbG9ycyA9IF9hLm51bUNvbG9ycywgdG9rZW5pc2VkID0gX2EudG9rZW5pc2VkO1xuICB2YXIgbnVtVmFsdWVzID0gdmFsdWVzLmxlbmd0aDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHYyKSB7XG4gICAgdmFyIG91dHB1dCA9IHRva2VuaXNlZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVZhbHVlczsgaSsrKSB7XG4gICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZShpIDwgbnVtQ29sb3JzID8gY29sb3JUb2tlbiA6IG51bWJlclRva2VuLCBpIDwgbnVtQ29sb3JzID8gY29sb3IudHJhbnNmb3JtKHYyW2ldKSA6IHNhbml0aXplKHYyW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59XG52YXIgY29udmVydE51bWJlcnNUb1plcm8gPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIiA/IDAgOiB2O1xufTtcbmZ1bmN0aW9uIGdldEFuaW1hdGFibGVOb25lKHYpIHtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlKHYpO1xuICB2YXIgdHJhbnNmb3JtZXIgPSBjcmVhdGVUcmFuc2Zvcm1lcih2KTtcbiAgcmV0dXJuIHRyYW5zZm9ybWVyKHBhcnNlZC5tYXAoY29udmVydE51bWJlcnNUb1plcm8pKTtcbn1cbnZhciBjb21wbGV4ID0geyB0ZXN0LCBwYXJzZSwgY3JlYXRlVHJhbnNmb3JtZXIsIGdldEFuaW1hdGFibGVOb25lIH07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS12YWx1ZS10eXBlcy9kaXN0L2VzL2NvbXBsZXgvZmlsdGVyLmpzXG52YXIgbWF4RGVmYXVsdHMgPSBuZXcgU2V0KFtcImJyaWdodG5lc3NcIiwgXCJjb250cmFzdFwiLCBcInNhdHVyYXRlXCIsIFwib3BhY2l0eVwiXSk7XG5mdW5jdGlvbiBhcHBseURlZmF1bHRGaWx0ZXIodikge1xuICB2YXIgX2EgPSB2LnNsaWNlKDAsIC0xKS5zcGxpdChcIihcIiksIG5hbWUgPSBfYVswXSwgdmFsdWUgPSBfYVsxXTtcbiAgaWYgKG5hbWUgPT09IFwiZHJvcC1zaGFkb3dcIilcbiAgICByZXR1cm4gdjtcbiAgdmFyIG51bWJlcjIgPSAodmFsdWUubWF0Y2goZmxvYXRSZWdleCkgfHwgW10pWzBdO1xuICBpZiAoIW51bWJlcjIpXG4gICAgcmV0dXJuIHY7XG4gIHZhciB1bml0ID0gdmFsdWUucmVwbGFjZShudW1iZXIyLCBcIlwiKTtcbiAgdmFyIGRlZmF1bHRWYWx1ZSA9IG1heERlZmF1bHRzLmhhcyhuYW1lKSA/IDEgOiAwO1xuICBpZiAobnVtYmVyMiAhPT0gdmFsdWUpXG4gICAgZGVmYXVsdFZhbHVlICo9IDEwMDtcbiAgcmV0dXJuIG5hbWUgKyBcIihcIiArIGRlZmF1bHRWYWx1ZSArIHVuaXQgKyBcIilcIjtcbn1cbnZhciBmdW5jdGlvblJlZ2V4ID0gLyhbYS16LV0qKVxcKC4qP1xcKS9nO1xudmFyIGZpbHRlciA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBjb21wbGV4KSwgeyBnZXRBbmltYXRhYmxlTm9uZTogZnVuY3Rpb24odikge1xuICB2YXIgZnVuY3Rpb25zID0gdi5tYXRjaChmdW5jdGlvblJlZ2V4KTtcbiAgcmV0dXJuIGZ1bmN0aW9ucyA/IGZ1bmN0aW9ucy5tYXAoYXBwbHlEZWZhdWx0RmlsdGVyKS5qb2luKFwiIFwiKSA6IHY7XG59IH0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvdHlwZS1pbnQuanNcbnZhciBpbnQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbnVtYmVyKSwgeyB0cmFuc2Zvcm06IE1hdGgucm91bmQgfSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9udW1iZXIuanNcbnZhciBudW1iZXJWYWx1ZVR5cGVzID0ge1xuICBib3JkZXJXaWR0aDogcHgsXG4gIGJvcmRlclRvcFdpZHRoOiBweCxcbiAgYm9yZGVyUmlnaHRXaWR0aDogcHgsXG4gIGJvcmRlckJvdHRvbVdpZHRoOiBweCxcbiAgYm9yZGVyTGVmdFdpZHRoOiBweCxcbiAgYm9yZGVyUmFkaXVzOiBweCxcbiAgcmFkaXVzOiBweCxcbiAgYm9yZGVyVG9wTGVmdFJhZGl1czogcHgsXG4gIGJvcmRlclRvcFJpZ2h0UmFkaXVzOiBweCxcbiAgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6IHB4LFxuICBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiBweCxcbiAgd2lkdGg6IHB4LFxuICBtYXhXaWR0aDogcHgsXG4gIGhlaWdodDogcHgsXG4gIG1heEhlaWdodDogcHgsXG4gIHNpemU6IHB4LFxuICB0b3A6IHB4LFxuICByaWdodDogcHgsXG4gIGJvdHRvbTogcHgsXG4gIGxlZnQ6IHB4LFxuICBwYWRkaW5nOiBweCxcbiAgcGFkZGluZ1RvcDogcHgsXG4gIHBhZGRpbmdSaWdodDogcHgsXG4gIHBhZGRpbmdCb3R0b206IHB4LFxuICBwYWRkaW5nTGVmdDogcHgsXG4gIG1hcmdpbjogcHgsXG4gIG1hcmdpblRvcDogcHgsXG4gIG1hcmdpblJpZ2h0OiBweCxcbiAgbWFyZ2luQm90dG9tOiBweCxcbiAgbWFyZ2luTGVmdDogcHgsXG4gIHJvdGF0ZTogZGVncmVlcyxcbiAgcm90YXRlWDogZGVncmVlcyxcbiAgcm90YXRlWTogZGVncmVlcyxcbiAgcm90YXRlWjogZGVncmVlcyxcbiAgc2NhbGUsXG4gIHNjYWxlWDogc2NhbGUsXG4gIHNjYWxlWTogc2NhbGUsXG4gIHNjYWxlWjogc2NhbGUsXG4gIHNrZXc6IGRlZ3JlZXMsXG4gIHNrZXdYOiBkZWdyZWVzLFxuICBza2V3WTogZGVncmVlcyxcbiAgZGlzdGFuY2U6IHB4LFxuICB0cmFuc2xhdGVYOiBweCxcbiAgdHJhbnNsYXRlWTogcHgsXG4gIHRyYW5zbGF0ZVo6IHB4LFxuICB4OiBweCxcbiAgeTogcHgsXG4gIHo6IHB4LFxuICBwZXJzcGVjdGl2ZTogcHgsXG4gIHRyYW5zZm9ybVBlcnNwZWN0aXZlOiBweCxcbiAgb3BhY2l0eTogX19hc3NpZ24oX19hc3NpZ24oe30sIGFscGhhKSwgeyBkZWZhdWx0OiAxIH0pLFxuICBvcmlnaW5YOiBwcm9ncmVzc1BlcmNlbnRhZ2UsXG4gIG9yaWdpblk6IHByb2dyZXNzUGVyY2VudGFnZSxcbiAgb3JpZ2luWjogcHgsXG4gIHpJbmRleDogaW50LFxuICBmaWxsT3BhY2l0eTogYWxwaGEsXG4gIHN0cm9rZU9wYWNpdHk6IGFscGhhLFxuICBudW1PY3RhdmVzOiBpbnRcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvYnVpbGQtc3R5bGVzLmpzXG5mdW5jdGlvbiBidWlsZEhUTUxTdHlsZXMoc3RhdGUsIGxhdGVzdFZhbHVlcywgcHJvamVjdGlvbiwgbGF5b3V0U3RhdGUsIG9wdGlvbnMsIHRyYW5zZm9ybVRlbXBsYXRlMiwgYnVpbGRQcm9qZWN0aW9uVHJhbnNmb3JtLCBidWlsZFByb2plY3Rpb25UcmFuc2Zvcm1PcmlnaW4pIHtcbiAgdmFyIF9hO1xuICB2YXIgc3R5bGUgPSBzdGF0ZS5zdHlsZSwgdmFycyA9IHN0YXRlLnZhcnMsIHRyYW5zZm9ybTIgPSBzdGF0ZS50cmFuc2Zvcm0sIHRyYW5zZm9ybUtleXMyID0gc3RhdGUudHJhbnNmb3JtS2V5cywgdHJhbnNmb3JtT3JpZ2luID0gc3RhdGUudHJhbnNmb3JtT3JpZ2luO1xuICB0cmFuc2Zvcm1LZXlzMi5sZW5ndGggPSAwO1xuICB2YXIgaGFzVHJhbnNmb3JtID0gZmFsc2U7XG4gIHZhciBoYXNUcmFuc2Zvcm1PcmlnaW4gPSBmYWxzZTtcbiAgdmFyIHRyYW5zZm9ybUlzTm9uZSA9IHRydWU7XG4gIGZvciAodmFyIGtleTYgaW4gbGF0ZXN0VmFsdWVzKSB7XG4gICAgdmFyIHZhbHVlID0gbGF0ZXN0VmFsdWVzW2tleTZdO1xuICAgIGlmIChpc0NTU1ZhcmlhYmxlKGtleTYpKSB7XG4gICAgICB2YXJzW2tleTZdID0gdmFsdWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHZhbHVlVHlwZSA9IG51bWJlclZhbHVlVHlwZXNba2V5Nl07XG4gICAgdmFyIHZhbHVlQXNUeXBlID0gZ2V0VmFsdWVBc1R5cGUodmFsdWUsIHZhbHVlVHlwZSk7XG4gICAgaWYgKGlzVHJhbnNmb3JtUHJvcChrZXk2KSkge1xuICAgICAgaGFzVHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgIHRyYW5zZm9ybTJba2V5Nl0gPSB2YWx1ZUFzVHlwZTtcbiAgICAgIHRyYW5zZm9ybUtleXMyLnB1c2goa2V5Nik7XG4gICAgICBpZiAoIXRyYW5zZm9ybUlzTm9uZSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAodmFsdWUgIT09ICgoX2EgPSB2YWx1ZVR5cGUuZGVmYXVsdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkpXG4gICAgICAgIHRyYW5zZm9ybUlzTm9uZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaXNUcmFuc2Zvcm1PcmlnaW5Qcm9wKGtleTYpKSB7XG4gICAgICB0cmFuc2Zvcm1PcmlnaW5ba2V5Nl0gPSB2YWx1ZUFzVHlwZTtcbiAgICAgIGhhc1RyYW5zZm9ybU9yaWdpbiA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsYXlvdXRTdGF0ZSAmJiBwcm9qZWN0aW9uICYmIGxheW91dFN0YXRlLmlzSHlkcmF0ZWQgJiYgdmFsdWVTY2FsZUNvcnJlY3Rpb25ba2V5Nl0pIHtcbiAgICAgICAgdmFyIGNvcnJlY3RlZFZhbHVlID0gdmFsdWVTY2FsZUNvcnJlY3Rpb25ba2V5Nl0ucHJvY2Vzcyh2YWx1ZSwgbGF5b3V0U3RhdGUsIHByb2plY3Rpb24pO1xuICAgICAgICB2YXIgYXBwbHlUbyA9IHZhbHVlU2NhbGVDb3JyZWN0aW9uW2tleTZdLmFwcGx5VG87XG4gICAgICAgIGlmIChhcHBseVRvKSB7XG4gICAgICAgICAgdmFyIG51bSA9IGFwcGx5VG8ubGVuZ3RoO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICAgICAgICAgIHN0eWxlW2FwcGx5VG9baV1dID0gY29ycmVjdGVkVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlW2tleTZdID0gY29ycmVjdGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlW2tleTZdID0gdmFsdWVBc1R5cGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChsYXlvdXRTdGF0ZSAmJiBwcm9qZWN0aW9uICYmIGJ1aWxkUHJvamVjdGlvblRyYW5zZm9ybSAmJiBidWlsZFByb2plY3Rpb25UcmFuc2Zvcm1PcmlnaW4pIHtcbiAgICBzdHlsZS50cmFuc2Zvcm0gPSBidWlsZFByb2plY3Rpb25UcmFuc2Zvcm0obGF5b3V0U3RhdGUuZGVsdGFGaW5hbCwgbGF5b3V0U3RhdGUudHJlZVNjYWxlLCBoYXNUcmFuc2Zvcm0gPyB0cmFuc2Zvcm0yIDogdm9pZCAwKTtcbiAgICBpZiAodHJhbnNmb3JtVGVtcGxhdGUyKSB7XG4gICAgICBzdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZW1wbGF0ZTIodHJhbnNmb3JtMiwgc3R5bGUudHJhbnNmb3JtKTtcbiAgICB9XG4gICAgc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gYnVpbGRQcm9qZWN0aW9uVHJhbnNmb3JtT3JpZ2luKGxheW91dFN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaGFzVHJhbnNmb3JtKSB7XG4gICAgICBzdHlsZS50cmFuc2Zvcm0gPSBidWlsZFRyYW5zZm9ybShzdGF0ZSwgb3B0aW9ucywgdHJhbnNmb3JtSXNOb25lLCB0cmFuc2Zvcm1UZW1wbGF0ZTIpO1xuICAgIH1cbiAgICBpZiAoaGFzVHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgICBzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBidWlsZFRyYW5zZm9ybU9yaWdpbih0cmFuc2Zvcm1PcmlnaW4pO1xuICAgIH1cbiAgfVxufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3V0aWxzL2NyZWF0ZS1yZW5kZXItc3RhdGUuanNcbnZhciBjcmVhdGVIdG1sUmVuZGVyU3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBzdHlsZToge30sXG4gICAgdHJhbnNmb3JtOiB7fSxcbiAgICB0cmFuc2Zvcm1LZXlzOiBbXSxcbiAgICB0cmFuc2Zvcm1PcmlnaW46IHt9LFxuICAgIHZhcnM6IHt9XG4gIH07XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3VzZS1wcm9wcy5qc1xuZnVuY3Rpb24gY29weVJhd1ZhbHVlc09ubHkodGFyZ2V0LCBzb3VyY2UsIHByb3BzKSB7XG4gIGZvciAodmFyIGtleTYgaW4gc291cmNlKSB7XG4gICAgaWYgKCFpc01vdGlvblZhbHVlKHNvdXJjZVtrZXk2XSkgJiYgIWlzRm9yY2VkTW90aW9uVmFsdWUoa2V5NiwgcHJvcHMpKSB7XG4gICAgICB0YXJnZXRba2V5Nl0gPSBzb3VyY2Vba2V5Nl07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1c2VJbml0aWFsTW90aW9uVmFsdWVzKF9hLCB2aXN1YWxTdGF0ZSwgaXNTdGF0aWMpIHtcbiAgdmFyIHRyYW5zZm9ybVRlbXBsYXRlMiA9IF9hLnRyYW5zZm9ybVRlbXBsYXRlO1xuICByZXR1cm4gdXNlTWVtbzIoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gY3JlYXRlSHRtbFJlbmRlclN0YXRlKCk7XG4gICAgYnVpbGRIVE1MU3R5bGVzKHN0YXRlLCB2aXN1YWxTdGF0ZSwgdm9pZCAwLCB2b2lkIDAsIHsgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb246ICFpc1N0YXRpYyB9LCB0cmFuc2Zvcm1UZW1wbGF0ZTIpO1xuICAgIHZhciB2YXJzID0gc3RhdGUudmFycywgc3R5bGUgPSBzdGF0ZS5zdHlsZTtcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHZhcnMpLCBzdHlsZSk7XG4gIH0sIFt2aXN1YWxTdGF0ZV0pO1xufVxuZnVuY3Rpb24gdXNlU3R5bGUocHJvcHMsIHZpc3VhbFN0YXRlLCBpc1N0YXRpYykge1xuICB2YXIgc3R5bGVQcm9wID0gcHJvcHMuc3R5bGUgfHwge307XG4gIHZhciBzdHlsZSA9IHt9O1xuICBjb3B5UmF3VmFsdWVzT25seShzdHlsZSwgc3R5bGVQcm9wLCBwcm9wcyk7XG4gIE9iamVjdC5hc3NpZ24oc3R5bGUsIHVzZUluaXRpYWxNb3Rpb25WYWx1ZXMocHJvcHMsIHZpc3VhbFN0YXRlLCBpc1N0YXRpYykpO1xuICBpZiAocHJvcHMudHJhbnNmb3JtVmFsdWVzKSB7XG4gICAgc3R5bGUgPSBwcm9wcy50cmFuc2Zvcm1WYWx1ZXMoc3R5bGUpO1xuICB9XG4gIHJldHVybiBzdHlsZTtcbn1cbmZ1bmN0aW9uIHVzZUhUTUxQcm9wcyhwcm9wcywgdmlzdWFsU3RhdGUsIGlzU3RhdGljKSB7XG4gIHZhciBodG1sUHJvcHMgPSB7fTtcbiAgdmFyIHN0eWxlID0gdXNlU3R5bGUocHJvcHMsIHZpc3VhbFN0YXRlLCBpc1N0YXRpYyk7XG4gIGlmIChCb29sZWFuKHByb3BzLmRyYWcpKSB7XG4gICAgaHRtbFByb3BzLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgIHN0eWxlLnVzZXJTZWxlY3QgPSBzdHlsZS5XZWJraXRVc2VyU2VsZWN0ID0gc3R5bGUuV2Via2l0VG91Y2hDYWxsb3V0ID0gXCJub25lXCI7XG4gICAgc3R5bGUudG91Y2hBY3Rpb24gPSBwcm9wcy5kcmFnID09PSB0cnVlID8gXCJub25lXCIgOiBcInBhbi1cIiArIChwcm9wcy5kcmFnID09PSBcInhcIiA/IFwieVwiIDogXCJ4XCIpO1xuICB9XG4gIGh0bWxQcm9wcy5zdHlsZSA9IHN0eWxlO1xuICByZXR1cm4gaHRtbFByb3BzO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy92YWxpZC1wcm9wLmpzXG52YXIgdmFsaWRNb3Rpb25Qcm9wcyA9IG5ldyBTZXQoW1xuICBcImluaXRpYWxcIixcbiAgXCJhbmltYXRlXCIsXG4gIFwiZXhpdFwiLFxuICBcInN0eWxlXCIsXG4gIFwidmFyaWFudHNcIixcbiAgXCJ0cmFuc2l0aW9uXCIsXG4gIFwidHJhbnNmb3JtVGVtcGxhdGVcIixcbiAgXCJ0cmFuc2Zvcm1WYWx1ZXNcIixcbiAgXCJjdXN0b21cIixcbiAgXCJpbmhlcml0XCIsXG4gIFwibGF5b3V0XCIsXG4gIFwibGF5b3V0SWRcIixcbiAgXCJfbGF5b3V0UmVzZXRUcmFuc2Zvcm1cIixcbiAgXCJvbkxheW91dEFuaW1hdGlvbkNvbXBsZXRlXCIsXG4gIFwib25WaWV3cG9ydEJveFVwZGF0ZVwiLFxuICBcIm9uTGF5b3V0TWVhc3VyZVwiLFxuICBcIm9uQmVmb3JlTGF5b3V0TWVhc3VyZVwiLFxuICBcIm9uQW5pbWF0aW9uU3RhcnRcIixcbiAgXCJvbkFuaW1hdGlvbkNvbXBsZXRlXCIsXG4gIFwib25VcGRhdGVcIixcbiAgXCJvbkRyYWdTdGFydFwiLFxuICBcIm9uRHJhZ1wiLFxuICBcIm9uRHJhZ0VuZFwiLFxuICBcIm9uTWVhc3VyZURyYWdDb25zdHJhaW50c1wiLFxuICBcIm9uRGlyZWN0aW9uTG9ja1wiLFxuICBcIm9uRHJhZ1RyYW5zaXRpb25FbmRcIixcbiAgXCJkcmFnXCIsXG4gIFwiZHJhZ0NvbnRyb2xzXCIsXG4gIFwiZHJhZ0xpc3RlbmVyXCIsXG4gIFwiZHJhZ0NvbnN0cmFpbnRzXCIsXG4gIFwiZHJhZ0RpcmVjdGlvbkxvY2tcIixcbiAgXCJfZHJhZ1hcIixcbiAgXCJfZHJhZ1lcIixcbiAgXCJkcmFnRWxhc3RpY1wiLFxuICBcImRyYWdNb21lbnR1bVwiLFxuICBcImRyYWdQcm9wYWdhdGlvblwiLFxuICBcImRyYWdUcmFuc2l0aW9uXCIsXG4gIFwid2hpbGVEcmFnXCIsXG4gIFwib25QYW5cIixcbiAgXCJvblBhblN0YXJ0XCIsXG4gIFwib25QYW5FbmRcIixcbiAgXCJvblBhblNlc3Npb25TdGFydFwiLFxuICBcIm9uVGFwXCIsXG4gIFwib25UYXBTdGFydFwiLFxuICBcIm9uVGFwQ2FuY2VsXCIsXG4gIFwib25Ib3ZlclN0YXJ0XCIsXG4gIFwib25Ib3ZlckVuZFwiLFxuICBcIndoaWxlRm9jdXNcIixcbiAgXCJ3aGlsZVRhcFwiLFxuICBcIndoaWxlSG92ZXJcIlxuXSk7XG5mdW5jdGlvbiBpc1ZhbGlkTW90aW9uUHJvcChrZXk2KSB7XG4gIHJldHVybiB2YWxpZE1vdGlvblByb3BzLmhhcyhrZXk2KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2ZpbHRlci1wcm9wcy5qc1xudmFyIHNob3VsZEZvcndhcmQgPSBmdW5jdGlvbihrZXk2KSB7XG4gIHJldHVybiAhaXNWYWxpZE1vdGlvblByb3Aoa2V5Nik7XG59O1xudHJ5IHtcbiAgZW1vdGlvbklzUHJvcFZhbGlkXzEgPSByZXF1aXJlX2lzX3Byb3BfdmFsaWRfYnJvd3Nlcl9janMoKS5kZWZhdWx0O1xuICBzaG91bGRGb3J3YXJkID0gZnVuY3Rpb24oa2V5Nikge1xuICAgIGlmIChrZXk2LnN0YXJ0c1dpdGgoXCJvblwiKSkge1xuICAgICAgcmV0dXJuICFpc1ZhbGlkTW90aW9uUHJvcChrZXk2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVtb3Rpb25Jc1Byb3BWYWxpZF8xKGtleTYpO1xuICAgIH1cbiAgfTtcbn0gY2F0Y2ggKF9hKSB7XG59XG52YXIgZW1vdGlvbklzUHJvcFZhbGlkXzE7XG5mdW5jdGlvbiBmaWx0ZXJQcm9wcyhwcm9wcywgaXNEb20sIGZvcndhcmRNb3Rpb25Qcm9wcykge1xuICB2YXIgZmlsdGVyZWRQcm9wczIgPSB7fTtcbiAgZm9yICh2YXIga2V5NiBpbiBwcm9wcykge1xuICAgIGlmIChzaG91bGRGb3J3YXJkKGtleTYpIHx8IGZvcndhcmRNb3Rpb25Qcm9wcyA9PT0gdHJ1ZSAmJiBpc1ZhbGlkTW90aW9uUHJvcChrZXk2KSB8fCAhaXNEb20gJiYgIWlzVmFsaWRNb3Rpb25Qcm9wKGtleTYpKSB7XG4gICAgICBmaWx0ZXJlZFByb3BzMltrZXk2XSA9IHByb3BzW2tleTZdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmlsdGVyZWRQcm9wczI7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91c2UtcHJvcHMuanNcbmltcG9ydCB7IHVzZU1lbW8gYXMgdXNlTWVtbzMgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL3RyYW5zZm9ybS1vcmlnaW4uanNcbmZ1bmN0aW9uIGNhbGNPcmlnaW4ob3JpZ2luLCBvZmZzZXQsIHNpemUyKSB7XG4gIHJldHVybiB0eXBlb2Ygb3JpZ2luID09PSBcInN0cmluZ1wiID8gb3JpZ2luIDogcHgudHJhbnNmb3JtKG9mZnNldCArIHNpemUyICogb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIGNhbGNTVkdUcmFuc2Zvcm1PcmlnaW4oZGltZW5zaW9ucywgb3JpZ2luWCwgb3JpZ2luWSkge1xuICB2YXIgcHhPcmlnaW5YID0gY2FsY09yaWdpbihvcmlnaW5YLCBkaW1lbnNpb25zLngsIGRpbWVuc2lvbnMud2lkdGgpO1xuICB2YXIgcHhPcmlnaW5ZID0gY2FsY09yaWdpbihvcmlnaW5ZLCBkaW1lbnNpb25zLnksIGRpbWVuc2lvbnMuaGVpZ2h0KTtcbiAgcmV0dXJuIHB4T3JpZ2luWCArIFwiIFwiICsgcHhPcmlnaW5ZO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdXRpbHMvcGF0aC5qc1xudmFyIHByb2dyZXNzVG9QaXhlbHMgPSBmdW5jdGlvbihwcm9ncmVzczIsIGxlbmd0aCkge1xuICByZXR1cm4gcHgudHJhbnNmb3JtKHByb2dyZXNzMiAqIGxlbmd0aCk7XG59O1xudmFyIGRhc2hLZXlzID0ge1xuICBvZmZzZXQ6IFwic3Ryb2tlLWRhc2hvZmZzZXRcIixcbiAgYXJyYXk6IFwic3Ryb2tlLWRhc2hhcnJheVwiXG59O1xudmFyIGNhbWVsS2V5cyA9IHtcbiAgb2Zmc2V0OiBcInN0cm9rZURhc2hvZmZzZXRcIixcbiAgYXJyYXk6IFwic3Ryb2tlRGFzaGFycmF5XCJcbn07XG5mdW5jdGlvbiBidWlsZFNWR1BhdGgoYXR0cnMsIHRvdGFsTGVuZ3RoLCBsZW5ndGgsIHNwYWNpbmcsIG9mZnNldCwgdXNlRGFzaENhc2UpIHtcbiAgaWYgKHNwYWNpbmcgPT09IHZvaWQgMCkge1xuICAgIHNwYWNpbmcgPSAxO1xuICB9XG4gIGlmIChvZmZzZXQgPT09IHZvaWQgMCkge1xuICAgIG9mZnNldCA9IDA7XG4gIH1cbiAgaWYgKHVzZURhc2hDYXNlID09PSB2b2lkIDApIHtcbiAgICB1c2VEYXNoQ2FzZSA9IHRydWU7XG4gIH1cbiAgdmFyIGtleXMyID0gdXNlRGFzaENhc2UgPyBkYXNoS2V5cyA6IGNhbWVsS2V5cztcbiAgYXR0cnNba2V5czIub2Zmc2V0XSA9IHByb2dyZXNzVG9QaXhlbHMoLW9mZnNldCwgdG90YWxMZW5ndGgpO1xuICB2YXIgcGF0aExlbmd0aCA9IHByb2dyZXNzVG9QaXhlbHMobGVuZ3RoLCB0b3RhbExlbmd0aCk7XG4gIHZhciBwYXRoU3BhY2luZyA9IHByb2dyZXNzVG9QaXhlbHMoc3BhY2luZywgdG90YWxMZW5ndGgpO1xuICBhdHRyc1trZXlzMi5hcnJheV0gPSBwYXRoTGVuZ3RoICsgXCIgXCIgKyBwYXRoU3BhY2luZztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL2J1aWxkLWF0dHJzLmpzXG5mdW5jdGlvbiBidWlsZFNWR0F0dHJzKHN0YXRlLCBfYSwgcHJvamVjdGlvbiwgbGF5b3V0U3RhdGUsIG9wdGlvbnMsIHRyYW5zZm9ybVRlbXBsYXRlMiwgYnVpbGRQcm9qZWN0aW9uVHJhbnNmb3JtLCBidWlsZFByb2plY3Rpb25UcmFuc2Zvcm1PcmlnaW4pIHtcbiAgdmFyIGF0dHJYID0gX2EuYXR0clgsIGF0dHJZID0gX2EuYXR0clksIG9yaWdpblggPSBfYS5vcmlnaW5YLCBvcmlnaW5ZID0gX2Eub3JpZ2luWSwgcGF0aExlbmd0aCA9IF9hLnBhdGhMZW5ndGgsIF9iID0gX2EucGF0aFNwYWNpbmcsIHBhdGhTcGFjaW5nID0gX2IgPT09IHZvaWQgMCA/IDEgOiBfYiwgX2MgPSBfYS5wYXRoT2Zmc2V0LCBwYXRoT2Zmc2V0ID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYywgbGF0ZXN0ID0gX19yZXN0KF9hLCBbXCJhdHRyWFwiLCBcImF0dHJZXCIsIFwib3JpZ2luWFwiLCBcIm9yaWdpbllcIiwgXCJwYXRoTGVuZ3RoXCIsIFwicGF0aFNwYWNpbmdcIiwgXCJwYXRoT2Zmc2V0XCJdKTtcbiAgYnVpbGRIVE1MU3R5bGVzKHN0YXRlLCBsYXRlc3QsIHByb2plY3Rpb24sIGxheW91dFN0YXRlLCBvcHRpb25zLCB0cmFuc2Zvcm1UZW1wbGF0ZTIsIGJ1aWxkUHJvamVjdGlvblRyYW5zZm9ybSwgYnVpbGRQcm9qZWN0aW9uVHJhbnNmb3JtT3JpZ2luKTtcbiAgc3RhdGUuYXR0cnMgPSBzdGF0ZS5zdHlsZTtcbiAgc3RhdGUuc3R5bGUgPSB7fTtcbiAgdmFyIGF0dHJzID0gc3RhdGUuYXR0cnMsIHN0eWxlID0gc3RhdGUuc3R5bGUsIGRpbWVuc2lvbnMgPSBzdGF0ZS5kaW1lbnNpb25zLCB0b3RhbFBhdGhMZW5ndGggPSBzdGF0ZS50b3RhbFBhdGhMZW5ndGg7XG4gIGlmIChhdHRycy50cmFuc2Zvcm0pIHtcbiAgICBpZiAoZGltZW5zaW9ucylcbiAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IGF0dHJzLnRyYW5zZm9ybTtcbiAgICBkZWxldGUgYXR0cnMudHJhbnNmb3JtO1xuICB9XG4gIGlmIChkaW1lbnNpb25zICYmIChvcmlnaW5YICE9PSB2b2lkIDAgfHwgb3JpZ2luWSAhPT0gdm9pZCAwIHx8IHN0eWxlLnRyYW5zZm9ybSkpIHtcbiAgICBzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBjYWxjU1ZHVHJhbnNmb3JtT3JpZ2luKGRpbWVuc2lvbnMsIG9yaWdpblggIT09IHZvaWQgMCA/IG9yaWdpblggOiAwLjUsIG9yaWdpblkgIT09IHZvaWQgMCA/IG9yaWdpblkgOiAwLjUpO1xuICB9XG4gIGlmIChhdHRyWCAhPT0gdm9pZCAwKVxuICAgIGF0dHJzLnggPSBhdHRyWDtcbiAgaWYgKGF0dHJZICE9PSB2b2lkIDApXG4gICAgYXR0cnMueSA9IGF0dHJZO1xuICBpZiAodG90YWxQYXRoTGVuZ3RoICE9PSB2b2lkIDAgJiYgcGF0aExlbmd0aCAhPT0gdm9pZCAwKSB7XG4gICAgYnVpbGRTVkdQYXRoKGF0dHJzLCB0b3RhbFBhdGhMZW5ndGgsIHBhdGhMZW5ndGgsIHBhdGhTcGFjaW5nLCBwYXRoT2Zmc2V0LCBmYWxzZSk7XG4gIH1cbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL2NyZWF0ZS1yZW5kZXItc3RhdGUuanNcbnZhciBjcmVhdGVTdmdSZW5kZXJTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSgpKSwgeyBhdHRyczoge30gfSk7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdXNlLXByb3BzLmpzXG5mdW5jdGlvbiB1c2VTVkdQcm9wcyhwcm9wcywgdmlzdWFsU3RhdGUpIHtcbiAgdmFyIHZpc3VhbFByb3BzID0gdXNlTWVtbzMoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gY3JlYXRlU3ZnUmVuZGVyU3RhdGUoKTtcbiAgICBidWlsZFNWR0F0dHJzKHN0YXRlLCB2aXN1YWxTdGF0ZSwgdm9pZCAwLCB2b2lkIDAsIHsgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb246IGZhbHNlIH0sIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0YXRlLmF0dHJzKSwgeyBzdHlsZTogX19hc3NpZ24oe30sIHN0YXRlLnN0eWxlKSB9KTtcbiAgfSwgW3Zpc3VhbFN0YXRlXSk7XG4gIGlmIChwcm9wcy5zdHlsZSkge1xuICAgIHZhciByYXdTdHlsZXMgPSB7fTtcbiAgICBjb3B5UmF3VmFsdWVzT25seShyYXdTdHlsZXMsIHByb3BzLnN0eWxlLCBwcm9wcyk7XG4gICAgdmlzdWFsUHJvcHMuc3R5bGUgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmF3U3R5bGVzKSwgdmlzdWFsUHJvcHMuc3R5bGUpO1xuICB9XG4gIHJldHVybiB2aXN1YWxQcm9wcztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3VzZS1yZW5kZXIuanNcbmZ1bmN0aW9uIGNyZWF0ZVVzZVJlbmRlcihmb3J3YXJkTW90aW9uUHJvcHMpIHtcbiAgaWYgKGZvcndhcmRNb3Rpb25Qcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgZm9yd2FyZE1vdGlvblByb3BzID0gZmFsc2U7XG4gIH1cbiAgdmFyIHVzZVJlbmRlciA9IGZ1bmN0aW9uKENvbXBvbmVudDE5LCBwcm9wcywgcmVmLCBfYSwgaXNTdGF0aWMpIHtcbiAgICB2YXIgbGF0ZXN0VmFsdWVzID0gX2EubGF0ZXN0VmFsdWVzO1xuICAgIHZhciB1c2VWaXN1YWxQcm9wcyA9IGlzU1ZHQ29tcG9uZW50KENvbXBvbmVudDE5KSA/IHVzZVNWR1Byb3BzIDogdXNlSFRNTFByb3BzO1xuICAgIHZhciB2aXN1YWxQcm9wcyA9IHVzZVZpc3VhbFByb3BzKHByb3BzLCBsYXRlc3RWYWx1ZXMsIGlzU3RhdGljKTtcbiAgICB2YXIgZmlsdGVyZWRQcm9wczIgPSBmaWx0ZXJQcm9wcyhwcm9wcywgdHlwZW9mIENvbXBvbmVudDE5ID09PSBcInN0cmluZ1wiLCBmb3J3YXJkTW90aW9uUHJvcHMpO1xuICAgIHZhciBlbGVtZW50UHJvcHMgPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZmlsdGVyZWRQcm9wczIpLCB2aXN1YWxQcm9wcyksIHsgcmVmIH0pO1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50MyhDb21wb25lbnQxOSwgZWxlbWVudFByb3BzKTtcbiAgfTtcbiAgcmV0dXJuIHVzZVJlbmRlcjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2NhbWVsLXRvLWRhc2guanNcbnZhciBDQU1FTF9DQVNFX1BBVFRFUk4gPSAvKFthLXpdKShbQS1aXSkvZztcbnZhciBSRVBMQUNFX1RFTVBMQVRFID0gXCIkMS0kMlwiO1xudmFyIGNhbWVsVG9EYXNoID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShDQU1FTF9DQVNFX1BBVFRFUk4sIFJFUExBQ0VfVEVNUExBVEUpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3V0aWxzL3JlbmRlci5qc1xuZnVuY3Rpb24gcmVuZGVySFRNTChlbGVtZW50LCBfYSkge1xuICB2YXIgc3R5bGUgPSBfYS5zdHlsZSwgdmFycyA9IF9hLnZhcnM7XG4gIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICBmb3IgKHZhciBrZXk2IGluIHZhcnMpIHtcbiAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KGtleTYsIHZhcnNba2V5Nl0pO1xuICB9XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy9jYW1lbC1jYXNlLWF0dHJzLmpzXG52YXIgY2FtZWxDYXNlQXR0cmlidXRlcyA9IG5ldyBTZXQoW1xuICBcImJhc2VGcmVxdWVuY3lcIixcbiAgXCJkaWZmdXNlQ29uc3RhbnRcIixcbiAgXCJrZXJuZWxNYXRyaXhcIixcbiAgXCJrZXJuZWxVbml0TGVuZ3RoXCIsXG4gIFwia2V5U3BsaW5lc1wiLFxuICBcImtleVRpbWVzXCIsXG4gIFwibGltaXRpbmdDb25lQW5nbGVcIixcbiAgXCJtYXJrZXJIZWlnaHRcIixcbiAgXCJtYXJrZXJXaWR0aFwiLFxuICBcIm51bU9jdGF2ZXNcIixcbiAgXCJ0YXJnZXRYXCIsXG4gIFwidGFyZ2V0WVwiLFxuICBcInN1cmZhY2VTY2FsZVwiLFxuICBcInNwZWN1bGFyQ29uc3RhbnRcIixcbiAgXCJzcGVjdWxhckV4cG9uZW50XCIsXG4gIFwic3RkRGV2aWF0aW9uXCIsXG4gIFwidGFibGVWYWx1ZXNcIixcbiAgXCJ2aWV3Qm94XCJcbl0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdXRpbHMvcmVuZGVyLmpzXG5mdW5jdGlvbiByZW5kZXJTVkcoZWxlbWVudCwgcmVuZGVyU3RhdGUpIHtcbiAgcmVuZGVySFRNTChlbGVtZW50LCByZW5kZXJTdGF0ZSk7XG4gIGZvciAodmFyIGtleTYgaW4gcmVuZGVyU3RhdGUuYXR0cnMpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSghY2FtZWxDYXNlQXR0cmlidXRlcy5oYXMoa2V5NikgPyBjYW1lbFRvRGFzaChrZXk2KSA6IGtleTYsIHJlbmRlclN0YXRlLmF0dHJzW2tleTZdKTtcbiAgfVxufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3V0aWxzL3NjcmFwZS1tb3Rpb24tdmFsdWVzLmpzXG5mdW5jdGlvbiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMocHJvcHMpIHtcbiAgdmFyIHN0eWxlID0gcHJvcHMuc3R5bGU7XG4gIHZhciBuZXdWYWx1ZXMgPSB7fTtcbiAgZm9yICh2YXIga2V5NiBpbiBzdHlsZSkge1xuICAgIGlmIChpc01vdGlvblZhbHVlKHN0eWxlW2tleTZdKSB8fCBpc0ZvcmNlZE1vdGlvblZhbHVlKGtleTYsIHByb3BzKSkge1xuICAgICAgbmV3VmFsdWVzW2tleTZdID0gc3R5bGVba2V5Nl07XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdWYWx1ZXM7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy9zY3JhcGUtbW90aW9uLXZhbHVlcy5qc1xuZnVuY3Rpb24gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzMihwcm9wcykge1xuICB2YXIgbmV3VmFsdWVzID0gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzKTtcbiAgZm9yICh2YXIga2V5NiBpbiBwcm9wcykge1xuICAgIGlmIChpc01vdGlvblZhbHVlKHByb3BzW2tleTZdKSkge1xuICAgICAgdmFyIHRhcmdldEtleSA9IGtleTYgPT09IFwieFwiIHx8IGtleTYgPT09IFwieVwiID8gXCJhdHRyXCIgKyBrZXk2LnRvVXBwZXJDYXNlKCkgOiBrZXk2O1xuICAgICAgbmV3VmFsdWVzW3RhcmdldEtleV0gPSBwcm9wc1trZXk2XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld1ZhbHVlcztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vdXRpbHMvdXNlLXZpc3VhbC1zdGF0ZS5qc1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0NyB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi91dGlscy9pcy1hbmltYXRpb24tY29udHJvbHMuanNcbmZ1bmN0aW9uIGlzQW5pbWF0aW9uQ29udHJvbHModikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHYuc3RhcnQgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vdXRpbHMvaXMta2V5ZnJhbWVzLXRhcmdldC5qc1xudmFyIGlzS2V5ZnJhbWVzVGFyZ2V0ID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvcmVzb2x2ZS12YWx1ZS5qc1xudmFyIGlzQ3VzdG9tVmFsdWUgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBCb29sZWFuKHYgJiYgdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdi5taXggJiYgdi50b1ZhbHVlKTtcbn07XG52YXIgcmVzb2x2ZUZpbmFsVmFsdWVJbktleWZyYW1lcyA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIGlzS2V5ZnJhbWVzVGFyZ2V0KHYpID8gdlt2Lmxlbmd0aCAtIDFdIHx8IDAgOiB2O1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS91dGlscy9yZXNvbHZlLW1vdGlvbi12YWx1ZS5qc1xuZnVuY3Rpb24gcmVzb2x2ZU1vdGlvblZhbHVlKHZhbHVlKSB7XG4gIHZhciB1bndyYXBwZWRWYWx1ZSA9IGlzTW90aW9uVmFsdWUodmFsdWUpID8gdmFsdWUuZ2V0KCkgOiB2YWx1ZTtcbiAgcmV0dXJuIGlzQ3VzdG9tVmFsdWUodW53cmFwcGVkVmFsdWUpID8gdW53cmFwcGVkVmFsdWUudG9WYWx1ZSgpIDogdW53cmFwcGVkVmFsdWU7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL3VzZS12aXN1YWwtc3RhdGUuanNcbmZ1bmN0aW9uIG1ha2VTdGF0ZShfYSwgcHJvcHMsIGNvbnRleHQsIHByZXNlbmNlQ29udGV4dCkge1xuICB2YXIgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzMyA9IF9hLnNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcywgY3JlYXRlUmVuZGVyU3RhdGUgPSBfYS5jcmVhdGVSZW5kZXJTdGF0ZSwgb25Nb3VudCA9IF9hLm9uTW91bnQ7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICBsYXRlc3RWYWx1ZXM6IG1ha2VMYXRlc3RWYWx1ZXMocHJvcHMsIGNvbnRleHQsIHByZXNlbmNlQ29udGV4dCwgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzMyksXG4gICAgcmVuZGVyU3RhdGU6IGNyZWF0ZVJlbmRlclN0YXRlKClcbiAgfTtcbiAgaWYgKG9uTW91bnQpIHtcbiAgICBzdGF0ZS5tb3VudCA9IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gb25Nb3VudChwcm9wcywgaW5zdGFuY2UsIHN0YXRlKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbnZhciBtYWtlVXNlVmlzdWFsU3RhdGUgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3BzLCBpc1N0YXRpYykge1xuICAgIHZhciBjb250ZXh0ID0gdXNlQ29udGV4dDcoTW90aW9uQ29udGV4dCk7XG4gICAgdmFyIHByZXNlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQ3KFByZXNlbmNlQ29udGV4dCk7XG4gICAgcmV0dXJuIGlzU3RhdGljID8gbWFrZVN0YXRlKGNvbmZpZywgcHJvcHMsIGNvbnRleHQsIHByZXNlbmNlQ29udGV4dCkgOiB1c2VDb25zdGFudChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtYWtlU3RhdGUoY29uZmlnLCBwcm9wcywgY29udGV4dCwgcHJlc2VuY2VDb250ZXh0KTtcbiAgICB9KTtcbiAgfTtcbn07XG5mdW5jdGlvbiBtYWtlTGF0ZXN0VmFsdWVzKHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQsIHNjcmFwZU1vdGlvblZhbHVlcykge1xuICB2YXIgdmFsdWVzID0ge307XG4gIHZhciBibG9ja0luaXRpYWxBbmltYXRpb24gPSAocHJlc2VuY2VDb250ZXh0ID09PSBudWxsIHx8IHByZXNlbmNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJlc2VuY2VDb250ZXh0LmluaXRpYWwpID09PSBmYWxzZTtcbiAgdmFyIG1vdGlvblZhbHVlcyA9IHNjcmFwZU1vdGlvblZhbHVlcyhwcm9wcyk7XG4gIGZvciAodmFyIGtleTYgaW4gbW90aW9uVmFsdWVzKSB7XG4gICAgdmFsdWVzW2tleTZdID0gcmVzb2x2ZU1vdGlvblZhbHVlKG1vdGlvblZhbHVlc1trZXk2XSk7XG4gIH1cbiAgdmFyIGluaXRpYWwgPSBwcm9wcy5pbml0aWFsLCBhbmltYXRlNCA9IHByb3BzLmFuaW1hdGU7XG4gIHZhciBpc0NvbnRyb2xsaW5nVmFyaWFudHMgPSBjaGVja0lmQ29udHJvbGxpbmdWYXJpYW50cyhwcm9wcyk7XG4gIHZhciBpc1ZhcmlhbnROb2RlID0gY2hlY2tJZlZhcmlhbnROb2RlKHByb3BzKTtcbiAgaWYgKGNvbnRleHQgJiYgaXNWYXJpYW50Tm9kZSAmJiAhaXNDb250cm9sbGluZ1ZhcmlhbnRzICYmIHByb3BzLmluaGVyaXQgIT09IGZhbHNlKSB7XG4gICAgaW5pdGlhbCAhPT0gbnVsbCAmJiBpbml0aWFsICE9PSB2b2lkIDAgPyBpbml0aWFsIDogaW5pdGlhbCA9IGNvbnRleHQuaW5pdGlhbDtcbiAgICBhbmltYXRlNCAhPT0gbnVsbCAmJiBhbmltYXRlNCAhPT0gdm9pZCAwID8gYW5pbWF0ZTQgOiBhbmltYXRlNCA9IGNvbnRleHQuYW5pbWF0ZTtcbiAgfVxuICB2YXIgdmFyaWFudFRvU2V0ID0gYmxvY2tJbml0aWFsQW5pbWF0aW9uIHx8IGluaXRpYWwgPT09IGZhbHNlID8gYW5pbWF0ZTQgOiBpbml0aWFsO1xuICBpZiAodmFyaWFudFRvU2V0ICYmIHR5cGVvZiB2YXJpYW50VG9TZXQgIT09IFwiYm9vbGVhblwiICYmICFpc0FuaW1hdGlvbkNvbnRyb2xzKHZhcmlhbnRUb1NldCkpIHtcbiAgICB2YXIgbGlzdCA9IEFycmF5LmlzQXJyYXkodmFyaWFudFRvU2V0KSA/IHZhcmlhbnRUb1NldCA6IFt2YXJpYW50VG9TZXRdO1xuICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbihkZWZpbml0aW9uKSB7XG4gICAgICB2YXIgcmVzb2x2ZWQgPSByZXNvbHZlVmFyaWFudEZyb21Qcm9wcyhwcm9wcywgZGVmaW5pdGlvbik7XG4gICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICByZXR1cm47XG4gICAgICB2YXIgdHJhbnNpdGlvbkVuZCA9IHJlc29sdmVkLnRyYW5zaXRpb25FbmQ7XG4gICAgICByZXNvbHZlZC50cmFuc2l0aW9uO1xuICAgICAgdmFyIHRhcmdldCA9IF9fcmVzdChyZXNvbHZlZCwgW1widHJhbnNpdGlvbkVuZFwiLCBcInRyYW5zaXRpb25cIl0pO1xuICAgICAgZm9yICh2YXIga2V5NyBpbiB0YXJnZXQpXG4gICAgICAgIHZhbHVlc1trZXk3XSA9IHRhcmdldFtrZXk3XTtcbiAgICAgIGZvciAodmFyIGtleTcgaW4gdHJhbnNpdGlvbkVuZClcbiAgICAgICAgdmFsdWVzW2tleTddID0gdHJhbnNpdGlvbkVuZFtrZXk3XTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvY29uZmlnLW1vdGlvbi5qc1xudmFyIHN2Z01vdGlvbkNvbmZpZyA9IHtcbiAgdXNlVmlzdWFsU3RhdGU6IG1ha2VVc2VWaXN1YWxTdGF0ZSh7XG4gICAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzOiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMyLFxuICAgIGNyZWF0ZVJlbmRlclN0YXRlOiBjcmVhdGVTdmdSZW5kZXJTdGF0ZSxcbiAgICBvbk1vdW50OiBmdW5jdGlvbihwcm9wcywgaW5zdGFuY2UsIF9hKSB7XG4gICAgICB2YXIgcmVuZGVyU3RhdGUgPSBfYS5yZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzID0gX2EubGF0ZXN0VmFsdWVzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVuZGVyU3RhdGUuZGltZW5zaW9ucyA9IHR5cGVvZiBpbnN0YW5jZS5nZXRCQm94ID09PSBcImZ1bmN0aW9uXCIgPyBpbnN0YW5jZS5nZXRCQm94KCkgOiBpbnN0YW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVuZGVyU3RhdGUuZGltZW5zaW9ucyA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoaXNQYXRoKGluc3RhbmNlKSkge1xuICAgICAgICByZW5kZXJTdGF0ZS50b3RhbFBhdGhMZW5ndGggPSBpbnN0YW5jZS5nZXRUb3RhbExlbmd0aCgpO1xuICAgICAgfVxuICAgICAgYnVpbGRTVkdBdHRycyhyZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzLCB2b2lkIDAsIHZvaWQgMCwgeyBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbjogZmFsc2UgfSwgcHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgICAgcmVuZGVyU1ZHKGluc3RhbmNlLCByZW5kZXJTdGF0ZSk7XG4gICAgfVxuICB9KVxufTtcbmZ1bmN0aW9uIGlzUGF0aChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LnRhZ05hbWUgPT09IFwicGF0aFwiO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL2NvbmZpZy1tb3Rpb24uanNcbnZhciBodG1sTW90aW9uQ29uZmlnID0ge1xuICB1c2VWaXN1YWxTdGF0ZTogbWFrZVVzZVZpc3VhbFN0YXRlKHtcbiAgICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMsXG4gICAgY3JlYXRlUmVuZGVyU3RhdGU6IGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZVxuICB9KVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2NyZWF0ZS1jb25maWcuanNcbmZ1bmN0aW9uIGNyZWF0ZURvbU1vdGlvbkNvbmZpZyhDb21wb25lbnQxOSwgX2EsIHByZWxvYWRlZEZlYXR1cmVzLCBjcmVhdGVWaXN1YWxFbGVtZW50KSB7XG4gIHZhciBfYiA9IF9hLmZvcndhcmRNb3Rpb25Qcm9wcywgZm9yd2FyZE1vdGlvblByb3BzID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7XG4gIHZhciBiYXNlQ29uZmlnID0gaXNTVkdDb21wb25lbnQoQ29tcG9uZW50MTkpID8gc3ZnTW90aW9uQ29uZmlnIDogaHRtbE1vdGlvbkNvbmZpZztcbiAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBiYXNlQ29uZmlnKSwge1xuICAgIHByZWxvYWRlZEZlYXR1cmVzLFxuICAgIHVzZVJlbmRlcjogY3JlYXRlVXNlUmVuZGVyKGZvcndhcmRNb3Rpb25Qcm9wcyksXG4gICAgY3JlYXRlVmlzdWFsRWxlbWVudCxcbiAgICBDb21wb25lbnQ6IENvbXBvbmVudDE5XG4gIH0pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy90eXBlcy5qc1xudmFyIEFuaW1hdGlvblR5cGU7XG4oZnVuY3Rpb24oQW5pbWF0aW9uVHlwZTIpIHtcbiAgQW5pbWF0aW9uVHlwZTJbXCJBbmltYXRlXCJdID0gXCJhbmltYXRlXCI7XG4gIEFuaW1hdGlvblR5cGUyW1wiSG92ZXJcIl0gPSBcIndoaWxlSG92ZXJcIjtcbiAgQW5pbWF0aW9uVHlwZTJbXCJUYXBcIl0gPSBcIndoaWxlVGFwXCI7XG4gIEFuaW1hdGlvblR5cGUyW1wiRHJhZ1wiXSA9IFwid2hpbGVEcmFnXCI7XG4gIEFuaW1hdGlvblR5cGUyW1wiRm9jdXNcIl0gPSBcIndoaWxlRm9jdXNcIjtcbiAgQW5pbWF0aW9uVHlwZTJbXCJFeGl0XCJdID0gXCJleGl0XCI7XG59KShBbmltYXRpb25UeXBlIHx8IChBbmltYXRpb25UeXBlID0ge30pKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9ldmVudHMvdXNlLWRvbS1ldmVudC5qc1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDQgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIGFkZERvbUV2ZW50KHRhcmdldCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZURvbUV2ZW50KHJlZiwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gIHVzZUVmZmVjdDQoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVsZW1lbnQgPSByZWYuY3VycmVudDtcbiAgICBpZiAoaGFuZGxlciAmJiBlbGVtZW50KSB7XG4gICAgICByZXR1cm4gYWRkRG9tRXZlbnQoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9XG4gIH0sIFtyZWYsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9uc10pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3VzZS1mb2N1cy1nZXN0dXJlLmpzXG5mdW5jdGlvbiB1c2VGb2N1c0dlc3R1cmUoX2EpIHtcbiAgdmFyIHdoaWxlRm9jdXMgPSBfYS53aGlsZUZvY3VzLCB2aXN1YWxFbGVtZW50MiA9IF9hLnZpc3VhbEVsZW1lbnQ7XG4gIHZhciBvbkZvY3VzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF9hMjtcbiAgICAoX2EyID0gdmlzdWFsRWxlbWVudDIuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9hMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EyLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLkZvY3VzLCB0cnVlKTtcbiAgfTtcbiAgdmFyIG9uQmx1ciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfYTI7XG4gICAgKF9hMiA9IHZpc3VhbEVsZW1lbnQyLmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hMi5zZXRBY3RpdmUoQW5pbWF0aW9uVHlwZS5Gb2N1cywgZmFsc2UpO1xuICB9O1xuICB1c2VEb21FdmVudCh2aXN1YWxFbGVtZW50MiwgXCJmb2N1c1wiLCB3aGlsZUZvY3VzID8gb25Gb2N1cyA6IHZvaWQgMCk7XG4gIHVzZURvbUV2ZW50KHZpc3VhbEVsZW1lbnQyLCBcImJsdXJcIiwgd2hpbGVGb2N1cyA/IG9uQmx1ciA6IHZvaWQgMCk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvdXRpbHMvZXZlbnQtdHlwZS5qc1xuZnVuY3Rpb24gaXNNb3VzZUV2ZW50KGV2ZW50KSB7XG4gIGlmICh0eXBlb2YgUG9pbnRlckV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGV2ZW50IGluc3RhbmNlb2YgUG9pbnRlckV2ZW50KSB7XG4gICAgcmV0dXJuICEhKGV2ZW50LnBvaW50ZXJUeXBlID09PSBcIm1vdXNlXCIpO1xuICB9XG4gIHJldHVybiBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQ7XG59XG5mdW5jdGlvbiBpc1RvdWNoRXZlbnQoZXZlbnQpIHtcbiAgdmFyIGhhc1RvdWNoZXMgPSAhIWV2ZW50LnRvdWNoZXM7XG4gIHJldHVybiBoYXNUb3VjaGVzO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2V2ZW50cy9ldmVudC1pbmZvLmpzXG5mdW5jdGlvbiBmaWx0ZXJQcmltYXJ5UG9pbnRlcihldmVudEhhbmRsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGlzTW91c2VFdmVudDIgPSBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQ7XG4gICAgdmFyIGlzUHJpbWFyeVBvaW50ZXIgPSAhaXNNb3VzZUV2ZW50MiB8fCBpc01vdXNlRXZlbnQyICYmIGV2ZW50LmJ1dHRvbiA9PT0gMDtcbiAgICBpZiAoaXNQcmltYXJ5UG9pbnRlcikge1xuICAgICAgZXZlbnRIYW5kbGVyKGV2ZW50KTtcbiAgICB9XG4gIH07XG59XG52YXIgZGVmYXVsdFBhZ2VQb2ludCA9IHsgcGFnZVg6IDAsIHBhZ2VZOiAwIH07XG5mdW5jdGlvbiBwb2ludEZyb21Ub3VjaChlLCBwb2ludFR5cGUpIHtcbiAgaWYgKHBvaW50VHlwZSA9PT0gdm9pZCAwKSB7XG4gICAgcG9pbnRUeXBlID0gXCJwYWdlXCI7XG4gIH1cbiAgdmFyIHByaW1hcnlUb3VjaCA9IGUudG91Y2hlc1swXSB8fCBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICB2YXIgcG9pbnQgPSBwcmltYXJ5VG91Y2ggfHwgZGVmYXVsdFBhZ2VQb2ludDtcbiAgcmV0dXJuIHtcbiAgICB4OiBwb2ludFtwb2ludFR5cGUgKyBcIlhcIl0sXG4gICAgeTogcG9pbnRbcG9pbnRUeXBlICsgXCJZXCJdXG4gIH07XG59XG5mdW5jdGlvbiBwb2ludEZyb21Nb3VzZShwb2ludCwgcG9pbnRUeXBlKSB7XG4gIGlmIChwb2ludFR5cGUgPT09IHZvaWQgMCkge1xuICAgIHBvaW50VHlwZSA9IFwicGFnZVwiO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogcG9pbnRbcG9pbnRUeXBlICsgXCJYXCJdLFxuICAgIHk6IHBvaW50W3BvaW50VHlwZSArIFwiWVwiXVxuICB9O1xufVxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50SW5mbyhldmVudCwgcG9pbnRUeXBlKSB7XG4gIGlmIChwb2ludFR5cGUgPT09IHZvaWQgMCkge1xuICAgIHBvaW50VHlwZSA9IFwicGFnZVwiO1xuICB9XG4gIHJldHVybiB7XG4gICAgcG9pbnQ6IGlzVG91Y2hFdmVudChldmVudCkgPyBwb2ludEZyb21Ub3VjaChldmVudCwgcG9pbnRUeXBlKSA6IHBvaW50RnJvbU1vdXNlKGV2ZW50LCBwb2ludFR5cGUpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRWaWV3cG9ydFBvaW50RnJvbUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBleHRyYWN0RXZlbnRJbmZvKGV2ZW50LCBcImNsaWVudFwiKTtcbn1cbnZhciB3cmFwSGFuZGxlciA9IGZ1bmN0aW9uKGhhbmRsZXIsIHNob3VsZEZpbHRlclByaW1hcnlQb2ludGVyKSB7XG4gIGlmIChzaG91bGRGaWx0ZXJQcmltYXJ5UG9pbnRlciA9PT0gdm9pZCAwKSB7XG4gICAgc2hvdWxkRmlsdGVyUHJpbWFyeVBvaW50ZXIgPSBmYWxzZTtcbiAgfVxuICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiBoYW5kbGVyKGV2ZW50LCBleHRyYWN0RXZlbnRJbmZvKGV2ZW50KSk7XG4gIH07XG4gIHJldHVybiBzaG91bGRGaWx0ZXJQcmltYXJ5UG9pbnRlciA/IGZpbHRlclByaW1hcnlQb2ludGVyKGxpc3RlbmVyKSA6IGxpc3RlbmVyO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9ldmVudHMvdXRpbHMuanNcbnZhciBzdXBwb3J0c1BvaW50ZXJFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGlzQnJvd3NlciAmJiB3aW5kb3cub25wb2ludGVyZG93biA9PT0gbnVsbDtcbn07XG52YXIgc3VwcG9ydHNUb3VjaEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gaXNCcm93c2VyICYmIHdpbmRvdy5vbnRvdWNoc3RhcnQgPT09IG51bGw7XG59O1xudmFyIHN1cHBvcnRzTW91c2VFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGlzQnJvd3NlciAmJiB3aW5kb3cub25tb3VzZWRvd24gPT09IG51bGw7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2V2ZW50cy91c2UtcG9pbnRlci1ldmVudC5qc1xudmFyIG1vdXNlRXZlbnROYW1lcyA9IHtcbiAgcG9pbnRlcmRvd246IFwibW91c2Vkb3duXCIsXG4gIHBvaW50ZXJtb3ZlOiBcIm1vdXNlbW92ZVwiLFxuICBwb2ludGVydXA6IFwibW91c2V1cFwiLFxuICBwb2ludGVyY2FuY2VsOiBcIm1vdXNlY2FuY2VsXCIsXG4gIHBvaW50ZXJvdmVyOiBcIm1vdXNlb3ZlclwiLFxuICBwb2ludGVyb3V0OiBcIm1vdXNlb3V0XCIsXG4gIHBvaW50ZXJlbnRlcjogXCJtb3VzZWVudGVyXCIsXG4gIHBvaW50ZXJsZWF2ZTogXCJtb3VzZWxlYXZlXCJcbn07XG52YXIgdG91Y2hFdmVudE5hbWVzID0ge1xuICBwb2ludGVyZG93bjogXCJ0b3VjaHN0YXJ0XCIsXG4gIHBvaW50ZXJtb3ZlOiBcInRvdWNobW92ZVwiLFxuICBwb2ludGVydXA6IFwidG91Y2hlbmRcIixcbiAgcG9pbnRlcmNhbmNlbDogXCJ0b3VjaGNhbmNlbFwiXG59O1xuZnVuY3Rpb24gZ2V0UG9pbnRlckV2ZW50TmFtZShuYW1lKSB7XG4gIGlmIChzdXBwb3J0c1BvaW50ZXJFdmVudHMoKSkge1xuICAgIHJldHVybiBuYW1lO1xuICB9IGVsc2UgaWYgKHN1cHBvcnRzVG91Y2hFdmVudHMoKSkge1xuICAgIHJldHVybiB0b3VjaEV2ZW50TmFtZXNbbmFtZV07XG4gIH0gZWxzZSBpZiAoc3VwcG9ydHNNb3VzZUV2ZW50cygpKSB7XG4gICAgcmV0dXJuIG1vdXNlRXZlbnROYW1lc1tuYW1lXTtcbiAgfVxuICByZXR1cm4gbmFtZTtcbn1cbmZ1bmN0aW9uIGFkZFBvaW50ZXJFdmVudCh0YXJnZXQsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICByZXR1cm4gYWRkRG9tRXZlbnQodGFyZ2V0LCBnZXRQb2ludGVyRXZlbnROYW1lKGV2ZW50TmFtZSksIHdyYXBIYW5kbGVyKGhhbmRsZXIsIGV2ZW50TmFtZSA9PT0gXCJwb2ludGVyZG93blwiKSwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB1c2VQb2ludGVyRXZlbnQocmVmLCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHVzZURvbUV2ZW50KHJlZiwgZ2V0UG9pbnRlckV2ZW50TmFtZShldmVudE5hbWUpLCBoYW5kbGVyICYmIHdyYXBIYW5kbGVyKGhhbmRsZXIsIGV2ZW50TmFtZSA9PT0gXCJwb2ludGVyZG93blwiKSwgb3B0aW9ucyk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvZHJhZy91dGlscy9sb2NrLmpzXG5mdW5jdGlvbiBjcmVhdGVMb2NrKG5hbWUpIHtcbiAgdmFyIGxvY2sgPSBudWxsO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9wZW5Mb2NrID0gZnVuY3Rpb24oKSB7XG4gICAgICBsb2NrID0gbnVsbDtcbiAgICB9O1xuICAgIGlmIChsb2NrID09PSBudWxsKSB7XG4gICAgICBsb2NrID0gbmFtZTtcbiAgICAgIHJldHVybiBvcGVuTG9jaztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufVxudmFyIGdsb2JhbEhvcml6b250YWxMb2NrID0gY3JlYXRlTG9jayhcImRyYWdIb3Jpem9udGFsXCIpO1xudmFyIGdsb2JhbFZlcnRpY2FsTG9jayA9IGNyZWF0ZUxvY2soXCJkcmFnVmVydGljYWxcIik7XG5mdW5jdGlvbiBnZXRHbG9iYWxMb2NrKGRyYWcyKSB7XG4gIHZhciBsb2NrID0gZmFsc2U7XG4gIGlmIChkcmFnMiA9PT0gXCJ5XCIpIHtcbiAgICBsb2NrID0gZ2xvYmFsVmVydGljYWxMb2NrKCk7XG4gIH0gZWxzZSBpZiAoZHJhZzIgPT09IFwieFwiKSB7XG4gICAgbG9jayA9IGdsb2JhbEhvcml6b250YWxMb2NrKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG9wZW5Ib3Jpem9udGFsXzEgPSBnbG9iYWxIb3Jpem9udGFsTG9jaygpO1xuICAgIHZhciBvcGVuVmVydGljYWxfMSA9IGdsb2JhbFZlcnRpY2FsTG9jaygpO1xuICAgIGlmIChvcGVuSG9yaXpvbnRhbF8xICYmIG9wZW5WZXJ0aWNhbF8xKSB7XG4gICAgICBsb2NrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG9wZW5Ib3Jpem9udGFsXzEoKTtcbiAgICAgICAgb3BlblZlcnRpY2FsXzEoKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcGVuSG9yaXpvbnRhbF8xKVxuICAgICAgICBvcGVuSG9yaXpvbnRhbF8xKCk7XG4gICAgICBpZiAob3BlblZlcnRpY2FsXzEpXG4gICAgICAgIG9wZW5WZXJ0aWNhbF8xKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsb2NrO1xufVxuZnVuY3Rpb24gaXNEcmFnQWN0aXZlKCkge1xuICB2YXIgb3Blbkdlc3R1cmVMb2NrID0gZ2V0R2xvYmFsTG9jayh0cnVlKTtcbiAgaWYgKCFvcGVuR2VzdHVyZUxvY2spXG4gICAgcmV0dXJuIHRydWU7XG4gIG9wZW5HZXN0dXJlTG9jaygpO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvdXNlLWhvdmVyLWdlc3R1cmUuanNcbmZ1bmN0aW9uIGNyZWF0ZUhvdmVyRXZlbnQodmlzdWFsRWxlbWVudDIsIGlzQWN0aXZlLCBjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnQsIGluZm8pIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFpc01vdXNlRXZlbnQoZXZlbnQpIHx8ICF2aXN1YWxFbGVtZW50Mi5pc0hvdmVyRXZlbnRzRW5hYmxlZCB8fCBpc0RyYWdBY3RpdmUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soZXZlbnQsIGluZm8pO1xuICAgIChfYSA9IHZpc3VhbEVsZW1lbnQyLmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuSG92ZXIsIGlzQWN0aXZlKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUhvdmVyR2VzdHVyZShfYSkge1xuICB2YXIgb25Ib3ZlclN0YXJ0ID0gX2Eub25Ib3ZlclN0YXJ0LCBvbkhvdmVyRW5kID0gX2Eub25Ib3ZlckVuZCwgd2hpbGVIb3ZlciA9IF9hLndoaWxlSG92ZXIsIHZpc3VhbEVsZW1lbnQyID0gX2EudmlzdWFsRWxlbWVudDtcbiAgdXNlUG9pbnRlckV2ZW50KHZpc3VhbEVsZW1lbnQyLCBcInBvaW50ZXJlbnRlclwiLCBvbkhvdmVyU3RhcnQgfHwgd2hpbGVIb3ZlciA/IGNyZWF0ZUhvdmVyRXZlbnQodmlzdWFsRWxlbWVudDIsIHRydWUsIG9uSG92ZXJTdGFydCkgOiB2b2lkIDApO1xuICB1c2VQb2ludGVyRXZlbnQodmlzdWFsRWxlbWVudDIsIFwicG9pbnRlcmxlYXZlXCIsIG9uSG92ZXJFbmQgfHwgd2hpbGVIb3ZlciA/IGNyZWF0ZUhvdmVyRXZlbnQodmlzdWFsRWxlbWVudDIsIGZhbHNlLCBvbkhvdmVyRW5kKSA6IHZvaWQgMCk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvdXNlLXRhcC1nZXN0dXJlLmpzXG5pbXBvcnQgeyB1c2VSZWYgYXMgdXNlUmVmMyB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3V0aWxzL2lzLW5vZGUtb3ItY2hpbGQuanNcbnZhciBpc05vZGVPckNoaWxkID0gZnVuY3Rpb24ocGFyZW50LCBjaGlsZCkge1xuICBpZiAoIWNoaWxkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKHBhcmVudCA9PT0gY2hpbGQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaXNOb2RlT3JDaGlsZChwYXJlbnQsIGNoaWxkLnBhcmVudEVsZW1lbnQpO1xuICB9XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3VzZS11bm1vdW50LWVmZmVjdC5qc1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDUgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZVVubW91bnRFZmZlY3QoY2FsbGJhY2spIHtcbiAgcmV0dXJuIHVzZUVmZmVjdDUoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgfSwgW10pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvY2xhbXAuanNcbnZhciBjbGFtcDIgPSBmdW5jdGlvbihtaW4sIG1heCwgdikge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodiwgbWluKSwgbWF4KTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9hbmltYXRpb25zL3V0aWxzL2ZpbmQtc3ByaW5nLmpzXG52YXIgc2FmZU1pbiA9IDFlLTM7XG52YXIgbWluRHVyYXRpb24gPSAwLjAxO1xudmFyIG1heER1cmF0aW9uID0gMTA7XG52YXIgbWluRGFtcGluZyA9IDAuMDU7XG52YXIgbWF4RGFtcGluZyA9IDE7XG5mdW5jdGlvbiBmaW5kU3ByaW5nKF9hKSB7XG4gIHZhciBfYiA9IF9hLmR1cmF0aW9uLCBkdXJhdGlvbiA9IF9iID09PSB2b2lkIDAgPyA4MDAgOiBfYiwgX2MgPSBfYS5ib3VuY2UsIGJvdW5jZSA9IF9jID09PSB2b2lkIDAgPyAwLjI1IDogX2MsIF9kID0gX2EudmVsb2NpdHksIHZlbG9jaXR5ID0gX2QgPT09IHZvaWQgMCA/IDAgOiBfZCwgX2UgPSBfYS5tYXNzLCBtYXNzID0gX2UgPT09IHZvaWQgMCA/IDEgOiBfZTtcbiAgdmFyIGVudmVsb3BlO1xuICB2YXIgZGVyaXZhdGl2ZTtcbiAgd2FybmluZyhkdXJhdGlvbiA8PSBtYXhEdXJhdGlvbiAqIDFlMywgXCJTcHJpbmcgZHVyYXRpb24gbXVzdCBiZSAxMCBzZWNvbmRzIG9yIGxlc3NcIik7XG4gIHZhciBkYW1waW5nUmF0aW8gPSAxIC0gYm91bmNlO1xuICBkYW1waW5nUmF0aW8gPSBjbGFtcDIobWluRGFtcGluZywgbWF4RGFtcGluZywgZGFtcGluZ1JhdGlvKTtcbiAgZHVyYXRpb24gPSBjbGFtcDIobWluRHVyYXRpb24sIG1heER1cmF0aW9uLCBkdXJhdGlvbiAvIDFlMyk7XG4gIGlmIChkYW1waW5nUmF0aW8gPCAxKSB7XG4gICAgZW52ZWxvcGUgPSBmdW5jdGlvbih1bmRhbXBlZEZyZXEyKSB7XG4gICAgICB2YXIgZXhwb25lbnRpYWxEZWNheSA9IHVuZGFtcGVkRnJlcTIgKiBkYW1waW5nUmF0aW87XG4gICAgICB2YXIgZGVsdGEyID0gZXhwb25lbnRpYWxEZWNheSAqIGR1cmF0aW9uO1xuICAgICAgdmFyIGEyID0gZXhwb25lbnRpYWxEZWNheSAtIHZlbG9jaXR5O1xuICAgICAgdmFyIGIyID0gY2FsY0FuZ3VsYXJGcmVxKHVuZGFtcGVkRnJlcTIsIGRhbXBpbmdSYXRpbyk7XG4gICAgICB2YXIgYzIgPSBNYXRoLmV4cCgtZGVsdGEyKTtcbiAgICAgIHJldHVybiBzYWZlTWluIC0gYTIgLyBiMiAqIGMyO1xuICAgIH07XG4gICAgZGVyaXZhdGl2ZSA9IGZ1bmN0aW9uKHVuZGFtcGVkRnJlcTIpIHtcbiAgICAgIHZhciBleHBvbmVudGlhbERlY2F5ID0gdW5kYW1wZWRGcmVxMiAqIGRhbXBpbmdSYXRpbztcbiAgICAgIHZhciBkZWx0YTIgPSBleHBvbmVudGlhbERlY2F5ICogZHVyYXRpb247XG4gICAgICB2YXIgZCA9IGRlbHRhMiAqIHZlbG9jaXR5ICsgdmVsb2NpdHk7XG4gICAgICB2YXIgZSA9IE1hdGgucG93KGRhbXBpbmdSYXRpbywgMikgKiBNYXRoLnBvdyh1bmRhbXBlZEZyZXEyLCAyKSAqIGR1cmF0aW9uO1xuICAgICAgdmFyIGYgPSBNYXRoLmV4cCgtZGVsdGEyKTtcbiAgICAgIHZhciBnID0gY2FsY0FuZ3VsYXJGcmVxKE1hdGgucG93KHVuZGFtcGVkRnJlcTIsIDIpLCBkYW1waW5nUmF0aW8pO1xuICAgICAgdmFyIGZhY3RvciA9IC1lbnZlbG9wZSh1bmRhbXBlZEZyZXEyKSArIHNhZmVNaW4gPiAwID8gLTEgOiAxO1xuICAgICAgcmV0dXJuIGZhY3RvciAqICgoZCAtIGUpICogZikgLyBnO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZW52ZWxvcGUgPSBmdW5jdGlvbih1bmRhbXBlZEZyZXEyKSB7XG4gICAgICB2YXIgYTIgPSBNYXRoLmV4cCgtdW5kYW1wZWRGcmVxMiAqIGR1cmF0aW9uKTtcbiAgICAgIHZhciBiMiA9ICh1bmRhbXBlZEZyZXEyIC0gdmVsb2NpdHkpICogZHVyYXRpb24gKyAxO1xuICAgICAgcmV0dXJuIC1zYWZlTWluICsgYTIgKiBiMjtcbiAgICB9O1xuICAgIGRlcml2YXRpdmUgPSBmdW5jdGlvbih1bmRhbXBlZEZyZXEyKSB7XG4gICAgICB2YXIgYTIgPSBNYXRoLmV4cCgtdW5kYW1wZWRGcmVxMiAqIGR1cmF0aW9uKTtcbiAgICAgIHZhciBiMiA9ICh2ZWxvY2l0eSAtIHVuZGFtcGVkRnJlcTIpICogKGR1cmF0aW9uICogZHVyYXRpb24pO1xuICAgICAgcmV0dXJuIGEyICogYjI7XG4gICAgfTtcbiAgfVxuICB2YXIgaW5pdGlhbEd1ZXNzID0gNSAvIGR1cmF0aW9uO1xuICB2YXIgdW5kYW1wZWRGcmVxID0gYXBwcm94aW1hdGVSb290KGVudmVsb3BlLCBkZXJpdmF0aXZlLCBpbml0aWFsR3Vlc3MpO1xuICBkdXJhdGlvbiA9IGR1cmF0aW9uICogMWUzO1xuICBpZiAoaXNOYU4odW5kYW1wZWRGcmVxKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGlmZm5lc3M6IDEwMCxcbiAgICAgIGRhbXBpbmc6IDEwLFxuICAgICAgZHVyYXRpb25cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciBzdGlmZm5lc3MgPSBNYXRoLnBvdyh1bmRhbXBlZEZyZXEsIDIpICogbWFzcztcbiAgICByZXR1cm4ge1xuICAgICAgc3RpZmZuZXNzLFxuICAgICAgZGFtcGluZzogZGFtcGluZ1JhdGlvICogMiAqIE1hdGguc3FydChtYXNzICogc3RpZmZuZXNzKSxcbiAgICAgIGR1cmF0aW9uXG4gICAgfTtcbiAgfVxufVxudmFyIHJvb3RJdGVyYXRpb25zID0gMTI7XG5mdW5jdGlvbiBhcHByb3hpbWF0ZVJvb3QoZW52ZWxvcGUsIGRlcml2YXRpdmUsIGluaXRpYWxHdWVzcykge1xuICB2YXIgcmVzdWx0ID0gaW5pdGlhbEd1ZXNzO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IHJvb3RJdGVyYXRpb25zOyBpKyspIHtcbiAgICByZXN1bHQgPSByZXN1bHQgLSBlbnZlbG9wZShyZXN1bHQpIC8gZGVyaXZhdGl2ZShyZXN1bHQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjYWxjQW5ndWxhckZyZXEodW5kYW1wZWRGcmVxLCBkYW1waW5nUmF0aW8pIHtcbiAgcmV0dXJuIHVuZGFtcGVkRnJlcSAqIE1hdGguc3FydCgxIC0gZGFtcGluZ1JhdGlvICogZGFtcGluZ1JhdGlvKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbnMvZ2VuZXJhdG9ycy9zcHJpbmcuanNcbnZhciBkdXJhdGlvbktleXMgPSBbXCJkdXJhdGlvblwiLCBcImJvdW5jZVwiXTtcbnZhciBwaHlzaWNzS2V5cyA9IFtcInN0aWZmbmVzc1wiLCBcImRhbXBpbmdcIiwgXCJtYXNzXCJdO1xuZnVuY3Rpb24gaXNTcHJpbmdUeXBlKG9wdGlvbnMsIGtleXMyKSB7XG4gIHJldHVybiBrZXlzMi5zb21lKGZ1bmN0aW9uKGtleTYpIHtcbiAgICByZXR1cm4gb3B0aW9uc1trZXk2XSAhPT0gdm9pZCAwO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFNwcmluZ09wdGlvbnMob3B0aW9ucykge1xuICB2YXIgc3ByaW5nT3B0aW9ucyA9IF9fYXNzaWduKHsgdmVsb2NpdHk6IDAsIHN0aWZmbmVzczogMTAwLCBkYW1waW5nOiAxMCwgbWFzczogMSwgaXNSZXNvbHZlZEZyb21EdXJhdGlvbjogZmFsc2UgfSwgb3B0aW9ucyk7XG4gIGlmICghaXNTcHJpbmdUeXBlKG9wdGlvbnMsIHBoeXNpY3NLZXlzKSAmJiBpc1NwcmluZ1R5cGUob3B0aW9ucywgZHVyYXRpb25LZXlzKSkge1xuICAgIHZhciBkZXJpdmVkID0gZmluZFNwcmluZyhvcHRpb25zKTtcbiAgICBzcHJpbmdPcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIHNwcmluZ09wdGlvbnMpLCBkZXJpdmVkKSwgeyB2ZWxvY2l0eTogMCwgbWFzczogMSB9KTtcbiAgICBzcHJpbmdPcHRpb25zLmlzUmVzb2x2ZWRGcm9tRHVyYXRpb24gPSB0cnVlO1xuICB9XG4gIHJldHVybiBzcHJpbmdPcHRpb25zO1xufVxuZnVuY3Rpb24gc3ByaW5nKF9hKSB7XG4gIHZhciBfYiA9IF9hLmZyb20sIGZyb20gPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iLCBfYyA9IF9hLnRvLCB0byA9IF9jID09PSB2b2lkIDAgPyAxIDogX2MsIF9kID0gX2EucmVzdFNwZWVkLCByZXN0U3BlZWQgPSBfZCA9PT0gdm9pZCAwID8gMiA6IF9kLCByZXN0RGVsdGEgPSBfYS5yZXN0RGVsdGEsIG9wdGlvbnMgPSBfX3Jlc3QoX2EsIFtcImZyb21cIiwgXCJ0b1wiLCBcInJlc3RTcGVlZFwiLCBcInJlc3REZWx0YVwiXSk7XG4gIHZhciBzdGF0ZSA9IHsgZG9uZTogZmFsc2UsIHZhbHVlOiBmcm9tIH07XG4gIHZhciBfZSA9IGdldFNwcmluZ09wdGlvbnMob3B0aW9ucyksIHN0aWZmbmVzcyA9IF9lLnN0aWZmbmVzcywgZGFtcGluZyA9IF9lLmRhbXBpbmcsIG1hc3MgPSBfZS5tYXNzLCB2ZWxvY2l0eSA9IF9lLnZlbG9jaXR5LCBkdXJhdGlvbiA9IF9lLmR1cmF0aW9uLCBpc1Jlc29sdmVkRnJvbUR1cmF0aW9uID0gX2UuaXNSZXNvbHZlZEZyb21EdXJhdGlvbjtcbiAgdmFyIHJlc29sdmVTcHJpbmcgPSB6ZXJvO1xuICB2YXIgcmVzb2x2ZVZlbG9jaXR5ID0gemVybztcbiAgZnVuY3Rpb24gY3JlYXRlU3ByaW5nKCkge1xuICAgIHZhciBpbml0aWFsVmVsb2NpdHkgPSB2ZWxvY2l0eSA/IC0odmVsb2NpdHkgLyAxZTMpIDogMDtcbiAgICB2YXIgaW5pdGlhbERlbHRhID0gdG8gLSBmcm9tO1xuICAgIHZhciBkYW1waW5nUmF0aW8gPSBkYW1waW5nIC8gKDIgKiBNYXRoLnNxcnQoc3RpZmZuZXNzICogbWFzcykpO1xuICAgIHZhciB1bmRhbXBlZEFuZ3VsYXJGcmVxID0gTWF0aC5zcXJ0KHN0aWZmbmVzcyAvIG1hc3MpIC8gMWUzO1xuICAgIHJlc3REZWx0YSAhPT0gbnVsbCAmJiByZXN0RGVsdGEgIT09IHZvaWQgMCA/IHJlc3REZWx0YSA6IHJlc3REZWx0YSA9IE1hdGguYWJzKHRvIC0gZnJvbSkgPD0gMSA/IDAuMDEgOiAwLjQ7XG4gICAgaWYgKGRhbXBpbmdSYXRpbyA8IDEpIHtcbiAgICAgIHZhciBhbmd1bGFyRnJlcV8xID0gY2FsY0FuZ3VsYXJGcmVxKHVuZGFtcGVkQW5ndWxhckZyZXEsIGRhbXBpbmdSYXRpbyk7XG4gICAgICByZXNvbHZlU3ByaW5nID0gZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgZW52ZWxvcGUgPSBNYXRoLmV4cCgtZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIHQpO1xuICAgICAgICByZXR1cm4gdG8gLSBlbnZlbG9wZSAqICgoaW5pdGlhbFZlbG9jaXR5ICsgZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIGluaXRpYWxEZWx0YSkgLyBhbmd1bGFyRnJlcV8xICogTWF0aC5zaW4oYW5ndWxhckZyZXFfMSAqIHQpICsgaW5pdGlhbERlbHRhICogTWF0aC5jb3MoYW5ndWxhckZyZXFfMSAqIHQpKTtcbiAgICAgIH07XG4gICAgICByZXNvbHZlVmVsb2NpdHkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBlbnZlbG9wZSA9IE1hdGguZXhwKC1kYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogdCk7XG4gICAgICAgIHJldHVybiBkYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogZW52ZWxvcGUgKiAoTWF0aC5zaW4oYW5ndWxhckZyZXFfMSAqIHQpICogKGluaXRpYWxWZWxvY2l0eSArIGRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiBpbml0aWFsRGVsdGEpIC8gYW5ndWxhckZyZXFfMSArIGluaXRpYWxEZWx0YSAqIE1hdGguY29zKGFuZ3VsYXJGcmVxXzEgKiB0KSkgLSBlbnZlbG9wZSAqIChNYXRoLmNvcyhhbmd1bGFyRnJlcV8xICogdCkgKiAoaW5pdGlhbFZlbG9jaXR5ICsgZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIGluaXRpYWxEZWx0YSkgLSBhbmd1bGFyRnJlcV8xICogaW5pdGlhbERlbHRhICogTWF0aC5zaW4oYW5ndWxhckZyZXFfMSAqIHQpKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkYW1waW5nUmF0aW8gPT09IDEpIHtcbiAgICAgIHJlc29sdmVTcHJpbmcgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0byAtIE1hdGguZXhwKC11bmRhbXBlZEFuZ3VsYXJGcmVxICogdCkgKiAoaW5pdGlhbERlbHRhICsgKGluaXRpYWxWZWxvY2l0eSArIHVuZGFtcGVkQW5ndWxhckZyZXEgKiBpbml0aWFsRGVsdGEpICogdCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGFtcGVkQW5ndWxhckZyZXFfMSA9IHVuZGFtcGVkQW5ndWxhckZyZXEgKiBNYXRoLnNxcnQoZGFtcGluZ1JhdGlvICogZGFtcGluZ1JhdGlvIC0gMSk7XG4gICAgICByZXNvbHZlU3ByaW5nID0gZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgZW52ZWxvcGUgPSBNYXRoLmV4cCgtZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIHQpO1xuICAgICAgICB2YXIgZnJlcUZvclQgPSBNYXRoLm1pbihkYW1wZWRBbmd1bGFyRnJlcV8xICogdCwgMzAwKTtcbiAgICAgICAgcmV0dXJuIHRvIC0gZW52ZWxvcGUgKiAoKGluaXRpYWxWZWxvY2l0eSArIGRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiBpbml0aWFsRGVsdGEpICogTWF0aC5zaW5oKGZyZXFGb3JUKSArIGRhbXBlZEFuZ3VsYXJGcmVxXzEgKiBpbml0aWFsRGVsdGEgKiBNYXRoLmNvc2goZnJlcUZvclQpKSAvIGRhbXBlZEFuZ3VsYXJGcmVxXzE7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBjcmVhdGVTcHJpbmcoKTtcbiAgcmV0dXJuIHtcbiAgICBuZXh0OiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgY3VycmVudCA9IHJlc29sdmVTcHJpbmcodCk7XG4gICAgICBpZiAoIWlzUmVzb2x2ZWRGcm9tRHVyYXRpb24pIHtcbiAgICAgICAgdmFyIGN1cnJlbnRWZWxvY2l0eSA9IHJlc29sdmVWZWxvY2l0eSh0KSAqIDFlMztcbiAgICAgICAgdmFyIGlzQmVsb3dWZWxvY2l0eVRocmVzaG9sZCA9IE1hdGguYWJzKGN1cnJlbnRWZWxvY2l0eSkgPD0gcmVzdFNwZWVkO1xuICAgICAgICB2YXIgaXNCZWxvd0Rpc3BsYWNlbWVudFRocmVzaG9sZCA9IE1hdGguYWJzKHRvIC0gY3VycmVudCkgPD0gcmVzdERlbHRhO1xuICAgICAgICBzdGF0ZS5kb25lID0gaXNCZWxvd1ZlbG9jaXR5VGhyZXNob2xkICYmIGlzQmVsb3dEaXNwbGFjZW1lbnRUaHJlc2hvbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5kb25lID0gdCA+PSBkdXJhdGlvbjtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnZhbHVlID0gc3RhdGUuZG9uZSA/IHRvIDogY3VycmVudDtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuICAgIGZsaXBUYXJnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIHZlbG9jaXR5ID0gLXZlbG9jaXR5O1xuICAgICAgX2EyID0gW3RvLCBmcm9tXSwgZnJvbSA9IF9hMlswXSwgdG8gPSBfYTJbMV07XG4gICAgICBjcmVhdGVTcHJpbmcoKTtcbiAgICB9XG4gIH07XG59XG5zcHJpbmcubmVlZHNJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24oYTIsIGIyKSB7XG4gIHJldHVybiB0eXBlb2YgYTIgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGIyID09PSBcInN0cmluZ1wiO1xufTtcbnZhciB6ZXJvID0gZnVuY3Rpb24oX3QpIHtcbiAgcmV0dXJuIDA7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvcHJvZ3Jlc3MuanNcbnZhciBwcm9ncmVzcyA9IGZ1bmN0aW9uKGZyb20sIHRvLCB2YWx1ZSkge1xuICB2YXIgdG9Gcm9tRGlmZmVyZW5jZSA9IHRvIC0gZnJvbTtcbiAgcmV0dXJuIHRvRnJvbURpZmZlcmVuY2UgPT09IDAgPyAxIDogKHZhbHVlIC0gZnJvbSkgLyB0b0Zyb21EaWZmZXJlbmNlO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL21peC5qc1xudmFyIG1peCA9IGZ1bmN0aW9uKGZyb20sIHRvLCBwcm9ncmVzczIpIHtcbiAgcmV0dXJuIC1wcm9ncmVzczIgKiBmcm9tICsgcHJvZ3Jlc3MyICogdG8gKyBmcm9tO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL21peC1jb2xvci5qc1xudmFyIG1peExpbmVhckNvbG9yID0gZnVuY3Rpb24oZnJvbSwgdG8sIHYpIHtcbiAgdmFyIGZyb21FeHBvID0gZnJvbSAqIGZyb207XG4gIHZhciB0b0V4cG8gPSB0byAqIHRvO1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIHYgKiAodG9FeHBvIC0gZnJvbUV4cG8pICsgZnJvbUV4cG8pKTtcbn07XG52YXIgY29sb3JUeXBlcyA9IFtoZXgsIHJnYmEsIGhzbGFdO1xudmFyIGdldENvbG9yVHlwZSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIGNvbG9yVHlwZXMuZmluZChmdW5jdGlvbih0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUudGVzdCh2KTtcbiAgfSk7XG59O1xudmFyIG5vdEFuaW1hdGFibGUgPSBmdW5jdGlvbihjb2xvcjIpIHtcbiAgcmV0dXJuIFwiJ1wiICsgY29sb3IyICsgXCInIGlzIG5vdCBhbiBhbmltYXRhYmxlIGNvbG9yLiBVc2UgdGhlIGVxdWl2YWxlbnQgY29sb3IgY29kZSBpbnN0ZWFkLlwiO1xufTtcbnZhciBtaXhDb2xvciA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIHZhciBmcm9tQ29sb3JUeXBlID0gZ2V0Q29sb3JUeXBlKGZyb20pO1xuICB2YXIgdG9Db2xvclR5cGUgPSBnZXRDb2xvclR5cGUodG8pO1xuICBpbnZhcmlhbnQoISFmcm9tQ29sb3JUeXBlLCBub3RBbmltYXRhYmxlKGZyb20pKTtcbiAgaW52YXJpYW50KCEhdG9Db2xvclR5cGUsIG5vdEFuaW1hdGFibGUodG8pKTtcbiAgaW52YXJpYW50KGZyb21Db2xvclR5cGUudHJhbnNmb3JtID09PSB0b0NvbG9yVHlwZS50cmFuc2Zvcm0sIFwiQm90aCBjb2xvcnMgbXVzdCBiZSBoZXgvUkdCQSwgT1IgYm90aCBtdXN0IGJlIEhTTEEuXCIpO1xuICB2YXIgZnJvbUNvbG9yID0gZnJvbUNvbG9yVHlwZS5wYXJzZShmcm9tKTtcbiAgdmFyIHRvQ29sb3IgPSB0b0NvbG9yVHlwZS5wYXJzZSh0byk7XG4gIHZhciBibGVuZGVkID0gX19hc3NpZ24oe30sIGZyb21Db2xvcik7XG4gIHZhciBtaXhGdW5jID0gZnJvbUNvbG9yVHlwZSA9PT0gaHNsYSA/IG1peCA6IG1peExpbmVhckNvbG9yO1xuICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgIGZvciAodmFyIGtleTYgaW4gYmxlbmRlZCkge1xuICAgICAgaWYgKGtleTYgIT09IFwiYWxwaGFcIikge1xuICAgICAgICBibGVuZGVkW2tleTZdID0gbWl4RnVuYyhmcm9tQ29sb3Jba2V5Nl0sIHRvQ29sb3Jba2V5Nl0sIHYpO1xuICAgICAgfVxuICAgIH1cbiAgICBibGVuZGVkLmFscGhhID0gbWl4KGZyb21Db2xvci5hbHBoYSwgdG9Db2xvci5hbHBoYSwgdik7XG4gICAgcmV0dXJuIGZyb21Db2xvclR5cGUudHJhbnNmb3JtKGJsZW5kZWQpO1xuICB9O1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL2luYy5qc1xudmFyIGlzTnVtID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCI7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvcGlwZS5qc1xudmFyIGNvbWJpbmVGdW5jdGlvbnMgPSBmdW5jdGlvbihhMiwgYjIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gYjIoYTIodikpO1xuICB9O1xufTtcbnZhciBwaXBlID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0cmFuc2Zvcm1lcnMgPSBbXTtcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICB0cmFuc2Zvcm1lcnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtZXJzLnJlZHVjZShjb21iaW5lRnVuY3Rpb25zKTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9taXgtY29tcGxleC5qc1xuZnVuY3Rpb24gZ2V0TWl4ZXIob3JpZ2luLCB0YXJnZXQpIHtcbiAgaWYgKGlzTnVtKG9yaWdpbikpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIG1peChvcmlnaW4sIHRhcmdldCwgdik7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChjb2xvci50ZXN0KG9yaWdpbikpIHtcbiAgICByZXR1cm4gbWl4Q29sb3Iob3JpZ2luLCB0YXJnZXQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtaXhDb21wbGV4KG9yaWdpbiwgdGFyZ2V0KTtcbiAgfVxufVxudmFyIG1peEFycmF5ID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgdmFyIG91dHB1dCA9IF9fc3ByZWFkQXJyYXkoW10sIGZyb20pO1xuICB2YXIgbnVtVmFsdWVzID0gb3V0cHV0Lmxlbmd0aDtcbiAgdmFyIGJsZW5kVmFsdWUgPSBmcm9tLm1hcChmdW5jdGlvbihmcm9tVGhpcywgaSkge1xuICAgIHJldHVybiBnZXRNaXhlcihmcm9tVGhpcywgdG9baV0pO1xuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVZhbHVlczsgaSsrKSB7XG4gICAgICBvdXRwdXRbaV0gPSBibGVuZFZhbHVlW2ldKHYpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xufTtcbnZhciBtaXhPYmplY3QgPSBmdW5jdGlvbihvcmlnaW4sIHRhcmdldCkge1xuICB2YXIgb3V0cHV0ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG9yaWdpbiksIHRhcmdldCk7XG4gIHZhciBibGVuZFZhbHVlID0ge307XG4gIGZvciAodmFyIGtleTYgaW4gb3V0cHV0KSB7XG4gICAgaWYgKG9yaWdpbltrZXk2XSAhPT0gdm9pZCAwICYmIHRhcmdldFtrZXk2XSAhPT0gdm9pZCAwKSB7XG4gICAgICBibGVuZFZhbHVlW2tleTZdID0gZ2V0TWl4ZXIob3JpZ2luW2tleTZdLCB0YXJnZXRba2V5Nl0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgIGZvciAodmFyIGtleTcgaW4gYmxlbmRWYWx1ZSkge1xuICAgICAgb3V0cHV0W2tleTddID0gYmxlbmRWYWx1ZVtrZXk3XSh2KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbn07XG5mdW5jdGlvbiBhbmFseXNlMih2YWx1ZSkge1xuICB2YXIgcGFyc2VkID0gY29tcGxleC5wYXJzZSh2YWx1ZSk7XG4gIHZhciBudW1WYWx1ZXMgPSBwYXJzZWQubGVuZ3RoO1xuICB2YXIgbnVtTnVtYmVycyA9IDA7XG4gIHZhciBudW1SR0IgPSAwO1xuICB2YXIgbnVtSFNMID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1WYWx1ZXM7IGkrKykge1xuICAgIGlmIChudW1OdW1iZXJzIHx8IHR5cGVvZiBwYXJzZWRbaV0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIG51bU51bWJlcnMrKztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhcnNlZFtpXS5odWUgIT09IHZvaWQgMCkge1xuICAgICAgICBudW1IU0wrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG51bVJHQisrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4geyBwYXJzZWQsIG51bU51bWJlcnMsIG51bVJHQiwgbnVtSFNMIH07XG59XG52YXIgbWl4Q29tcGxleCA9IGZ1bmN0aW9uKG9yaWdpbiwgdGFyZ2V0KSB7XG4gIHZhciB0ZW1wbGF0ZSA9IGNvbXBsZXguY3JlYXRlVHJhbnNmb3JtZXIodGFyZ2V0KTtcbiAgdmFyIG9yaWdpblN0YXRzID0gYW5hbHlzZTIob3JpZ2luKTtcbiAgdmFyIHRhcmdldFN0YXRzID0gYW5hbHlzZTIodGFyZ2V0KTtcbiAgaW52YXJpYW50KG9yaWdpblN0YXRzLm51bUhTTCA9PT0gdGFyZ2V0U3RhdHMubnVtSFNMICYmIG9yaWdpblN0YXRzLm51bVJHQiA9PT0gdGFyZ2V0U3RhdHMubnVtUkdCICYmIG9yaWdpblN0YXRzLm51bU51bWJlcnMgPj0gdGFyZ2V0U3RhdHMubnVtTnVtYmVycywgXCJDb21wbGV4IHZhbHVlcyAnXCIgKyBvcmlnaW4gKyBcIicgYW5kICdcIiArIHRhcmdldCArIFwiJyB0b28gZGlmZmVyZW50IHRvIG1peC4gRW5zdXJlIGFsbCBjb2xvcnMgYXJlIG9mIHRoZSBzYW1lIHR5cGUuXCIpO1xuICByZXR1cm4gcGlwZShtaXhBcnJheShvcmlnaW5TdGF0cy5wYXJzZWQsIHRhcmdldFN0YXRzLnBhcnNlZCksIHRlbXBsYXRlKTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9pbnRlcnBvbGF0ZS5qc1xudmFyIG1peE51bWJlciA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIHJldHVybiBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIG1peChmcm9tLCB0bywgcCk7XG4gIH07XG59O1xuZnVuY3Rpb24gZGV0ZWN0TWl4ZXJGYWN0b3J5KHYpIHtcbiAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIG1peE51bWJlcjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChjb2xvci50ZXN0KHYpKSB7XG4gICAgICByZXR1cm4gbWl4Q29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtaXhDb21wbGV4O1xuICAgIH1cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgcmV0dXJuIG1peEFycmF5O1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIG1peE9iamVjdDtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlTWl4ZXJzKG91dHB1dCwgZWFzZSwgY3VzdG9tTWl4ZXIpIHtcbiAgdmFyIG1peGVycyA9IFtdO1xuICB2YXIgbWl4ZXJGYWN0b3J5ID0gY3VzdG9tTWl4ZXIgfHwgZGV0ZWN0TWl4ZXJGYWN0b3J5KG91dHB1dFswXSk7XG4gIHZhciBudW1NaXhlcnMgPSBvdXRwdXQubGVuZ3RoIC0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1NaXhlcnM7IGkrKykge1xuICAgIHZhciBtaXhlciA9IG1peGVyRmFjdG9yeShvdXRwdXRbaV0sIG91dHB1dFtpICsgMV0pO1xuICAgIGlmIChlYXNlKSB7XG4gICAgICB2YXIgZWFzaW5nRnVuY3Rpb24gPSBBcnJheS5pc0FycmF5KGVhc2UpID8gZWFzZVtpXSA6IGVhc2U7XG4gICAgICBtaXhlciA9IHBpcGUoZWFzaW5nRnVuY3Rpb24sIG1peGVyKTtcbiAgICB9XG4gICAgbWl4ZXJzLnB1c2gobWl4ZXIpO1xuICB9XG4gIHJldHVybiBtaXhlcnM7XG59XG5mdW5jdGlvbiBmYXN0SW50ZXJwb2xhdGUoX2EsIF9iKSB7XG4gIHZhciBmcm9tID0gX2FbMF0sIHRvID0gX2FbMV07XG4gIHZhciBtaXhlciA9IF9iWzBdO1xuICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBtaXhlcihwcm9ncmVzcyhmcm9tLCB0bywgdikpO1xuICB9O1xufVxuZnVuY3Rpb24gc2xvd0ludGVycG9sYXRlKGlucHV0LCBtaXhlcnMpIHtcbiAgdmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICB2YXIgbGFzdElucHV0SW5kZXggPSBpbnB1dExlbmd0aCAtIDE7XG4gIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG1peGVySW5kZXggPSAwO1xuICAgIHZhciBmb3VuZE1peGVySW5kZXggPSBmYWxzZTtcbiAgICBpZiAodiA8PSBpbnB1dFswXSkge1xuICAgICAgZm91bmRNaXhlckluZGV4ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHYgPj0gaW5wdXRbbGFzdElucHV0SW5kZXhdKSB7XG4gICAgICBtaXhlckluZGV4ID0gbGFzdElucHV0SW5kZXggLSAxO1xuICAgICAgZm91bmRNaXhlckluZGV4ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFmb3VuZE1peGVySW5kZXgpIHtcbiAgICAgIHZhciBpID0gMTtcbiAgICAgIGZvciAoOyBpIDwgaW5wdXRMZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5wdXRbaV0gPiB2IHx8IGkgPT09IGxhc3RJbnB1dEluZGV4KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1peGVySW5kZXggPSBpIC0gMTtcbiAgICB9XG4gICAgdmFyIHByb2dyZXNzSW5SYW5nZSA9IHByb2dyZXNzKGlucHV0W21peGVySW5kZXhdLCBpbnB1dFttaXhlckluZGV4ICsgMV0sIHYpO1xuICAgIHJldHVybiBtaXhlcnNbbWl4ZXJJbmRleF0ocHJvZ3Jlc3NJblJhbmdlKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlKGlucHV0LCBvdXRwdXQsIF9hKSB7XG4gIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLmNsYW1wLCBpc0NsYW1wID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYywgZWFzZSA9IF9iLmVhc2UsIG1peGVyID0gX2IubWl4ZXI7XG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgaW52YXJpYW50KGlucHV0TGVuZ3RoID09PSBvdXRwdXQubGVuZ3RoLCBcIkJvdGggaW5wdXQgYW5kIG91dHB1dCByYW5nZXMgbXVzdCBiZSB0aGUgc2FtZSBsZW5ndGhcIik7XG4gIGludmFyaWFudCghZWFzZSB8fCAhQXJyYXkuaXNBcnJheShlYXNlKSB8fCBlYXNlLmxlbmd0aCA9PT0gaW5wdXRMZW5ndGggLSAxLCBcIkFycmF5IG9mIGVhc2luZyBmdW5jdGlvbnMgbXVzdCBiZSBvZiBsZW5ndGggYGlucHV0Lmxlbmd0aCAtIDFgLCBhcyBpdCBhcHBsaWVzIHRvIHRoZSB0cmFuc2l0aW9ucyAqKmJldHdlZW4qKiB0aGUgZGVmaW5lZCB2YWx1ZXMuXCIpO1xuICBpZiAoaW5wdXRbMF0gPiBpbnB1dFtpbnB1dExlbmd0aCAtIDFdKSB7XG4gICAgaW5wdXQgPSBbXS5jb25jYXQoaW5wdXQpO1xuICAgIG91dHB1dCA9IFtdLmNvbmNhdChvdXRwdXQpO1xuICAgIGlucHV0LnJldmVyc2UoKTtcbiAgICBvdXRwdXQucmV2ZXJzZSgpO1xuICB9XG4gIHZhciBtaXhlcnMgPSBjcmVhdGVNaXhlcnMob3V0cHV0LCBlYXNlLCBtaXhlcik7XG4gIHZhciBpbnRlcnBvbGF0b3IgPSBpbnB1dExlbmd0aCA9PT0gMiA/IGZhc3RJbnRlcnBvbGF0ZShpbnB1dCwgbWl4ZXJzKSA6IHNsb3dJbnRlcnBvbGF0ZShpbnB1dCwgbWl4ZXJzKTtcbiAgcmV0dXJuIGlzQ2xhbXAgPyBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIGludGVycG9sYXRvcihjbGFtcDIoaW5wdXRbMF0sIGlucHV0W2lucHV0TGVuZ3RoIC0gMV0sIHYpKTtcbiAgfSA6IGludGVycG9sYXRvcjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2Vhc2luZy91dGlscy5qc1xudmFyIHJldmVyc2VFYXNpbmcgPSBmdW5jdGlvbihlYXNpbmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gMSAtIGVhc2luZygxIC0gcCk7XG4gIH07XG59O1xudmFyIG1pcnJvckVhc2luZyA9IGZ1bmN0aW9uKGVhc2luZykge1xuICByZXR1cm4gZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiBwIDw9IDAuNSA/IGVhc2luZygyICogcCkgLyAyIDogKDIgLSBlYXNpbmcoMiAqICgxIC0gcCkpKSAvIDI7XG4gIH07XG59O1xudmFyIGNyZWF0ZUV4cG9JbiA9IGZ1bmN0aW9uKHBvd2VyKSB7XG4gIHJldHVybiBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHAsIHBvd2VyKTtcbiAgfTtcbn07XG52YXIgY3JlYXRlQmFja0luID0gZnVuY3Rpb24ocG93ZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gcCAqIHAgKiAoKHBvd2VyICsgMSkgKiBwIC0gcG93ZXIpO1xuICB9O1xufTtcbnZhciBjcmVhdGVBbnRpY2lwYXRlID0gZnVuY3Rpb24ocG93ZXIpIHtcbiAgdmFyIGJhY2tFYXNpbmcgPSBjcmVhdGVCYWNrSW4ocG93ZXIpO1xuICByZXR1cm4gZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAocCAqPSAyKSA8IDEgPyAwLjUgKiBiYWNrRWFzaW5nKHApIDogMC41ICogKDIgLSBNYXRoLnBvdygyLCAtMTAgKiAocCAtIDEpKSk7XG4gIH07XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvZWFzaW5nL2luZGV4LmpzXG52YXIgREVGQVVMVF9PVkVSU0hPT1RfU1RSRU5HVEggPSAxLjUyNTtcbnZhciBCT1VOQ0VfRklSU1RfVEhSRVNIT0xEID0gNCAvIDExO1xudmFyIEJPVU5DRV9TRUNPTkRfVEhSRVNIT0xEID0gOCAvIDExO1xudmFyIEJPVU5DRV9USElSRF9USFJFU0hPTEQgPSA5IC8gMTA7XG52YXIgbGluZWFyID0gZnVuY3Rpb24ocCkge1xuICByZXR1cm4gcDtcbn07XG52YXIgZWFzZUluID0gY3JlYXRlRXhwb0luKDIpO1xudmFyIGVhc2VPdXQgPSByZXZlcnNlRWFzaW5nKGVhc2VJbik7XG52YXIgZWFzZUluT3V0ID0gbWlycm9yRWFzaW5nKGVhc2VJbik7XG52YXIgY2lyY0luID0gZnVuY3Rpb24ocCkge1xuICByZXR1cm4gMSAtIE1hdGguc2luKE1hdGguYWNvcyhwKSk7XG59O1xudmFyIGNpcmNPdXQgPSByZXZlcnNlRWFzaW5nKGNpcmNJbik7XG52YXIgY2lyY0luT3V0ID0gbWlycm9yRWFzaW5nKGNpcmNPdXQpO1xudmFyIGJhY2tJbiA9IGNyZWF0ZUJhY2tJbihERUZBVUxUX09WRVJTSE9PVF9TVFJFTkdUSCk7XG52YXIgYmFja091dCA9IHJldmVyc2VFYXNpbmcoYmFja0luKTtcbnZhciBiYWNrSW5PdXQgPSBtaXJyb3JFYXNpbmcoYmFja0luKTtcbnZhciBhbnRpY2lwYXRlID0gY3JlYXRlQW50aWNpcGF0ZShERUZBVUxUX09WRVJTSE9PVF9TVFJFTkdUSCk7XG52YXIgY2EgPSA0MzU2IC8gMzYxO1xudmFyIGNiID0gMzU0NDIgLyAxODA1O1xudmFyIGNjID0gMTYwNjEgLyAxODA1O1xudmFyIGJvdW5jZU91dCA9IGZ1bmN0aW9uKHApIHtcbiAgaWYgKHAgPT09IDEgfHwgcCA9PT0gMClcbiAgICByZXR1cm4gcDtcbiAgdmFyIHAyID0gcCAqIHA7XG4gIHJldHVybiBwIDwgQk9VTkNFX0ZJUlNUX1RIUkVTSE9MRCA/IDcuNTYyNSAqIHAyIDogcCA8IEJPVU5DRV9TRUNPTkRfVEhSRVNIT0xEID8gOS4wNzUgKiBwMiAtIDkuOSAqIHAgKyAzLjQgOiBwIDwgQk9VTkNFX1RISVJEX1RIUkVTSE9MRCA/IGNhICogcDIgLSBjYiAqIHAgKyBjYyA6IDEwLjggKiBwICogcCAtIDIwLjUyICogcCArIDEwLjcyO1xufTtcbnZhciBib3VuY2VJbiA9IHJldmVyc2VFYXNpbmcoYm91bmNlT3V0KTtcbnZhciBib3VuY2VJbk91dCA9IGZ1bmN0aW9uKHApIHtcbiAgcmV0dXJuIHAgPCAwLjUgPyAwLjUgKiAoMSAtIGJvdW5jZU91dCgxIC0gcCAqIDIpKSA6IDAuNSAqIGJvdW5jZU91dChwICogMiAtIDEpICsgMC41O1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbnMvZ2VuZXJhdG9ycy9rZXlmcmFtZXMuanNcbmZ1bmN0aW9uIGRlZmF1bHRFYXNpbmcodmFsdWVzLCBlYXNpbmcpIHtcbiAgcmV0dXJuIHZhbHVlcy5tYXAoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGVhc2luZyB8fCBlYXNlSW5PdXQ7XG4gIH0pLnNwbGljZSgwLCB2YWx1ZXMubGVuZ3RoIC0gMSk7XG59XG5mdW5jdGlvbiBkZWZhdWx0T2Zmc2V0KHZhbHVlcykge1xuICB2YXIgbnVtVmFsdWVzID0gdmFsdWVzLmxlbmd0aDtcbiAgcmV0dXJuIHZhbHVlcy5tYXAoZnVuY3Rpb24oX3ZhbHVlLCBpKSB7XG4gICAgcmV0dXJuIGkgIT09IDAgPyBpIC8gKG51bVZhbHVlcyAtIDEpIDogMDtcbiAgfSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0T2Zmc2V0VG9UaW1lcyhvZmZzZXQsIGR1cmF0aW9uKSB7XG4gIHJldHVybiBvZmZzZXQubWFwKGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gbyAqIGR1cmF0aW9uO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGtleWZyYW1lcyhfYSkge1xuICB2YXIgX2IgPSBfYS5mcm9tLCBmcm9tID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYiwgX2MgPSBfYS50bywgdG8gPSBfYyA9PT0gdm9pZCAwID8gMSA6IF9jLCBlYXNlID0gX2EuZWFzZSwgb2Zmc2V0ID0gX2Eub2Zmc2V0LCBfZCA9IF9hLmR1cmF0aW9uLCBkdXJhdGlvbiA9IF9kID09PSB2b2lkIDAgPyAzMDAgOiBfZDtcbiAgdmFyIHN0YXRlID0geyBkb25lOiBmYWxzZSwgdmFsdWU6IGZyb20gfTtcbiAgdmFyIHZhbHVlcyA9IEFycmF5LmlzQXJyYXkodG8pID8gdG8gOiBbZnJvbSwgdG9dO1xuICB2YXIgdGltZXMgPSBjb252ZXJ0T2Zmc2V0VG9UaW1lcyhvZmZzZXQgJiYgb2Zmc2V0Lmxlbmd0aCA9PT0gdmFsdWVzLmxlbmd0aCA/IG9mZnNldCA6IGRlZmF1bHRPZmZzZXQodmFsdWVzKSwgZHVyYXRpb24pO1xuICBmdW5jdGlvbiBjcmVhdGVJbnRlcnBvbGF0b3IoKSB7XG4gICAgcmV0dXJuIGludGVycG9sYXRlKHRpbWVzLCB2YWx1ZXMsIHtcbiAgICAgIGVhc2U6IEFycmF5LmlzQXJyYXkoZWFzZSkgPyBlYXNlIDogZGVmYXVsdEVhc2luZyh2YWx1ZXMsIGVhc2UpXG4gICAgfSk7XG4gIH1cbiAgdmFyIGludGVycG9sYXRvciA9IGNyZWF0ZUludGVycG9sYXRvcigpO1xuICByZXR1cm4ge1xuICAgIG5leHQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHN0YXRlLnZhbHVlID0gaW50ZXJwb2xhdG9yKHQpO1xuICAgICAgc3RhdGUuZG9uZSA9IHQgPj0gZHVyYXRpb247XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcbiAgICBmbGlwVGFyZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhbHVlcy5yZXZlcnNlKCk7XG4gICAgICBpbnRlcnBvbGF0b3IgPSBjcmVhdGVJbnRlcnBvbGF0b3IoKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9hbmltYXRpb25zL2dlbmVyYXRvcnMvZGVjYXkuanNcbmZ1bmN0aW9uIGRlY2F5KF9hKSB7XG4gIHZhciBfYiA9IF9hLnZlbG9jaXR5LCB2ZWxvY2l0eSA9IF9iID09PSB2b2lkIDAgPyAwIDogX2IsIF9jID0gX2EuZnJvbSwgZnJvbSA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsIF9kID0gX2EucG93ZXIsIHBvd2VyID0gX2QgPT09IHZvaWQgMCA/IDAuOCA6IF9kLCBfZSA9IF9hLnRpbWVDb25zdGFudCwgdGltZUNvbnN0YW50MiA9IF9lID09PSB2b2lkIDAgPyAzNTAgOiBfZSwgX2YgPSBfYS5yZXN0RGVsdGEsIHJlc3REZWx0YSA9IF9mID09PSB2b2lkIDAgPyAwLjUgOiBfZiwgbW9kaWZ5VGFyZ2V0ID0gX2EubW9kaWZ5VGFyZ2V0O1xuICB2YXIgc3RhdGUgPSB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogZnJvbSB9O1xuICB2YXIgYW1wbGl0dWRlID0gcG93ZXIgKiB2ZWxvY2l0eTtcbiAgdmFyIGlkZWFsID0gZnJvbSArIGFtcGxpdHVkZTtcbiAgdmFyIHRhcmdldCA9IG1vZGlmeVRhcmdldCA9PT0gdm9pZCAwID8gaWRlYWwgOiBtb2RpZnlUYXJnZXQoaWRlYWwpO1xuICBpZiAodGFyZ2V0ICE9PSBpZGVhbClcbiAgICBhbXBsaXR1ZGUgPSB0YXJnZXQgLSBmcm9tO1xuICByZXR1cm4ge1xuICAgIG5leHQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBkZWx0YTIgPSAtYW1wbGl0dWRlICogTWF0aC5leHAoLXQgLyB0aW1lQ29uc3RhbnQyKTtcbiAgICAgIHN0YXRlLmRvbmUgPSAhKGRlbHRhMiA+IHJlc3REZWx0YSB8fCBkZWx0YTIgPCAtcmVzdERlbHRhKTtcbiAgICAgIHN0YXRlLnZhbHVlID0gc3RhdGUuZG9uZSA/IHRhcmdldCA6IHRhcmdldCArIGRlbHRhMjtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuICAgIGZsaXBUYXJnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIH1cbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbnMvdXRpbHMvZGV0ZWN0LWFuaW1hdGlvbi1mcm9tLW9wdGlvbnMuanNcbnZhciB0eXBlcyA9IHsga2V5ZnJhbWVzLCBzcHJpbmcsIGRlY2F5IH07XG5mdW5jdGlvbiBkZXRlY3RBbmltYXRpb25Gcm9tT3B0aW9ucyhjb25maWcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLnRvKSkge1xuICAgIHJldHVybiBrZXlmcmFtZXM7XG4gIH0gZWxzZSBpZiAodHlwZXNbY29uZmlnLnR5cGVdKSB7XG4gICAgcmV0dXJuIHR5cGVzW2NvbmZpZy50eXBlXTtcbiAgfVxuICB2YXIga2V5czIgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGNvbmZpZykpO1xuICBpZiAoa2V5czIuaGFzKFwiZWFzZVwiKSB8fCBrZXlzMi5oYXMoXCJkdXJhdGlvblwiKSAmJiAha2V5czIuaGFzKFwiZGFtcGluZ1JhdGlvXCIpKSB7XG4gICAgcmV0dXJuIGtleWZyYW1lcztcbiAgfSBlbHNlIGlmIChrZXlzMi5oYXMoXCJkYW1waW5nUmF0aW9cIikgfHwga2V5czIuaGFzKFwic3RpZmZuZXNzXCIpIHx8IGtleXMyLmhhcyhcIm1hc3NcIikgfHwga2V5czIuaGFzKFwiZGFtcGluZ1wiKSB8fCBrZXlzMi5oYXMoXCJyZXN0U3BlZWRcIikgfHwga2V5czIuaGFzKFwicmVzdERlbHRhXCIpKSB7XG4gICAgcmV0dXJuIHNwcmluZztcbiAgfVxuICByZXR1cm4ga2V5ZnJhbWVzO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVzeW5jL2Rpc3QvZXMvb24tbmV4dC1mcmFtZS5qc1xudmFyIGRlZmF1bHRUaW1lc3RlcCA9IDEgLyA2MCAqIDFlMztcbnZhciBnZXRDdXJyZW50VGltZSA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIiA/IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG59IDogZnVuY3Rpb24oKSB7XG4gIHJldHVybiBEYXRlLm5vdygpO1xufTtcbnZhciBvbk5leHRGcmFtZSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyBmdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XG59IDogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGdldEN1cnJlbnRUaW1lKCkpO1xuICB9LCBkZWZhdWx0VGltZXN0ZXApO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lc3luYy9kaXN0L2VzL2NyZWF0ZS1yZW5kZXItc3RlcC5qc1xuZnVuY3Rpb24gY3JlYXRlUmVuZGVyU3RlcChydW5OZXh0RnJhbWUyKSB7XG4gIHZhciB0b1J1biA9IFtdO1xuICB2YXIgdG9SdW5OZXh0RnJhbWUgPSBbXTtcbiAgdmFyIG51bVRvUnVuID0gMDtcbiAgdmFyIGlzUHJvY2Vzc2luZzIgPSBmYWxzZTtcbiAgdmFyIHRvS2VlcEFsaXZlID0gbmV3IFdlYWtTZXQoKTtcbiAgdmFyIHN0ZXAgPSB7XG4gICAgc2NoZWR1bGU6IGZ1bmN0aW9uKGNhbGxiYWNrLCBrZWVwQWxpdmUsIGltbWVkaWF0ZSkge1xuICAgICAgaWYgKGtlZXBBbGl2ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGtlZXBBbGl2ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGltbWVkaWF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGltbWVkaWF0ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGFkZFRvQ3VycmVudEZyYW1lID0gaW1tZWRpYXRlICYmIGlzUHJvY2Vzc2luZzI7XG4gICAgICB2YXIgYnVmZmVyID0gYWRkVG9DdXJyZW50RnJhbWUgPyB0b1J1biA6IHRvUnVuTmV4dEZyYW1lO1xuICAgICAgaWYgKGtlZXBBbGl2ZSlcbiAgICAgICAgdG9LZWVwQWxpdmUuYWRkKGNhbGxiYWNrKTtcbiAgICAgIGlmIChidWZmZXIuaW5kZXhPZihjYWxsYmFjaykgPT09IC0xKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGFkZFRvQ3VycmVudEZyYW1lICYmIGlzUHJvY2Vzc2luZzIpXG4gICAgICAgICAgbnVtVG9SdW4gPSB0b1J1bi5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgfSxcbiAgICBjYW5jZWw6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaW5kZXggPSB0b1J1bk5leHRGcmFtZS5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgIHRvUnVuTmV4dEZyYW1lLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB0b0tlZXBBbGl2ZS5kZWxldGUoY2FsbGJhY2spO1xuICAgIH0sXG4gICAgcHJvY2VzczogZnVuY3Rpb24oZnJhbWVEYXRhKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpc1Byb2Nlc3NpbmcyID0gdHJ1ZTtcbiAgICAgIF9hID0gW3RvUnVuTmV4dEZyYW1lLCB0b1J1bl0sIHRvUnVuID0gX2FbMF0sIHRvUnVuTmV4dEZyYW1lID0gX2FbMV07XG4gICAgICB0b1J1bk5leHRGcmFtZS5sZW5ndGggPSAwO1xuICAgICAgbnVtVG9SdW4gPSB0b1J1bi5sZW5ndGg7XG4gICAgICBpZiAobnVtVG9SdW4pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ub1J1bjsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrID0gdG9SdW5baV07XG4gICAgICAgICAgY2FsbGJhY2soZnJhbWVEYXRhKTtcbiAgICAgICAgICBpZiAodG9LZWVwQWxpdmUuaGFzKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgc3RlcC5zY2hlZHVsZShjYWxsYmFjayk7XG4gICAgICAgICAgICBydW5OZXh0RnJhbWUyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpc1Byb2Nlc3NpbmcyID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICByZXR1cm4gc3RlcDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lc3luYy9kaXN0L2VzL2luZGV4LmpzXG52YXIgbWF4RWxhcHNlZCA9IDQwO1xudmFyIHVzZURlZmF1bHRFbGFwc2VkID0gdHJ1ZTtcbnZhciBydW5OZXh0RnJhbWUgPSBmYWxzZTtcbnZhciBpc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbnZhciBmcmFtZSA9IHtcbiAgZGVsdGE6IDAsXG4gIHRpbWVzdGFtcDogMFxufTtcbnZhciBzdGVwc09yZGVyID0gW1wicmVhZFwiLCBcInVwZGF0ZVwiLCBcInByZVJlbmRlclwiLCBcInJlbmRlclwiLCBcInBvc3RSZW5kZXJcIl07XG52YXIgc3RlcHMgPSAvKiBAX19QVVJFX18gKi8gc3RlcHNPcmRlci5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBrZXk2KSB7XG4gIGFjY1trZXk2XSA9IGNyZWF0ZVJlbmRlclN0ZXAoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHJ1bk5leHRGcmFtZSA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gYWNjO1xufSwge30pO1xudmFyIHN5bmMgPSAvKiBAX19QVVJFX18gKi8gc3RlcHNPcmRlci5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBrZXk2KSB7XG4gIHZhciBzdGVwID0gc3RlcHNba2V5Nl07XG4gIGFjY1trZXk2XSA9IGZ1bmN0aW9uKHByb2Nlc3MzLCBrZWVwQWxpdmUsIGltbWVkaWF0ZSkge1xuICAgIGlmIChrZWVwQWxpdmUgPT09IHZvaWQgMCkge1xuICAgICAga2VlcEFsaXZlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpbW1lZGlhdGUgPT09IHZvaWQgMCkge1xuICAgICAgaW1tZWRpYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICghcnVuTmV4dEZyYW1lKVxuICAgICAgc3RhcnRMb29wKCk7XG4gICAgcmV0dXJuIHN0ZXAuc2NoZWR1bGUocHJvY2VzczMsIGtlZXBBbGl2ZSwgaW1tZWRpYXRlKTtcbiAgfTtcbiAgcmV0dXJuIGFjYztcbn0sIHt9KTtcbnZhciBjYW5jZWxTeW5jID0gLyogQF9fUFVSRV9fICovIHN0ZXBzT3JkZXIucmVkdWNlKGZ1bmN0aW9uKGFjYywga2V5Nikge1xuICBhY2Nba2V5Nl0gPSBzdGVwc1trZXk2XS5jYW5jZWw7XG4gIHJldHVybiBhY2M7XG59LCB7fSk7XG52YXIgZmx1c2hTeW5jID0gLyogQF9fUFVSRV9fICovIHN0ZXBzT3JkZXIucmVkdWNlKGZ1bmN0aW9uKGFjYywga2V5Nikge1xuICBhY2Nba2V5Nl0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc3RlcHNba2V5Nl0ucHJvY2VzcyhmcmFtZSk7XG4gIH07XG4gIHJldHVybiBhY2M7XG59LCB7fSk7XG52YXIgcHJvY2Vzc1N0ZXAgPSBmdW5jdGlvbihzdGVwSWQpIHtcbiAgcmV0dXJuIHN0ZXBzW3N0ZXBJZF0ucHJvY2VzcyhmcmFtZSk7XG59O1xudmFyIHByb2Nlc3NGcmFtZSA9IGZ1bmN0aW9uKHRpbWVzdGFtcCkge1xuICBydW5OZXh0RnJhbWUgPSBmYWxzZTtcbiAgZnJhbWUuZGVsdGEgPSB1c2VEZWZhdWx0RWxhcHNlZCA/IGRlZmF1bHRUaW1lc3RlcCA6IE1hdGgubWF4KE1hdGgubWluKHRpbWVzdGFtcCAtIGZyYW1lLnRpbWVzdGFtcCwgbWF4RWxhcHNlZCksIDEpO1xuICBmcmFtZS50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gIGlzUHJvY2Vzc2luZyA9IHRydWU7XG4gIHN0ZXBzT3JkZXIuZm9yRWFjaChwcm9jZXNzU3RlcCk7XG4gIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICBpZiAocnVuTmV4dEZyYW1lKSB7XG4gICAgdXNlRGVmYXVsdEVsYXBzZWQgPSBmYWxzZTtcbiAgICBvbk5leHRGcmFtZShwcm9jZXNzRnJhbWUpO1xuICB9XG59O1xudmFyIHN0YXJ0TG9vcCA9IGZ1bmN0aW9uKCkge1xuICBydW5OZXh0RnJhbWUgPSB0cnVlO1xuICB1c2VEZWZhdWx0RWxhcHNlZCA9IHRydWU7XG4gIGlmICghaXNQcm9jZXNzaW5nKVxuICAgIG9uTmV4dEZyYW1lKHByb2Nlc3NGcmFtZSk7XG59O1xudmFyIGdldEZyYW1lRGF0YSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZnJhbWU7XG59O1xudmFyIGVzX2RlZmF1bHQgPSBzeW5jO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9ucy91dGlscy9lbGFwc2VkLmpzXG5mdW5jdGlvbiBsb29wRWxhcHNlZChlbGFwc2VkLCBkdXJhdGlvbiwgZGVsYXkpIHtcbiAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHtcbiAgICBkZWxheSA9IDA7XG4gIH1cbiAgcmV0dXJuIGVsYXBzZWQgLSBkdXJhdGlvbiAtIGRlbGF5O1xufVxuZnVuY3Rpb24gcmV2ZXJzZUVsYXBzZWQoZWxhcHNlZCwgZHVyYXRpb24sIGRlbGF5LCBpc0ZvcndhcmRQbGF5YmFjaykge1xuICBpZiAoZGVsYXkgPT09IHZvaWQgMCkge1xuICAgIGRlbGF5ID0gMDtcbiAgfVxuICBpZiAoaXNGb3J3YXJkUGxheWJhY2sgPT09IHZvaWQgMCkge1xuICAgIGlzRm9yd2FyZFBsYXliYWNrID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gaXNGb3J3YXJkUGxheWJhY2sgPyBsb29wRWxhcHNlZChkdXJhdGlvbiArIC1lbGFwc2VkLCBkdXJhdGlvbiwgZGVsYXkpIDogZHVyYXRpb24gLSAoZWxhcHNlZCAtIGR1cmF0aW9uKSArIGRlbGF5O1xufVxuZnVuY3Rpb24gaGFzUmVwZWF0RGVsYXlFbGFwc2VkKGVsYXBzZWQsIGR1cmF0aW9uLCBkZWxheSwgaXNGb3J3YXJkUGxheWJhY2spIHtcbiAgcmV0dXJuIGlzRm9yd2FyZFBsYXliYWNrID8gZWxhcHNlZCA+PSBkdXJhdGlvbiArIGRlbGF5IDogZWxhcHNlZCA8PSAtZGVsYXk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9hbmltYXRpb25zL2luZGV4LmpzXG52YXIgZnJhbWVzeW5jID0gZnVuY3Rpb24odXBkYXRlKSB7XG4gIHZhciBwYXNzVGltZXN0YW1wID0gZnVuY3Rpb24oX2EpIHtcbiAgICB2YXIgZGVsdGEyID0gX2EuZGVsdGE7XG4gICAgcmV0dXJuIHVwZGF0ZShkZWx0YTIpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlc19kZWZhdWx0LnVwZGF0ZShwYXNzVGltZXN0YW1wLCB0cnVlKTtcbiAgICB9LFxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNhbmNlbFN5bmMudXBkYXRlKHBhc3NUaW1lc3RhbXApO1xuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiBhbmltYXRlKF9hKSB7XG4gIHZhciBfYiwgX2M7XG4gIHZhciBmcm9tID0gX2EuZnJvbSwgX2QgPSBfYS5hdXRvcGxheSwgYXV0b3BsYXkgPSBfZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9kLCBfZSA9IF9hLmRyaXZlciwgZHJpdmVyID0gX2UgPT09IHZvaWQgMCA/IGZyYW1lc3luYyA6IF9lLCBfZiA9IF9hLmVsYXBzZWQsIGVsYXBzZWQgPSBfZiA9PT0gdm9pZCAwID8gMCA6IF9mLCBfZyA9IF9hLnJlcGVhdCwgcmVwZWF0TWF4ID0gX2cgPT09IHZvaWQgMCA/IDAgOiBfZywgX2ggPSBfYS5yZXBlYXRUeXBlLCByZXBlYXRUeXBlID0gX2ggPT09IHZvaWQgMCA/IFwibG9vcFwiIDogX2gsIF9qID0gX2EucmVwZWF0RGVsYXksIHJlcGVhdERlbGF5ID0gX2ogPT09IHZvaWQgMCA/IDAgOiBfaiwgb25QbGF5ID0gX2Eub25QbGF5LCBvblN0b3AgPSBfYS5vblN0b3AsIG9uQ29tcGxldGUgPSBfYS5vbkNvbXBsZXRlLCBvblJlcGVhdCA9IF9hLm9uUmVwZWF0LCBvblVwZGF0ZSA9IF9hLm9uVXBkYXRlLCBvcHRpb25zID0gX19yZXN0KF9hLCBbXCJmcm9tXCIsIFwiYXV0b3BsYXlcIiwgXCJkcml2ZXJcIiwgXCJlbGFwc2VkXCIsIFwicmVwZWF0XCIsIFwicmVwZWF0VHlwZVwiLCBcInJlcGVhdERlbGF5XCIsIFwib25QbGF5XCIsIFwib25TdG9wXCIsIFwib25Db21wbGV0ZVwiLCBcIm9uUmVwZWF0XCIsIFwib25VcGRhdGVcIl0pO1xuICB2YXIgdG8gPSBvcHRpb25zLnRvO1xuICB2YXIgZHJpdmVyQ29udHJvbHM7XG4gIHZhciByZXBlYXRDb3VudCA9IDA7XG4gIHZhciBjb21wdXRlZER1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcbiAgdmFyIGxhdGVzdDtcbiAgdmFyIGlzQ29tcGxldGUgPSBmYWxzZTtcbiAgdmFyIGlzRm9yd2FyZFBsYXliYWNrID0gdHJ1ZTtcbiAgdmFyIGludGVycG9sYXRlRnJvbU51bWJlcjtcbiAgdmFyIGFuaW1hdG9yID0gZGV0ZWN0QW5pbWF0aW9uRnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gIGlmICgoX2MgPSAoX2IgPSBhbmltYXRvcikubmVlZHNJbnRlcnBvbGF0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYiwgZnJvbSwgdG8pKSB7XG4gICAgaW50ZXJwb2xhdGVGcm9tTnVtYmVyID0gaW50ZXJwb2xhdGUoWzAsIDEwMF0sIFtmcm9tLCB0b10sIHtcbiAgICAgIGNsYW1wOiBmYWxzZVxuICAgIH0pO1xuICAgIGZyb20gPSAwO1xuICAgIHRvID0gMTAwO1xuICB9XG4gIHZhciBhbmltYXRpb24gPSBhbmltYXRvcihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgZnJvbSwgdG8gfSkpO1xuICBmdW5jdGlvbiByZXBlYXQoKSB7XG4gICAgcmVwZWF0Q291bnQrKztcbiAgICBpZiAocmVwZWF0VHlwZSA9PT0gXCJyZXZlcnNlXCIpIHtcbiAgICAgIGlzRm9yd2FyZFBsYXliYWNrID0gcmVwZWF0Q291bnQgJSAyID09PSAwO1xuICAgICAgZWxhcHNlZCA9IHJldmVyc2VFbGFwc2VkKGVsYXBzZWQsIGNvbXB1dGVkRHVyYXRpb24sIHJlcGVhdERlbGF5LCBpc0ZvcndhcmRQbGF5YmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsYXBzZWQgPSBsb29wRWxhcHNlZChlbGFwc2VkLCBjb21wdXRlZER1cmF0aW9uLCByZXBlYXREZWxheSk7XG4gICAgICBpZiAocmVwZWF0VHlwZSA9PT0gXCJtaXJyb3JcIilcbiAgICAgICAgYW5pbWF0aW9uLmZsaXBUYXJnZXQoKTtcbiAgICB9XG4gICAgaXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgIG9uUmVwZWF0ICYmIG9uUmVwZWF0KCk7XG4gIH1cbiAgZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgZHJpdmVyQ29udHJvbHMuc3RvcCgpO1xuICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZSgpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZShkZWx0YTIpIHtcbiAgICBpZiAoIWlzRm9yd2FyZFBsYXliYWNrKVxuICAgICAgZGVsdGEyID0gLWRlbHRhMjtcbiAgICBlbGFwc2VkICs9IGRlbHRhMjtcbiAgICBpZiAoIWlzQ29tcGxldGUpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGFuaW1hdGlvbi5uZXh0KE1hdGgubWF4KDAsIGVsYXBzZWQpKTtcbiAgICAgIGxhdGVzdCA9IHN0YXRlLnZhbHVlO1xuICAgICAgaWYgKGludGVycG9sYXRlRnJvbU51bWJlcilcbiAgICAgICAgbGF0ZXN0ID0gaW50ZXJwb2xhdGVGcm9tTnVtYmVyKGxhdGVzdCk7XG4gICAgICBpc0NvbXBsZXRlID0gaXNGb3J3YXJkUGxheWJhY2sgPyBzdGF0ZS5kb25lIDogZWxhcHNlZCA8PSAwO1xuICAgIH1cbiAgICBvblVwZGF0ZSA9PT0gbnVsbCB8fCBvblVwZGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25VcGRhdGUobGF0ZXN0KTtcbiAgICBpZiAoaXNDb21wbGV0ZSkge1xuICAgICAgaWYgKHJlcGVhdENvdW50ID09PSAwKVxuICAgICAgICBjb21wdXRlZER1cmF0aW9uICE9PSBudWxsICYmIGNvbXB1dGVkRHVyYXRpb24gIT09IHZvaWQgMCA/IGNvbXB1dGVkRHVyYXRpb24gOiBjb21wdXRlZER1cmF0aW9uID0gZWxhcHNlZDtcbiAgICAgIGlmIChyZXBlYXRDb3VudCA8IHJlcGVhdE1heCkge1xuICAgICAgICBoYXNSZXBlYXREZWxheUVsYXBzZWQoZWxhcHNlZCwgY29tcHV0ZWREdXJhdGlvbiwgcmVwZWF0RGVsYXksIGlzRm9yd2FyZFBsYXliYWNrKSAmJiByZXBlYXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgb25QbGF5ID09PSBudWxsIHx8IG9uUGxheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25QbGF5KCk7XG4gICAgZHJpdmVyQ29udHJvbHMgPSBkcml2ZXIodXBkYXRlKTtcbiAgICBkcml2ZXJDb250cm9scy5zdGFydCgpO1xuICB9XG4gIGF1dG9wbGF5ICYmIHBsYXkoKTtcbiAgcmV0dXJuIHtcbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIG9uU3RvcCA9PT0gbnVsbCB8fCBvblN0b3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uU3RvcCgpO1xuICAgICAgZHJpdmVyQ29udHJvbHMuc3RvcCgpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL3ZlbG9jaXR5LXBlci1zZWNvbmQuanNcbmZ1bmN0aW9uIHZlbG9jaXR5UGVyU2Vjb25kKHZlbG9jaXR5LCBmcmFtZUR1cmF0aW9uKSB7XG4gIHJldHVybiBmcmFtZUR1cmF0aW9uID8gdmVsb2NpdHkgKiAoMWUzIC8gZnJhbWVEdXJhdGlvbikgOiAwO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9ucy9pbmVydGlhLmpzXG5mdW5jdGlvbiBpbmVydGlhKF9hKSB7XG4gIHZhciBfYiA9IF9hLmZyb20sIGZyb20gPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iLCBfYyA9IF9hLnZlbG9jaXR5LCB2ZWxvY2l0eSA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsIG1pbiA9IF9hLm1pbiwgbWF4ID0gX2EubWF4LCBfZCA9IF9hLnBvd2VyLCBwb3dlciA9IF9kID09PSB2b2lkIDAgPyAwLjggOiBfZCwgX2UgPSBfYS50aW1lQ29uc3RhbnQsIHRpbWVDb25zdGFudDIgPSBfZSA9PT0gdm9pZCAwID8gNzUwIDogX2UsIF9mID0gX2EuYm91bmNlU3RpZmZuZXNzLCBib3VuY2VTdGlmZm5lc3MgPSBfZiA9PT0gdm9pZCAwID8gNTAwIDogX2YsIF9nID0gX2EuYm91bmNlRGFtcGluZywgYm91bmNlRGFtcGluZyA9IF9nID09PSB2b2lkIDAgPyAxMCA6IF9nLCBfaCA9IF9hLnJlc3REZWx0YSwgcmVzdERlbHRhID0gX2ggPT09IHZvaWQgMCA/IDEgOiBfaCwgbW9kaWZ5VGFyZ2V0ID0gX2EubW9kaWZ5VGFyZ2V0LCBkcml2ZXIgPSBfYS5kcml2ZXIsIG9uVXBkYXRlID0gX2Eub25VcGRhdGUsIG9uQ29tcGxldGUgPSBfYS5vbkNvbXBsZXRlLCBvblN0b3AgPSBfYS5vblN0b3A7XG4gIHZhciBjdXJyZW50QW5pbWF0aW9uO1xuICBmdW5jdGlvbiBpc091dE9mQm91bmRzKHYpIHtcbiAgICByZXR1cm4gbWluICE9PSB2b2lkIDAgJiYgdiA8IG1pbiB8fCBtYXggIT09IHZvaWQgMCAmJiB2ID4gbWF4O1xuICB9XG4gIGZ1bmN0aW9uIGJvdW5kYXJ5TmVhcmVzdCh2KSB7XG4gICAgaWYgKG1pbiA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIG1heDtcbiAgICBpZiAobWF4ID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gbWluO1xuICAgIHJldHVybiBNYXRoLmFicyhtaW4gLSB2KSA8IE1hdGguYWJzKG1heCAtIHYpID8gbWluIDogbWF4O1xuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0QW5pbWF0aW9uMyhvcHRpb25zKSB7XG4gICAgY3VycmVudEFuaW1hdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50QW5pbWF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50QW5pbWF0aW9uLnN0b3AoKTtcbiAgICBjdXJyZW50QW5pbWF0aW9uID0gYW5pbWF0ZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHtcbiAgICAgIGRyaXZlcixcbiAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIG9uVXBkYXRlID09PSBudWxsIHx8IG9uVXBkYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblVwZGF0ZSh2KTtcbiAgICAgICAgKF9hMiA9IG9wdGlvbnMub25VcGRhdGUpID09PSBudWxsIHx8IF9hMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EyLmNhbGwob3B0aW9ucywgdik7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZSxcbiAgICAgIG9uU3RvcFxuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiBzdGFydFNwcmluZyhvcHRpb25zKSB7XG4gICAgc3RhcnRBbmltYXRpb24zKF9fYXNzaWduKHsgdHlwZTogXCJzcHJpbmdcIiwgc3RpZmZuZXNzOiBib3VuY2VTdGlmZm5lc3MsIGRhbXBpbmc6IGJvdW5jZURhbXBpbmcsIHJlc3REZWx0YSB9LCBvcHRpb25zKSk7XG4gIH1cbiAgaWYgKGlzT3V0T2ZCb3VuZHMoZnJvbSkpIHtcbiAgICBzdGFydFNwcmluZyh7IGZyb20sIHZlbG9jaXR5LCB0bzogYm91bmRhcnlOZWFyZXN0KGZyb20pIH0pO1xuICB9IGVsc2Uge1xuICAgIHZhciB0YXJnZXQgPSBwb3dlciAqIHZlbG9jaXR5ICsgZnJvbTtcbiAgICBpZiAodHlwZW9mIG1vZGlmeVRhcmdldCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgIHRhcmdldCA9IG1vZGlmeVRhcmdldCh0YXJnZXQpO1xuICAgIHZhciBib3VuZGFyeV8xID0gYm91bmRhcnlOZWFyZXN0KHRhcmdldCk7XG4gICAgdmFyIGhlYWRpbmdfMSA9IGJvdW5kYXJ5XzEgPT09IG1pbiA/IC0xIDogMTtcbiAgICB2YXIgcHJldl8xO1xuICAgIHZhciBjdXJyZW50XzE7XG4gICAgdmFyIGNoZWNrQm91bmRhcnkgPSBmdW5jdGlvbih2KSB7XG4gICAgICBwcmV2XzEgPSBjdXJyZW50XzE7XG4gICAgICBjdXJyZW50XzEgPSB2O1xuICAgICAgdmVsb2NpdHkgPSB2ZWxvY2l0eVBlclNlY29uZCh2IC0gcHJldl8xLCBnZXRGcmFtZURhdGEoKS5kZWx0YSk7XG4gICAgICBpZiAoaGVhZGluZ18xID09PSAxICYmIHYgPiBib3VuZGFyeV8xIHx8IGhlYWRpbmdfMSA9PT0gLTEgJiYgdiA8IGJvdW5kYXJ5XzEpIHtcbiAgICAgICAgc3RhcnRTcHJpbmcoeyBmcm9tOiB2LCB0bzogYm91bmRhcnlfMSwgdmVsb2NpdHkgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBzdGFydEFuaW1hdGlvbjMoe1xuICAgICAgdHlwZTogXCJkZWNheVwiLFxuICAgICAgZnJvbSxcbiAgICAgIHZlbG9jaXR5LFxuICAgICAgdGltZUNvbnN0YW50OiB0aW1lQ29uc3RhbnQyLFxuICAgICAgcG93ZXIsXG4gICAgICByZXN0RGVsdGEsXG4gICAgICBtb2RpZnlUYXJnZXQsXG4gICAgICBvblVwZGF0ZTogaXNPdXRPZkJvdW5kcyh0YXJnZXQpID8gY2hlY2tCb3VuZGFyeSA6IHZvaWQgMFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY3VycmVudEFuaW1hdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50QW5pbWF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50QW5pbWF0aW9uLnN0b3AoKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9pcy1wb2ludC5qc1xudmFyIGlzUG9pbnQgPSBmdW5jdGlvbihwb2ludCkge1xuICByZXR1cm4gcG9pbnQuaGFzT3duUHJvcGVydHkoXCJ4XCIpICYmIHBvaW50Lmhhc093blByb3BlcnR5KFwieVwiKTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9pcy1wb2ludC0zZC5qc1xudmFyIGlzUG9pbnQzRCA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gIHJldHVybiBpc1BvaW50KHBvaW50KSAmJiBwb2ludC5oYXNPd25Qcm9wZXJ0eShcInpcIik7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvZGlzdGFuY2UuanNcbnZhciBkaXN0YW5jZTFEID0gZnVuY3Rpb24oYTIsIGIyKSB7XG4gIHJldHVybiBNYXRoLmFicyhhMiAtIGIyKTtcbn07XG5mdW5jdGlvbiBkaXN0YW5jZShhMiwgYjIpIHtcbiAgaWYgKGlzTnVtKGEyKSAmJiBpc051bShiMikpIHtcbiAgICByZXR1cm4gZGlzdGFuY2UxRChhMiwgYjIpO1xuICB9IGVsc2UgaWYgKGlzUG9pbnQoYTIpICYmIGlzUG9pbnQoYjIpKSB7XG4gICAgdmFyIHhEZWx0YSA9IGRpc3RhbmNlMUQoYTIueCwgYjIueCk7XG4gICAgdmFyIHlEZWx0YSA9IGRpc3RhbmNlMUQoYTIueSwgYjIueSk7XG4gICAgdmFyIHpEZWx0YSA9IGlzUG9pbnQzRChhMikgJiYgaXNQb2ludDNEKGIyKSA/IGRpc3RhbmNlMUQoYTIueiwgYjIueikgOiAwO1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeERlbHRhLCAyKSArIE1hdGgucG93KHlEZWx0YSwgMikgKyBNYXRoLnBvdyh6RGVsdGEsIDIpKTtcbiAgfVxufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvd3JhcC5qc1xudmFyIHdyYXAgPSBmdW5jdGlvbihtaW4sIG1heCwgdikge1xuICB2YXIgcmFuZ2VTaXplID0gbWF4IC0gbWluO1xuICByZXR1cm4gKCh2IC0gbWluKSAlIHJhbmdlU2l6ZSArIHJhbmdlU2l6ZSkgJSByYW5nZVNpemUgKyBtaW47XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvZWFzaW5nL2N1YmljLWJlemllci5qc1xudmFyIGEgPSBmdW5jdGlvbihhMSwgYTIpIHtcbiAgcmV0dXJuIDEgLSAzICogYTIgKyAzICogYTE7XG59O1xudmFyIGIgPSBmdW5jdGlvbihhMSwgYTIpIHtcbiAgcmV0dXJuIDMgKiBhMiAtIDYgKiBhMTtcbn07XG52YXIgYyA9IGZ1bmN0aW9uKGExKSB7XG4gIHJldHVybiAzICogYTE7XG59O1xudmFyIGNhbGNCZXppZXIgPSBmdW5jdGlvbih0LCBhMSwgYTIpIHtcbiAgcmV0dXJuICgoYShhMSwgYTIpICogdCArIGIoYTEsIGEyKSkgKiB0ICsgYyhhMSkpICogdDtcbn07XG52YXIgZ2V0U2xvcGUgPSBmdW5jdGlvbih0LCBhMSwgYTIpIHtcbiAgcmV0dXJuIDMgKiBhKGExLCBhMikgKiB0ICogdCArIDIgKiBiKGExLCBhMikgKiB0ICsgYyhhMSk7XG59O1xudmFyIHN1YmRpdmlzaW9uUHJlY2lzaW9uID0gMWUtNztcbnZhciBzdWJkaXZpc2lvbk1heEl0ZXJhdGlvbnMgPSAxMDtcbmZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZShhWCwgYUEsIGFCLCBtWDEsIG1YMikge1xuICB2YXIgY3VycmVudFg7XG4gIHZhciBjdXJyZW50VDtcbiAgdmFyIGkgPSAwO1xuICBkbyB7XG4gICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDI7XG4gICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcbiAgICBpZiAoY3VycmVudFggPiAwKSB7XG4gICAgICBhQiA9IGN1cnJlbnRUO1xuICAgIH0gZWxzZSB7XG4gICAgICBhQSA9IGN1cnJlbnRUO1xuICAgIH1cbiAgfSB3aGlsZSAoTWF0aC5hYnMoY3VycmVudFgpID4gc3ViZGl2aXNpb25QcmVjaXNpb24gJiYgKytpIDwgc3ViZGl2aXNpb25NYXhJdGVyYXRpb25zKTtcbiAgcmV0dXJuIGN1cnJlbnRUO1xufVxudmFyIG5ld3Rvbkl0ZXJhdGlvbnMgPSA4O1xudmFyIG5ld3Rvbk1pblNsb3BlID0gMWUtMztcbmZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NULCBtWDEsIG1YMikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld3Rvbkl0ZXJhdGlvbnM7ICsraSkge1xuICAgIHZhciBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG4gICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGFHdWVzc1Q7XG4gICAgfVxuICAgIHZhciBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcbiAgfVxuICByZXR1cm4gYUd1ZXNzVDtcbn1cbnZhciBrU3BsaW5lVGFibGVTaXplID0gMTE7XG52YXIga1NhbXBsZVN0ZXBTaXplID0gMSAvIChrU3BsaW5lVGFibGVTaXplIC0gMSk7XG5mdW5jdGlvbiBjdWJpY0JlemllcihtWDEsIG1ZMSwgbVgyLCBtWTIpIHtcbiAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKVxuICAgIHJldHVybiBsaW5lYXI7XG4gIHZhciBzYW1wbGVWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KGtTcGxpbmVUYWJsZVNpemUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtTcGxpbmVUYWJsZVNpemU7ICsraSkge1xuICAgIHNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFRGb3JYKGFYKSB7XG4gICAgdmFyIGludGVydmFsU3RhcnQgPSAwO1xuICAgIHZhciBjdXJyZW50U2FtcGxlID0gMTtcbiAgICB2YXIgbGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuICAgIGZvciAoOyBjdXJyZW50U2FtcGxlICE9PSBsYXN0U2FtcGxlICYmIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSA8PSBhWDsgKytjdXJyZW50U2FtcGxlKSB7XG4gICAgICBpbnRlcnZhbFN0YXJ0ICs9IGtTYW1wbGVTdGVwU2l6ZTtcbiAgICB9XG4gICAgLS1jdXJyZW50U2FtcGxlO1xuICAgIHZhciBkaXN0ID0gKGFYIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIChzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKTtcbiAgICB2YXIgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemU7XG4gICAgdmFyIGluaXRpYWxTbG9wZSA9IGdldFNsb3BlKGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgIGlmIChpbml0aWFsU2xvcGUgPj0gbmV3dG9uTWluU2xvcGUpIHtcbiAgICAgIHJldHVybiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgfSBlbHNlIGlmIChpbml0aWFsU2xvcGUgPT09IDApIHtcbiAgICAgIHJldHVybiBndWVzc0ZvclQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoYVgsIGludGVydmFsU3RhcnQsIGludGVydmFsU3RhcnQgKyBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdCA9PT0gMCB8fCB0ID09PSAxID8gdCA6IGNhbGNCZXppZXIoZ2V0VEZvclgodCksIG1ZMSwgbVkyKTtcbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy91c2UtdGFwLWdlc3R1cmUuanNcbmZ1bmN0aW9uIHVzZVRhcEdlc3R1cmUoX2EpIHtcbiAgdmFyIG9uVGFwID0gX2Eub25UYXAsIG9uVGFwU3RhcnQgPSBfYS5vblRhcFN0YXJ0LCBvblRhcENhbmNlbCA9IF9hLm9uVGFwQ2FuY2VsLCB3aGlsZVRhcCA9IF9hLndoaWxlVGFwLCB2aXN1YWxFbGVtZW50MiA9IF9hLnZpc3VhbEVsZW1lbnQ7XG4gIHZhciBoYXNQcmVzc0xpc3RlbmVycyA9IG9uVGFwIHx8IG9uVGFwU3RhcnQgfHwgb25UYXBDYW5jZWwgfHwgd2hpbGVUYXA7XG4gIHZhciBpc1ByZXNzaW5nID0gdXNlUmVmMyhmYWxzZSk7XG4gIHZhciBjYW5jZWxQb2ludGVyRW5kTGlzdGVuZXJzID0gdXNlUmVmMyhudWxsKTtcbiAgZnVuY3Rpb24gcmVtb3ZlUG9pbnRlckVuZExpc3RlbmVyKCkge1xuICAgIHZhciBfYTI7XG4gICAgKF9hMiA9IGNhbmNlbFBvaW50ZXJFbmRMaXN0ZW5lcnMuY3VycmVudCkgPT09IG51bGwgfHwgX2EyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTIuY2FsbChjYW5jZWxQb2ludGVyRW5kTGlzdGVuZXJzKTtcbiAgICBjYW5jZWxQb2ludGVyRW5kTGlzdGVuZXJzLmN1cnJlbnQgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrUG9pbnRlckVuZCgpIHtcbiAgICB2YXIgX2EyO1xuICAgIHJlbW92ZVBvaW50ZXJFbmRMaXN0ZW5lcigpO1xuICAgIGlzUHJlc3NpbmcuY3VycmVudCA9IGZhbHNlO1xuICAgIChfYTIgPSB2aXN1YWxFbGVtZW50Mi5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTIuc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuVGFwLCBmYWxzZSk7XG4gICAgcmV0dXJuICFpc0RyYWdBY3RpdmUoKTtcbiAgfVxuICBmdW5jdGlvbiBvblBvaW50ZXJVcChldmVudCwgaW5mbykge1xuICAgIGlmICghY2hlY2tQb2ludGVyRW5kKCkpXG4gICAgICByZXR1cm47XG4gICAgIWlzTm9kZU9yQ2hpbGQodmlzdWFsRWxlbWVudDIuZ2V0SW5zdGFuY2UoKSwgZXZlbnQudGFyZ2V0KSA/IG9uVGFwQ2FuY2VsID09PSBudWxsIHx8IG9uVGFwQ2FuY2VsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblRhcENhbmNlbChldmVudCwgaW5mbykgOiBvblRhcCA9PT0gbnVsbCB8fCBvblRhcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25UYXAoZXZlbnQsIGluZm8pO1xuICB9XG4gIGZ1bmN0aW9uIG9uUG9pbnRlckNhbmNlbChldmVudCwgaW5mbykge1xuICAgIGlmICghY2hlY2tQb2ludGVyRW5kKCkpXG4gICAgICByZXR1cm47XG4gICAgb25UYXBDYW5jZWwgPT09IG51bGwgfHwgb25UYXBDYW5jZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uVGFwQ2FuY2VsKGV2ZW50LCBpbmZvKTtcbiAgfVxuICBmdW5jdGlvbiBvblBvaW50ZXJEb3duKGV2ZW50LCBpbmZvKSB7XG4gICAgdmFyIF9hMjtcbiAgICByZW1vdmVQb2ludGVyRW5kTGlzdGVuZXIoKTtcbiAgICBpZiAoaXNQcmVzc2luZy5jdXJyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGlzUHJlc3NpbmcuY3VycmVudCA9IHRydWU7XG4gICAgY2FuY2VsUG9pbnRlckVuZExpc3RlbmVycy5jdXJyZW50ID0gcGlwZShhZGRQb2ludGVyRXZlbnQod2luZG93LCBcInBvaW50ZXJ1cFwiLCBvblBvaW50ZXJVcCksIGFkZFBvaW50ZXJFdmVudCh3aW5kb3csIFwicG9pbnRlcmNhbmNlbFwiLCBvblBvaW50ZXJDYW5jZWwpKTtcbiAgICBvblRhcFN0YXJ0ID09PSBudWxsIHx8IG9uVGFwU3RhcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uVGFwU3RhcnQoZXZlbnQsIGluZm8pO1xuICAgIChfYTIgPSB2aXN1YWxFbGVtZW50Mi5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTIuc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuVGFwLCB0cnVlKTtcbiAgfVxuICB1c2VQb2ludGVyRXZlbnQodmlzdWFsRWxlbWVudDIsIFwicG9pbnRlcmRvd25cIiwgaGFzUHJlc3NMaXN0ZW5lcnMgPyBvblBvaW50ZXJEb3duIDogdm9pZCAwKTtcbiAgdXNlVW5tb3VudEVmZmVjdChyZW1vdmVQb2ludGVyRW5kTGlzdGVuZXIpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy9tYWtlLXJlbmRlcmxlc3MtY29tcG9uZW50LmpzXG52YXIgbWFrZVJlbmRlcmxlc3NDb21wb25lbnQgPSBmdW5jdGlvbihob29rKSB7XG4gIHJldHVybiBmdW5jdGlvbihwcm9wcykge1xuICAgIGhvb2socHJvcHMpO1xuICAgIHJldHVybiBudWxsO1xuICB9O1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvZ2VzdHVyZXMuanNcbnZhciBnZXN0dXJlQW5pbWF0aW9ucyA9IHtcbiAgdGFwOiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCh1c2VUYXBHZXN0dXJlKSxcbiAgZm9jdXM6IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KHVzZUZvY3VzR2VzdHVyZSksXG4gIGhvdmVyOiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCh1c2VIb3Zlckdlc3R1cmUpXG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9hbmltYXRpb25zLmpzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NiwgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0OCB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3NoYWxsb3ctY29tcGFyZS5qc1xuZnVuY3Rpb24gc2hhbGxvd0NvbXBhcmUobmV4dCwgcHJldikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocHJldikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB2YXIgcHJldkxlbmd0aCA9IHByZXYubGVuZ3RoO1xuICBpZiAocHJldkxlbmd0aCAhPT0gbmV4dC5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZMZW5ndGg7IGkrKykge1xuICAgIGlmIChwcmV2W2ldICE9PSBuZXh0W2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3RpbWUtY29udmVyc2lvbi5qc1xudmFyIHNlY29uZHNUb01pbGxpc2Vjb25kcyA9IGZ1bmN0aW9uKHNlY29uZHMpIHtcbiAgcmV0dXJuIHNlY29uZHMgKiAxZTM7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi91dGlscy9lYXNpbmcuanNcbnZhciBlYXNpbmdMb29rdXAgPSB7XG4gIGxpbmVhcixcbiAgZWFzZUluLFxuICBlYXNlSW5PdXQsXG4gIGVhc2VPdXQsXG4gIGNpcmNJbixcbiAgY2lyY0luT3V0LFxuICBjaXJjT3V0LFxuICBiYWNrSW4sXG4gIGJhY2tJbk91dCxcbiAgYmFja091dCxcbiAgYW50aWNpcGF0ZSxcbiAgYm91bmNlSW4sXG4gIGJvdW5jZUluT3V0LFxuICBib3VuY2VPdXRcbn07XG52YXIgZWFzaW5nRGVmaW5pdGlvblRvRnVuY3Rpb24gPSBmdW5jdGlvbihkZWZpbml0aW9uKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24pKSB7XG4gICAgaW52YXJpYW50KGRlZmluaXRpb24ubGVuZ3RoID09PSA0LCBcIkN1YmljIGJlemllciBhcnJheXMgbXVzdCBjb250YWluIGZvdXIgbnVtZXJpY2FsIHZhbHVlcy5cIik7XG4gICAgdmFyIF9hID0gX19yZWFkKGRlZmluaXRpb24sIDQpLCB4MSA9IF9hWzBdLCB5MSA9IF9hWzFdLCB4MiA9IF9hWzJdLCB5MiA9IF9hWzNdO1xuICAgIHJldHVybiBjdWJpY0Jlemllcih4MSwgeTEsIHgyLCB5Mik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICBpbnZhcmlhbnQoZWFzaW5nTG9va3VwW2RlZmluaXRpb25dICE9PSB2b2lkIDAsIFwiSW52YWxpZCBlYXNpbmcgdHlwZSAnXCIgKyBkZWZpbml0aW9uICsgXCInXCIpO1xuICAgIHJldHVybiBlYXNpbmdMb29rdXBbZGVmaW5pdGlvbl07XG4gIH1cbiAgcmV0dXJuIGRlZmluaXRpb247XG59O1xudmFyIGlzRWFzaW5nQXJyYXkgPSBmdW5jdGlvbihlYXNlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGVhc2UpICYmIHR5cGVvZiBlYXNlWzBdICE9PSBcIm51bWJlclwiO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vdXRpbHMvaXMtYW5pbWF0YWJsZS5qc1xudmFyIGlzQW5pbWF0YWJsZSA9IGZ1bmN0aW9uKGtleTYsIHZhbHVlKSB7XG4gIGlmIChrZXk2ID09PSBcInpJbmRleFwiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiBjb21wbGV4LnRlc3QodmFsdWUpICYmICF2YWx1ZS5zdGFydHNXaXRoKFwidXJsKFwiKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL3V0aWxzL2RlZmF1bHQtdHJhbnNpdGlvbnMuanNcbnZhciB1bmRlckRhbXBlZFNwcmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3ByaW5nXCIsXG4gICAgc3RpZmZuZXNzOiA1MDAsXG4gICAgZGFtcGluZzogMjUsXG4gICAgcmVzdERlbHRhOiAwLjUsXG4gICAgcmVzdFNwZWVkOiAxMFxuICB9O1xufTtcbnZhciBjcml0aWNhbGx5RGFtcGVkU3ByaW5nID0gZnVuY3Rpb24odG8pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInNwcmluZ1wiLFxuICAgIHN0aWZmbmVzczogNTUwLFxuICAgIGRhbXBpbmc6IHRvID09PSAwID8gMiAqIE1hdGguc3FydCg1NTApIDogMzAsXG4gICAgcmVzdERlbHRhOiAwLjAxLFxuICAgIHJlc3RTcGVlZDogMTBcbiAgfTtcbn07XG52YXIgbGluZWFyVHdlZW4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImtleWZyYW1lc1wiLFxuICAgIGVhc2U6IFwibGluZWFyXCIsXG4gICAgZHVyYXRpb246IDAuM1xuICB9O1xufTtcbnZhciBrZXlmcmFtZXMyID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJrZXlmcmFtZXNcIixcbiAgICBkdXJhdGlvbjogMC44LFxuICAgIHZhbHVlc1xuICB9O1xufTtcbnZhciBkZWZhdWx0VHJhbnNpdGlvbnMgPSB7XG4gIHg6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICB5OiB1bmRlckRhbXBlZFNwcmluZyxcbiAgejogdW5kZXJEYW1wZWRTcHJpbmcsXG4gIHJvdGF0ZTogdW5kZXJEYW1wZWRTcHJpbmcsXG4gIHJvdGF0ZVg6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICByb3RhdGVZOiB1bmRlckRhbXBlZFNwcmluZyxcbiAgcm90YXRlWjogdW5kZXJEYW1wZWRTcHJpbmcsXG4gIHNjYWxlWDogY3JpdGljYWxseURhbXBlZFNwcmluZyxcbiAgc2NhbGVZOiBjcml0aWNhbGx5RGFtcGVkU3ByaW5nLFxuICBzY2FsZTogY3JpdGljYWxseURhbXBlZFNwcmluZyxcbiAgb3BhY2l0eTogbGluZWFyVHdlZW4sXG4gIGJhY2tncm91bmRDb2xvcjogbGluZWFyVHdlZW4sXG4gIGNvbG9yOiBsaW5lYXJUd2VlbixcbiAgZGVmYXVsdDogY3JpdGljYWxseURhbXBlZFNwcmluZ1xufTtcbnZhciBnZXREZWZhdWx0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uKHZhbHVlS2V5LCB0bykge1xuICB2YXIgdHJhbnNpdGlvbkZhY3Rvcnk7XG4gIGlmIChpc0tleWZyYW1lc1RhcmdldCh0bykpIHtcbiAgICB0cmFuc2l0aW9uRmFjdG9yeSA9IGtleWZyYW1lczI7XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNpdGlvbkZhY3RvcnkgPSBkZWZhdWx0VHJhbnNpdGlvbnNbdmFsdWVLZXldIHx8IGRlZmF1bHRUcmFuc2l0aW9ucy5kZWZhdWx0O1xuICB9XG4gIHJldHVybiBfX2Fzc2lnbih7IHRvIH0sIHRyYW5zaXRpb25GYWN0b3J5KHRvKSk7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvZGVmYXVsdHMuanNcbnZhciBkZWZhdWx0VmFsdWVUeXBlcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBudW1iZXJWYWx1ZVR5cGVzKSwge1xuICBjb2xvcixcbiAgYmFja2dyb3VuZENvbG9yOiBjb2xvcixcbiAgb3V0bGluZUNvbG9yOiBjb2xvcixcbiAgZmlsbDogY29sb3IsXG4gIHN0cm9rZTogY29sb3IsXG4gIGJvcmRlckNvbG9yOiBjb2xvcixcbiAgYm9yZGVyVG9wQ29sb3I6IGNvbG9yLFxuICBib3JkZXJSaWdodENvbG9yOiBjb2xvcixcbiAgYm9yZGVyQm90dG9tQ29sb3I6IGNvbG9yLFxuICBib3JkZXJMZWZ0Q29sb3I6IGNvbG9yLFxuICBmaWx0ZXIsXG4gIFdlYmtpdEZpbHRlcjogZmlsdGVyXG59KTtcbnZhciBnZXREZWZhdWx0VmFsdWVUeXBlID0gZnVuY3Rpb24oa2V5Nikge1xuICByZXR1cm4gZGVmYXVsdFZhbHVlVHlwZXNba2V5Nl07XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvYW5pbWF0YWJsZS1ub25lLmpzXG5mdW5jdGlvbiBnZXRBbmltYXRhYmxlTm9uZTIoa2V5NiwgdmFsdWUpIHtcbiAgdmFyIF9hO1xuICB2YXIgZGVmYXVsdFZhbHVlVHlwZSA9IGdldERlZmF1bHRWYWx1ZVR5cGUoa2V5Nik7XG4gIGlmIChkZWZhdWx0VmFsdWVUeXBlICE9PSBmaWx0ZXIpXG4gICAgZGVmYXVsdFZhbHVlVHlwZSA9IGNvbXBsZXg7XG4gIHJldHVybiAoX2EgPSBkZWZhdWx0VmFsdWVUeXBlLmdldEFuaW1hdGFibGVOb25lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChkZWZhdWx0VmFsdWVUeXBlLCB2YWx1ZSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL3V0aWxzL3RyYW5zaXRpb25zLmpzXG5mdW5jdGlvbiBpc1RyYW5zaXRpb25EZWZpbmVkKF9hKSB7XG4gIF9hLndoZW47XG4gIF9hLmRlbGF5O1xuICBfYS5kZWxheUNoaWxkcmVuO1xuICBfYS5zdGFnZ2VyQ2hpbGRyZW47XG4gIF9hLnN0YWdnZXJEaXJlY3Rpb247XG4gIF9hLnJlcGVhdDtcbiAgX2EucmVwZWF0VHlwZTtcbiAgX2EucmVwZWF0RGVsYXk7XG4gIF9hLmZyb207XG4gIHZhciB0cmFuc2l0aW9uID0gX19yZXN0KF9hLCBbXCJ3aGVuXCIsIFwiZGVsYXlcIiwgXCJkZWxheUNoaWxkcmVuXCIsIFwic3RhZ2dlckNoaWxkcmVuXCIsIFwic3RhZ2dlckRpcmVjdGlvblwiLCBcInJlcGVhdFwiLCBcInJlcGVhdFR5cGVcIiwgXCJyZXBlYXREZWxheVwiLCBcImZyb21cIl0pO1xuICByZXR1cm4gISFPYmplY3Qua2V5cyh0cmFuc2l0aW9uKS5sZW5ndGg7XG59XG52YXIgbGVnYWN5UmVwZWF0V2FybmluZyA9IGZhbHNlO1xuZnVuY3Rpb24gY29udmVydFRyYW5zaXRpb25Ub0FuaW1hdGlvbk9wdGlvbnMoX2EpIHtcbiAgdmFyIGVhc2UgPSBfYS5lYXNlLCB0aW1lcyA9IF9hLnRpbWVzLCB5b3lvID0gX2EueW95bywgZmxpcCA9IF9hLmZsaXAsIGxvb3AgPSBfYS5sb29wLCB0cmFuc2l0aW9uID0gX19yZXN0KF9hLCBbXCJlYXNlXCIsIFwidGltZXNcIiwgXCJ5b3lvXCIsIFwiZmxpcFwiLCBcImxvb3BcIl0pO1xuICB2YXIgb3B0aW9ucyA9IF9fYXNzaWduKHt9LCB0cmFuc2l0aW9uKTtcbiAgaWYgKHRpbWVzKVxuICAgIG9wdGlvbnNbXCJvZmZzZXRcIl0gPSB0aW1lcztcbiAgaWYgKHRyYW5zaXRpb24uZHVyYXRpb24pXG4gICAgb3B0aW9uc1tcImR1cmF0aW9uXCJdID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKHRyYW5zaXRpb24uZHVyYXRpb24pO1xuICBpZiAodHJhbnNpdGlvbi5yZXBlYXREZWxheSlcbiAgICBvcHRpb25zLnJlcGVhdERlbGF5ID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKHRyYW5zaXRpb24ucmVwZWF0RGVsYXkpO1xuICBpZiAoZWFzZSkge1xuICAgIG9wdGlvbnNbXCJlYXNlXCJdID0gaXNFYXNpbmdBcnJheShlYXNlKSA/IGVhc2UubWFwKGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uKSA6IGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uKGVhc2UpO1xuICB9XG4gIGlmICh0cmFuc2l0aW9uLnR5cGUgPT09IFwidHdlZW5cIilcbiAgICBvcHRpb25zLnR5cGUgPSBcImtleWZyYW1lc1wiO1xuICBpZiAoeW95byB8fCBsb29wIHx8IGZsaXApIHtcbiAgICB3YXJuaW5nKCFsZWdhY3lSZXBlYXRXYXJuaW5nLCBcInlveW8sIGxvb3AgYW5kIGZsaXAgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgQVBJLiBSZXBsYWNlIHdpdGggcmVwZWF0IGFuZCByZXBlYXRUeXBlIG9wdGlvbnMuXCIpO1xuICAgIGxlZ2FjeVJlcGVhdFdhcm5pbmcgPSB0cnVlO1xuICAgIGlmICh5b3lvKSB7XG4gICAgICBvcHRpb25zLnJlcGVhdFR5cGUgPSBcInJldmVyc2VcIjtcbiAgICB9IGVsc2UgaWYgKGxvb3ApIHtcbiAgICAgIG9wdGlvbnMucmVwZWF0VHlwZSA9IFwibG9vcFwiO1xuICAgIH0gZWxzZSBpZiAoZmxpcCkge1xuICAgICAgb3B0aW9ucy5yZXBlYXRUeXBlID0gXCJtaXJyb3JcIjtcbiAgICB9XG4gICAgb3B0aW9ucy5yZXBlYXQgPSBsb29wIHx8IHlveW8gfHwgZmxpcCB8fCB0cmFuc2l0aW9uLnJlcGVhdDtcbiAgfVxuICBpZiAodHJhbnNpdGlvbi50eXBlICE9PSBcInNwcmluZ1wiKVxuICAgIG9wdGlvbnMudHlwZSA9IFwia2V5ZnJhbWVzXCI7XG4gIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gZ2V0RGVsYXlGcm9tVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBrZXk2KSB7XG4gIHZhciBfYTtcbiAgdmFyIHZhbHVlVHJhbnNpdGlvbiA9IGdldFZhbHVlVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBrZXk2KSB8fCB7fTtcbiAgcmV0dXJuIChfYSA9IHZhbHVlVHJhbnNpdGlvbi5kZWxheSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbn1cbmZ1bmN0aW9uIGh5ZHJhdGVLZXlmcmFtZXMob3B0aW9ucykge1xuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnRvKSAmJiBvcHRpb25zLnRvWzBdID09PSBudWxsKSB7XG4gICAgb3B0aW9ucy50byA9IF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChvcHRpb25zLnRvKSk7XG4gICAgb3B0aW9ucy50b1swXSA9IG9wdGlvbnMuZnJvbTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGdldFBvcG1vdGlvbkFuaW1hdGlvbk9wdGlvbnModHJhbnNpdGlvbiwgb3B0aW9ucywga2V5Nikge1xuICB2YXIgX2E7XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMudG8pKSB7XG4gICAgKF9hID0gdHJhbnNpdGlvbi5kdXJhdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJhbnNpdGlvbi5kdXJhdGlvbiA9IDAuODtcbiAgfVxuICBoeWRyYXRlS2V5ZnJhbWVzKG9wdGlvbnMpO1xuICBpZiAoIWlzVHJhbnNpdGlvbkRlZmluZWQodHJhbnNpdGlvbikpIHtcbiAgICB0cmFuc2l0aW9uID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRyYW5zaXRpb24pLCBnZXREZWZhdWx0VHJhbnNpdGlvbihrZXk2LCBvcHRpb25zLnRvKSk7XG4gIH1cbiAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgY29udmVydFRyYW5zaXRpb25Ub0FuaW1hdGlvbk9wdGlvbnModHJhbnNpdGlvbikpO1xufVxuZnVuY3Rpb24gZ2V0QW5pbWF0aW9uKGtleTYsIHZhbHVlLCB0YXJnZXQsIHRyYW5zaXRpb24sIG9uQ29tcGxldGUpIHtcbiAgdmFyIF9hO1xuICB2YXIgdmFsdWVUcmFuc2l0aW9uID0gZ2V0VmFsdWVUcmFuc2l0aW9uKHRyYW5zaXRpb24sIGtleTYpO1xuICB2YXIgb3JpZ2luID0gKF9hID0gdmFsdWVUcmFuc2l0aW9uLmZyb20pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlLmdldCgpO1xuICB2YXIgaXNUYXJnZXRBbmltYXRhYmxlID0gaXNBbmltYXRhYmxlKGtleTYsIHRhcmdldCk7XG4gIGlmIChvcmlnaW4gPT09IFwibm9uZVwiICYmIGlzVGFyZ2V0QW5pbWF0YWJsZSAmJiB0eXBlb2YgdGFyZ2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgb3JpZ2luID0gZ2V0QW5pbWF0YWJsZU5vbmUyKGtleTYsIHRhcmdldCk7XG4gIH0gZWxzZSBpZiAoaXNaZXJvKG9yaWdpbikgJiYgdHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgIG9yaWdpbiA9IGdldFplcm9Vbml0KHRhcmdldCk7XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1plcm8odGFyZ2V0KSAmJiB0eXBlb2Ygb3JpZ2luID09PSBcInN0cmluZ1wiKSB7XG4gICAgdGFyZ2V0ID0gZ2V0WmVyb1VuaXQob3JpZ2luKTtcbiAgfVxuICB2YXIgaXNPcmlnaW5BbmltYXRhYmxlID0gaXNBbmltYXRhYmxlKGtleTYsIG9yaWdpbik7XG4gIHdhcm5pbmcoaXNPcmlnaW5BbmltYXRhYmxlID09PSBpc1RhcmdldEFuaW1hdGFibGUsIFwiWW91IGFyZSB0cnlpbmcgdG8gYW5pbWF0ZSBcIiArIGtleTYgKyAnIGZyb20gXCInICsgb3JpZ2luICsgJ1wiIHRvIFwiJyArIHRhcmdldCArICdcIi4gJyArIG9yaWdpbiArIFwiIGlzIG5vdCBhbiBhbmltYXRhYmxlIHZhbHVlIC0gdG8gZW5hYmxlIHRoaXMgYW5pbWF0aW9uIHNldCBcIiArIG9yaWdpbiArIFwiIHRvIGEgdmFsdWUgYW5pbWF0YWJsZSB0byBcIiArIHRhcmdldCArIFwiIHZpYSB0aGUgYHN0eWxlYCBwcm9wZXJ0eS5cIik7XG4gIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgZnJvbTogb3JpZ2luLFxuICAgICAgdG86IHRhcmdldCxcbiAgICAgIHZlbG9jaXR5OiB2YWx1ZS5nZXRWZWxvY2l0eSgpLFxuICAgICAgb25Db21wbGV0ZSxcbiAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5zZXQodik7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gdmFsdWVUcmFuc2l0aW9uLnR5cGUgPT09IFwiaW5lcnRpYVwiIHx8IHZhbHVlVHJhbnNpdGlvbi50eXBlID09PSBcImRlY2F5XCIgPyBpbmVydGlhKF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgdmFsdWVUcmFuc2l0aW9uKSkgOiBhbmltYXRlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBnZXRQb3Btb3Rpb25BbmltYXRpb25PcHRpb25zKHZhbHVlVHJhbnNpdGlvbiwgb3B0aW9ucywga2V5NikpLCB7IG9uVXBkYXRlOiBmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgb3B0aW9ucy5vblVwZGF0ZSh2KTtcbiAgICAgIChfYTIgPSB2YWx1ZVRyYW5zaXRpb24ub25VcGRhdGUpID09PSBudWxsIHx8IF9hMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EyLmNhbGwodmFsdWVUcmFuc2l0aW9uLCB2KTtcbiAgICB9LCBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBvcHRpb25zLm9uQ29tcGxldGUoKTtcbiAgICAgIChfYTIgPSB2YWx1ZVRyYW5zaXRpb24ub25Db21wbGV0ZSkgPT09IG51bGwgfHwgX2EyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTIuY2FsbCh2YWx1ZVRyYW5zaXRpb24pO1xuICAgIH0gfSkpO1xuICB9XG4gIGZ1bmN0aW9uIHNldCgpIHtcbiAgICB2YXIgX2EyO1xuICAgIHZhbHVlLnNldCh0YXJnZXQpO1xuICAgIG9uQ29tcGxldGUoKTtcbiAgICAoX2EyID0gdmFsdWVUcmFuc2l0aW9uID09PSBudWxsIHx8IHZhbHVlVHJhbnNpdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVUcmFuc2l0aW9uLm9uQ29tcGxldGUpID09PSBudWxsIHx8IF9hMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EyLmNhbGwodmFsdWVUcmFuc2l0aW9uKTtcbiAgICByZXR1cm4geyBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICB9IH07XG4gIH1cbiAgcmV0dXJuICFpc09yaWdpbkFuaW1hdGFibGUgfHwgIWlzVGFyZ2V0QW5pbWF0YWJsZSB8fCB2YWx1ZVRyYW5zaXRpb24udHlwZSA9PT0gZmFsc2UgPyBzZXQgOiBzdGFydDtcbn1cbmZ1bmN0aW9uIGlzWmVybyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IDAgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHBhcnNlRmxvYXQodmFsdWUpID09PSAwICYmIHZhbHVlLmluZGV4T2YoXCIgXCIpID09PSAtMTtcbn1cbmZ1bmN0aW9uIGdldFplcm9Vbml0KHBvdGVudGlhbFVuaXRUeXBlKSB7XG4gIHJldHVybiB0eXBlb2YgcG90ZW50aWFsVW5pdFR5cGUgPT09IFwibnVtYmVyXCIgPyAwIDogZ2V0QW5pbWF0YWJsZU5vbmUyKFwiXCIsIHBvdGVudGlhbFVuaXRUeXBlKTtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBrZXk2KSB7XG4gIHJldHVybiB0cmFuc2l0aW9uW2tleTZdIHx8IHRyYW5zaXRpb25bXCJkZWZhdWx0XCJdIHx8IHRyYW5zaXRpb247XG59XG5mdW5jdGlvbiBzdGFydEFuaW1hdGlvbihrZXk2LCB2YWx1ZSwgdGFyZ2V0LCB0cmFuc2l0aW9uKSB7XG4gIGlmICh0cmFuc2l0aW9uID09PSB2b2lkIDApIHtcbiAgICB0cmFuc2l0aW9uID0ge307XG4gIH1cbiAgcmV0dXJuIHZhbHVlLnN0YXJ0KGZ1bmN0aW9uKG9uQ29tcGxldGUpIHtcbiAgICB2YXIgZGVsYXlUaW1lcjtcbiAgICB2YXIgY29udHJvbHM7XG4gICAgdmFyIGFuaW1hdGlvbiA9IGdldEFuaW1hdGlvbihrZXk2LCB2YWx1ZSwgdGFyZ2V0LCB0cmFuc2l0aW9uLCBvbkNvbXBsZXRlKTtcbiAgICB2YXIgZGVsYXkgPSBnZXREZWxheUZyb21UcmFuc2l0aW9uKHRyYW5zaXRpb24sIGtleTYpO1xuICAgIHZhciBzdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNvbnRyb2xzID0gYW5pbWF0aW9uKCk7XG4gICAgfTtcbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGRlbGF5VGltZXIgPSBzZXRUaW1lb3V0KHN0YXJ0LCBzZWNvbmRzVG9NaWxsaXNlY29uZHMoZGVsYXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGRlbGF5VGltZXIpO1xuICAgICAgY29udHJvbHMgPT09IG51bGwgfHwgY29udHJvbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRyb2xzLnN0b3AoKTtcbiAgICB9O1xuICB9KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9pcy1udW1lcmljYWwtc3RyaW5nLmpzXG52YXIgaXNOdW1lcmljYWxTdHJpbmcgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAvXlxcLT9cXGQqXFwuP1xcZCskLy50ZXN0KHYpO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9hcnJheS5qc1xuZnVuY3Rpb24gYWRkVW5pcXVlSXRlbShhcnIsIGl0ZW0pIHtcbiAgYXJyLmluZGV4T2YoaXRlbSkgPT09IC0xICYmIGFyci5wdXNoKGl0ZW0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlSXRlbShhcnIsIGl0ZW0pIHtcbiAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gIGluZGV4ID4gLTEgJiYgYXJyLnNwbGljZShpbmRleCwgMSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvc3Vic2NyaXB0aW9uLW1hbmFnZXIuanNcbnZhciBTdWJzY3JpcHRpb25NYW5hZ2VyID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbk1hbmFnZXIyKCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICB9XG4gIFN1YnNjcmlwdGlvbk1hbmFnZXIyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBhZGRVbmlxdWVJdGVtKHRoaXMuc3Vic2NyaXB0aW9ucywgaGFuZGxlcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlbW92ZUl0ZW0oX3RoaXMuc3Vic2NyaXB0aW9ucywgaGFuZGxlcik7XG4gICAgfTtcbiAgfTtcbiAgU3Vic2NyaXB0aW9uTWFuYWdlcjIucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uKGEyLCBiMiwgYzIpIHtcbiAgICB2YXIgbnVtU3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG4gICAgaWYgKCFudW1TdWJzY3JpcHRpb25zKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChudW1TdWJzY3JpcHRpb25zID09PSAxKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnNbMF0oYTIsIGIyLCBjMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU3Vic2NyaXB0aW9uczsgaSsrKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5zdWJzY3JpcHRpb25zW2ldO1xuICAgICAgICBoYW5kbGVyICYmIGhhbmRsZXIoYTIsIGIyLCBjMik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBTdWJzY3JpcHRpb25NYW5hZ2VyMi5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoO1xuICB9O1xuICBTdWJzY3JpcHRpb25NYW5hZ2VyMi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoID0gMDtcbiAgfTtcbiAgcmV0dXJuIFN1YnNjcmlwdGlvbk1hbmFnZXIyO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL2luZGV4LmpzXG52YXIgaXNGbG9hdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xufTtcbnZhciBNb3Rpb25WYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBNb3Rpb25WYWx1ZTEwKGluaXQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMudGltZURlbHRhID0gMDtcbiAgICB0aGlzLmxhc3RVcGRhdGVkID0gMDtcbiAgICB0aGlzLnVwZGF0ZVN1YnNjcmliZXJzID0gbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXIoKTtcbiAgICB0aGlzLnZlbG9jaXR5VXBkYXRlU3Vic2NyaWJlcnMgPSBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcigpO1xuICAgIHRoaXMucmVuZGVyU3Vic2NyaWJlcnMgPSBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcigpO1xuICAgIHRoaXMuY2FuVHJhY2tWZWxvY2l0eSA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlQW5kTm90aWZ5ID0gZnVuY3Rpb24odiwgcmVuZGVyKSB7XG4gICAgICBpZiAocmVuZGVyID09PSB2b2lkIDApIHtcbiAgICAgICAgcmVuZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIF90aGlzLnByZXYgPSBfdGhpcy5jdXJyZW50O1xuICAgICAgX3RoaXMuY3VycmVudCA9IHY7XG4gICAgICB2YXIgX2EgPSBnZXRGcmFtZURhdGEoKSwgZGVsdGEyID0gX2EuZGVsdGEsIHRpbWVzdGFtcCA9IF9hLnRpbWVzdGFtcDtcbiAgICAgIGlmIChfdGhpcy5sYXN0VXBkYXRlZCAhPT0gdGltZXN0YW1wKSB7XG4gICAgICAgIF90aGlzLnRpbWVEZWx0YSA9IGRlbHRhMjtcbiAgICAgICAgX3RoaXMubGFzdFVwZGF0ZWQgPSB0aW1lc3RhbXA7XG4gICAgICAgIGVzX2RlZmF1bHQucG9zdFJlbmRlcihfdGhpcy5zY2hlZHVsZVZlbG9jaXR5Q2hlY2spO1xuICAgICAgfVxuICAgICAgaWYgKF90aGlzLnByZXYgIT09IF90aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgX3RoaXMudXBkYXRlU3Vic2NyaWJlcnMubm90aWZ5KF90aGlzLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKF90aGlzLnZlbG9jaXR5VXBkYXRlU3Vic2NyaWJlcnMuZ2V0U2l6ZSgpKSB7XG4gICAgICAgIF90aGlzLnZlbG9jaXR5VXBkYXRlU3Vic2NyaWJlcnMubm90aWZ5KF90aGlzLmdldFZlbG9jaXR5KCkpO1xuICAgICAgfVxuICAgICAgaWYgKHJlbmRlcikge1xuICAgICAgICBfdGhpcy5yZW5kZXJTdWJzY3JpYmVycy5ub3RpZnkoX3RoaXMuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnNjaGVkdWxlVmVsb2NpdHlDaGVjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGVzX2RlZmF1bHQucG9zdFJlbmRlcihfdGhpcy52ZWxvY2l0eUNoZWNrKTtcbiAgICB9O1xuICAgIHRoaXMudmVsb2NpdHlDaGVjayA9IGZ1bmN0aW9uKF9hKSB7XG4gICAgICB2YXIgdGltZXN0YW1wID0gX2EudGltZXN0YW1wO1xuICAgICAgaWYgKHRpbWVzdGFtcCAhPT0gX3RoaXMubGFzdFVwZGF0ZWQpIHtcbiAgICAgICAgX3RoaXMucHJldiA9IF90aGlzLmN1cnJlbnQ7XG4gICAgICAgIF90aGlzLnZlbG9jaXR5VXBkYXRlU3Vic2NyaWJlcnMubm90aWZ5KF90aGlzLmdldFZlbG9jaXR5KCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYXNBbmltYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMucHJldiA9IHRoaXMuY3VycmVudCA9IGluaXQ7XG4gICAgdGhpcy5jYW5UcmFja1ZlbG9jaXR5ID0gaXNGbG9hdCh0aGlzLmN1cnJlbnQpO1xuICB9XG4gIE1vdGlvblZhbHVlMTAucHJvdG90eXBlLm9uQ2hhbmdlID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlU3Vic2NyaWJlcnMuYWRkKHN1YnNjcmlwdGlvbik7XG4gIH07XG4gIE1vdGlvblZhbHVlMTAucHJvdG90eXBlLmNsZWFyTGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51cGRhdGVTdWJzY3JpYmVycy5jbGVhcigpO1xuICB9O1xuICBNb3Rpb25WYWx1ZTEwLnByb3RvdHlwZS5vblJlbmRlclJlcXVlc3QgPSBmdW5jdGlvbihzdWJzY3JpcHRpb24pIHtcbiAgICBzdWJzY3JpcHRpb24odGhpcy5nZXQoKSk7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyU3Vic2NyaWJlcnMuYWRkKHN1YnNjcmlwdGlvbik7XG4gIH07XG4gIE1vdGlvblZhbHVlMTAucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uKHBhc3NpdmVFZmZlY3QpIHtcbiAgICB0aGlzLnBhc3NpdmVFZmZlY3QgPSBwYXNzaXZlRWZmZWN0O1xuICB9O1xuICBNb3Rpb25WYWx1ZTEwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbih2LCByZW5kZXIpIHtcbiAgICBpZiAocmVuZGVyID09PSB2b2lkIDApIHtcbiAgICAgIHJlbmRlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICghcmVuZGVyIHx8ICF0aGlzLnBhc3NpdmVFZmZlY3QpIHtcbiAgICAgIHRoaXMudXBkYXRlQW5kTm90aWZ5KHYsIHJlbmRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFzc2l2ZUVmZmVjdCh2LCB0aGlzLnVwZGF0ZUFuZE5vdGlmeSk7XG4gICAgfVxuICB9O1xuICBNb3Rpb25WYWx1ZTEwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICB9O1xuICBNb3Rpb25WYWx1ZTEwLnByb3RvdHlwZS5nZXRQcmV2aW91cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnByZXY7XG4gIH07XG4gIE1vdGlvblZhbHVlMTAucHJvdG90eXBlLmdldFZlbG9jaXR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FuVHJhY2tWZWxvY2l0eSA/IHZlbG9jaXR5UGVyU2Vjb25kKHBhcnNlRmxvYXQodGhpcy5jdXJyZW50KSAtIHBhcnNlRmxvYXQodGhpcy5wcmV2KSwgdGhpcy50aW1lRGVsdGEpIDogMDtcbiAgfTtcbiAgTW90aW9uVmFsdWUxMC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihhbmltYXRpb24pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICBfdGhpcy5oYXNBbmltYXRlZCA9IHRydWU7XG4gICAgICBfdGhpcy5zdG9wQW5pbWF0aW9uID0gYW5pbWF0aW9uKHJlc29sdmUpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX3RoaXMuY2xlYXJBbmltYXRpb24oKTtcbiAgICB9KTtcbiAgfTtcbiAgTW90aW9uVmFsdWUxMC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnN0b3BBbmltYXRpb24pXG4gICAgICB0aGlzLnN0b3BBbmltYXRpb24oKTtcbiAgICB0aGlzLmNsZWFyQW5pbWF0aW9uKCk7XG4gIH07XG4gIE1vdGlvblZhbHVlMTAucHJvdG90eXBlLmlzQW5pbWF0aW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhdGhpcy5zdG9wQW5pbWF0aW9uO1xuICB9O1xuICBNb3Rpb25WYWx1ZTEwLnByb3RvdHlwZS5jbGVhckFuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3RvcEFuaW1hdGlvbiA9IG51bGw7XG4gIH07XG4gIE1vdGlvblZhbHVlMTAucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVwZGF0ZVN1YnNjcmliZXJzLmNsZWFyKCk7XG4gICAgdGhpcy5yZW5kZXJTdWJzY3JpYmVycy5jbGVhcigpO1xuICAgIHRoaXMuc3RvcCgpO1xuICB9O1xuICByZXR1cm4gTW90aW9uVmFsdWUxMDtcbn0oKTtcbmZ1bmN0aW9uIG1vdGlvblZhbHVlKGluaXQpIHtcbiAgcmV0dXJuIG5ldyBNb3Rpb25WYWx1ZShpbml0KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL3Rlc3QuanNcbnZhciB0ZXN0VmFsdWVUeXBlID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gZnVuY3Rpb24odHlwZSkge1xuICAgIHJldHVybiB0eXBlLnRlc3Qodik7XG4gIH07XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvdHlwZS1hdXRvLmpzXG52YXIgYXV0byA9IHtcbiAgdGVzdDogZnVuY3Rpb24odikge1xuICAgIHJldHVybiB2ID09PSBcImF1dG9cIjtcbiAgfSxcbiAgcGFyc2U6IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL2RpbWVuc2lvbnMuanNcbnZhciBkaW1lbnNpb25WYWx1ZVR5cGVzID0gW251bWJlciwgcHgsIHBlcmNlbnQsIGRlZ3JlZXMsIHZ3LCB2aCwgYXV0b107XG52YXIgZmluZERpbWVuc2lvblZhbHVlVHlwZSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIGRpbWVuc2lvblZhbHVlVHlwZXMuZmluZCh0ZXN0VmFsdWVUeXBlKHYpKTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9maW5kLmpzXG52YXIgdmFsdWVUeXBlcyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGRpbWVuc2lvblZhbHVlVHlwZXMpKSwgW2NvbG9yLCBjb21wbGV4XSk7XG52YXIgZmluZFZhbHVlVHlwZSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIHZhbHVlVHlwZXMuZmluZCh0ZXN0VmFsdWVUeXBlKHYpKTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL3NldHRlcnMuanNcbmZ1bmN0aW9uIHNldE1vdGlvblZhbHVlKHZpc3VhbEVsZW1lbnQyLCBrZXk2LCB2YWx1ZSkge1xuICBpZiAodmlzdWFsRWxlbWVudDIuaGFzVmFsdWUoa2V5NikpIHtcbiAgICB2aXN1YWxFbGVtZW50Mi5nZXRWYWx1ZShrZXk2KS5zZXQodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZpc3VhbEVsZW1lbnQyLmFkZFZhbHVlKGtleTYsIG1vdGlvblZhbHVlKHZhbHVlKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFRhcmdldCh2aXN1YWxFbGVtZW50MiwgZGVmaW5pdGlvbikge1xuICB2YXIgcmVzb2x2ZWQgPSByZXNvbHZlVmFyaWFudCh2aXN1YWxFbGVtZW50MiwgZGVmaW5pdGlvbik7XG4gIHZhciBfYSA9IHJlc29sdmVkID8gdmlzdWFsRWxlbWVudDIubWFrZVRhcmdldEFuaW1hdGFibGUocmVzb2x2ZWQsIGZhbHNlKSA6IHt9LCBfYiA9IF9hLnRyYW5zaXRpb25FbmQsIHRyYW5zaXRpb25FbmQgPSBfYiA9PT0gdm9pZCAwID8ge30gOiBfYjtcbiAgX2EudHJhbnNpdGlvbjtcbiAgdmFyIHRhcmdldCA9IF9fcmVzdChfYSwgW1widHJhbnNpdGlvbkVuZFwiLCBcInRyYW5zaXRpb25cIl0pO1xuICB0YXJnZXQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGFyZ2V0KSwgdHJhbnNpdGlvbkVuZCk7XG4gIGZvciAodmFyIGtleTYgaW4gdGFyZ2V0KSB7XG4gICAgdmFyIHZhbHVlID0gcmVzb2x2ZUZpbmFsVmFsdWVJbktleWZyYW1lcyh0YXJnZXRba2V5Nl0pO1xuICAgIHNldE1vdGlvblZhbHVlKHZpc3VhbEVsZW1lbnQyLCBrZXk2LCB2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFZhcmlhbnRzKHZpc3VhbEVsZW1lbnQyLCB2YXJpYW50TGFiZWxzKSB7XG4gIHZhciByZXZlcnNlZExhYmVscyA9IF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZCh2YXJpYW50TGFiZWxzKSkucmV2ZXJzZSgpO1xuICByZXZlcnNlZExhYmVscy5mb3JFYWNoKGZ1bmN0aW9uKGtleTYpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIHZhcmlhbnQgPSB2aXN1YWxFbGVtZW50Mi5nZXRWYXJpYW50KGtleTYpO1xuICAgIHZhcmlhbnQgJiYgc2V0VGFyZ2V0KHZpc3VhbEVsZW1lbnQyLCB2YXJpYW50KTtcbiAgICAoX2EgPSB2aXN1YWxFbGVtZW50Mi52YXJpYW50Q2hpbGRyZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICBzZXRWYXJpYW50cyhjaGlsZCwgdmFyaWFudExhYmVscyk7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gc2V0VmFsdWVzKHZpc3VhbEVsZW1lbnQyLCBkZWZpbml0aW9uKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24pKSB7XG4gICAgcmV0dXJuIHNldFZhcmlhbnRzKHZpc3VhbEVsZW1lbnQyLCBkZWZpbml0aW9uKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzZXRWYXJpYW50cyh2aXN1YWxFbGVtZW50MiwgW2RlZmluaXRpb25dKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRUYXJnZXQodmlzdWFsRWxlbWVudDIsIGRlZmluaXRpb24pO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja1RhcmdldEZvck5ld1ZhbHVlcyh2aXN1YWxFbGVtZW50MiwgdGFyZ2V0LCBvcmlnaW4pIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIHZhciBfZDtcbiAgdmFyIG5ld1ZhbHVlS2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldCkuZmlsdGVyKGZ1bmN0aW9uKGtleTcpIHtcbiAgICByZXR1cm4gIXZpc3VhbEVsZW1lbnQyLmhhc1ZhbHVlKGtleTcpO1xuICB9KTtcbiAgdmFyIG51bU5ld1ZhbHVlcyA9IG5ld1ZhbHVlS2V5cy5sZW5ndGg7XG4gIGlmICghbnVtTmV3VmFsdWVzKVxuICAgIHJldHVybjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1OZXdWYWx1ZXM7IGkrKykge1xuICAgIHZhciBrZXk2ID0gbmV3VmFsdWVLZXlzW2ldO1xuICAgIHZhciB0YXJnZXRWYWx1ZSA9IHRhcmdldFtrZXk2XTtcbiAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldFZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB0YXJnZXRWYWx1ZVswXTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICB2YWx1ZSA9IChfYiA9IChfYSA9IG9yaWdpbltrZXk2XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmlzdWFsRWxlbWVudDIucmVhZFZhbHVlKGtleTYpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0YXJnZXRba2V5Nl07XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwIHx8IHZhbHVlID09PSBudWxsKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAoaXNOdW1lcmljYWxTdHJpbmcodmFsdWUpIHx8IHZhbHVlLnN0YXJ0c1dpdGgoXCIwXCIpKSkge1xuICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKCFmaW5kVmFsdWVUeXBlKHZhbHVlKSAmJiBjb21wbGV4LnRlc3QodGFyZ2V0VmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IGdldEFuaW1hdGFibGVOb25lMihrZXk2LCB0YXJnZXRWYWx1ZSk7XG4gICAgfVxuICAgIHZpc3VhbEVsZW1lbnQyLmFkZFZhbHVlKGtleTYsIG1vdGlvblZhbHVlKHZhbHVlKSk7XG4gICAgKF9jID0gKF9kID0gb3JpZ2luKVtrZXk2XSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogX2Rba2V5Nl0gPSB2YWx1ZTtcbiAgICB2aXN1YWxFbGVtZW50Mi5zZXRCYXNlVGFyZ2V0KGtleTYsIHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0T3JpZ2luRnJvbVRyYW5zaXRpb24oa2V5NiwgdHJhbnNpdGlvbikge1xuICBpZiAoIXRyYW5zaXRpb24pXG4gICAgcmV0dXJuO1xuICB2YXIgdmFsdWVUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXk2XSB8fCB0cmFuc2l0aW9uW1wiZGVmYXVsdFwiXSB8fCB0cmFuc2l0aW9uO1xuICByZXR1cm4gdmFsdWVUcmFuc2l0aW9uLmZyb207XG59XG5mdW5jdGlvbiBnZXRPcmlnaW4odGFyZ2V0LCB0cmFuc2l0aW9uLCB2aXN1YWxFbGVtZW50Mikge1xuICB2YXIgX2EsIF9iO1xuICB2YXIgb3JpZ2luID0ge307XG4gIGZvciAodmFyIGtleTYgaW4gdGFyZ2V0KSB7XG4gICAgb3JpZ2luW2tleTZdID0gKF9hID0gZ2V0T3JpZ2luRnJvbVRyYW5zaXRpb24oa2V5NiwgdHJhbnNpdGlvbikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYiA9IHZpc3VhbEVsZW1lbnQyLmdldFZhbHVlKGtleTYpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0KCk7XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvYW5pbWF0aW9uLmpzXG5mdW5jdGlvbiBhbmltYXRlVmlzdWFsRWxlbWVudCh2aXN1YWxFbGVtZW50MiwgZGVmaW5pdGlvbiwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHZpc3VhbEVsZW1lbnQyLm5vdGlmeUFuaW1hdGlvblN0YXJ0KCk7XG4gIHZhciBhbmltYXRpb247XG4gIGlmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24pKSB7XG4gICAgdmFyIGFuaW1hdGlvbnMyID0gZGVmaW5pdGlvbi5tYXAoZnVuY3Rpb24odmFyaWFudCkge1xuICAgICAgcmV0dXJuIGFuaW1hdGVWYXJpYW50KHZpc3VhbEVsZW1lbnQyLCB2YXJpYW50LCBvcHRpb25zKTtcbiAgICB9KTtcbiAgICBhbmltYXRpb24gPSBQcm9taXNlLmFsbChhbmltYXRpb25zMik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICBhbmltYXRpb24gPSBhbmltYXRlVmFyaWFudCh2aXN1YWxFbGVtZW50MiwgZGVmaW5pdGlvbiwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlc29sdmVkRGVmaW5pdGlvbiA9IHR5cGVvZiBkZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCIgPyByZXNvbHZlVmFyaWFudCh2aXN1YWxFbGVtZW50MiwgZGVmaW5pdGlvbiwgb3B0aW9ucy5jdXN0b20pIDogZGVmaW5pdGlvbjtcbiAgICBhbmltYXRpb24gPSBhbmltYXRlVGFyZ2V0KHZpc3VhbEVsZW1lbnQyLCByZXNvbHZlZERlZmluaXRpb24sIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBhbmltYXRpb24udGhlbihmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmlzdWFsRWxlbWVudDIubm90aWZ5QW5pbWF0aW9uQ29tcGxldGUoZGVmaW5pdGlvbik7XG4gIH0pO1xufVxuZnVuY3Rpb24gYW5pbWF0ZVZhcmlhbnQodmlzdWFsRWxlbWVudDIsIHZhcmlhbnQsIG9wdGlvbnMpIHtcbiAgdmFyIF9hO1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHZhciByZXNvbHZlZCA9IHJlc29sdmVWYXJpYW50KHZpc3VhbEVsZW1lbnQyLCB2YXJpYW50LCBvcHRpb25zLmN1c3RvbSk7XG4gIHZhciBfYiA9IChyZXNvbHZlZCB8fCB7fSkudHJhbnNpdGlvbiwgdHJhbnNpdGlvbiA9IF9iID09PSB2b2lkIDAgPyB2aXN1YWxFbGVtZW50Mi5nZXREZWZhdWx0VHJhbnNpdGlvbigpIHx8IHt9IDogX2I7XG4gIGlmIChvcHRpb25zLnRyYW5zaXRpb25PdmVycmlkZSkge1xuICAgIHRyYW5zaXRpb24gPSBvcHRpb25zLnRyYW5zaXRpb25PdmVycmlkZTtcbiAgfVxuICB2YXIgZ2V0QW5pbWF0aW9uMiA9IHJlc29sdmVkID8gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFuaW1hdGVUYXJnZXQodmlzdWFsRWxlbWVudDIsIHJlc29sdmVkLCBvcHRpb25zKTtcbiAgfSA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgdmFyIGdldENoaWxkQW5pbWF0aW9ucyA9ICgoX2EgPSB2aXN1YWxFbGVtZW50Mi52YXJpYW50Q2hpbGRyZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaXplKSA/IGZ1bmN0aW9uKGZvcndhcmREZWxheSkge1xuICAgIGlmIChmb3J3YXJkRGVsYXkgPT09IHZvaWQgMCkge1xuICAgICAgZm9yd2FyZERlbGF5ID0gMDtcbiAgICB9XG4gICAgdmFyIF9hMiA9IHRyYW5zaXRpb24uZGVsYXlDaGlsZHJlbiwgZGVsYXlDaGlsZHJlbiA9IF9hMiA9PT0gdm9pZCAwID8gMCA6IF9hMiwgc3RhZ2dlckNoaWxkcmVuID0gdHJhbnNpdGlvbi5zdGFnZ2VyQ2hpbGRyZW4sIHN0YWdnZXJEaXJlY3Rpb24gPSB0cmFuc2l0aW9uLnN0YWdnZXJEaXJlY3Rpb247XG4gICAgcmV0dXJuIGFuaW1hdGVDaGlsZHJlbih2aXN1YWxFbGVtZW50MiwgdmFyaWFudCwgZGVsYXlDaGlsZHJlbiArIGZvcndhcmREZWxheSwgc3RhZ2dlckNoaWxkcmVuLCBzdGFnZ2VyRGlyZWN0aW9uLCBvcHRpb25zKTtcbiAgfSA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgdmFyIHdoZW4gPSB0cmFuc2l0aW9uLndoZW47XG4gIGlmICh3aGVuKSB7XG4gICAgdmFyIF9jID0gX19yZWFkKHdoZW4gPT09IFwiYmVmb3JlQ2hpbGRyZW5cIiA/IFtnZXRBbmltYXRpb24yLCBnZXRDaGlsZEFuaW1hdGlvbnNdIDogW2dldENoaWxkQW5pbWF0aW9ucywgZ2V0QW5pbWF0aW9uMl0sIDIpLCBmaXJzdCA9IF9jWzBdLCBsYXN0ID0gX2NbMV07XG4gICAgcmV0dXJuIGZpcnN0KCkudGhlbihsYXN0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2dldEFuaW1hdGlvbjIoKSwgZ2V0Q2hpbGRBbmltYXRpb25zKG9wdGlvbnMuZGVsYXkpXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFuaW1hdGVUYXJnZXQodmlzdWFsRWxlbWVudDIsIGRlZmluaXRpb24sIF9hKSB7XG4gIHZhciBfYjtcbiAgdmFyIF9jID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9kID0gX2MuZGVsYXksIGRlbGF5ID0gX2QgPT09IHZvaWQgMCA/IDAgOiBfZCwgdHJhbnNpdGlvbk92ZXJyaWRlID0gX2MudHJhbnNpdGlvbk92ZXJyaWRlLCB0eXBlID0gX2MudHlwZTtcbiAgdmFyIF9lID0gdmlzdWFsRWxlbWVudDIubWFrZVRhcmdldEFuaW1hdGFibGUoZGVmaW5pdGlvbiksIF9mID0gX2UudHJhbnNpdGlvbiwgdHJhbnNpdGlvbiA9IF9mID09PSB2b2lkIDAgPyB2aXN1YWxFbGVtZW50Mi5nZXREZWZhdWx0VHJhbnNpdGlvbigpIDogX2YsIHRyYW5zaXRpb25FbmQgPSBfZS50cmFuc2l0aW9uRW5kLCB0YXJnZXQgPSBfX3Jlc3QoX2UsIFtcInRyYW5zaXRpb25cIiwgXCJ0cmFuc2l0aW9uRW5kXCJdKTtcbiAgaWYgKHRyYW5zaXRpb25PdmVycmlkZSlcbiAgICB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbk92ZXJyaWRlO1xuICB2YXIgYW5pbWF0aW9uczIgPSBbXTtcbiAgdmFyIGFuaW1hdGlvblR5cGVTdGF0ZSA9IHR5cGUgJiYgKChfYiA9IHZpc3VhbEVsZW1lbnQyLmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0U3RhdGUoKVt0eXBlXSk7XG4gIGZvciAodmFyIGtleTYgaW4gdGFyZ2V0KSB7XG4gICAgdmFyIHZhbHVlID0gdmlzdWFsRWxlbWVudDIuZ2V0VmFsdWUoa2V5Nik7XG4gICAgdmFyIHZhbHVlVGFyZ2V0ID0gdGFyZ2V0W2tleTZdO1xuICAgIGlmICghdmFsdWUgfHwgdmFsdWVUYXJnZXQgPT09IHZvaWQgMCB8fCBhbmltYXRpb25UeXBlU3RhdGUgJiYgc2hvdWxkQmxvY2tBbmltYXRpb24oYW5pbWF0aW9uVHlwZVN0YXRlLCBrZXk2KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBhbmltYXRpb24gPSBzdGFydEFuaW1hdGlvbihrZXk2LCB2YWx1ZSwgdmFsdWVUYXJnZXQsIF9fYXNzaWduKHsgZGVsYXkgfSwgdHJhbnNpdGlvbikpO1xuICAgIGFuaW1hdGlvbnMyLnB1c2goYW5pbWF0aW9uKTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwoYW5pbWF0aW9uczIpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgdHJhbnNpdGlvbkVuZCAmJiBzZXRUYXJnZXQodmlzdWFsRWxlbWVudDIsIHRyYW5zaXRpb25FbmQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFuaW1hdGVDaGlsZHJlbih2aXN1YWxFbGVtZW50MiwgdmFyaWFudCwgZGVsYXlDaGlsZHJlbiwgc3RhZ2dlckNoaWxkcmVuLCBzdGFnZ2VyRGlyZWN0aW9uLCBvcHRpb25zKSB7XG4gIGlmIChkZWxheUNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICBkZWxheUNoaWxkcmVuID0gMDtcbiAgfVxuICBpZiAoc3RhZ2dlckNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICBzdGFnZ2VyQ2hpbGRyZW4gPSAwO1xuICB9XG4gIGlmIChzdGFnZ2VyRGlyZWN0aW9uID09PSB2b2lkIDApIHtcbiAgICBzdGFnZ2VyRGlyZWN0aW9uID0gMTtcbiAgfVxuICB2YXIgYW5pbWF0aW9uczIgPSBbXTtcbiAgdmFyIG1heFN0YWdnZXJEdXJhdGlvbiA9ICh2aXN1YWxFbGVtZW50Mi52YXJpYW50Q2hpbGRyZW4uc2l6ZSAtIDEpICogc3RhZ2dlckNoaWxkcmVuO1xuICB2YXIgZ2VuZXJhdGVTdGFnZ2VyRHVyYXRpb24gPSBzdGFnZ2VyRGlyZWN0aW9uID09PSAxID8gZnVuY3Rpb24oaSkge1xuICAgIGlmIChpID09PSB2b2lkIDApIHtcbiAgICAgIGkgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gaSAqIHN0YWdnZXJDaGlsZHJlbjtcbiAgfSA6IGZ1bmN0aW9uKGkpIHtcbiAgICBpZiAoaSA9PT0gdm9pZCAwKSB7XG4gICAgICBpID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1heFN0YWdnZXJEdXJhdGlvbiAtIGkgKiBzdGFnZ2VyQ2hpbGRyZW47XG4gIH07XG4gIEFycmF5LmZyb20odmlzdWFsRWxlbWVudDIudmFyaWFudENoaWxkcmVuKS5zb3J0KHNvcnRCeVRyZWVPcmRlcikuZm9yRWFjaChmdW5jdGlvbihjaGlsZCwgaSkge1xuICAgIGFuaW1hdGlvbnMyLnB1c2goYW5pbWF0ZVZhcmlhbnQoY2hpbGQsIHZhcmlhbnQsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBkZWxheTogZGVsYXlDaGlsZHJlbiArIGdlbmVyYXRlU3RhZ2dlckR1cmF0aW9uKGkpIH0pKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNoaWxkLm5vdGlmeUFuaW1hdGlvbkNvbXBsZXRlKHZhcmlhbnQpO1xuICAgIH0pKTtcbiAgfSk7XG4gIHJldHVybiBQcm9taXNlLmFsbChhbmltYXRpb25zMik7XG59XG5mdW5jdGlvbiBzdG9wQW5pbWF0aW9uKHZpc3VhbEVsZW1lbnQyKSB7XG4gIHZpc3VhbEVsZW1lbnQyLmZvckVhY2hWYWx1ZShmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5zdG9wKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gc29ydEJ5VHJlZU9yZGVyKGEyLCBiMikge1xuICByZXR1cm4gYTIuc29ydE5vZGVQb3NpdGlvbihiMik7XG59XG5mdW5jdGlvbiBzaG91bGRCbG9ja0FuaW1hdGlvbihfYSwga2V5Nikge1xuICB2YXIgcHJvdGVjdGVkS2V5cyA9IF9hLnByb3RlY3RlZEtleXMsIG5lZWRzQW5pbWF0aW5nID0gX2EubmVlZHNBbmltYXRpbmc7XG4gIHZhciBzaG91bGRCbG9jayA9IHByb3RlY3RlZEtleXMuaGFzT3duUHJvcGVydHkoa2V5NikgJiYgbmVlZHNBbmltYXRpbmdba2V5Nl0gIT09IHRydWU7XG4gIG5lZWRzQW5pbWF0aW5nW2tleTZdID0gZmFsc2U7XG4gIHJldHVybiBzaG91bGRCbG9jaztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvYW5pbWF0aW9uLXN0YXRlLmpzXG52YXIgdmFyaWFudFByaW9yaXR5T3JkZXIgPSBbXG4gIEFuaW1hdGlvblR5cGUuQW5pbWF0ZSxcbiAgQW5pbWF0aW9uVHlwZS5Ib3ZlcixcbiAgQW5pbWF0aW9uVHlwZS5UYXAsXG4gIEFuaW1hdGlvblR5cGUuRHJhZyxcbiAgQW5pbWF0aW9uVHlwZS5Gb2N1cyxcbiAgQW5pbWF0aW9uVHlwZS5FeGl0XG5dO1xudmFyIHJldmVyc2VQcmlvcml0eU9yZGVyID0gX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHZhcmlhbnRQcmlvcml0eU9yZGVyKSkucmV2ZXJzZSgpO1xudmFyIG51bUFuaW1hdGlvblR5cGVzID0gdmFyaWFudFByaW9yaXR5T3JkZXIubGVuZ3RoO1xuZnVuY3Rpb24gYW5pbWF0ZUxpc3QodmlzdWFsRWxlbWVudDIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFuaW1hdGlvbnMyKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGFuaW1hdGlvbnMyLm1hcChmdW5jdGlvbihfYSkge1xuICAgICAgdmFyIGFuaW1hdGlvbiA9IF9hLmFuaW1hdGlvbiwgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgICByZXR1cm4gYW5pbWF0ZVZpc3VhbEVsZW1lbnQodmlzdWFsRWxlbWVudDIsIGFuaW1hdGlvbiwgb3B0aW9ucyk7XG4gICAgfSkpO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQW5pbWF0aW9uU3RhdGUodmlzdWFsRWxlbWVudDIpIHtcbiAgdmFyIGFuaW1hdGU0ID0gYW5pbWF0ZUxpc3QodmlzdWFsRWxlbWVudDIpO1xuICB2YXIgc3RhdGUgPSBjcmVhdGVTdGF0ZSgpO1xuICB2YXIgYWxsQW5pbWF0ZWRLZXlzID0ge307XG4gIHZhciBpc0luaXRpYWxSZW5kZXIgPSB0cnVlO1xuICB2YXIgYnVpbGRSZXNvbHZlZFR5cGVWYWx1ZXMgPSBmdW5jdGlvbihhY2MsIGRlZmluaXRpb24pIHtcbiAgICB2YXIgcmVzb2x2ZWQgPSByZXNvbHZlVmFyaWFudCh2aXN1YWxFbGVtZW50MiwgZGVmaW5pdGlvbik7XG4gICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICByZXNvbHZlZC50cmFuc2l0aW9uO1xuICAgICAgdmFyIHRyYW5zaXRpb25FbmQgPSByZXNvbHZlZC50cmFuc2l0aW9uRW5kLCB0YXJnZXQgPSBfX3Jlc3QocmVzb2x2ZWQsIFtcInRyYW5zaXRpb25cIiwgXCJ0cmFuc2l0aW9uRW5kXCJdKTtcbiAgICAgIGFjYyA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBhY2MpLCB0YXJnZXQpLCB0cmFuc2l0aW9uRW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfTtcbiAgZnVuY3Rpb24gaXNBbmltYXRlZChrZXk2KSB7XG4gICAgcmV0dXJuIGFsbEFuaW1hdGVkS2V5c1trZXk2XSAhPT0gdm9pZCAwO1xuICB9XG4gIGZ1bmN0aW9uIHNldEFuaW1hdGVGdW5jdGlvbihtYWtlQW5pbWF0b3IpIHtcbiAgICBhbmltYXRlNCA9IG1ha2VBbmltYXRvcih2aXN1YWxFbGVtZW50Mik7XG4gIH1cbiAgZnVuY3Rpb24gYW5pbWF0ZUNoYW5nZXMob3B0aW9ucywgY2hhbmdlZEFjdGl2ZVR5cGUpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIHByb3BzID0gdmlzdWFsRWxlbWVudDIuZ2V0UHJvcHMoKTtcbiAgICB2YXIgY29udGV4dCA9IHZpc3VhbEVsZW1lbnQyLmdldFZhcmlhbnRDb250ZXh0KHRydWUpIHx8IHt9O1xuICAgIHZhciBhbmltYXRpb25zMiA9IFtdO1xuICAgIHZhciByZW1vdmVkS2V5cyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZW5jb3VudGVyZWRLZXlzID0ge307XG4gICAgdmFyIHJlbW92ZWRWYXJpYW50SW5kZXggPSBJbmZpbml0eTtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uKGkyKSB7XG4gICAgICB2YXIgdHlwZSA9IHJldmVyc2VQcmlvcml0eU9yZGVyW2kyXTtcbiAgICAgIHZhciB0eXBlU3RhdGUgPSBzdGF0ZVt0eXBlXTtcbiAgICAgIHZhciBwcm9wID0gKF9hID0gcHJvcHNbdHlwZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnRleHRbdHlwZV07XG4gICAgICB2YXIgcHJvcElzVmFyaWFudCA9IGlzVmFyaWFudExhYmVsKHByb3ApO1xuICAgICAgdmFyIGFjdGl2ZURlbHRhID0gdHlwZSA9PT0gY2hhbmdlZEFjdGl2ZVR5cGUgPyB0eXBlU3RhdGUuaXNBY3RpdmUgOiBudWxsO1xuICAgICAgaWYgKGFjdGl2ZURlbHRhID09PSBmYWxzZSlcbiAgICAgICAgcmVtb3ZlZFZhcmlhbnRJbmRleCA9IGkyO1xuICAgICAgdmFyIGlzSW5oZXJpdGVkID0gcHJvcCA9PT0gY29udGV4dFt0eXBlXSAmJiBwcm9wICE9PSBwcm9wc1t0eXBlXSAmJiBwcm9wSXNWYXJpYW50O1xuICAgICAgaWYgKGlzSW5oZXJpdGVkICYmIGlzSW5pdGlhbFJlbmRlciAmJiB2aXN1YWxFbGVtZW50Mi5tYW51YWxseUFuaW1hdGVPbk1vdW50KSB7XG4gICAgICAgIGlzSW5oZXJpdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0eXBlU3RhdGUucHJvdGVjdGVkS2V5cyA9IF9fYXNzaWduKHt9LCBlbmNvdW50ZXJlZEtleXMpO1xuICAgICAgaWYgKCF0eXBlU3RhdGUuaXNBY3RpdmUgJiYgYWN0aXZlRGVsdGEgPT09IG51bGwgfHwgIXByb3AgJiYgIXR5cGVTdGF0ZS5wcmV2UHJvcCB8fCBpc0FuaW1hdGlvbkNvbnRyb2xzKHByb3ApIHx8IHR5cGVvZiBwcm9wID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgfVxuICAgICAgdmFyIHNob3VsZEFuaW1hdGVUeXBlID0gdmFyaWFudHNIYXZlQ2hhbmdlZCh0eXBlU3RhdGUucHJldlByb3AsIHByb3ApIHx8IHR5cGUgPT09IGNoYW5nZWRBY3RpdmVUeXBlICYmIHR5cGVTdGF0ZS5pc0FjdGl2ZSAmJiAhaXNJbmhlcml0ZWQgJiYgcHJvcElzVmFyaWFudCB8fCBpMiA+IHJlbW92ZWRWYXJpYW50SW5kZXggJiYgcHJvcElzVmFyaWFudDtcbiAgICAgIHZhciBkZWZpbml0aW9uTGlzdCA9IEFycmF5LmlzQXJyYXkocHJvcCkgPyBwcm9wIDogW3Byb3BdO1xuICAgICAgdmFyIHJlc29sdmVkVmFsdWVzID0gZGVmaW5pdGlvbkxpc3QucmVkdWNlKGJ1aWxkUmVzb2x2ZWRUeXBlVmFsdWVzLCB7fSk7XG4gICAgICBpZiAoYWN0aXZlRGVsdGEgPT09IGZhbHNlKVxuICAgICAgICByZXNvbHZlZFZhbHVlcyA9IHt9O1xuICAgICAgdmFyIF9iID0gdHlwZVN0YXRlLnByZXZSZXNvbHZlZFZhbHVlcywgcHJldlJlc29sdmVkVmFsdWVzID0gX2IgPT09IHZvaWQgMCA/IHt9IDogX2I7XG4gICAgICB2YXIgYWxsS2V5cyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcmV2UmVzb2x2ZWRWYWx1ZXMpLCByZXNvbHZlZFZhbHVlcyk7XG4gICAgICB2YXIgbWFya1RvQW5pbWF0ZSA9IGZ1bmN0aW9uKGtleTcpIHtcbiAgICAgICAgc2hvdWxkQW5pbWF0ZVR5cGUgPSB0cnVlO1xuICAgICAgICByZW1vdmVkS2V5cy5kZWxldGUoa2V5Nyk7XG4gICAgICAgIHR5cGVTdGF0ZS5uZWVkc0FuaW1hdGluZ1trZXk3XSA9IHRydWU7XG4gICAgICB9O1xuICAgICAgZm9yICh2YXIga2V5NiBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBuZXh0ID0gcmVzb2x2ZWRWYWx1ZXNba2V5Nl07XG4gICAgICAgIHZhciBwcmV2ID0gcHJldlJlc29sdmVkVmFsdWVzW2tleTZdO1xuICAgICAgICBpZiAoZW5jb3VudGVyZWRLZXlzLmhhc093blByb3BlcnR5KGtleTYpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAobmV4dCAhPT0gcHJldikge1xuICAgICAgICAgIGlmIChpc0tleWZyYW1lc1RhcmdldChuZXh0KSAmJiBpc0tleWZyYW1lc1RhcmdldChwcmV2KSkge1xuICAgICAgICAgICAgaWYgKCFzaGFsbG93Q29tcGFyZShuZXh0LCBwcmV2KSkge1xuICAgICAgICAgICAgICBtYXJrVG9BbmltYXRlKGtleTYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHlwZVN0YXRlLnByb3RlY3RlZEtleXNba2V5Nl0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobmV4dCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBtYXJrVG9BbmltYXRlKGtleTYpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVkS2V5cy5hZGQoa2V5Nik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5leHQgIT09IHZvaWQgMCAmJiByZW1vdmVkS2V5cy5oYXMoa2V5NikpIHtcbiAgICAgICAgICBtYXJrVG9BbmltYXRlKGtleTYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR5cGVTdGF0ZS5wcm90ZWN0ZWRLZXlzW2tleTZdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHlwZVN0YXRlLnByZXZQcm9wID0gcHJvcDtcbiAgICAgIHR5cGVTdGF0ZS5wcmV2UmVzb2x2ZWRWYWx1ZXMgPSByZXNvbHZlZFZhbHVlcztcbiAgICAgIGlmICh0eXBlU3RhdGUuaXNBY3RpdmUpIHtcbiAgICAgICAgZW5jb3VudGVyZWRLZXlzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGVuY291bnRlcmVkS2V5cyksIHJlc29sdmVkVmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0luaXRpYWxSZW5kZXIgJiYgdmlzdWFsRWxlbWVudDIuYmxvY2tJbml0aWFsQW5pbWF0aW9uKSB7XG4gICAgICAgIHNob3VsZEFuaW1hdGVUeXBlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkQW5pbWF0ZVR5cGUgJiYgIWlzSW5oZXJpdGVkKSB7XG4gICAgICAgIGFuaW1hdGlvbnMyLnB1c2guYXBwbHkoYW5pbWF0aW9uczIsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChkZWZpbml0aW9uTGlzdC5tYXAoZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbixcbiAgICAgICAgICAgIG9wdGlvbnM6IF9fYXNzaWduKHsgdHlwZSB9LCBvcHRpb25zKVxuICAgICAgICAgIH07XG4gICAgICAgIH0pKSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1BbmltYXRpb25UeXBlczsgaSsrKSB7XG4gICAgICBfbG9vcF8xKGkpO1xuICAgIH1cbiAgICBhbGxBbmltYXRlZEtleXMgPSBfX2Fzc2lnbih7fSwgZW5jb3VudGVyZWRLZXlzKTtcbiAgICBpZiAocmVtb3ZlZEtleXMuc2l6ZSkge1xuICAgICAgdmFyIGZhbGxiYWNrQW5pbWF0aW9uXzEgPSB7fTtcbiAgICAgIHJlbW92ZWRLZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5Nikge1xuICAgICAgICB2YXIgZmFsbGJhY2tUYXJnZXQgPSB2aXN1YWxFbGVtZW50Mi5nZXRCYXNlVGFyZ2V0KGtleTYpO1xuICAgICAgICBpZiAoZmFsbGJhY2tUYXJnZXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGZhbGxiYWNrQW5pbWF0aW9uXzFba2V5Nl0gPSBmYWxsYmFja1RhcmdldDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhbmltYXRpb25zMi5wdXNoKHsgYW5pbWF0aW9uOiBmYWxsYmFja0FuaW1hdGlvbl8xIH0pO1xuICAgIH1cbiAgICB2YXIgc2hvdWxkQW5pbWF0ZSA9IEJvb2xlYW4oYW5pbWF0aW9uczIubGVuZ3RoKTtcbiAgICBpZiAoaXNJbml0aWFsUmVuZGVyICYmIHByb3BzLmluaXRpYWwgPT09IGZhbHNlICYmICF2aXN1YWxFbGVtZW50Mi5tYW51YWxseUFuaW1hdGVPbk1vdW50KSB7XG4gICAgICBzaG91bGRBbmltYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIGlzSW5pdGlhbFJlbmRlciA9IGZhbHNlO1xuICAgIHJldHVybiBzaG91bGRBbmltYXRlID8gYW5pbWF0ZTQoYW5pbWF0aW9uczIpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0QWN0aXZlKHR5cGUsIGlzQWN0aXZlLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChzdGF0ZVt0eXBlXS5pc0FjdGl2ZSA9PT0gaXNBY3RpdmUpXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgKF9hID0gdmlzdWFsRWxlbWVudDIudmFyaWFudENoaWxkcmVuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIHJldHVybiAoX2EyID0gY2hpbGQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9hMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EyLnNldEFjdGl2ZSh0eXBlLCBpc0FjdGl2ZSk7XG4gICAgfSk7XG4gICAgc3RhdGVbdHlwZV0uaXNBY3RpdmUgPSBpc0FjdGl2ZTtcbiAgICByZXR1cm4gYW5pbWF0ZUNoYW5nZXMob3B0aW9ucywgdHlwZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0FuaW1hdGVkLFxuICAgIGFuaW1hdGVDaGFuZ2VzLFxuICAgIHNldEFjdGl2ZSxcbiAgICBzZXRBbmltYXRlRnVuY3Rpb24sXG4gICAgZ2V0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHZhcmlhbnRzSGF2ZUNoYW5nZWQocHJldiwgbmV4dCkge1xuICBpZiAodHlwZW9mIG5leHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbmV4dCAhPT0gcHJldjtcbiAgfSBlbHNlIGlmIChpc1ZhcmlhbnRMYWJlbHMobmV4dCkpIHtcbiAgICByZXR1cm4gIXNoYWxsb3dDb21wYXJlKG5leHQsIHByZXYpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR5cGVTdGF0ZShpc0FjdGl2ZSkge1xuICBpZiAoaXNBY3RpdmUgPT09IHZvaWQgMCkge1xuICAgIGlzQWN0aXZlID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0FjdGl2ZSxcbiAgICBwcm90ZWN0ZWRLZXlzOiB7fSxcbiAgICBuZWVkc0FuaW1hdGluZzoge30sXG4gICAgcHJldlJlc29sdmVkVmFsdWVzOiB7fVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGUoKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIF9hID0ge30sIF9hW0FuaW1hdGlvblR5cGUuQW5pbWF0ZV0gPSBjcmVhdGVUeXBlU3RhdGUodHJ1ZSksIF9hW0FuaW1hdGlvblR5cGUuSG92ZXJdID0gY3JlYXRlVHlwZVN0YXRlKCksIF9hW0FuaW1hdGlvblR5cGUuVGFwXSA9IGNyZWF0ZVR5cGVTdGF0ZSgpLCBfYVtBbmltYXRpb25UeXBlLkRyYWddID0gY3JlYXRlVHlwZVN0YXRlKCksIF9hW0FuaW1hdGlvblR5cGUuRm9jdXNdID0gY3JlYXRlVHlwZVN0YXRlKCksIF9hW0FuaW1hdGlvblR5cGUuRXhpdF0gPSBjcmVhdGVUeXBlU3RhdGUoKSwgX2E7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2FuaW1hdGlvbnMuanNcbnZhciBhbmltYXRpb25zID0ge1xuICBhbmltYXRpb246IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KGZ1bmN0aW9uKF9hKSB7XG4gICAgdmFyIHZpc3VhbEVsZW1lbnQyID0gX2EudmlzdWFsRWxlbWVudCwgYW5pbWF0ZTQgPSBfYS5hbmltYXRlO1xuICAgIHZpc3VhbEVsZW1lbnQyLmFuaW1hdGlvblN0YXRlIHx8ICh2aXN1YWxFbGVtZW50Mi5hbmltYXRpb25TdGF0ZSA9IGNyZWF0ZUFuaW1hdGlvblN0YXRlKHZpc3VhbEVsZW1lbnQyKSk7XG4gICAgaWYgKGlzQW5pbWF0aW9uQ29udHJvbHMoYW5pbWF0ZTQpKSB7XG4gICAgICB1c2VFZmZlY3Q2KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYW5pbWF0ZTQuc3Vic2NyaWJlKHZpc3VhbEVsZW1lbnQyKTtcbiAgICAgIH0sIFthbmltYXRlNF0pO1xuICAgIH1cbiAgfSksXG4gIGV4aXQ6IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgdmFyIGN1c3RvbSA9IHByb3BzLmN1c3RvbSwgdmlzdWFsRWxlbWVudDIgPSBwcm9wcy52aXN1YWxFbGVtZW50O1xuICAgIHZhciBfYSA9IF9fcmVhZCh1c2VQcmVzZW5jZSgpLCAyKSwgaXNQcmVzZW50MiA9IF9hWzBdLCBvbkV4aXRDb21wbGV0ZSA9IF9hWzFdO1xuICAgIHZhciBwcmVzZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0OChQcmVzZW5jZUNvbnRleHQpO1xuICAgIHVzZUVmZmVjdDYoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX2EyLCBfYjtcbiAgICAgIHZhciBhbmltYXRpb24gPSAoX2EyID0gdmlzdWFsRWxlbWVudDIuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9hMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EyLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLkV4aXQsICFpc1ByZXNlbnQyLCB7IGN1c3RvbTogKF9iID0gcHJlc2VuY2VDb250ZXh0ID09PSBudWxsIHx8IHByZXNlbmNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJlc2VuY2VDb250ZXh0LmN1c3RvbSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY3VzdG9tIH0pO1xuICAgICAgIWlzUHJlc2VudDIgJiYgKGFuaW1hdGlvbiA9PT0gbnVsbCB8fCBhbmltYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFuaW1hdGlvbi50aGVuKG9uRXhpdENvbXBsZXRlKSk7XG4gICAgfSwgW2lzUHJlc2VudDJdKTtcbiAgfSlcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvZHJhZy91c2UtZHJhZy5qc1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0OSwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDcgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9QYW5TZXNzaW9uLmpzXG52YXIgUGFuU2Vzc2lvbiA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBQYW5TZXNzaW9uMihldmVudCwgaGFuZGxlcnMsIF9hKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgdHJhbnNmb3JtUGFnZVBvaW50ID0gX2IudHJhbnNmb3JtUGFnZVBvaW50O1xuICAgIHRoaXMuc3RhcnRFdmVudCA9IG51bGw7XG4gICAgdGhpcy5sYXN0TW92ZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmxhc3RNb3ZlRXZlbnRJbmZvID0gbnVsbDtcbiAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgdGhpcy51cGRhdGVQb2ludCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCEoX3RoaXMubGFzdE1vdmVFdmVudCAmJiBfdGhpcy5sYXN0TW92ZUV2ZW50SW5mbykpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHZhciBpbmZvMiA9IGdldFBhbkluZm8oX3RoaXMubGFzdE1vdmVFdmVudEluZm8sIF90aGlzLmhpc3RvcnkpO1xuICAgICAgdmFyIGlzUGFuU3RhcnRlZCA9IF90aGlzLnN0YXJ0RXZlbnQgIT09IG51bGw7XG4gICAgICB2YXIgaXNEaXN0YW5jZVBhc3RUaHJlc2hvbGQgPSBkaXN0YW5jZShpbmZvMi5vZmZzZXQsIHsgeDogMCwgeTogMCB9KSA+PSAzO1xuICAgICAgaWYgKCFpc1BhblN0YXJ0ZWQgJiYgIWlzRGlzdGFuY2VQYXN0VGhyZXNob2xkKVxuICAgICAgICByZXR1cm47XG4gICAgICB2YXIgcG9pbnQyID0gaW5mbzIucG9pbnQ7XG4gICAgICB2YXIgdGltZXN0YW1wMiA9IGdldEZyYW1lRGF0YSgpLnRpbWVzdGFtcDtcbiAgICAgIF90aGlzLmhpc3RvcnkucHVzaChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcG9pbnQyKSwgeyB0aW1lc3RhbXA6IHRpbWVzdGFtcDIgfSkpO1xuICAgICAgdmFyIF9hMiA9IF90aGlzLmhhbmRsZXJzLCBvblN0YXJ0ID0gX2EyLm9uU3RhcnQsIG9uTW92ZSA9IF9hMi5vbk1vdmU7XG4gICAgICBpZiAoIWlzUGFuU3RhcnRlZCkge1xuICAgICAgICBvblN0YXJ0ICYmIG9uU3RhcnQoX3RoaXMubGFzdE1vdmVFdmVudCwgaW5mbzIpO1xuICAgICAgICBfdGhpcy5zdGFydEV2ZW50ID0gX3RoaXMubGFzdE1vdmVFdmVudDtcbiAgICAgIH1cbiAgICAgIG9uTW92ZSAmJiBvbk1vdmUoX3RoaXMubGFzdE1vdmVFdmVudCwgaW5mbzIpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVQb2ludGVyTW92ZSA9IGZ1bmN0aW9uKGV2ZW50MiwgaW5mbzIpIHtcbiAgICAgIF90aGlzLmxhc3RNb3ZlRXZlbnQgPSBldmVudDI7XG4gICAgICBfdGhpcy5sYXN0TW92ZUV2ZW50SW5mbyA9IHRyYW5zZm9ybVBvaW50KGluZm8yLCBfdGhpcy50cmFuc2Zvcm1QYWdlUG9pbnQpO1xuICAgICAgaWYgKGlzTW91c2VFdmVudChldmVudDIpICYmIGV2ZW50Mi5idXR0b25zID09PSAwKSB7XG4gICAgICAgIF90aGlzLmhhbmRsZVBvaW50ZXJVcChldmVudDIsIGluZm8yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXNfZGVmYXVsdC51cGRhdGUoX3RoaXMudXBkYXRlUG9pbnQsIHRydWUpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVQb2ludGVyVXAgPSBmdW5jdGlvbihldmVudDIsIGluZm8yKSB7XG4gICAgICBfdGhpcy5lbmQoKTtcbiAgICAgIHZhciBvbkVuZCA9IF90aGlzLmhhbmRsZXJzLm9uRW5kO1xuICAgICAgaWYgKCFvbkVuZCB8fCAhX3RoaXMuc3RhcnRFdmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdmFyIHBhbkluZm8gPSBnZXRQYW5JbmZvKHRyYW5zZm9ybVBvaW50KGluZm8yLCBfdGhpcy50cmFuc2Zvcm1QYWdlUG9pbnQpLCBfdGhpcy5oaXN0b3J5KTtcbiAgICAgIG9uRW5kICYmIG9uRW5kKGV2ZW50MiwgcGFuSW5mbyk7XG4gICAgfTtcbiAgICBpZiAoaXNUb3VjaEV2ZW50KGV2ZW50KSAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgIHRoaXMudHJhbnNmb3JtUGFnZVBvaW50ID0gdHJhbnNmb3JtUGFnZVBvaW50O1xuICAgIHZhciBpbmZvID0gZXh0cmFjdEV2ZW50SW5mbyhldmVudCk7XG4gICAgdmFyIGluaXRpYWxJbmZvID0gdHJhbnNmb3JtUG9pbnQoaW5mbywgdGhpcy50cmFuc2Zvcm1QYWdlUG9pbnQpO1xuICAgIHZhciBwb2ludCA9IGluaXRpYWxJbmZvLnBvaW50O1xuICAgIHZhciB0aW1lc3RhbXAgPSBnZXRGcmFtZURhdGEoKS50aW1lc3RhbXA7XG4gICAgdGhpcy5oaXN0b3J5ID0gW19fYXNzaWduKF9fYXNzaWduKHt9LCBwb2ludCksIHsgdGltZXN0YW1wIH0pXTtcbiAgICB2YXIgb25TZXNzaW9uU3RhcnQgPSBoYW5kbGVycy5vblNlc3Npb25TdGFydDtcbiAgICBvblNlc3Npb25TdGFydCAmJiBvblNlc3Npb25TdGFydChldmVudCwgZ2V0UGFuSW5mbyhpbml0aWFsSW5mbywgdGhpcy5oaXN0b3J5KSk7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMgPSBwaXBlKGFkZFBvaW50ZXJFdmVudCh3aW5kb3csIFwicG9pbnRlcm1vdmVcIiwgdGhpcy5oYW5kbGVQb2ludGVyTW92ZSksIGFkZFBvaW50ZXJFdmVudCh3aW5kb3csIFwicG9pbnRlcnVwXCIsIHRoaXMuaGFuZGxlUG9pbnRlclVwKSwgYWRkUG9pbnRlckV2ZW50KHdpbmRvdywgXCJwb2ludGVyY2FuY2VsXCIsIHRoaXMuaGFuZGxlUG9pbnRlclVwKSk7XG4gIH1cbiAgUGFuU2Vzc2lvbjIucHJvdG90eXBlLnVwZGF0ZUhhbmRsZXJzID0gZnVuY3Rpb24oaGFuZGxlcnMpIHtcbiAgICB0aGlzLmhhbmRsZXJzID0gaGFuZGxlcnM7XG4gIH07XG4gIFBhblNlc3Npb24yLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVycyAmJiB0aGlzLnJlbW92ZUxpc3RlbmVycygpO1xuICAgIGNhbmNlbFN5bmMudXBkYXRlKHRoaXMudXBkYXRlUG9pbnQpO1xuICB9O1xuICByZXR1cm4gUGFuU2Vzc2lvbjI7XG59KCk7XG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludChpbmZvLCB0cmFuc2Zvcm1QYWdlUG9pbnQpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybVBhZ2VQb2ludCA/IHsgcG9pbnQ6IHRyYW5zZm9ybVBhZ2VQb2ludChpbmZvLnBvaW50KSB9IDogaW5mbztcbn1cbmZ1bmN0aW9uIHN1YnRyYWN0UG9pbnQoYTIsIGIyKSB7XG4gIHJldHVybiB7IHg6IGEyLnggLSBiMi54LCB5OiBhMi55IC0gYjIueSB9O1xufVxuZnVuY3Rpb24gZ2V0UGFuSW5mbyhfYSwgaGlzdG9yeSkge1xuICB2YXIgcG9pbnQgPSBfYS5wb2ludDtcbiAgcmV0dXJuIHtcbiAgICBwb2ludCxcbiAgICBkZWx0YTogc3VidHJhY3RQb2ludChwb2ludCwgbGFzdERldmljZVBvaW50KGhpc3RvcnkpKSxcbiAgICBvZmZzZXQ6IHN1YnRyYWN0UG9pbnQocG9pbnQsIHN0YXJ0RGV2aWNlUG9pbnQoaGlzdG9yeSkpLFxuICAgIHZlbG9jaXR5OiBnZXRWZWxvY2l0eTIoaGlzdG9yeSwgMC4xKVxuICB9O1xufVxuZnVuY3Rpb24gc3RhcnREZXZpY2VQb2ludChoaXN0b3J5KSB7XG4gIHJldHVybiBoaXN0b3J5WzBdO1xufVxuZnVuY3Rpb24gbGFzdERldmljZVBvaW50KGhpc3RvcnkpIHtcbiAgcmV0dXJuIGhpc3RvcnlbaGlzdG9yeS5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGdldFZlbG9jaXR5MihoaXN0b3J5LCB0aW1lRGVsdGEyKSB7XG4gIGlmIChoaXN0b3J5Lmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gIH1cbiAgdmFyIGkgPSBoaXN0b3J5Lmxlbmd0aCAtIDE7XG4gIHZhciB0aW1lc3RhbXBlZFBvaW50ID0gbnVsbDtcbiAgdmFyIGxhc3RQb2ludCA9IGxhc3REZXZpY2VQb2ludChoaXN0b3J5KTtcbiAgd2hpbGUgKGkgPj0gMCkge1xuICAgIHRpbWVzdGFtcGVkUG9pbnQgPSBoaXN0b3J5W2ldO1xuICAgIGlmIChsYXN0UG9pbnQudGltZXN0YW1wIC0gdGltZXN0YW1wZWRQb2ludC50aW1lc3RhbXAgPiBzZWNvbmRzVG9NaWxsaXNlY29uZHModGltZURlbHRhMikpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpLS07XG4gIH1cbiAgaWYgKCF0aW1lc3RhbXBlZFBvaW50KSB7XG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICB9XG4gIHZhciB0aW1lMyA9IChsYXN0UG9pbnQudGltZXN0YW1wIC0gdGltZXN0YW1wZWRQb2ludC50aW1lc3RhbXApIC8gMWUzO1xuICBpZiAodGltZTMgPT09IDApIHtcbiAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gIH1cbiAgdmFyIGN1cnJlbnRWZWxvY2l0eSA9IHtcbiAgICB4OiAobGFzdFBvaW50LnggLSB0aW1lc3RhbXBlZFBvaW50LngpIC8gdGltZTMsXG4gICAgeTogKGxhc3RQb2ludC55IC0gdGltZXN0YW1wZWRQb2ludC55KSAvIHRpbWUzXG4gIH07XG4gIGlmIChjdXJyZW50VmVsb2NpdHkueCA9PT0gSW5maW5pdHkpIHtcbiAgICBjdXJyZW50VmVsb2NpdHkueCA9IDA7XG4gIH1cbiAgaWYgKGN1cnJlbnRWZWxvY2l0eS55ID09PSBJbmZpbml0eSkge1xuICAgIGN1cnJlbnRWZWxvY2l0eS55ID0gMDtcbiAgfVxuICByZXR1cm4gY3VycmVudFZlbG9jaXR5O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL25vb3AuanNcbmZ1bmN0aW9uIG5vb3AoYW55KSB7XG4gIHJldHVybiBhbnk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvZ2VvbWV0cnkvaW5kZXguanNcbmZ1bmN0aW9uIGNvbnZlcnRCb3VuZGluZ0JveFRvQXhpc0JveChfYSkge1xuICB2YXIgdG9wID0gX2EudG9wLCBsZWZ0ID0gX2EubGVmdCwgcmlnaHQgPSBfYS5yaWdodCwgYm90dG9tID0gX2EuYm90dG9tO1xuICByZXR1cm4ge1xuICAgIHg6IHsgbWluOiBsZWZ0LCBtYXg6IHJpZ2h0IH0sXG4gICAgeTogeyBtaW46IHRvcCwgbWF4OiBib3R0b20gfVxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydEF4aXNCb3hUb0JvdW5kaW5nQm94KF9hKSB7XG4gIHZhciB4ID0gX2EueCwgeSA9IF9hLnk7XG4gIHJldHVybiB7XG4gICAgdG9wOiB5Lm1pbixcbiAgICBib3R0b206IHkubWF4LFxuICAgIGxlZnQ6IHgubWluLFxuICAgIHJpZ2h0OiB4Lm1heFxuICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtQm91bmRpbmdCb3goX2EsIHRyYW5zZm9ybVBvaW50Mikge1xuICB2YXIgdG9wID0gX2EudG9wLCBsZWZ0ID0gX2EubGVmdCwgYm90dG9tID0gX2EuYm90dG9tLCByaWdodCA9IF9hLnJpZ2h0O1xuICBpZiAodHJhbnNmb3JtUG9pbnQyID09PSB2b2lkIDApIHtcbiAgICB0cmFuc2Zvcm1Qb2ludDIgPSBub29wO1xuICB9XG4gIHZhciB0b3BMZWZ0ID0gdHJhbnNmb3JtUG9pbnQyKHsgeDogbGVmdCwgeTogdG9wIH0pO1xuICB2YXIgYm90dG9tUmlnaHQgPSB0cmFuc2Zvcm1Qb2ludDIoeyB4OiByaWdodCwgeTogYm90dG9tIH0pO1xuICByZXR1cm4ge1xuICAgIHRvcDogdG9wTGVmdC55LFxuICAgIGxlZnQ6IHRvcExlZnQueCxcbiAgICBib3R0b206IGJvdHRvbVJpZ2h0LnksXG4gICAgcmlnaHQ6IGJvdHRvbVJpZ2h0LnhcbiAgfTtcbn1cbmZ1bmN0aW9uIGF4aXNCb3goKSB7XG4gIHJldHVybiB7IHg6IHsgbWluOiAwLCBtYXg6IDEgfSwgeTogeyBtaW46IDAsIG1heDogMSB9IH07XG59XG5mdW5jdGlvbiBjb3B5QXhpc0JveChib3gpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBfX2Fzc2lnbih7fSwgYm94LngpLFxuICAgIHk6IF9fYXNzaWduKHt9LCBib3gueSlcbiAgfTtcbn1cbnZhciB6ZXJvRGVsdGEgPSB7XG4gIHRyYW5zbGF0ZTogMCxcbiAgc2NhbGU6IDEsXG4gIG9yaWdpbjogMCxcbiAgb3JpZ2luUG9pbnQ6IDBcbn07XG5mdW5jdGlvbiBkZWx0YSgpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBfX2Fzc2lnbih7fSwgemVyb0RlbHRhKSxcbiAgICB5OiBfX2Fzc2lnbih7fSwgemVyb0RlbHRhKVxuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL2VhY2gtYXhpcy5qc1xuZnVuY3Rpb24gZWFjaEF4aXMoaGFuZGxlcikge1xuICByZXR1cm4gW2hhbmRsZXIoXCJ4XCIpLCBoYW5kbGVyKFwieVwiKV07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvZHJhZy91dGlscy9jb25zdHJhaW50cy5qc1xuZnVuY3Rpb24gYXBwbHlDb25zdHJhaW50cyhwb2ludCwgX2EsIGVsYXN0aWMpIHtcbiAgdmFyIG1pbiA9IF9hLm1pbiwgbWF4ID0gX2EubWF4O1xuICBpZiAobWluICE9PSB2b2lkIDAgJiYgcG9pbnQgPCBtaW4pIHtcbiAgICBwb2ludCA9IGVsYXN0aWMgPyBtaXgobWluLCBwb2ludCwgZWxhc3RpYy5taW4pIDogTWF0aC5tYXgocG9pbnQsIG1pbik7XG4gIH0gZWxzZSBpZiAobWF4ICE9PSB2b2lkIDAgJiYgcG9pbnQgPiBtYXgpIHtcbiAgICBwb2ludCA9IGVsYXN0aWMgPyBtaXgobWF4LCBwb2ludCwgZWxhc3RpYy5tYXgpIDogTWF0aC5taW4ocG9pbnQsIG1heCk7XG4gIH1cbiAgcmV0dXJuIHBvaW50O1xufVxuZnVuY3Rpb24gY2FsY0NvbnN0cmFpbmVkTWluUG9pbnQocG9pbnQsIGxlbmd0aCwgcHJvZ3Jlc3MyLCBjb25zdHJhaW50cywgZWxhc3RpYykge1xuICB2YXIgbWluID0gcG9pbnQgLSBsZW5ndGggKiBwcm9ncmVzczI7XG4gIHJldHVybiBjb25zdHJhaW50cyA/IGFwcGx5Q29uc3RyYWludHMobWluLCBjb25zdHJhaW50cywgZWxhc3RpYykgOiBtaW47XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVBeGlzQ29uc3RyYWludHMoYXhpcywgbWluLCBtYXgpIHtcbiAgcmV0dXJuIHtcbiAgICBtaW46IG1pbiAhPT0gdm9pZCAwID8gYXhpcy5taW4gKyBtaW4gOiB2b2lkIDAsXG4gICAgbWF4OiBtYXggIT09IHZvaWQgMCA/IGF4aXMubWF4ICsgbWF4IC0gKGF4aXMubWF4IC0gYXhpcy5taW4pIDogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVDb25zdHJhaW50cyhsYXlvdXRCb3gsIF9hKSB7XG4gIHZhciB0b3AgPSBfYS50b3AsIGxlZnQgPSBfYS5sZWZ0LCBib3R0b20gPSBfYS5ib3R0b20sIHJpZ2h0ID0gX2EucmlnaHQ7XG4gIHJldHVybiB7XG4gICAgeDogY2FsY1JlbGF0aXZlQXhpc0NvbnN0cmFpbnRzKGxheW91dEJveC54LCBsZWZ0LCByaWdodCksXG4gICAgeTogY2FsY1JlbGF0aXZlQXhpc0NvbnN0cmFpbnRzKGxheW91dEJveC55LCB0b3AsIGJvdHRvbSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyhsYXlvdXRBeGlzLCBjb25zdHJhaW50c0F4aXMpIHtcbiAgdmFyIF9hO1xuICB2YXIgbWluID0gY29uc3RyYWludHNBeGlzLm1pbiAtIGxheW91dEF4aXMubWluO1xuICB2YXIgbWF4ID0gY29uc3RyYWludHNBeGlzLm1heCAtIGxheW91dEF4aXMubWF4O1xuICBpZiAoY29uc3RyYWludHNBeGlzLm1heCAtIGNvbnN0cmFpbnRzQXhpcy5taW4gPCBsYXlvdXRBeGlzLm1heCAtIGxheW91dEF4aXMubWluKSB7XG4gICAgX2EgPSBfX3JlYWQoW21heCwgbWluXSwgMiksIG1pbiA9IF9hWzBdLCBtYXggPSBfYVsxXTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG1pbjogbGF5b3V0QXhpcy5taW4gKyBtaW4sXG4gICAgbWF4OiBsYXlvdXRBeGlzLm1pbiArIG1heFxuICB9O1xufVxuZnVuY3Rpb24gY2FsY1ZpZXdwb3J0Q29uc3RyYWludHMobGF5b3V0Qm94LCBjb25zdHJhaW50c0JveCkge1xuICByZXR1cm4ge1xuICAgIHg6IGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyhsYXlvdXRCb3gueCwgY29uc3RyYWludHNCb3gueCksXG4gICAgeTogY2FsY1ZpZXdwb3J0QXhpc0NvbnN0cmFpbnRzKGxheW91dEJveC55LCBjb25zdHJhaW50c0JveC55KVxuICB9O1xufVxuZnVuY3Rpb24gY2FsY1Bvc2l0aW9uRnJvbVByb2dyZXNzKGF4aXMsIGNvbnN0cmFpbnRzLCBwcm9ncmVzczIpIHtcbiAgdmFyIGF4aXNMZW5ndGggPSBheGlzLm1heCAtIGF4aXMubWluO1xuICB2YXIgbWluID0gbWl4KGNvbnN0cmFpbnRzLm1pbiwgY29uc3RyYWludHMubWF4IC0gYXhpc0xlbmd0aCwgcHJvZ3Jlc3MyKTtcbiAgcmV0dXJuIHsgbWluLCBtYXg6IG1pbiArIGF4aXNMZW5ndGggfTtcbn1cbmZ1bmN0aW9uIHJlYmFzZUF4aXNDb25zdHJhaW50cyhsYXlvdXQsIGNvbnN0cmFpbnRzKSB7XG4gIHZhciByZWxhdGl2ZUNvbnN0cmFpbnRzID0ge307XG4gIGlmIChjb25zdHJhaW50cy5taW4gIT09IHZvaWQgMCkge1xuICAgIHJlbGF0aXZlQ29uc3RyYWludHMubWluID0gY29uc3RyYWludHMubWluIC0gbGF5b3V0Lm1pbjtcbiAgfVxuICBpZiAoY29uc3RyYWludHMubWF4ICE9PSB2b2lkIDApIHtcbiAgICByZWxhdGl2ZUNvbnN0cmFpbnRzLm1heCA9IGNvbnN0cmFpbnRzLm1heCAtIGxheW91dC5taW47XG4gIH1cbiAgcmV0dXJuIHJlbGF0aXZlQ29uc3RyYWludHM7XG59XG52YXIgZGVmYXVsdEVsYXN0aWMgPSAwLjM1O1xuZnVuY3Rpb24gcmVzb2x2ZURyYWdFbGFzdGljKGRyYWdFbGFzdGljKSB7XG4gIGlmIChkcmFnRWxhc3RpYyA9PT0gZmFsc2UpIHtcbiAgICBkcmFnRWxhc3RpYyA9IDA7XG4gIH0gZWxzZSBpZiAoZHJhZ0VsYXN0aWMgPT09IHRydWUpIHtcbiAgICBkcmFnRWxhc3RpYyA9IGRlZmF1bHRFbGFzdGljO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogcmVzb2x2ZUF4aXNFbGFzdGljKGRyYWdFbGFzdGljLCBcImxlZnRcIiwgXCJyaWdodFwiKSxcbiAgICB5OiByZXNvbHZlQXhpc0VsYXN0aWMoZHJhZ0VsYXN0aWMsIFwidG9wXCIsIFwiYm90dG9tXCIpXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlQXhpc0VsYXN0aWMoZHJhZ0VsYXN0aWMsIG1pbkxhYmVsLCBtYXhMYWJlbCkge1xuICByZXR1cm4ge1xuICAgIG1pbjogcmVzb2x2ZVBvaW50RWxhc3RpYyhkcmFnRWxhc3RpYywgbWluTGFiZWwpLFxuICAgIG1heDogcmVzb2x2ZVBvaW50RWxhc3RpYyhkcmFnRWxhc3RpYywgbWF4TGFiZWwpXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlUG9pbnRFbGFzdGljKGRyYWdFbGFzdGljLCBsYWJlbCkge1xuICB2YXIgX2E7XG4gIHJldHVybiB0eXBlb2YgZHJhZ0VsYXN0aWMgPT09IFwibnVtYmVyXCIgPyBkcmFnRWxhc3RpYyA6IChfYSA9IGRyYWdFbGFzdGljW2xhYmVsXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3Byb2plY3Rpb24vbWVhc3VyZS5qc1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdCb3goZWxlbWVudCwgdHJhbnNmb3JtUGFnZVBvaW50KSB7XG4gIHZhciBib3ggPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4gY29udmVydEJvdW5kaW5nQm94VG9BeGlzQm94KHRyYW5zZm9ybUJvdW5kaW5nQm94KGJveCwgdHJhbnNmb3JtUGFnZVBvaW50KSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvZ2VvbWV0cnkvZGVsdGEtY2FsYy5qc1xudmFyIGNsYW1wUHJvZ3Jlc3MgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBjbGFtcDIoMCwgMSwgdik7XG59O1xuZnVuY3Rpb24gaXNOZWFyKHZhbHVlLCB0YXJnZXQsIG1heERpc3RhbmNlKSB7XG4gIGlmICh0YXJnZXQgPT09IHZvaWQgMCkge1xuICAgIHRhcmdldCA9IDA7XG4gIH1cbiAgaWYgKG1heERpc3RhbmNlID09PSB2b2lkIDApIHtcbiAgICBtYXhEaXN0YW5jZSA9IDAuMDE7XG4gIH1cbiAgcmV0dXJuIGRpc3RhbmNlKHZhbHVlLCB0YXJnZXQpIDwgbWF4RGlzdGFuY2U7XG59XG5mdW5jdGlvbiBjYWxjTGVuZ3RoKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMubWF4IC0gYXhpcy5taW47XG59XG5mdW5jdGlvbiBjYWxjT3JpZ2luMihzb3VyY2UsIHRhcmdldCkge1xuICB2YXIgb3JpZ2luID0gMC41O1xuICB2YXIgc291cmNlTGVuZ3RoID0gY2FsY0xlbmd0aChzb3VyY2UpO1xuICB2YXIgdGFyZ2V0TGVuZ3RoID0gY2FsY0xlbmd0aCh0YXJnZXQpO1xuICBpZiAodGFyZ2V0TGVuZ3RoID4gc291cmNlTGVuZ3RoKSB7XG4gICAgb3JpZ2luID0gcHJvZ3Jlc3ModGFyZ2V0Lm1pbiwgdGFyZ2V0Lm1heCAtIHNvdXJjZUxlbmd0aCwgc291cmNlLm1pbik7XG4gIH0gZWxzZSBpZiAoc291cmNlTGVuZ3RoID4gdGFyZ2V0TGVuZ3RoKSB7XG4gICAgb3JpZ2luID0gcHJvZ3Jlc3Moc291cmNlLm1pbiwgc291cmNlLm1heCAtIHRhcmdldExlbmd0aCwgdGFyZ2V0Lm1pbik7XG4gIH1cbiAgcmV0dXJuIGNsYW1wUHJvZ3Jlc3Mob3JpZ2luKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUF4aXNEZWx0YShkZWx0YTIsIHNvdXJjZSwgdGFyZ2V0LCBvcmlnaW4pIHtcbiAgaWYgKG9yaWdpbiA9PT0gdm9pZCAwKSB7XG4gICAgb3JpZ2luID0gMC41O1xuICB9XG4gIGRlbHRhMi5vcmlnaW4gPSBvcmlnaW47XG4gIGRlbHRhMi5vcmlnaW5Qb2ludCA9IG1peChzb3VyY2UubWluLCBzb3VyY2UubWF4LCBkZWx0YTIub3JpZ2luKTtcbiAgZGVsdGEyLnNjYWxlID0gY2FsY0xlbmd0aCh0YXJnZXQpIC8gY2FsY0xlbmd0aChzb3VyY2UpO1xuICBpZiAoaXNOZWFyKGRlbHRhMi5zY2FsZSwgMSwgMWUtNCkpXG4gICAgZGVsdGEyLnNjYWxlID0gMTtcbiAgZGVsdGEyLnRyYW5zbGF0ZSA9IG1peCh0YXJnZXQubWluLCB0YXJnZXQubWF4LCBkZWx0YTIub3JpZ2luKSAtIGRlbHRhMi5vcmlnaW5Qb2ludDtcbiAgaWYgKGlzTmVhcihkZWx0YTIudHJhbnNsYXRlKSlcbiAgICBkZWx0YTIudHJhbnNsYXRlID0gMDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUJveERlbHRhKGRlbHRhMiwgc291cmNlLCB0YXJnZXQsIG9yaWdpbikge1xuICB1cGRhdGVBeGlzRGVsdGEoZGVsdGEyLngsIHNvdXJjZS54LCB0YXJnZXQueCwgZGVmYXVsdE9yaWdpbihvcmlnaW4ub3JpZ2luWCkpO1xuICB1cGRhdGVBeGlzRGVsdGEoZGVsdGEyLnksIHNvdXJjZS55LCB0YXJnZXQueSwgZGVmYXVsdE9yaWdpbihvcmlnaW4ub3JpZ2luWSkpO1xufVxuZnVuY3Rpb24gZGVmYXVsdE9yaWdpbihvcmlnaW4pIHtcbiAgcmV0dXJuIHR5cGVvZiBvcmlnaW4gPT09IFwibnVtYmVyXCIgPyBvcmlnaW4gOiAwLjU7XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVBeGlzKHRhcmdldCwgcmVsYXRpdmUsIHBhcmVudCkge1xuICB0YXJnZXQubWluID0gcGFyZW50Lm1pbiArIHJlbGF0aXZlLm1pbjtcbiAgdGFyZ2V0Lm1heCA9IHRhcmdldC5taW4gKyBjYWxjTGVuZ3RoKHJlbGF0aXZlKTtcbn1cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUJveChwcm9qZWN0aW9uLCBwYXJlbnRQcm9qZWN0aW9uKSB7XG4gIGNhbGNSZWxhdGl2ZUF4aXMocHJvamVjdGlvbi50YXJnZXQueCwgcHJvamVjdGlvbi5yZWxhdGl2ZVRhcmdldC54LCBwYXJlbnRQcm9qZWN0aW9uLnRhcmdldC54KTtcbiAgY2FsY1JlbGF0aXZlQXhpcyhwcm9qZWN0aW9uLnRhcmdldC55LCBwcm9qZWN0aW9uLnJlbGF0aXZlVGFyZ2V0LnksIHBhcmVudFByb2plY3Rpb24udGFyZ2V0LnkpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9jb21wYXJlLWJ5LWRlcHRoLmpzXG52YXIgY29tcGFyZUJ5RGVwdGggPSBmdW5jdGlvbihhMiwgYjIpIHtcbiAgcmV0dXJuIGEyLmRlcHRoIC0gYjIuZGVwdGg7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vcHJvamVjdGlvbi91dGlscy5qc1xuZnVuY3Rpb24gdXBkYXRlVHJlZUxheW91dE1lYXN1cmVtZW50cyh2aXN1YWxFbGVtZW50MiwgaXNSZWxhdGl2ZURyYWcpIHtcbiAgd2l0aG91dFRyZWVUcmFuc2Zvcm0odmlzdWFsRWxlbWVudDIsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhbGxDaGlsZHJlbiA9IGNvbGxlY3RQcm9qZWN0aW5nQ2hpbGRyZW4odmlzdWFsRWxlbWVudDIpO1xuICAgIGJhdGNoUmVzZXRBbmRNZWFzdXJlKGFsbENoaWxkcmVuKTtcbiAgICB1cGRhdGVMYXlvdXRNZWFzdXJlbWVudCh2aXN1YWxFbGVtZW50Mik7XG4gIH0pO1xuICAhaXNSZWxhdGl2ZURyYWcgJiYgdmlzdWFsRWxlbWVudDIucmViYXNlUHJvamVjdGlvblRhcmdldCh0cnVlLCB2aXN1YWxFbGVtZW50Mi5tZWFzdXJlVmlld3BvcnRCb3goZmFsc2UpKTtcbn1cbmZ1bmN0aW9uIGNvbGxlY3RQcm9qZWN0aW5nQ2hpbGRyZW4odmlzdWFsRWxlbWVudDIpIHtcbiAgdmFyIGNoaWxkcmVuID0gW107XG4gIHZhciBhZGRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLnByb2plY3Rpb24uaXNFbmFibGVkIHx8IGNoaWxkLnNob3VsZFJlc2V0VHJhbnNmb3JtKCkpIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgICBjaGlsZC5jaGlsZHJlbi5mb3JFYWNoKGFkZENoaWxkKTtcbiAgfTtcbiAgdmlzdWFsRWxlbWVudDIuY2hpbGRyZW4uZm9yRWFjaChhZGRDaGlsZCk7XG4gIHJldHVybiBjaGlsZHJlbi5zb3J0KGNvbXBhcmVCeURlcHRoKTtcbn1cbmZ1bmN0aW9uIHdpdGhvdXRUcmVlVHJhbnNmb3JtKHZpc3VhbEVsZW1lbnQyLCBjYWxsYmFjaykge1xuICB2YXIgcGFyZW50ID0gdmlzdWFsRWxlbWVudDIucGFyZW50O1xuICB2YXIgaXNFbmFibGVkID0gdmlzdWFsRWxlbWVudDIucHJvamVjdGlvbi5pc0VuYWJsZWQ7XG4gIHZhciBzaG91bGRSZXNldCA9IGlzRW5hYmxlZCB8fCB2aXN1YWxFbGVtZW50Mi5zaG91bGRSZXNldFRyYW5zZm9ybSgpO1xuICBzaG91bGRSZXNldCAmJiB2aXN1YWxFbGVtZW50Mi5yZXNldFRyYW5zZm9ybSgpO1xuICBwYXJlbnQgPyB3aXRob3V0VHJlZVRyYW5zZm9ybShwYXJlbnQsIGNhbGxiYWNrKSA6IGNhbGxiYWNrKCk7XG4gIHNob3VsZFJlc2V0ICYmIHZpc3VhbEVsZW1lbnQyLnJlc3RvcmVUcmFuc2Zvcm0oKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUxheW91dE1lYXN1cmVtZW50KHZpc3VhbEVsZW1lbnQyKSB7XG4gIGlmICh2aXN1YWxFbGVtZW50Mi5zaG91bGRSZXNldFRyYW5zZm9ybSgpKVxuICAgIHJldHVybjtcbiAgdmFyIGxheW91dFN0YXRlID0gdmlzdWFsRWxlbWVudDIuZ2V0TGF5b3V0U3RhdGUoKTtcbiAgdmlzdWFsRWxlbWVudDIubm90aWZ5QmVmb3JlTGF5b3V0TWVhc3VyZShsYXlvdXRTdGF0ZS5sYXlvdXQpO1xuICBsYXlvdXRTdGF0ZS5pc0h5ZHJhdGVkID0gdHJ1ZTtcbiAgbGF5b3V0U3RhdGUubGF5b3V0ID0gdmlzdWFsRWxlbWVudDIubWVhc3VyZVZpZXdwb3J0Qm94KCk7XG4gIGxheW91dFN0YXRlLmxheW91dENvcnJlY3RlZCA9IGNvcHlBeGlzQm94KGxheW91dFN0YXRlLmxheW91dCk7XG4gIHZpc3VhbEVsZW1lbnQyLm5vdGlmeUxheW91dE1lYXN1cmUobGF5b3V0U3RhdGUubGF5b3V0LCB2aXN1YWxFbGVtZW50Mi5wcmV2Vmlld3BvcnRCb3ggfHwgbGF5b3V0U3RhdGUubGF5b3V0KTtcbiAgZXNfZGVmYXVsdC51cGRhdGUoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZpc3VhbEVsZW1lbnQyLnJlYmFzZVByb2plY3Rpb25UYXJnZXQoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzbmFwc2hvdFZpZXdwb3J0Qm94KHZpc3VhbEVsZW1lbnQyKSB7XG4gIGlmICh2aXN1YWxFbGVtZW50Mi5zaG91bGRSZXNldFRyYW5zZm9ybSgpKVxuICAgIHJldHVybjtcbiAgdmlzdWFsRWxlbWVudDIucHJldlZpZXdwb3J0Qm94ID0gdmlzdWFsRWxlbWVudDIubWVhc3VyZVZpZXdwb3J0Qm94KGZhbHNlKTtcbiAgdmlzdWFsRWxlbWVudDIucmViYXNlUHJvamVjdGlvblRhcmdldChmYWxzZSwgdmlzdWFsRWxlbWVudDIucHJldlZpZXdwb3J0Qm94KTtcbn1cbmZ1bmN0aW9uIGJhdGNoUmVzZXRBbmRNZWFzdXJlKG9yZGVyMikge1xuICBvcmRlcjIuZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZC5yZXNldFRyYW5zZm9ybSgpO1xuICB9KTtcbiAgb3JkZXIyLmZvckVhY2godXBkYXRlTGF5b3V0TWVhc3VyZW1lbnQpO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9sYXlvdXQvdXRpbHMuanNcbmZ1bmN0aW9uIHR3ZWVuQXhpcyh0YXJnZXQsIHByZXYsIG5leHQsIHApIHtcbiAgdGFyZ2V0Lm1pbiA9IG1peChwcmV2Lm1pbiwgbmV4dC5taW4sIHApO1xuICB0YXJnZXQubWF4ID0gbWl4KHByZXYubWF4LCBuZXh0Lm1heCwgcCk7XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVPZmZzZXRBeGlzKHBhcmVudCwgY2hpbGQpIHtcbiAgcmV0dXJuIHtcbiAgICBtaW46IGNoaWxkLm1pbiAtIHBhcmVudC5taW4sXG4gICAgbWF4OiBjaGlsZC5tYXggLSBwYXJlbnQubWluXG4gIH07XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVPZmZzZXQocGFyZW50LCBjaGlsZCkge1xuICByZXR1cm4ge1xuICAgIHg6IGNhbGNSZWxhdGl2ZU9mZnNldEF4aXMocGFyZW50LngsIGNoaWxkLngpLFxuICAgIHk6IGNhbGNSZWxhdGl2ZU9mZnNldEF4aXMocGFyZW50LnksIGNoaWxkLnkpXG4gIH07XG59XG5mdW5jdGlvbiBjaGVja0lmUGFyZW50SGFzQ2hhbmdlZChwcmV2LCBuZXh0KSB7XG4gIHZhciBwcmV2SWQgPSBwcmV2LmdldExheW91dElkKCk7XG4gIHZhciBuZXh0SWQgPSBuZXh0LmdldExheW91dElkKCk7XG4gIHJldHVybiBwcmV2SWQgIT09IG5leHRJZCB8fCBuZXh0SWQgPT09IHZvaWQgMCAmJiBwcmV2ICE9PSBuZXh0O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9pcy1kcmFnZ2FibGUuanNcbmZ1bmN0aW9uIGlzRHJhZ2dhYmxlKHZpc3VhbEVsZW1lbnQyKSB7XG4gIHZhciBfYSA9IHZpc3VhbEVsZW1lbnQyLmdldFByb3BzKCksIGRyYWcyID0gX2EuZHJhZywgX2RyYWdYID0gX2EuX2RyYWdYO1xuICByZXR1cm4gZHJhZzIgJiYgIV9kcmFnWDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9nZW9tZXRyeS9kZWx0YS1hcHBseS5qc1xuZnVuY3Rpb24gcmVzZXRBeGlzKGF4aXMsIG9yaWdpbkF4aXMpIHtcbiAgYXhpcy5taW4gPSBvcmlnaW5BeGlzLm1pbjtcbiAgYXhpcy5tYXggPSBvcmlnaW5BeGlzLm1heDtcbn1cbmZ1bmN0aW9uIHJlc2V0Qm94KGJveCwgb3JpZ2luQm94KSB7XG4gIHJlc2V0QXhpcyhib3gueCwgb3JpZ2luQm94LngpO1xuICByZXNldEF4aXMoYm94LnksIG9yaWdpbkJveC55KTtcbn1cbmZ1bmN0aW9uIHNjYWxlUG9pbnQocG9pbnQsIHNjYWxlMiwgb3JpZ2luUG9pbnQpIHtcbiAgdmFyIGRpc3RhbmNlRnJvbU9yaWdpbiA9IHBvaW50IC0gb3JpZ2luUG9pbnQ7XG4gIHZhciBzY2FsZWQgPSBzY2FsZTIgKiBkaXN0YW5jZUZyb21PcmlnaW47XG4gIHJldHVybiBvcmlnaW5Qb2ludCArIHNjYWxlZDtcbn1cbmZ1bmN0aW9uIGFwcGx5UG9pbnREZWx0YShwb2ludCwgdHJhbnNsYXRlLCBzY2FsZTIsIG9yaWdpblBvaW50LCBib3hTY2FsZSkge1xuICBpZiAoYm94U2NhbGUgIT09IHZvaWQgMCkge1xuICAgIHBvaW50ID0gc2NhbGVQb2ludChwb2ludCwgYm94U2NhbGUsIG9yaWdpblBvaW50KTtcbiAgfVxuICByZXR1cm4gc2NhbGVQb2ludChwb2ludCwgc2NhbGUyLCBvcmlnaW5Qb2ludCkgKyB0cmFuc2xhdGU7XG59XG5mdW5jdGlvbiBhcHBseUF4aXNEZWx0YShheGlzLCB0cmFuc2xhdGUsIHNjYWxlMiwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKSB7XG4gIGlmICh0cmFuc2xhdGUgPT09IHZvaWQgMCkge1xuICAgIHRyYW5zbGF0ZSA9IDA7XG4gIH1cbiAgaWYgKHNjYWxlMiA9PT0gdm9pZCAwKSB7XG4gICAgc2NhbGUyID0gMTtcbiAgfVxuICBheGlzLm1pbiA9IGFwcGx5UG9pbnREZWx0YShheGlzLm1pbiwgdHJhbnNsYXRlLCBzY2FsZTIsIG9yaWdpblBvaW50LCBib3hTY2FsZSk7XG4gIGF4aXMubWF4ID0gYXBwbHlQb2ludERlbHRhKGF4aXMubWF4LCB0cmFuc2xhdGUsIHNjYWxlMiwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbn1cbmZ1bmN0aW9uIGFwcGx5Qm94RGVsdGEoYm94LCBfYSkge1xuICB2YXIgeCA9IF9hLngsIHkgPSBfYS55O1xuICBhcHBseUF4aXNEZWx0YShib3gueCwgeC50cmFuc2xhdGUsIHguc2NhbGUsIHgub3JpZ2luUG9pbnQpO1xuICBhcHBseUF4aXNEZWx0YShib3gueSwgeS50cmFuc2xhdGUsIHkuc2NhbGUsIHkub3JpZ2luUG9pbnQpO1xufVxuZnVuY3Rpb24gYXBwbHlBeGlzVHJhbnNmb3JtcyhmaW5hbCwgYXhpcywgdHJhbnNmb3JtcywgX2EpIHtcbiAgdmFyIF9iID0gX19yZWFkKF9hLCAzKSwga2V5NiA9IF9iWzBdLCBzY2FsZUtleSA9IF9iWzFdLCBvcmlnaW5LZXkgPSBfYlsyXTtcbiAgZmluYWwubWluID0gYXhpcy5taW47XG4gIGZpbmFsLm1heCA9IGF4aXMubWF4O1xuICB2YXIgYXhpc09yaWdpbiA9IHRyYW5zZm9ybXNbb3JpZ2luS2V5XSAhPT0gdm9pZCAwID8gdHJhbnNmb3Jtc1tvcmlnaW5LZXldIDogMC41O1xuICB2YXIgb3JpZ2luUG9pbnQgPSBtaXgoYXhpcy5taW4sIGF4aXMubWF4LCBheGlzT3JpZ2luKTtcbiAgYXBwbHlBeGlzRGVsdGEoZmluYWwsIHRyYW5zZm9ybXNba2V5Nl0sIHRyYW5zZm9ybXNbc2NhbGVLZXldLCBvcmlnaW5Qb2ludCwgdHJhbnNmb3Jtcy5zY2FsZSk7XG59XG52YXIgeEtleXMgPSBbXCJ4XCIsIFwic2NhbGVYXCIsIFwib3JpZ2luWFwiXTtcbnZhciB5S2V5cyA9IFtcInlcIiwgXCJzY2FsZVlcIiwgXCJvcmlnaW5ZXCJdO1xuZnVuY3Rpb24gYXBwbHlCb3hUcmFuc2Zvcm1zKGZpbmFsQm94LCBib3gsIHRyYW5zZm9ybXMpIHtcbiAgYXBwbHlBeGlzVHJhbnNmb3JtcyhmaW5hbEJveC54LCBib3gueCwgdHJhbnNmb3JtcywgeEtleXMpO1xuICBhcHBseUF4aXNUcmFuc2Zvcm1zKGZpbmFsQm94LnksIGJveC55LCB0cmFuc2Zvcm1zLCB5S2V5cyk7XG59XG5mdW5jdGlvbiByZW1vdmVQb2ludERlbHRhKHBvaW50LCB0cmFuc2xhdGUsIHNjYWxlMiwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKSB7XG4gIHBvaW50IC09IHRyYW5zbGF0ZTtcbiAgcG9pbnQgPSBzY2FsZVBvaW50KHBvaW50LCAxIC8gc2NhbGUyLCBvcmlnaW5Qb2ludCk7XG4gIGlmIChib3hTY2FsZSAhPT0gdm9pZCAwKSB7XG4gICAgcG9pbnQgPSBzY2FsZVBvaW50KHBvaW50LCAxIC8gYm94U2NhbGUsIG9yaWdpblBvaW50KTtcbiAgfVxuICByZXR1cm4gcG9pbnQ7XG59XG5mdW5jdGlvbiByZW1vdmVBeGlzRGVsdGEoYXhpcywgdHJhbnNsYXRlLCBzY2FsZTIsIG9yaWdpbiwgYm94U2NhbGUpIHtcbiAgaWYgKHRyYW5zbGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgdHJhbnNsYXRlID0gMDtcbiAgfVxuICBpZiAoc2NhbGUyID09PSB2b2lkIDApIHtcbiAgICBzY2FsZTIgPSAxO1xuICB9XG4gIGlmIChvcmlnaW4gPT09IHZvaWQgMCkge1xuICAgIG9yaWdpbiA9IDAuNTtcbiAgfVxuICB2YXIgb3JpZ2luUG9pbnQgPSBtaXgoYXhpcy5taW4sIGF4aXMubWF4LCBvcmlnaW4pIC0gdHJhbnNsYXRlO1xuICBheGlzLm1pbiA9IHJlbW92ZVBvaW50RGVsdGEoYXhpcy5taW4sIHRyYW5zbGF0ZSwgc2NhbGUyLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpO1xuICBheGlzLm1heCA9IHJlbW92ZVBvaW50RGVsdGEoYXhpcy5tYXgsIHRyYW5zbGF0ZSwgc2NhbGUyLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpO1xufVxuZnVuY3Rpb24gcmVtb3ZlQXhpc1RyYW5zZm9ybXMoYXhpcywgdHJhbnNmb3JtcywgX2EpIHtcbiAgdmFyIF9iID0gX19yZWFkKF9hLCAzKSwga2V5NiA9IF9iWzBdLCBzY2FsZUtleSA9IF9iWzFdLCBvcmlnaW5LZXkgPSBfYlsyXTtcbiAgcmVtb3ZlQXhpc0RlbHRhKGF4aXMsIHRyYW5zZm9ybXNba2V5Nl0sIHRyYW5zZm9ybXNbc2NhbGVLZXldLCB0cmFuc2Zvcm1zW29yaWdpbktleV0sIHRyYW5zZm9ybXMuc2NhbGUpO1xufVxuZnVuY3Rpb24gcmVtb3ZlQm94VHJhbnNmb3Jtcyhib3gsIHRyYW5zZm9ybXMpIHtcbiAgcmVtb3ZlQXhpc1RyYW5zZm9ybXMoYm94LngsIHRyYW5zZm9ybXMsIHhLZXlzKTtcbiAgcmVtb3ZlQXhpc1RyYW5zZm9ybXMoYm94LnksIHRyYW5zZm9ybXMsIHlLZXlzKTtcbn1cbmZ1bmN0aW9uIGFwcGx5VHJlZURlbHRhcyhib3gsIHRyZWVTY2FsZSwgdHJlZVBhdGgpIHtcbiAgdmFyIHRyZWVMZW5ndGggPSB0cmVlUGF0aC5sZW5ndGg7XG4gIGlmICghdHJlZUxlbmd0aClcbiAgICByZXR1cm47XG4gIHRyZWVTY2FsZS54ID0gdHJlZVNjYWxlLnkgPSAxO1xuICB2YXIgbm9kZTtcbiAgdmFyIGRlbHRhMjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlTGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gdHJlZVBhdGhbaV07XG4gICAgZGVsdGEyID0gbm9kZS5nZXRMYXlvdXRTdGF0ZSgpLmRlbHRhO1xuICAgIHRyZWVTY2FsZS54ICo9IGRlbHRhMi54LnNjYWxlO1xuICAgIHRyZWVTY2FsZS55ICo9IGRlbHRhMi55LnNjYWxlO1xuICAgIGFwcGx5Qm94RGVsdGEoYm94LCBkZWx0YTIpO1xuICAgIGlmIChpc0RyYWdnYWJsZShub2RlKSkge1xuICAgICAgYXBwbHlCb3hUcmFuc2Zvcm1zKGJveCwgYm94LCBub2RlLmdldExhdGVzdFZhbHVlcygpKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3Byb2plY3Rpb24vY29udmVydC10by1yZWxhdGl2ZS5qc1xuZnVuY3Rpb24gY29udmVydFRvUmVsYXRpdmVQcm9qZWN0aW9uKHZpc3VhbEVsZW1lbnQyLCBpc0xheW91dERyYWcpIHtcbiAgaWYgKGlzTGF5b3V0RHJhZyA9PT0gdm9pZCAwKSB7XG4gICAgaXNMYXlvdXREcmFnID0gdHJ1ZTtcbiAgfVxuICB2YXIgcHJvamVjdGlvblBhcmVudCA9IHZpc3VhbEVsZW1lbnQyLmdldFByb2plY3Rpb25QYXJlbnQoKTtcbiAgaWYgKCFwcm9qZWN0aW9uUGFyZW50KVxuICAgIHJldHVybiBmYWxzZTtcbiAgdmFyIG9mZnNldDtcbiAgaWYgKGlzTGF5b3V0RHJhZykge1xuICAgIG9mZnNldCA9IGNhbGNSZWxhdGl2ZU9mZnNldChwcm9qZWN0aW9uUGFyZW50LnByb2plY3Rpb24udGFyZ2V0LCB2aXN1YWxFbGVtZW50Mi5wcm9qZWN0aW9uLnRhcmdldCk7XG4gICAgcmVtb3ZlQm94VHJhbnNmb3JtcyhvZmZzZXQsIHByb2plY3Rpb25QYXJlbnQuZ2V0TGF0ZXN0VmFsdWVzKCkpO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldCA9IGNhbGNSZWxhdGl2ZU9mZnNldChwcm9qZWN0aW9uUGFyZW50LmdldExheW91dFN0YXRlKCkubGF5b3V0LCB2aXN1YWxFbGVtZW50Mi5nZXRMYXlvdXRTdGF0ZSgpLmxheW91dCk7XG4gIH1cbiAgZWFjaEF4aXMoZnVuY3Rpb24oYXhpcykge1xuICAgIHJldHVybiB2aXN1YWxFbGVtZW50Mi5zZXRQcm9qZWN0aW9uVGFyZ2V0QXhpcyhheGlzLCBvZmZzZXRbYXhpc10ubWluLCBvZmZzZXRbYXhpc10ubWF4LCB0cnVlKTtcbiAgfSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL2RyYWcvVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5qc1xudmFyIGVsZW1lbnREcmFnQ29udHJvbHMgPSBuZXcgV2Vha01hcCgpO1xudmFyIGxhc3RQb2ludGVyRXZlbnQ7XG52YXIgVmlzdWFsRWxlbWVudERyYWdDb250cm9scyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzMihfYSkge1xuICAgIHZhciB2aXN1YWxFbGVtZW50MiA9IF9hLnZpc3VhbEVsZW1lbnQ7XG4gICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50RGlyZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLmNvbnN0cmFpbnRzID0gZmFsc2U7XG4gICAgdGhpcy5lbGFzdGljID0gYXhpc0JveCgpO1xuICAgIHRoaXMucHJvcHMgPSB7fTtcbiAgICB0aGlzLmhhc011dGF0ZWRDb25zdHJhaW50cyA9IGZhbHNlO1xuICAgIHRoaXMuY3Vyc29yUHJvZ3Jlc3MgPSB7XG4gICAgICB4OiAwLjUsXG4gICAgICB5OiAwLjVcbiAgICB9O1xuICAgIHRoaXMub3JpZ2luUG9pbnQgPSB7fTtcbiAgICB0aGlzLm9wZW5HbG9iYWxMb2NrID0gbnVsbDtcbiAgICB0aGlzLnBhblNlc3Npb24gPSBudWxsO1xuICAgIHRoaXMudmlzdWFsRWxlbWVudCA9IHZpc3VhbEVsZW1lbnQyO1xuICAgIHRoaXMudmlzdWFsRWxlbWVudC5lbmFibGVMYXlvdXRQcm9qZWN0aW9uKCk7XG4gICAgZWxlbWVudERyYWdDb250cm9scy5zZXQodmlzdWFsRWxlbWVudDIsIHRoaXMpO1xuICB9XG4gIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9yaWdpbkV2ZW50LCBfYSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2Iuc25hcFRvQ3Vyc29yLCBzbmFwVG9DdXJzb3IgPSBfYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYywgY3Vyc29yUHJvZ3Jlc3MgPSBfYi5jdXJzb3JQcm9ncmVzcztcbiAgICB2YXIgb25TZXNzaW9uU3RhcnQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgX3RoaXMuc3RvcE1vdGlvbigpO1xuICAgICAgX3RoaXMudXBkYXRlTGF5b3V0TWVhc3VyZW1lbnRzKCk7XG4gICAgICBzbmFwVG9DdXJzb3IgJiYgX3RoaXMuc25hcFRvQ3Vyc29yKG9yaWdpbkV2ZW50KTtcbiAgICAgIF90aGlzLmlzTGF5b3V0RHJhZygpICYmIF90aGlzLnZpc3VhbEVsZW1lbnQubG9ja1Byb2plY3Rpb25UYXJnZXQoKTtcbiAgICAgIHZhciBwb2ludCA9IGdldFZpZXdwb3J0UG9pbnRGcm9tRXZlbnQoZXZlbnQpLnBvaW50O1xuICAgICAgZWFjaEF4aXMoZnVuY3Rpb24oYXhpcykge1xuICAgICAgICB2YXIgX2EyID0gX3RoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLnRhcmdldFtheGlzXSwgbWluID0gX2EyLm1pbiwgbWF4ID0gX2EyLm1heDtcbiAgICAgICAgX3RoaXMuY3Vyc29yUHJvZ3Jlc3NbYXhpc10gPSBjdXJzb3JQcm9ncmVzcyA/IGN1cnNvclByb2dyZXNzW2F4aXNdIDogcHJvZ3Jlc3MobWluLCBtYXgsIHBvaW50W2F4aXNdKTtcbiAgICAgICAgdmFyIGF4aXNWYWx1ZSA9IF90aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICAgICAgaWYgKGF4aXNWYWx1ZSkge1xuICAgICAgICAgIF90aGlzLm9yaWdpblBvaW50W2F4aXNdID0gYXhpc1ZhbHVlLmdldCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBvblN0YXJ0ID0gZnVuY3Rpb24oZXZlbnQsIGluZm8pIHtcbiAgICAgIHZhciBfYTIsIF9iMiwgX2MyO1xuICAgICAgdmFyIF9kID0gX3RoaXMucHJvcHMsIGRyYWcyID0gX2QuZHJhZywgZHJhZ1Byb3BhZ2F0aW9uID0gX2QuZHJhZ1Byb3BhZ2F0aW9uO1xuICAgICAgaWYgKGRyYWcyICYmICFkcmFnUHJvcGFnYXRpb24pIHtcbiAgICAgICAgaWYgKF90aGlzLm9wZW5HbG9iYWxMb2NrKVxuICAgICAgICAgIF90aGlzLm9wZW5HbG9iYWxMb2NrKCk7XG4gICAgICAgIF90aGlzLm9wZW5HbG9iYWxMb2NrID0gZ2V0R2xvYmFsTG9jayhkcmFnMik7XG4gICAgICAgIGlmICghX3RoaXMub3Blbkdsb2JhbExvY2spXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3RoaXMucmVzb2x2ZURyYWdDb25zdHJhaW50cygpO1xuICAgICAgX3RoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICBfdGhpcy5jdXJyZW50RGlyZWN0aW9uID0gbnVsbDtcbiAgICAgIChfYjIgPSAoX2EyID0gX3RoaXMucHJvcHMpLm9uRHJhZ1N0YXJ0KSA9PT0gbnVsbCB8fCBfYjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iMi5jYWxsKF9hMiwgZXZlbnQsIGluZm8pO1xuICAgICAgKF9jMiA9IF90aGlzLnZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9jMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MyLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLkRyYWcsIHRydWUpO1xuICAgIH07XG4gICAgdmFyIG9uTW92ZSA9IGZ1bmN0aW9uKGV2ZW50LCBpbmZvKSB7XG4gICAgICB2YXIgX2EyLCBfYjIsIF9jMiwgX2Q7XG4gICAgICB2YXIgX2UgPSBfdGhpcy5wcm9wcywgZHJhZ1Byb3BhZ2F0aW9uID0gX2UuZHJhZ1Byb3BhZ2F0aW9uLCBkcmFnRGlyZWN0aW9uTG9jayA9IF9lLmRyYWdEaXJlY3Rpb25Mb2NrO1xuICAgICAgaWYgKCFkcmFnUHJvcGFnYXRpb24gJiYgIV90aGlzLm9wZW5HbG9iYWxMb2NrKVxuICAgICAgICByZXR1cm47XG4gICAgICB2YXIgb2Zmc2V0ID0gaW5mby5vZmZzZXQ7XG4gICAgICBpZiAoZHJhZ0RpcmVjdGlvbkxvY2sgJiYgX3RoaXMuY3VycmVudERpcmVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICBfdGhpcy5jdXJyZW50RGlyZWN0aW9uID0gZ2V0Q3VycmVudERpcmVjdGlvbihvZmZzZXQpO1xuICAgICAgICBpZiAoX3RoaXMuY3VycmVudERpcmVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIChfYjIgPSAoX2EyID0gX3RoaXMucHJvcHMpLm9uRGlyZWN0aW9uTG9jaykgPT09IG51bGwgfHwgX2IyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYjIuY2FsbChfYTIsIF90aGlzLmN1cnJlbnREaXJlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF90aGlzLnVwZGF0ZUF4aXMoXCJ4XCIsIGV2ZW50LCBvZmZzZXQpO1xuICAgICAgX3RoaXMudXBkYXRlQXhpcyhcInlcIiwgZXZlbnQsIG9mZnNldCk7XG4gICAgICAoX2QgPSAoX2MyID0gX3RoaXMucHJvcHMpLm9uRHJhZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MyLCBldmVudCwgaW5mbyk7XG4gICAgICBsYXN0UG9pbnRlckV2ZW50ID0gZXZlbnQ7XG4gICAgfTtcbiAgICB2YXIgb25FbmQgPSBmdW5jdGlvbihldmVudCwgaW5mbykge1xuICAgICAgcmV0dXJuIF90aGlzLnN0b3AoZXZlbnQsIGluZm8pO1xuICAgIH07XG4gICAgdmFyIHRyYW5zZm9ybVBhZ2VQb2ludCA9IHRoaXMucHJvcHMudHJhbnNmb3JtUGFnZVBvaW50O1xuICAgIHRoaXMucGFuU2Vzc2lvbiA9IG5ldyBQYW5TZXNzaW9uKG9yaWdpbkV2ZW50LCB7XG4gICAgICBvblNlc3Npb25TdGFydCxcbiAgICAgIG9uU3RhcnQsXG4gICAgICBvbk1vdmUsXG4gICAgICBvbkVuZFxuICAgIH0sIHsgdHJhbnNmb3JtUGFnZVBvaW50IH0pO1xuICB9O1xuICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzMi5wcm90b3R5cGUudXBkYXRlTGF5b3V0TWVhc3VyZW1lbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlVHJlZUxheW91dE1lYXN1cmVtZW50cyh0aGlzLnZpc3VhbEVsZW1lbnQsIEJvb2xlYW4odGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoXCJ4XCIpICYmICF0aGlzLmlzRXh0ZXJuYWxEcmFnKCkpKTtcbiAgfTtcbiAgVmlzdWFsRWxlbWVudERyYWdDb250cm9sczIucHJvdG90eXBlLnJlc29sdmVEcmFnQ29uc3RyYWludHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGRyYWdDb25zdHJhaW50cyA9IF9hLmRyYWdDb25zdHJhaW50cywgZHJhZ0VsYXN0aWMgPSBfYS5kcmFnRWxhc3RpYztcbiAgICB0aGlzLnZpc3VhbEVsZW1lbnQudXBkYXRlTGF5b3V0UHJvamVjdGlvbigpO1xuICAgIHZhciBsYXlvdXQgPSB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0TGF5b3V0U3RhdGUoKS5sYXlvdXRDb3JyZWN0ZWQ7XG4gICAgaWYgKGRyYWdDb25zdHJhaW50cykge1xuICAgICAgdGhpcy5jb25zdHJhaW50cyA9IGlzUmVmT2JqZWN0KGRyYWdDb25zdHJhaW50cykgPyB0aGlzLnJlc29sdmVSZWZDb25zdHJhaW50cyhsYXlvdXQsIGRyYWdDb25zdHJhaW50cykgOiBjYWxjUmVsYXRpdmVDb25zdHJhaW50cyhsYXlvdXQsIGRyYWdDb25zdHJhaW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29uc3RyYWludHMgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5lbGFzdGljID0gcmVzb2x2ZURyYWdFbGFzdGljKGRyYWdFbGFzdGljKTtcbiAgICBpZiAodGhpcy5jb25zdHJhaW50cyAmJiAhdGhpcy5oYXNNdXRhdGVkQ29uc3RyYWludHMpIHtcbiAgICAgIGVhY2hBeGlzKGZ1bmN0aW9uKGF4aXMpIHtcbiAgICAgICAgaWYgKF90aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKSkge1xuICAgICAgICAgIF90aGlzLmNvbnN0cmFpbnRzW2F4aXNdID0gcmViYXNlQXhpc0NvbnN0cmFpbnRzKGxheW91dFtheGlzXSwgX3RoaXMuY29uc3RyYWludHNbYXhpc10pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMyLnByb3RvdHlwZS5yZXNvbHZlUmVmQ29uc3RyYWludHMgPSBmdW5jdGlvbihsYXlvdXRCb3gsIGNvbnN0cmFpbnRzKSB7XG4gICAgdmFyIF9hID0gdGhpcy5wcm9wcywgb25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzID0gX2Eub25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzLCB0cmFuc2Zvcm1QYWdlUG9pbnQgPSBfYS50cmFuc2Zvcm1QYWdlUG9pbnQ7XG4gICAgdmFyIGNvbnN0cmFpbnRzRWxlbWVudCA9IGNvbnN0cmFpbnRzLmN1cnJlbnQ7XG4gICAgaW52YXJpYW50KGNvbnN0cmFpbnRzRWxlbWVudCAhPT0gbnVsbCwgXCJJZiBgZHJhZ0NvbnN0cmFpbnRzYCBpcyBzZXQgYXMgYSBSZWFjdCByZWYsIHRoYXQgcmVmIG11c3QgYmUgcGFzc2VkIHRvIGFub3RoZXIgY29tcG9uZW50J3MgYHJlZmAgcHJvcC5cIik7XG4gICAgdGhpcy5jb25zdHJhaW50c0JveCA9IGdldEJvdW5kaW5nQm94KGNvbnN0cmFpbnRzRWxlbWVudCwgdHJhbnNmb3JtUGFnZVBvaW50KTtcbiAgICB2YXIgbWVhc3VyZWRDb25zdHJhaW50cyA9IGNhbGNWaWV3cG9ydENvbnN0cmFpbnRzKGxheW91dEJveCwgdGhpcy5jb25zdHJhaW50c0JveCk7XG4gICAgaWYgKG9uTWVhc3VyZURyYWdDb25zdHJhaW50cykge1xuICAgICAgdmFyIHVzZXJDb25zdHJhaW50cyA9IG9uTWVhc3VyZURyYWdDb25zdHJhaW50cyhjb252ZXJ0QXhpc0JveFRvQm91bmRpbmdCb3gobWVhc3VyZWRDb25zdHJhaW50cykpO1xuICAgICAgdGhpcy5oYXNNdXRhdGVkQ29uc3RyYWludHMgPSAhIXVzZXJDb25zdHJhaW50cztcbiAgICAgIGlmICh1c2VyQ29uc3RyYWludHMpIHtcbiAgICAgICAgbWVhc3VyZWRDb25zdHJhaW50cyA9IGNvbnZlcnRCb3VuZGluZ0JveFRvQXhpc0JveCh1c2VyQ29uc3RyYWludHMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVhc3VyZWRDb25zdHJhaW50cztcbiAgfTtcbiAgVmlzdWFsRWxlbWVudERyYWdDb250cm9sczIucHJvdG90eXBlLmNhbmNlbERyYWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5wYW5TZXNzaW9uICYmIHRoaXMucGFuU2Vzc2lvbi5lbmQoKTtcbiAgICB0aGlzLnBhblNlc3Npb24gPSBudWxsO1xuICAgIGlmICghdGhpcy5wcm9wcy5kcmFnUHJvcGFnYXRpb24gJiYgdGhpcy5vcGVuR2xvYmFsTG9jaykge1xuICAgICAgdGhpcy5vcGVuR2xvYmFsTG9jaygpO1xuICAgICAgdGhpcy5vcGVuR2xvYmFsTG9jayA9IG51bGw7XG4gICAgfVxuICAgIChfYSA9IHRoaXMudmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLkRyYWcsIGZhbHNlKTtcbiAgfTtcbiAgVmlzdWFsRWxlbWVudERyYWdDb250cm9sczIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbihldmVudCwgaW5mbykge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHRoaXMudmlzdWFsRWxlbWVudC51bmxvY2tQcm9qZWN0aW9uVGFyZ2V0KCk7XG4gICAgKF9hID0gdGhpcy5wYW5TZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW5kKCk7XG4gICAgdGhpcy5wYW5TZXNzaW9uID0gbnVsbDtcbiAgICB2YXIgaXNEcmFnZ2luZyA9IHRoaXMuaXNEcmFnZ2luZztcbiAgICB0aGlzLmNhbmNlbERyYWcoKTtcbiAgICBpZiAoIWlzRHJhZ2dpbmcpXG4gICAgICByZXR1cm47XG4gICAgdmFyIHZlbG9jaXR5ID0gaW5mby52ZWxvY2l0eTtcbiAgICB0aGlzLmFuaW1hdGVEcmFnRW5kKHZlbG9jaXR5KTtcbiAgICAoX2MgPSAoX2IgPSB0aGlzLnByb3BzKS5vbkRyYWdFbmQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iLCBldmVudCwgaW5mbyk7XG4gIH07XG4gIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMyLnByb3RvdHlwZS5zbmFwVG9DdXJzb3IgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgZWFjaEF4aXMoZnVuY3Rpb24oYXhpcykge1xuICAgICAgdmFyIGRyYWcyID0gX3RoaXMucHJvcHMuZHJhZztcbiAgICAgIGlmICghc2hvdWxkRHJhZyhheGlzLCBkcmFnMiwgX3RoaXMuY3VycmVudERpcmVjdGlvbikpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHZhciBheGlzVmFsdWUgPSBfdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICBpZiAoYXhpc1ZhbHVlKSB7XG4gICAgICAgIHZhciBwb2ludCA9IGdldFZpZXdwb3J0UG9pbnRGcm9tRXZlbnQoZXZlbnQpLnBvaW50O1xuICAgICAgICB2YXIgYm94ID0gX3RoaXMudmlzdWFsRWxlbWVudC5nZXRMYXlvdXRTdGF0ZSgpLmxheW91dDtcbiAgICAgICAgdmFyIGxlbmd0aF8xID0gYm94W2F4aXNdLm1heCAtIGJveFtheGlzXS5taW47XG4gICAgICAgIHZhciBjZW50ZXIgPSBib3hbYXhpc10ubWluICsgbGVuZ3RoXzEgLyAyO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gcG9pbnRbYXhpc10gLSBjZW50ZXI7XG4gICAgICAgIF90aGlzLm9yaWdpblBvaW50W2F4aXNdID0gcG9pbnRbYXhpc107XG4gICAgICAgIGF4aXNWYWx1ZS5zZXQob2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLmN1cnNvclByb2dyZXNzW2F4aXNdID0gMC41O1xuICAgICAgICBfdGhpcy51cGRhdGVWaXN1YWxFbGVtZW50QXhpcyhheGlzLCBldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMyLnByb3RvdHlwZS51cGRhdGVBeGlzID0gZnVuY3Rpb24oYXhpcywgZXZlbnQsIG9mZnNldCkge1xuICAgIHZhciBkcmFnMiA9IHRoaXMucHJvcHMuZHJhZztcbiAgICBpZiAoIXNob3VsZERyYWcoYXhpcywgZHJhZzIsIHRoaXMuY3VycmVudERpcmVjdGlvbikpXG4gICAgICByZXR1cm47XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpID8gdGhpcy51cGRhdGVBeGlzTW90aW9uVmFsdWUoYXhpcywgb2Zmc2V0KSA6IHRoaXMudXBkYXRlVmlzdWFsRWxlbWVudEF4aXMoYXhpcywgZXZlbnQpO1xuICB9O1xuICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzMi5wcm90b3R5cGUudXBkYXRlQXhpc01vdGlvblZhbHVlID0gZnVuY3Rpb24oYXhpcywgb2Zmc2V0KSB7XG4gICAgdmFyIGF4aXNWYWx1ZSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgIGlmICghb2Zmc2V0IHx8ICFheGlzVmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgdmFyIG5leHRWYWx1ZSA9IHRoaXMub3JpZ2luUG9pbnRbYXhpc10gKyBvZmZzZXRbYXhpc107XG4gICAgdmFyIHVwZGF0ZSA9IHRoaXMuY29uc3RyYWludHMgPyBhcHBseUNvbnN0cmFpbnRzKG5leHRWYWx1ZSwgdGhpcy5jb25zdHJhaW50c1theGlzXSwgdGhpcy5lbGFzdGljW2F4aXNdKSA6IG5leHRWYWx1ZTtcbiAgICBheGlzVmFsdWUuc2V0KHVwZGF0ZSk7XG4gIH07XG4gIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMyLnByb3RvdHlwZS51cGRhdGVWaXN1YWxFbGVtZW50QXhpcyA9IGZ1bmN0aW9uKGF4aXMsIGV2ZW50KSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBheGlzTGF5b3V0ID0gdGhpcy52aXN1YWxFbGVtZW50LmdldExheW91dFN0YXRlKCkubGF5b3V0W2F4aXNdO1xuICAgIHZhciBheGlzTGVuZ3RoID0gYXhpc0xheW91dC5tYXggLSBheGlzTGF5b3V0Lm1pbjtcbiAgICB2YXIgYXhpc1Byb2dyZXNzID0gdGhpcy5jdXJzb3JQcm9ncmVzc1theGlzXTtcbiAgICB2YXIgcG9pbnQgPSBnZXRWaWV3cG9ydFBvaW50RnJvbUV2ZW50KGV2ZW50KS5wb2ludDtcbiAgICB2YXIgbWluID0gY2FsY0NvbnN0cmFpbmVkTWluUG9pbnQocG9pbnRbYXhpc10sIGF4aXNMZW5ndGgsIGF4aXNQcm9ncmVzcywgKF9hID0gdGhpcy5jb25zdHJhaW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2F4aXNdLCB0aGlzLmVsYXN0aWNbYXhpc10pO1xuICAgIHRoaXMudmlzdWFsRWxlbWVudC5zZXRQcm9qZWN0aW9uVGFyZ2V0QXhpcyhheGlzLCBtaW4sIG1pbiArIGF4aXNMZW5ndGgpO1xuICB9O1xuICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzMi5wcm90b3R5cGUuc2V0UHJvcHMgPSBmdW5jdGlvbihfYSkge1xuICAgIHZhciBfYiA9IF9hLmRyYWcsIGRyYWcyID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2IsIF9jID0gX2EuZHJhZ0RpcmVjdGlvbkxvY2ssIGRyYWdEaXJlY3Rpb25Mb2NrID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIF9kID0gX2EuZHJhZ1Byb3BhZ2F0aW9uLCBkcmFnUHJvcGFnYXRpb24gPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZCwgX2UgPSBfYS5kcmFnQ29uc3RyYWludHMsIGRyYWdDb25zdHJhaW50cyA9IF9lID09PSB2b2lkIDAgPyBmYWxzZSA6IF9lLCBfZiA9IF9hLmRyYWdFbGFzdGljLCBkcmFnRWxhc3RpYyA9IF9mID09PSB2b2lkIDAgPyBkZWZhdWx0RWxhc3RpYyA6IF9mLCBfZyA9IF9hLmRyYWdNb21lbnR1bSwgZHJhZ01vbWVudHVtID0gX2cgPT09IHZvaWQgMCA/IHRydWUgOiBfZywgcmVtYWluaW5nUHJvcHMgPSBfX3Jlc3QoX2EsIFtcImRyYWdcIiwgXCJkcmFnRGlyZWN0aW9uTG9ja1wiLCBcImRyYWdQcm9wYWdhdGlvblwiLCBcImRyYWdDb25zdHJhaW50c1wiLCBcImRyYWdFbGFzdGljXCIsIFwiZHJhZ01vbWVudHVtXCJdKTtcbiAgICB0aGlzLnByb3BzID0gX19hc3NpZ24oe1xuICAgICAgZHJhZzogZHJhZzIsXG4gICAgICBkcmFnRGlyZWN0aW9uTG9jayxcbiAgICAgIGRyYWdQcm9wYWdhdGlvbixcbiAgICAgIGRyYWdDb25zdHJhaW50cyxcbiAgICAgIGRyYWdFbGFzdGljLFxuICAgICAgZHJhZ01vbWVudHVtXG4gICAgfSwgcmVtYWluaW5nUHJvcHMpO1xuICB9O1xuICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzMi5wcm90b3R5cGUuZ2V0QXhpc01vdGlvblZhbHVlID0gZnVuY3Rpb24oYXhpcykge1xuICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGxheW91dCA9IF9hLmxheW91dCwgbGF5b3V0SWQgPSBfYS5sYXlvdXRJZDtcbiAgICB2YXIgZHJhZ0tleSA9IFwiX2RyYWdcIiArIGF4aXMudG9VcHBlckNhc2UoKTtcbiAgICBpZiAodGhpcy5wcm9wc1tkcmFnS2V5XSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHNbZHJhZ0tleV07XG4gICAgfSBlbHNlIGlmICghbGF5b3V0ICYmIGxheW91dElkID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoYXhpcywgMCk7XG4gICAgfVxuICB9O1xuICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzMi5wcm90b3R5cGUuaXNMYXlvdXREcmFnID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShcInhcIik7XG4gIH07XG4gIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMyLnByb3RvdHlwZS5pc0V4dGVybmFsRHJhZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIF9kcmFnWCA9IF9hLl9kcmFnWCwgX2RyYWdZID0gX2EuX2RyYWdZO1xuICAgIHJldHVybiBfZHJhZ1ggfHwgX2RyYWdZO1xuICB9O1xuICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzMi5wcm90b3R5cGUuYW5pbWF0ZURyYWdFbmQgPSBmdW5jdGlvbih2ZWxvY2l0eSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZHJhZzIgPSBfYS5kcmFnLCBkcmFnTW9tZW50dW0gPSBfYS5kcmFnTW9tZW50dW0sIGRyYWdFbGFzdGljID0gX2EuZHJhZ0VsYXN0aWMsIGRyYWdUcmFuc2l0aW9uID0gX2EuZHJhZ1RyYW5zaXRpb247XG4gICAgdmFyIGlzUmVsYXRpdmUgPSBjb252ZXJ0VG9SZWxhdGl2ZVByb2plY3Rpb24odGhpcy52aXN1YWxFbGVtZW50LCB0aGlzLmlzTGF5b3V0RHJhZygpICYmICF0aGlzLmlzRXh0ZXJuYWxEcmFnKCkpO1xuICAgIHZhciBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHMgfHwge307XG4gICAgaWYgKGlzUmVsYXRpdmUgJiYgT2JqZWN0LmtleXMoY29uc3RyYWludHMpLmxlbmd0aCAmJiB0aGlzLmlzTGF5b3V0RHJhZygpKSB7XG4gICAgICB2YXIgcHJvamVjdGlvblBhcmVudCA9IHRoaXMudmlzdWFsRWxlbWVudC5nZXRQcm9qZWN0aW9uUGFyZW50KCk7XG4gICAgICBpZiAocHJvamVjdGlvblBhcmVudCkge1xuICAgICAgICB2YXIgcmVsYXRpdmVDb25zdHJhaW50c18xID0gY2FsY1JlbGF0aXZlT2Zmc2V0KHByb2plY3Rpb25QYXJlbnQucHJvamVjdGlvbi50YXJnZXRGaW5hbCwgY29uc3RyYWludHMpO1xuICAgICAgICBlYWNoQXhpcyhmdW5jdGlvbihheGlzKSB7XG4gICAgICAgICAgdmFyIF9hMiA9IHJlbGF0aXZlQ29uc3RyYWludHNfMVtheGlzXSwgbWluID0gX2EyLm1pbiwgbWF4ID0gX2EyLm1heDtcbiAgICAgICAgICBjb25zdHJhaW50c1theGlzXSA9IHtcbiAgICAgICAgICAgIG1pbjogaXNOYU4obWluKSA/IHZvaWQgMCA6IG1pbixcbiAgICAgICAgICAgIG1heDogaXNOYU4obWF4KSA/IHZvaWQgMCA6IG1heFxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbW9tZW50dW1BbmltYXRpb25zID0gZWFjaEF4aXMoZnVuY3Rpb24oYXhpcykge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGlmICghc2hvdWxkRHJhZyhheGlzLCBkcmFnMiwgX3RoaXMuY3VycmVudERpcmVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHRyYW5zaXRpb24gPSAoX2EyID0gY29uc3RyYWludHMgPT09IG51bGwgfHwgY29uc3RyYWludHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnN0cmFpbnRzW2F4aXNdKSAhPT0gbnVsbCAmJiBfYTIgIT09IHZvaWQgMCA/IF9hMiA6IHt9O1xuICAgICAgdmFyIGJvdW5jZVN0aWZmbmVzcyA9IGRyYWdFbGFzdGljID8gMjAwIDogMWU2O1xuICAgICAgdmFyIGJvdW5jZURhbXBpbmcgPSBkcmFnRWxhc3RpYyA/IDQwIDogMWU3O1xuICAgICAgdmFyIGluZXJ0aWEyID0gX19hc3NpZ24oX19hc3NpZ24oe1xuICAgICAgICB0eXBlOiBcImluZXJ0aWFcIixcbiAgICAgICAgdmVsb2NpdHk6IGRyYWdNb21lbnR1bSA/IHZlbG9jaXR5W2F4aXNdIDogMCxcbiAgICAgICAgYm91bmNlU3RpZmZuZXNzLFxuICAgICAgICBib3VuY2VEYW1waW5nLFxuICAgICAgICB0aW1lQ29uc3RhbnQ6IDc1MCxcbiAgICAgICAgcmVzdERlbHRhOiAxLFxuICAgICAgICByZXN0U3BlZWQ6IDEwXG4gICAgICB9LCBkcmFnVHJhbnNpdGlvbiksIHRyYW5zaXRpb24pO1xuICAgICAgcmV0dXJuIF90aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKSA/IF90aGlzLnN0YXJ0QXhpc1ZhbHVlQW5pbWF0aW9uKGF4aXMsIGluZXJ0aWEyKSA6IF90aGlzLnZpc3VhbEVsZW1lbnQuc3RhcnRMYXlvdXRBbmltYXRpb24oYXhpcywgaW5lcnRpYTIsIGlzUmVsYXRpdmUpO1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChtb21lbnR1bUFuaW1hdGlvbnMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX2EyLCBfYjtcbiAgICAgIChfYiA9IChfYTIgPSBfdGhpcy5wcm9wcykub25EcmFnVHJhbnNpdGlvbkVuZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EyKTtcbiAgICB9KTtcbiAgfTtcbiAgVmlzdWFsRWxlbWVudERyYWdDb250cm9sczIucHJvdG90eXBlLnN0b3BNb3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGVhY2hBeGlzKGZ1bmN0aW9uKGF4aXMpIHtcbiAgICAgIHZhciBheGlzVmFsdWUgPSBfdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICBheGlzVmFsdWUgPyBheGlzVmFsdWUuc3RvcCgpIDogX3RoaXMudmlzdWFsRWxlbWVudC5zdG9wTGF5b3V0QW5pbWF0aW9uKCk7XG4gICAgfSk7XG4gIH07XG4gIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMyLnByb3RvdHlwZS5zdGFydEF4aXNWYWx1ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uKGF4aXMsIHRyYW5zaXRpb24pIHtcbiAgICB2YXIgYXhpc1ZhbHVlID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgaWYgKCFheGlzVmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgdmFyIGN1cnJlbnRWYWx1ZSA9IGF4aXNWYWx1ZS5nZXQoKTtcbiAgICBheGlzVmFsdWUuc2V0KGN1cnJlbnRWYWx1ZSk7XG4gICAgYXhpc1ZhbHVlLnNldChjdXJyZW50VmFsdWUpO1xuICAgIHJldHVybiBzdGFydEFuaW1hdGlvbihheGlzLCBheGlzVmFsdWUsIDAsIHRyYW5zaXRpb24pO1xuICB9O1xuICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzMi5wcm90b3R5cGUuc2NhbGVQb2ludCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZHJhZzIgPSBfYS5kcmFnLCBkcmFnQ29uc3RyYWludHMgPSBfYS5kcmFnQ29uc3RyYWludHM7XG4gICAgaWYgKCFpc1JlZk9iamVjdChkcmFnQ29uc3RyYWludHMpIHx8ICF0aGlzLmNvbnN0cmFpbnRzQm94KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuc3RvcE1vdGlvbigpO1xuICAgIHZhciBib3hQcm9ncmVzcyA9IHsgeDogMCwgeTogMCB9O1xuICAgIGVhY2hBeGlzKGZ1bmN0aW9uKGF4aXMpIHtcbiAgICAgIGJveFByb2dyZXNzW2F4aXNdID0gY2FsY09yaWdpbjIoX3RoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLnRhcmdldFtheGlzXSwgX3RoaXMuY29uc3RyYWludHNCb3hbYXhpc10pO1xuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlTGF5b3V0TWVhc3VyZW1lbnRzKCk7XG4gICAgdGhpcy5yZXNvbHZlRHJhZ0NvbnN0cmFpbnRzKCk7XG4gICAgZWFjaEF4aXMoZnVuY3Rpb24oYXhpcykge1xuICAgICAgaWYgKCFzaG91bGREcmFnKGF4aXMsIGRyYWcyLCBudWxsKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdmFyIF9hMiA9IGNhbGNQb3NpdGlvbkZyb21Qcm9ncmVzcyhfdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24udGFyZ2V0W2F4aXNdLCBfdGhpcy5jb25zdHJhaW50c0JveFtheGlzXSwgYm94UHJvZ3Jlc3NbYXhpc10pLCBtaW4gPSBfYTIubWluLCBtYXggPSBfYTIubWF4O1xuICAgICAgX3RoaXMudmlzdWFsRWxlbWVudC5zZXRQcm9qZWN0aW9uVGFyZ2V0QXhpcyhheGlzLCBtaW4sIG1heCk7XG4gICAgfSk7XG4gIH07XG4gIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMyLnByb3RvdHlwZS5tb3VudCA9IGZ1bmN0aW9uKHZpc3VhbEVsZW1lbnQyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgZWxlbWVudCA9IHZpc3VhbEVsZW1lbnQyLmdldEluc3RhbmNlKCk7XG4gICAgdmFyIHN0b3BQb2ludGVyTGlzdGVuZXIgPSBhZGRQb2ludGVyRXZlbnQoZWxlbWVudCwgXCJwb2ludGVyZG93blwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIGRyYWcyID0gX2EuZHJhZywgX2IgPSBfYS5kcmFnTGlzdGVuZXIsIGRyYWdMaXN0ZW5lciA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2I7XG4gICAgICBkcmFnMiAmJiBkcmFnTGlzdGVuZXIgJiYgX3RoaXMuc3RhcnQoZXZlbnQpO1xuICAgIH0pO1xuICAgIHZhciBzdG9wUmVzaXplTGlzdGVuZXIgPSBhZGREb21FdmVudCh3aW5kb3csIFwicmVzaXplXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgX3RoaXMuc2NhbGVQb2ludCgpO1xuICAgIH0pO1xuICAgIHZhciBzdG9wTGF5b3V0VXBkYXRlTGlzdGVuZXIgPSB2aXN1YWxFbGVtZW50Mi5vbkxheW91dFVwZGF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGlmIChfdGhpcy5pc0RyYWdnaW5nKVxuICAgICAgICBfdGhpcy5yZXNvbHZlRHJhZ0NvbnN0cmFpbnRzKCk7XG4gICAgfSk7XG4gICAgdmFyIHByZXZEcmFnQ3Vyc29yID0gdmlzdWFsRWxlbWVudDIucHJldkRyYWdDdXJzb3I7XG4gICAgaWYgKHByZXZEcmFnQ3Vyc29yKSB7XG4gICAgICB0aGlzLnN0YXJ0KGxhc3RQb2ludGVyRXZlbnQsIHsgY3Vyc29yUHJvZ3Jlc3M6IHByZXZEcmFnQ3Vyc29yIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBzdG9wUG9pbnRlckxpc3RlbmVyID09PSBudWxsIHx8IHN0b3BQb2ludGVyTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0b3BQb2ludGVyTGlzdGVuZXIoKTtcbiAgICAgIHN0b3BSZXNpemVMaXN0ZW5lciA9PT0gbnVsbCB8fCBzdG9wUmVzaXplTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0b3BSZXNpemVMaXN0ZW5lcigpO1xuICAgICAgc3RvcExheW91dFVwZGF0ZUxpc3RlbmVyID09PSBudWxsIHx8IHN0b3BMYXlvdXRVcGRhdGVMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RvcExheW91dFVwZGF0ZUxpc3RlbmVyKCk7XG4gICAgICBfdGhpcy5jYW5jZWxEcmFnKCk7XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMyO1xufSgpO1xuZnVuY3Rpb24gc2hvdWxkRHJhZyhkaXJlY3Rpb24sIGRyYWcyLCBjdXJyZW50RGlyZWN0aW9uKSB7XG4gIHJldHVybiAoZHJhZzIgPT09IHRydWUgfHwgZHJhZzIgPT09IGRpcmVjdGlvbikgJiYgKGN1cnJlbnREaXJlY3Rpb24gPT09IG51bGwgfHwgY3VycmVudERpcmVjdGlvbiA9PT0gZGlyZWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnREaXJlY3Rpb24ob2Zmc2V0LCBsb2NrVGhyZXNob2xkKSB7XG4gIGlmIChsb2NrVGhyZXNob2xkID09PSB2b2lkIDApIHtcbiAgICBsb2NrVGhyZXNob2xkID0gMTA7XG4gIH1cbiAgdmFyIGRpcmVjdGlvbiA9IG51bGw7XG4gIGlmIChNYXRoLmFicyhvZmZzZXQueSkgPiBsb2NrVGhyZXNob2xkKSB7XG4gICAgZGlyZWN0aW9uID0gXCJ5XCI7XG4gIH0gZWxzZSBpZiAoTWF0aC5hYnMob2Zmc2V0LngpID4gbG9ja1RocmVzaG9sZCkge1xuICAgIGRpcmVjdGlvbiA9IFwieFwiO1xuICB9XG4gIHJldHVybiBkaXJlY3Rpb247XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvZHJhZy91c2UtZHJhZy5qc1xuZnVuY3Rpb24gdXNlRHJhZyhwcm9wcykge1xuICB2YXIgZ3JvdXBEcmFnQ29udHJvbHMgPSBwcm9wcy5kcmFnQ29udHJvbHMsIHZpc3VhbEVsZW1lbnQyID0gcHJvcHMudmlzdWFsRWxlbWVudDtcbiAgdmFyIHRyYW5zZm9ybVBhZ2VQb2ludCA9IHVzZUNvbnRleHQ5KE1vdGlvbkNvbmZpZ0NvbnRleHQpLnRyYW5zZm9ybVBhZ2VQb2ludDtcbiAgdmFyIGRyYWdDb250cm9scyA9IHVzZUNvbnN0YW50KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgVmlzdWFsRWxlbWVudERyYWdDb250cm9scyh7XG4gICAgICB2aXN1YWxFbGVtZW50OiB2aXN1YWxFbGVtZW50MlxuICAgIH0pO1xuICB9KTtcbiAgZHJhZ0NvbnRyb2xzLnNldFByb3BzKF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcm9wcyksIHsgdHJhbnNmb3JtUGFnZVBvaW50IH0pKTtcbiAgdXNlRWZmZWN0NyhmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ3JvdXBEcmFnQ29udHJvbHMgJiYgZ3JvdXBEcmFnQ29udHJvbHMuc3Vic2NyaWJlKGRyYWdDb250cm9scyk7XG4gIH0sIFtkcmFnQ29udHJvbHNdKTtcbiAgdXNlRWZmZWN0NyhmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZHJhZ0NvbnRyb2xzLm1vdW50KHZpc3VhbEVsZW1lbnQyKTtcbiAgfSwgW10pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3VzZS1wYW4tZ2VzdHVyZS5qc1xuaW1wb3J0IHsgdXNlUmVmIGFzIHVzZVJlZjQsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDEwLCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0OCB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlUGFuR2VzdHVyZShfYSkge1xuICB2YXIgb25QYW4gPSBfYS5vblBhbiwgb25QYW5TdGFydCA9IF9hLm9uUGFuU3RhcnQsIG9uUGFuRW5kID0gX2Eub25QYW5FbmQsIG9uUGFuU2Vzc2lvblN0YXJ0ID0gX2Eub25QYW5TZXNzaW9uU3RhcnQsIHZpc3VhbEVsZW1lbnQyID0gX2EudmlzdWFsRWxlbWVudDtcbiAgdmFyIGhhc1BhbkV2ZW50cyA9IG9uUGFuIHx8IG9uUGFuU3RhcnQgfHwgb25QYW5FbmQgfHwgb25QYW5TZXNzaW9uU3RhcnQ7XG4gIHZhciBwYW5TZXNzaW9uID0gdXNlUmVmNChudWxsKTtcbiAgdmFyIHRyYW5zZm9ybVBhZ2VQb2ludCA9IHVzZUNvbnRleHQxMChNb3Rpb25Db25maWdDb250ZXh0KS50cmFuc2Zvcm1QYWdlUG9pbnQ7XG4gIHZhciBoYW5kbGVycyA9IHtcbiAgICBvblNlc3Npb25TdGFydDogb25QYW5TZXNzaW9uU3RhcnQsXG4gICAgb25TdGFydDogb25QYW5TdGFydCxcbiAgICBvbk1vdmU6IG9uUGFuLFxuICAgIG9uRW5kOiBmdW5jdGlvbihldmVudCwgaW5mbykge1xuICAgICAgcGFuU2Vzc2lvbi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIG9uUGFuRW5kICYmIG9uUGFuRW5kKGV2ZW50LCBpbmZvKTtcbiAgICB9XG4gIH07XG4gIHVzZUVmZmVjdDgoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHBhblNlc3Npb24uY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgcGFuU2Vzc2lvbi5jdXJyZW50LnVwZGF0ZUhhbmRsZXJzKGhhbmRsZXJzKTtcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBvblBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgcGFuU2Vzc2lvbi5jdXJyZW50ID0gbmV3IFBhblNlc3Npb24oZXZlbnQsIGhhbmRsZXJzLCB7XG4gICAgICB0cmFuc2Zvcm1QYWdlUG9pbnRcbiAgICB9KTtcbiAgfVxuICB1c2VQb2ludGVyRXZlbnQodmlzdWFsRWxlbWVudDIsIFwicG9pbnRlcmRvd25cIiwgaGFzUGFuRXZlbnRzICYmIG9uUG9pbnRlckRvd24pO1xuICB1c2VVbm1vdW50RWZmZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwYW5TZXNzaW9uLmN1cnJlbnQgJiYgcGFuU2Vzc2lvbi5jdXJyZW50LmVuZCgpO1xuICB9KTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvZHJhZy5qc1xudmFyIGRyYWcgPSB7XG4gIHBhbjogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQodXNlUGFuR2VzdHVyZSksXG4gIGRyYWc6IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KHVzZURyYWcpXG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9sYXlvdXQvQW5pbWF0ZS5qc1xuaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQ0XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbXBvbmVudHMvQW5pbWF0ZVNoYXJlZExheW91dC90eXBlcy5qc1xudmFyIFByZXNlbmNlO1xuKGZ1bmN0aW9uKFByZXNlbmNlMikge1xuICBQcmVzZW5jZTJbUHJlc2VuY2UyW1wiRW50ZXJpbmdcIl0gPSAwXSA9IFwiRW50ZXJpbmdcIjtcbiAgUHJlc2VuY2UyW1ByZXNlbmNlMltcIlByZXNlbnRcIl0gPSAxXSA9IFwiUHJlc2VudFwiO1xuICBQcmVzZW5jZTJbUHJlc2VuY2UyW1wiRXhpdGluZ1wiXSA9IDJdID0gXCJFeGl0aW5nXCI7XG59KShQcmVzZW5jZSB8fCAoUHJlc2VuY2UgPSB7fSkpO1xudmFyIFZpc2liaWxpdHlBY3Rpb247XG4oZnVuY3Rpb24oVmlzaWJpbGl0eUFjdGlvbjIpIHtcbiAgVmlzaWJpbGl0eUFjdGlvbjJbVmlzaWJpbGl0eUFjdGlvbjJbXCJIaWRlXCJdID0gMF0gPSBcIkhpZGVcIjtcbiAgVmlzaWJpbGl0eUFjdGlvbjJbVmlzaWJpbGl0eUFjdGlvbjJbXCJTaG93XCJdID0gMV0gPSBcIlNob3dcIjtcbn0pKFZpc2liaWxpdHlBY3Rpb24gfHwgKFZpc2liaWxpdHlBY3Rpb24gPSB7fSkpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvY3NzLXZhcmlhYmxlcy1jb252ZXJzaW9uLmpzXG5mdW5jdGlvbiBpc0NTU1ZhcmlhYmxlMih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN0YXJ0c1dpdGgoXCJ2YXIoLS1cIik7XG59XG52YXIgY3NzVmFyaWFibGVSZWdleCA9IC92YXJcXCgoLS1bYS16QS1aMC05LV9dKyksPyA/KFthLXpBLVowLTkgKCklIy4sLV0rKT9cXCkvO1xuZnVuY3Rpb24gcGFyc2VDU1NWYXJpYWJsZShjdXJyZW50KSB7XG4gIHZhciBtYXRjaCA9IGNzc1ZhcmlhYmxlUmVnZXguZXhlYyhjdXJyZW50KTtcbiAgaWYgKCFtYXRjaClcbiAgICByZXR1cm4gWyxdO1xuICB2YXIgX2EgPSBfX3JlYWQobWF0Y2gsIDMpLCB0b2tlbiA9IF9hWzFdLCBmYWxsYmFjayA9IF9hWzJdO1xuICByZXR1cm4gW3Rva2VuLCBmYWxsYmFja107XG59XG52YXIgbWF4RGVwdGggPSA0O1xuZnVuY3Rpb24gZ2V0VmFyaWFibGVWYWx1ZShjdXJyZW50LCBlbGVtZW50LCBkZXB0aCkge1xuICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgIGRlcHRoID0gMTtcbiAgfVxuICBpbnZhcmlhbnQoZGVwdGggPD0gbWF4RGVwdGgsICdNYXggQ1NTIHZhcmlhYmxlIGZhbGxiYWNrIGRlcHRoIGRldGVjdGVkIGluIHByb3BlcnR5IFwiJyArIGN1cnJlbnQgKyAnXCIuIFRoaXMgbWF5IGluZGljYXRlIGEgY2lyY3VsYXIgZmFsbGJhY2sgZGVwZW5kZW5jeS4nKTtcbiAgdmFyIF9hID0gX19yZWFkKHBhcnNlQ1NTVmFyaWFibGUoY3VycmVudCksIDIpLCB0b2tlbiA9IF9hWzBdLCBmYWxsYmFjayA9IF9hWzFdO1xuICBpZiAoIXRva2VuKVxuICAgIHJldHVybjtcbiAgdmFyIHJlc29sdmVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSh0b2tlbik7XG4gIGlmIChyZXNvbHZlZCkge1xuICAgIHJldHVybiByZXNvbHZlZC50cmltKCk7XG4gIH0gZWxzZSBpZiAoaXNDU1NWYXJpYWJsZTIoZmFsbGJhY2spKSB7XG4gICAgcmV0dXJuIGdldFZhcmlhYmxlVmFsdWUoZmFsbGJhY2ssIGVsZW1lbnQsIGRlcHRoICsgMSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlQ1NTVmFyaWFibGVzKHZpc3VhbEVsZW1lbnQyLCBfYSwgdHJhbnNpdGlvbkVuZCkge1xuICB2YXIgX2I7XG4gIHZhciB0YXJnZXQgPSBfX3Jlc3QoX2EsIFtdKTtcbiAgdmFyIGVsZW1lbnQgPSB2aXN1YWxFbGVtZW50Mi5nZXRJbnN0YW5jZSgpO1xuICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKVxuICAgIHJldHVybiB7IHRhcmdldCwgdHJhbnNpdGlvbkVuZCB9O1xuICBpZiAodHJhbnNpdGlvbkVuZCkge1xuICAgIHRyYW5zaXRpb25FbmQgPSBfX2Fzc2lnbih7fSwgdHJhbnNpdGlvbkVuZCk7XG4gIH1cbiAgdmlzdWFsRWxlbWVudDIuZm9yRWFjaFZhbHVlKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGN1cnJlbnQyID0gdmFsdWUuZ2V0KCk7XG4gICAgaWYgKCFpc0NTU1ZhcmlhYmxlMihjdXJyZW50MikpXG4gICAgICByZXR1cm47XG4gICAgdmFyIHJlc29sdmVkMiA9IGdldFZhcmlhYmxlVmFsdWUoY3VycmVudDIsIGVsZW1lbnQpO1xuICAgIGlmIChyZXNvbHZlZDIpXG4gICAgICB2YWx1ZS5zZXQocmVzb2x2ZWQyKTtcbiAgfSk7XG4gIGZvciAodmFyIGtleTYgaW4gdGFyZ2V0KSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0YXJnZXRba2V5Nl07XG4gICAgaWYgKCFpc0NTU1ZhcmlhYmxlMihjdXJyZW50KSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIHZhciByZXNvbHZlZCA9IGdldFZhcmlhYmxlVmFsdWUoY3VycmVudCwgZWxlbWVudCk7XG4gICAgaWYgKCFyZXNvbHZlZClcbiAgICAgIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXk2XSA9IHJlc29sdmVkO1xuICAgIGlmICh0cmFuc2l0aW9uRW5kKVxuICAgICAgKF9iID0gdHJhbnNpdGlvbkVuZFtrZXk2XSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJhbnNpdGlvbkVuZFtrZXk2XSA9IGN1cnJlbnQ7XG4gIH1cbiAgcmV0dXJuIHsgdGFyZ2V0LCB0cmFuc2l0aW9uRW5kIH07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS9wcm9qZWN0aW9uL2RlZmF1bHQtc2NhbGUtY29ycmVjdG9ycy5qc1xuZnVuY3Rpb24gcGl4ZWxzVG9QZXJjZW50KHBpeGVscywgYXhpcykge1xuICByZXR1cm4gcGl4ZWxzIC8gKGF4aXMubWF4IC0gYXhpcy5taW4pICogMTAwO1xufVxuZnVuY3Rpb24gY29ycmVjdEJvcmRlclJhZGl1cyhsYXRlc3QsIF9sYXlvdXRTdGF0ZSwgX2EpIHtcbiAgdmFyIHRhcmdldCA9IF9hLnRhcmdldDtcbiAgaWYgKHR5cGVvZiBsYXRlc3QgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAocHgudGVzdChsYXRlc3QpKSB7XG4gICAgICBsYXRlc3QgPSBwYXJzZUZsb2F0KGxhdGVzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsYXRlc3Q7XG4gICAgfVxuICB9XG4gIHZhciB4ID0gcGl4ZWxzVG9QZXJjZW50KGxhdGVzdCwgdGFyZ2V0LngpO1xuICB2YXIgeSA9IHBpeGVsc1RvUGVyY2VudChsYXRlc3QsIHRhcmdldC55KTtcbiAgcmV0dXJuIHggKyBcIiUgXCIgKyB5ICsgXCIlXCI7XG59XG52YXIgdmFyVG9rZW4gPSBcIl8kY3NzXCI7XG5mdW5jdGlvbiBjb3JyZWN0Qm94U2hhZG93KGxhdGVzdCwgX2EpIHtcbiAgdmFyIGRlbHRhMiA9IF9hLmRlbHRhLCB0cmVlU2NhbGUgPSBfYS50cmVlU2NhbGU7XG4gIHZhciBvcmlnaW5hbCA9IGxhdGVzdDtcbiAgdmFyIGNvbnRhaW5zQ1NTVmFyaWFibGVzID0gbGF0ZXN0LmluY2x1ZGVzKFwidmFyKFwiKTtcbiAgdmFyIGNzc1ZhcmlhYmxlcyA9IFtdO1xuICBpZiAoY29udGFpbnNDU1NWYXJpYWJsZXMpIHtcbiAgICBsYXRlc3QgPSBsYXRlc3QucmVwbGFjZShjc3NWYXJpYWJsZVJlZ2V4LCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgY3NzVmFyaWFibGVzLnB1c2gobWF0Y2gpO1xuICAgICAgcmV0dXJuIHZhclRva2VuO1xuICAgIH0pO1xuICB9XG4gIHZhciBzaGFkb3cgPSBjb21wbGV4LnBhcnNlKGxhdGVzdCk7XG4gIGlmIChzaGFkb3cubGVuZ3RoID4gNSlcbiAgICByZXR1cm4gb3JpZ2luYWw7XG4gIHZhciB0ZW1wbGF0ZSA9IGNvbXBsZXguY3JlYXRlVHJhbnNmb3JtZXIobGF0ZXN0KTtcbiAgdmFyIG9mZnNldCA9IHR5cGVvZiBzaGFkb3dbMF0gIT09IFwibnVtYmVyXCIgPyAxIDogMDtcbiAgdmFyIHhTY2FsZSA9IGRlbHRhMi54LnNjYWxlICogdHJlZVNjYWxlLng7XG4gIHZhciB5U2NhbGUgPSBkZWx0YTIueS5zY2FsZSAqIHRyZWVTY2FsZS55O1xuICBzaGFkb3dbMCArIG9mZnNldF0gLz0geFNjYWxlO1xuICBzaGFkb3dbMSArIG9mZnNldF0gLz0geVNjYWxlO1xuICB2YXIgYXZlcmFnZVNjYWxlID0gbWl4KHhTY2FsZSwgeVNjYWxlLCAwLjUpO1xuICBpZiAodHlwZW9mIHNoYWRvd1syICsgb2Zmc2V0XSA9PT0gXCJudW1iZXJcIilcbiAgICBzaGFkb3dbMiArIG9mZnNldF0gLz0gYXZlcmFnZVNjYWxlO1xuICBpZiAodHlwZW9mIHNoYWRvd1szICsgb2Zmc2V0XSA9PT0gXCJudW1iZXJcIilcbiAgICBzaGFkb3dbMyArIG9mZnNldF0gLz0gYXZlcmFnZVNjYWxlO1xuICB2YXIgb3V0cHV0ID0gdGVtcGxhdGUoc2hhZG93KTtcbiAgaWYgKGNvbnRhaW5zQ1NTVmFyaWFibGVzKSB7XG4gICAgdmFyIGlfMSA9IDA7XG4gICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UodmFyVG9rZW4sIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNzc1ZhcmlhYmxlID0gY3NzVmFyaWFibGVzW2lfMV07XG4gICAgICBpXzErKztcbiAgICAgIHJldHVybiBjc3NWYXJpYWJsZTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxudmFyIGJvcmRlckNvcnJlY3Rpb25EZWZpbml0aW9uID0ge1xuICBwcm9jZXNzOiBjb3JyZWN0Qm9yZGVyUmFkaXVzXG59O1xudmFyIGRlZmF1bHRTY2FsZUNvcnJlY3RvcnMgPSB7XG4gIGJvcmRlclJhZGl1czogX19hc3NpZ24oX19hc3NpZ24oe30sIGJvcmRlckNvcnJlY3Rpb25EZWZpbml0aW9uKSwgeyBhcHBseVRvOiBbXG4gICAgXCJib3JkZXJUb3BMZWZ0UmFkaXVzXCIsXG4gICAgXCJib3JkZXJUb3BSaWdodFJhZGl1c1wiLFxuICAgIFwiYm9yZGVyQm90dG9tTGVmdFJhZGl1c1wiLFxuICAgIFwiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXNcIlxuICBdIH0pLFxuICBib3JkZXJUb3BMZWZ0UmFkaXVzOiBib3JkZXJDb3JyZWN0aW9uRGVmaW5pdGlvbixcbiAgYm9yZGVyVG9wUmlnaHRSYWRpdXM6IGJvcmRlckNvcnJlY3Rpb25EZWZpbml0aW9uLFxuICBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiBib3JkZXJDb3JyZWN0aW9uRGVmaW5pdGlvbixcbiAgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6IGJvcmRlckNvcnJlY3Rpb25EZWZpbml0aW9uLFxuICBib3hTaGFkb3c6IHtcbiAgICBwcm9jZXNzOiBjb3JyZWN0Qm94U2hhZG93XG4gIH1cbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2xheW91dC9BbmltYXRlLmpzXG52YXIgcHJvZ3Jlc3NUYXJnZXQgPSAxZTM7XG52YXIgQW5pbWF0ZSA9IGZ1bmN0aW9uKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQW5pbWF0ZTIsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEFuaW1hdGUyKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLmZyYW1lVGFyZ2V0ID0gYXhpc0JveCgpO1xuICAgIF90aGlzLmN1cnJlbnRBbmltYXRpb25UYXJnZXQgPSBheGlzQm94KCk7XG4gICAgX3RoaXMuaXNBbmltYXRpbmcgPSB7XG4gICAgICB4OiBmYWxzZSxcbiAgICAgIHk6IGZhbHNlXG4gICAgfTtcbiAgICBfdGhpcy5zdG9wQXhpc0FuaW1hdGlvbiA9IHtcbiAgICAgIHg6IHZvaWQgMCxcbiAgICAgIHk6IHZvaWQgMFxuICAgIH07XG4gICAgX3RoaXMuaXNBbmltYXRpbmdUcmVlID0gZmFsc2U7XG4gICAgX3RoaXMuYW5pbWF0ZSA9IGZ1bmN0aW9uKHRhcmdldCwgb3JpZ2luLCBfYSkge1xuICAgICAgaWYgKF9hID09PSB2b2lkIDApIHtcbiAgICAgICAgX2EgPSB7fTtcbiAgICAgIH1cbiAgICAgIHZhciBvcmlnaW5Cb3ggPSBfYS5vcmlnaW5Cb3gsIHRhcmdldEJveCA9IF9hLnRhcmdldEJveCwgdmlzaWJpbGl0eUFjdGlvbiA9IF9hLnZpc2liaWxpdHlBY3Rpb24sIHNob3VsZFN0YWNrQW5pbWF0ZSA9IF9hLnNob3VsZFN0YWNrQW5pbWF0ZSwgb25Db21wbGV0ZSA9IF9hLm9uQ29tcGxldGUsIHByZXZQYXJlbnQgPSBfYS5wcmV2UGFyZW50LCBjb25maWcgPSBfX3Jlc3QoX2EsIFtcIm9yaWdpbkJveFwiLCBcInRhcmdldEJveFwiLCBcInZpc2liaWxpdHlBY3Rpb25cIiwgXCJzaG91bGRTdGFja0FuaW1hdGVcIiwgXCJvbkNvbXBsZXRlXCIsIFwicHJldlBhcmVudFwiXSk7XG4gICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgdmlzdWFsRWxlbWVudDIgPSBfYi52aXN1YWxFbGVtZW50LCBsYXlvdXQgPSBfYi5sYXlvdXQ7XG4gICAgICBpZiAoc2hvdWxkU3RhY2tBbmltYXRlID09PSBmYWxzZSkge1xuICAgICAgICBfdGhpcy5pc0FuaW1hdGluZ1RyZWUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzLnNhZmVUb1JlbW92ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKF90aGlzLmlzQW5pbWF0aW5nVHJlZSAmJiBzaG91bGRTdGFja0FuaW1hdGUgIT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChzaG91bGRTdGFja0FuaW1hdGUpIHtcbiAgICAgICAgX3RoaXMuaXNBbmltYXRpbmdUcmVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG9yaWdpbiA9IG9yaWdpbkJveCB8fCBvcmlnaW47XG4gICAgICB0YXJnZXQgPSB0YXJnZXRCb3ggfHwgdGFyZ2V0O1xuICAgICAgdmFyIGlzUmVsYXRpdmUgPSBmYWxzZTtcbiAgICAgIHZhciBwcm9qZWN0aW9uUGFyZW50ID0gdmlzdWFsRWxlbWVudDIuZ2V0UHJvamVjdGlvblBhcmVudCgpO1xuICAgICAgaWYgKHByb2plY3Rpb25QYXJlbnQpIHtcbiAgICAgICAgdmFyIHByZXZQYXJlbnRWaWV3cG9ydEJveCA9IHByb2plY3Rpb25QYXJlbnQucHJldlZpZXdwb3J0Qm94O1xuICAgICAgICB2YXIgcGFyZW50TGF5b3V0ID0gcHJvamVjdGlvblBhcmVudC5nZXRMYXlvdXRTdGF0ZSgpLmxheW91dDtcbiAgICAgICAgaWYgKHByZXZQYXJlbnQpIHtcbiAgICAgICAgICBpZiAodGFyZ2V0Qm94KSB7XG4gICAgICAgICAgICBwYXJlbnRMYXlvdXQgPSBwcmV2UGFyZW50LmdldExheW91dFN0YXRlKCkubGF5b3V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3JpZ2luQm94ICYmICFjaGVja0lmUGFyZW50SGFzQ2hhbmdlZChwcmV2UGFyZW50LCBwcm9qZWN0aW9uUGFyZW50KSAmJiBwcmV2UGFyZW50LnByZXZWaWV3cG9ydEJveCkge1xuICAgICAgICAgICAgcHJldlBhcmVudFZpZXdwb3J0Qm94ID0gcHJldlBhcmVudC5wcmV2Vmlld3BvcnRCb3g7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2UGFyZW50Vmlld3BvcnRCb3ggJiYgaXNQcm92aWRlZENvcnJlY3REYXRhRm9yUmVsYXRpdmVTaGFyZWRMYXlvdXQocHJldlBhcmVudCwgb3JpZ2luQm94LCB0YXJnZXRCb3gpKSB7XG4gICAgICAgICAgaXNSZWxhdGl2ZSA9IHRydWU7XG4gICAgICAgICAgb3JpZ2luID0gY2FsY1JlbGF0aXZlT2Zmc2V0KHByZXZQYXJlbnRWaWV3cG9ydEJveCwgb3JpZ2luKTtcbiAgICAgICAgICB0YXJnZXQgPSBjYWxjUmVsYXRpdmVPZmZzZXQocGFyZW50TGF5b3V0LCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgYm94SGFzTW92ZWQgPSBoYXNNb3ZlZChvcmlnaW4sIHRhcmdldCk7XG4gICAgICB2YXIgYW5pbWF0aW9uczIgPSBlYWNoQXhpcyhmdW5jdGlvbihheGlzKSB7XG4gICAgICAgIHZhciBfYTIsIF9iMjtcbiAgICAgICAgaWYgKGxheW91dCA9PT0gXCJwb3NpdGlvblwiKSB7XG4gICAgICAgICAgdmFyIHRhcmdldExlbmd0aCA9IHRhcmdldFtheGlzXS5tYXggLSB0YXJnZXRbYXhpc10ubWluO1xuICAgICAgICAgIG9yaWdpbltheGlzXS5tYXggPSBvcmlnaW5bYXhpc10ubWluICsgdGFyZ2V0TGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aXN1YWxFbGVtZW50Mi5wcm9qZWN0aW9uLmlzVGFyZ2V0TG9ja2VkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHZpc2liaWxpdHlBY3Rpb24gIT09IHZvaWQgMCkge1xuICAgICAgICAgIHZpc3VhbEVsZW1lbnQyLnNldFZpc2liaWxpdHkodmlzaWJpbGl0eUFjdGlvbiA9PT0gVmlzaWJpbGl0eUFjdGlvbi5TaG93KTtcbiAgICAgICAgfSBlbHNlIGlmIChib3hIYXNNb3ZlZCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5hbmltYXRlQXhpcyhheGlzLCB0YXJnZXRbYXhpc10sIG9yaWdpbltheGlzXSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGNvbmZpZyksIHsgaXNSZWxhdGl2ZSB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKF9iMiA9IChfYTIgPSBfdGhpcy5zdG9wQXhpc0FuaW1hdGlvbilbYXhpc10pID09PSBudWxsIHx8IF9iMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IyLmNhbGwoX2EyKTtcbiAgICAgICAgICByZXR1cm4gdmlzdWFsRWxlbWVudDIuc2V0UHJvamVjdGlvblRhcmdldEF4aXMoYXhpcywgdGFyZ2V0W2F4aXNdLm1pbiwgdGFyZ2V0W2F4aXNdLm1heCwgaXNSZWxhdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmlzdWFsRWxlbWVudDIuc3luY1JlbmRlcigpO1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGFuaW1hdGlvbnMyKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5pc0FuaW1hdGluZ1RyZWUgPSBmYWxzZTtcbiAgICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKCk7XG4gICAgICAgIHZpc3VhbEVsZW1lbnQyLm5vdGlmeUxheW91dEFuaW1hdGlvbkNvbXBsZXRlKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBBbmltYXRlMi5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciB2aXN1YWxFbGVtZW50MiA9IHRoaXMucHJvcHMudmlzdWFsRWxlbWVudDtcbiAgICB2aXN1YWxFbGVtZW50Mi5hbmltYXRlTW90aW9uVmFsdWUgPSBzdGFydEFuaW1hdGlvbjtcbiAgICB2aXN1YWxFbGVtZW50Mi5lbmFibGVMYXlvdXRQcm9qZWN0aW9uKCk7XG4gICAgdGhpcy51bnN1YkxheW91dFJlYWR5ID0gdmlzdWFsRWxlbWVudDIub25MYXlvdXRVcGRhdGUodGhpcy5hbmltYXRlKTtcbiAgICB2aXN1YWxFbGVtZW50Mi5sYXlvdXRTYWZlVG9SZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfdGhpcy5zYWZlVG9SZW1vdmUoKTtcbiAgICB9O1xuICAgIGFkZFNjYWxlQ29ycmVjdGlvbihkZWZhdWx0U2NhbGVDb3JyZWN0b3JzKTtcbiAgfTtcbiAgQW5pbWF0ZTIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLnVuc3ViTGF5b3V0UmVhZHkoKTtcbiAgICBlYWNoQXhpcyhmdW5jdGlvbihheGlzKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIChfYiA9IChfYSA9IF90aGlzLnN0b3BBeGlzQW5pbWF0aW9uKVtheGlzXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgIH0pO1xuICB9O1xuICBBbmltYXRlMi5wcm90b3R5cGUuYW5pbWF0ZUF4aXMgPSBmdW5jdGlvbihheGlzLCB0YXJnZXQsIG9yaWdpbiwgX2EpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBfYiwgX2M7XG4gICAgdmFyIF9kID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIHRyYW5zaXRpb24gPSBfZC50cmFuc2l0aW9uLCBpc1JlbGF0aXZlID0gX2QuaXNSZWxhdGl2ZTtcbiAgICBpZiAodGhpcy5pc0FuaW1hdGluZ1theGlzXSAmJiBheGlzSXNFcXVhbCh0YXJnZXQsIHRoaXMuY3VycmVudEFuaW1hdGlvblRhcmdldFtheGlzXSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKF9jID0gKF9iID0gdGhpcy5zdG9wQXhpc0FuaW1hdGlvbilbYXhpc10pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iKTtcbiAgICB0aGlzLmlzQW5pbWF0aW5nW2F4aXNdID0gdHJ1ZTtcbiAgICB2YXIgdmlzdWFsRWxlbWVudDIgPSB0aGlzLnByb3BzLnZpc3VhbEVsZW1lbnQ7XG4gICAgdmFyIGZyYW1lVGFyZ2V0ID0gdGhpcy5mcmFtZVRhcmdldFtheGlzXTtcbiAgICB2YXIgbGF5b3V0UHJvZ3Jlc3MgPSB2aXN1YWxFbGVtZW50Mi5nZXRQcm9qZWN0aW9uQW5pbWF0aW9uUHJvZ3Jlc3MoKVtheGlzXTtcbiAgICBsYXlvdXRQcm9ncmVzcy5jbGVhckxpc3RlbmVycygpO1xuICAgIGxheW91dFByb2dyZXNzLnNldCgwKTtcbiAgICBsYXlvdXRQcm9ncmVzcy5zZXQoMCk7XG4gICAgdmFyIGZyYW1lMiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHAgPSBsYXlvdXRQcm9ncmVzcy5nZXQoKSAvIHByb2dyZXNzVGFyZ2V0O1xuICAgICAgdHdlZW5BeGlzKGZyYW1lVGFyZ2V0LCBvcmlnaW4sIHRhcmdldCwgcCk7XG4gICAgICB2aXN1YWxFbGVtZW50Mi5zZXRQcm9qZWN0aW9uVGFyZ2V0QXhpcyhheGlzLCBmcmFtZVRhcmdldC5taW4sIGZyYW1lVGFyZ2V0Lm1heCwgaXNSZWxhdGl2ZSk7XG4gICAgfTtcbiAgICBmcmFtZTIoKTtcbiAgICB2YXIgdW5zdWJzY3JpYmVQcm9ncmVzcyA9IGxheW91dFByb2dyZXNzLm9uQ2hhbmdlKGZyYW1lMik7XG4gICAgdGhpcy5zdG9wQXhpc0FuaW1hdGlvbltheGlzXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgX3RoaXMuaXNBbmltYXRpbmdbYXhpc10gPSBmYWxzZTtcbiAgICAgIGxheW91dFByb2dyZXNzLnN0b3AoKTtcbiAgICAgIHVuc3Vic2NyaWJlUHJvZ3Jlc3MoKTtcbiAgICB9O1xuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvblRhcmdldFtheGlzXSA9IHRhcmdldDtcbiAgICB2YXIgbGF5b3V0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb24gfHwgdmlzdWFsRWxlbWVudDIuZ2V0RGVmYXVsdFRyYW5zaXRpb24oKSB8fCBkZWZhdWx0TGF5b3V0VHJhbnNpdGlvbjtcbiAgICB2YXIgYW5pbWF0aW9uID0gc3RhcnRBbmltYXRpb24oYXhpcyA9PT0gXCJ4XCIgPyBcImxheW91dFhcIiA6IFwibGF5b3V0WVwiLCBsYXlvdXRQcm9ncmVzcywgcHJvZ3Jlc3NUYXJnZXQsIGxheW91dFRyYW5zaXRpb24gJiYgZ2V0VmFsdWVUcmFuc2l0aW9uKGxheW91dFRyYW5zaXRpb24sIFwibGF5b3V0XCIpKS50aGVuKHRoaXMuc3RvcEF4aXNBbmltYXRpb25bYXhpc10pO1xuICAgIHJldHVybiBhbmltYXRpb247XG4gIH07XG4gIEFuaW1hdGUyLnByb3RvdHlwZS5zYWZlVG9SZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIChfYiA9IChfYSA9IHRoaXMucHJvcHMpLnNhZmVUb1JlbW92ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICB9O1xuICBBbmltYXRlMi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIHJldHVybiBBbmltYXRlMjtcbn0oQ29tcG9uZW50KTtcbmZ1bmN0aW9uIEFuaW1hdGVMYXlvdXRDb250ZXh0UHJvdmlkZXIocHJvcHMpIHtcbiAgdmFyIF9hID0gX19yZWFkKHVzZVByZXNlbmNlKCksIDIpLCBzYWZlVG9SZW1vdmUgPSBfYVsxXTtcbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQ0KEFuaW1hdGUsIF9fYXNzaWduKHt9LCBwcm9wcywgeyBzYWZlVG9SZW1vdmUgfSkpO1xufVxuZnVuY3Rpb24gaGFzTW92ZWQoYTIsIGIyKSB7XG4gIHJldHVybiAhaXNaZXJvQm94KGEyKSAmJiAhaXNaZXJvQm94KGIyKSAmJiAoIWF4aXNJc0VxdWFsKGEyLngsIGIyLngpIHx8ICFheGlzSXNFcXVhbChhMi55LCBiMi55KSk7XG59XG52YXIgemVyb0F4aXMgPSB7IG1pbjogMCwgbWF4OiAwIH07XG5mdW5jdGlvbiBpc1plcm9Cb3goYTIpIHtcbiAgcmV0dXJuIGF4aXNJc0VxdWFsKGEyLngsIHplcm9BeGlzKSAmJiBheGlzSXNFcXVhbChhMi55LCB6ZXJvQXhpcyk7XG59XG5mdW5jdGlvbiBheGlzSXNFcXVhbChhMiwgYjIpIHtcbiAgcmV0dXJuIGEyLm1pbiA9PT0gYjIubWluICYmIGEyLm1heCA9PT0gYjIubWF4O1xufVxudmFyIGRlZmF1bHRMYXlvdXRUcmFuc2l0aW9uID0ge1xuICBkdXJhdGlvbjogMC40NSxcbiAgZWFzZTogWzAuNCwgMCwgMC4xLCAxXVxufTtcbmZ1bmN0aW9uIGlzUHJvdmlkZWRDb3JyZWN0RGF0YUZvclJlbGF0aXZlU2hhcmVkTGF5b3V0KHByZXZQYXJlbnQsIG9yaWdpbkJveCwgdGFyZ2V0Qm94KSB7XG4gIHJldHVybiBwcmV2UGFyZW50IHx8ICFwcmV2UGFyZW50ICYmICEob3JpZ2luQm94IHx8IHRhcmdldEJveCk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2xheW91dC9NZWFzdXJlLmpzXG5pbXBvcnQgUmVhY3RfX2RlZmF1bHQsIHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTEgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L1NoYXJlZExheW91dENvbnRleHQuanNcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDYgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb21wb25lbnRzL0FuaW1hdGVTaGFyZWRMYXlvdXQvdXRpbHMvYmF0Y2hlci5qc1xudmFyIGRlZmF1bHRIYW5kbGVyID0ge1xuICBsYXlvdXRSZWFkeTogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQubm90aWZ5TGF5b3V0UmVhZHkoKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhdGNoZXIoKSB7XG4gIHZhciBxdWV1ZSA9IG5ldyBTZXQoKTtcbiAgcmV0dXJuIHtcbiAgICBhZGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4gcXVldWUuYWRkKGNoaWxkKTtcbiAgICB9LFxuICAgIGZsdXNoOiBmdW5jdGlvbihfYSkge1xuICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IGRlZmF1bHRIYW5kbGVyIDogX2EsIGxheW91dFJlYWR5ID0gX2IubGF5b3V0UmVhZHksIHBhcmVudCA9IF9iLnBhcmVudDtcbiAgICAgIHZhciBvcmRlcjIgPSBBcnJheS5mcm9tKHF1ZXVlKS5zb3J0KGNvbXBhcmVCeURlcHRoKTtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgd2l0aG91dFRyZWVUcmFuc2Zvcm0ocGFyZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBiYXRjaFJlc2V0QW5kTWVhc3VyZShvcmRlcjIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhdGNoUmVzZXRBbmRNZWFzdXJlKG9yZGVyMik7XG4gICAgICB9XG4gICAgICBvcmRlcjIuZm9yRWFjaChsYXlvdXRSZWFkeSk7XG4gICAgICBvcmRlcjIuZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQuaXNQcmVzZW50KVxuICAgICAgICAgIGNoaWxkLnByZXNlbmNlID0gUHJlc2VuY2UuUHJlc2VudDtcbiAgICAgIH0pO1xuICAgICAgZmx1c2hTeW5jLnByZVJlbmRlcigpO1xuICAgICAgZmx1c2hTeW5jLnJlbmRlcigpO1xuICAgICAgZXNfZGVmYXVsdC5wb3N0UmVuZGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gb3JkZXIyLmZvckVhY2goYXNzaWduUHJvamVjdGlvblRvU25hcHNob3QpO1xuICAgICAgfSk7XG4gICAgICBxdWV1ZS5jbGVhcigpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGFzc2lnblByb2plY3Rpb25Ub1NuYXBzaG90KGNoaWxkKSB7XG4gIGNoaWxkLnByZXZWaWV3cG9ydEJveCA9IGNoaWxkLnByb2plY3Rpb24udGFyZ2V0O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvU2hhcmVkTGF5b3V0Q29udGV4dC5qc1xudmFyIFNoYXJlZExheW91dENvbnRleHQgPSBjcmVhdGVDb250ZXh0NihjcmVhdGVCYXRjaGVyKCkpO1xudmFyIEZyYW1lclRyZWVMYXlvdXRDb250ZXh0ID0gY3JlYXRlQ29udGV4dDYoY3JlYXRlQmF0Y2hlcigpKTtcbmZ1bmN0aW9uIGlzU2hhcmVkTGF5b3V0KGNvbnRleHQpIHtcbiAgcmV0dXJuICEhY29udGV4dC5mb3JjZVVwZGF0ZTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvbGF5b3V0L01lYXN1cmUuanNcbnZhciBNZWFzdXJlID0gZnVuY3Rpb24oX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhNZWFzdXJlMiwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gTWVhc3VyZTIoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIE1lYXN1cmUyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHN5bmNMYXlvdXQgPSBfYS5zeW5jTGF5b3V0LCBmcmFtZXJTeW5jTGF5b3V0ID0gX2EuZnJhbWVyU3luY0xheW91dCwgdmlzdWFsRWxlbWVudDIgPSBfYS52aXN1YWxFbGVtZW50O1xuICAgIGlzU2hhcmVkTGF5b3V0KHN5bmNMYXlvdXQpICYmIHN5bmNMYXlvdXQucmVnaXN0ZXIodmlzdWFsRWxlbWVudDIpO1xuICAgIGlzU2hhcmVkTGF5b3V0KGZyYW1lclN5bmNMYXlvdXQpICYmIGZyYW1lclN5bmNMYXlvdXQucmVnaXN0ZXIodmlzdWFsRWxlbWVudDIpO1xuICAgIHZpc3VhbEVsZW1lbnQyLm9uVW5tb3VudChmdW5jdGlvbigpIHtcbiAgICAgIGlmIChpc1NoYXJlZExheW91dChzeW5jTGF5b3V0KSkge1xuICAgICAgICBzeW5jTGF5b3V0LnJlbW92ZSh2aXN1YWxFbGVtZW50Mik7XG4gICAgICB9XG4gICAgICBpZiAoaXNTaGFyZWRMYXlvdXQoZnJhbWVyU3luY0xheW91dCkpIHtcbiAgICAgICAgZnJhbWVyU3luY0xheW91dC5yZW1vdmUodmlzdWFsRWxlbWVudDIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBNZWFzdXJlMi5wcm90b3R5cGUuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBzeW5jTGF5b3V0ID0gX2Euc3luY0xheW91dCwgdmlzdWFsRWxlbWVudDIgPSBfYS52aXN1YWxFbGVtZW50O1xuICAgIGlmIChpc1NoYXJlZExheW91dChzeW5jTGF5b3V0KSkge1xuICAgICAgc3luY0xheW91dC5zeW5jVXBkYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNuYXBzaG90Vmlld3BvcnRCb3godmlzdWFsRWxlbWVudDIpO1xuICAgICAgc3luY0xheW91dC5hZGQodmlzdWFsRWxlbWVudDIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgTWVhc3VyZTIucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzeW5jTGF5b3V0ID0gdGhpcy5wcm9wcy5zeW5jTGF5b3V0O1xuICAgIGlmICghaXNTaGFyZWRMYXlvdXQoc3luY0xheW91dCkpXG4gICAgICBzeW5jTGF5b3V0LmZsdXNoKCk7XG4gIH07XG4gIE1lYXN1cmUyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgcmV0dXJuIE1lYXN1cmUyO1xufShSZWFjdF9fZGVmYXVsdC5Db21wb25lbnQpO1xuZnVuY3Rpb24gTWVhc3VyZUNvbnRleHRQcm92aWRlcihwcm9wcykge1xuICB2YXIgc3luY0xheW91dCA9IHVzZUNvbnRleHQxMShTaGFyZWRMYXlvdXRDb250ZXh0KTtcbiAgdmFyIGZyYW1lclN5bmNMYXlvdXQgPSB1c2VDb250ZXh0MTEoRnJhbWVyVHJlZUxheW91dENvbnRleHQpO1xuICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChNZWFzdXJlLCBfX2Fzc2lnbih7fSwgcHJvcHMsIHsgc3luY0xheW91dCwgZnJhbWVyU3luY0xheW91dCB9KSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2xheW91dC9pbmRleC5qc1xudmFyIGxheW91dEFuaW1hdGlvbnMgPSB7XG4gIG1lYXN1cmVMYXlvdXQ6IE1lYXN1cmVDb250ZXh0UHJvdmlkZXIsXG4gIGxheW91dEFuaW1hdGlvbjogQW5pbWF0ZUxheW91dENvbnRleHRQcm92aWRlclxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvc3RhdGUuanNcbnZhciBjcmVhdGVQcm9qZWN0aW9uU3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBpc0VuYWJsZWQ6IGZhbHNlLFxuICAgIGlzVGFyZ2V0TG9ja2VkOiBmYWxzZSxcbiAgICB0YXJnZXQ6IGF4aXNCb3goKSxcbiAgICB0YXJnZXRGaW5hbDogYXhpc0JveCgpXG4gIH07XG59O1xuZnVuY3Rpb24gY3JlYXRlTGF5b3V0U3RhdGUoKSB7XG4gIHJldHVybiB7XG4gICAgaXNIeWRyYXRlZDogZmFsc2UsXG4gICAgbGF5b3V0OiBheGlzQm94KCksXG4gICAgbGF5b3V0Q29ycmVjdGVkOiBheGlzQm94KCksXG4gICAgdHJlZVNjYWxlOiB7IHg6IDEsIHk6IDEgfSxcbiAgICBkZWx0YTogZGVsdGEoKSxcbiAgICBkZWx0YUZpbmFsOiBkZWx0YSgpLFxuICAgIGRlbHRhVHJhbnNmb3JtOiBcIlwiXG4gIH07XG59XG52YXIgemVyb0xheW91dCA9IGNyZWF0ZUxheW91dFN0YXRlKCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvYnVpbGQtcHJvamVjdGlvbi10cmFuc2Zvcm0uanNcbmZ1bmN0aW9uIGJ1aWxkTGF5b3V0UHJvamVjdGlvblRyYW5zZm9ybShfYSwgdHJlZVNjYWxlLCBsYXRlc3RUcmFuc2Zvcm0pIHtcbiAgdmFyIHggPSBfYS54LCB5ID0gX2EueTtcbiAgdmFyIHhUcmFuc2xhdGUgPSB4LnRyYW5zbGF0ZSAvIHRyZWVTY2FsZS54O1xuICB2YXIgeVRyYW5zbGF0ZSA9IHkudHJhbnNsYXRlIC8gdHJlZVNjYWxlLnk7XG4gIHZhciB0cmFuc2Zvcm0yID0gXCJ0cmFuc2xhdGUzZChcIiArIHhUcmFuc2xhdGUgKyBcInB4LCBcIiArIHlUcmFuc2xhdGUgKyBcInB4LCAwKSBcIjtcbiAgaWYgKGxhdGVzdFRyYW5zZm9ybSkge1xuICAgIHZhciByb3RhdGUgPSBsYXRlc3RUcmFuc2Zvcm0ucm90YXRlLCByb3RhdGVYID0gbGF0ZXN0VHJhbnNmb3JtLnJvdGF0ZVgsIHJvdGF0ZVkgPSBsYXRlc3RUcmFuc2Zvcm0ucm90YXRlWTtcbiAgICBpZiAocm90YXRlKVxuICAgICAgdHJhbnNmb3JtMiArPSBcInJvdGF0ZShcIiArIHJvdGF0ZSArIFwiKSBcIjtcbiAgICBpZiAocm90YXRlWClcbiAgICAgIHRyYW5zZm9ybTIgKz0gXCJyb3RhdGVYKFwiICsgcm90YXRlWCArIFwiKSBcIjtcbiAgICBpZiAocm90YXRlWSlcbiAgICAgIHRyYW5zZm9ybTIgKz0gXCJyb3RhdGVZKFwiICsgcm90YXRlWSArIFwiKSBcIjtcbiAgfVxuICB0cmFuc2Zvcm0yICs9IFwic2NhbGUoXCIgKyB4LnNjYWxlICsgXCIsIFwiICsgeS5zY2FsZSArIFwiKVwiO1xuICByZXR1cm4gIWxhdGVzdFRyYW5zZm9ybSAmJiB0cmFuc2Zvcm0yID09PSBpZGVudGl0eVByb2plY3Rpb24gPyBcIlwiIDogdHJhbnNmb3JtMjtcbn1cbmZ1bmN0aW9uIGJ1aWxkTGF5b3V0UHJvamVjdGlvblRyYW5zZm9ybU9yaWdpbihfYSkge1xuICB2YXIgZGVsdGFGaW5hbCA9IF9hLmRlbHRhRmluYWw7XG4gIHJldHVybiBkZWx0YUZpbmFsLngub3JpZ2luICogMTAwICsgXCIlIFwiICsgZGVsdGFGaW5hbC55Lm9yaWdpbiAqIDEwMCArIFwiJSAwXCI7XG59XG52YXIgaWRlbnRpdHlQcm9qZWN0aW9uID0gYnVpbGRMYXlvdXRQcm9qZWN0aW9uVHJhbnNmb3JtKHplcm9MYXlvdXQuZGVsdGEsIHplcm9MYXlvdXQudHJlZVNjYWxlLCB7IHg6IDEsIHk6IDEgfSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL2xpZmVjeWNsZXMuanNcbnZhciBuYW1lcyA9IFtcbiAgXCJMYXlvdXRNZWFzdXJlXCIsXG4gIFwiQmVmb3JlTGF5b3V0TWVhc3VyZVwiLFxuICBcIkxheW91dFVwZGF0ZVwiLFxuICBcIlZpZXdwb3J0Qm94VXBkYXRlXCIsXG4gIFwiVXBkYXRlXCIsXG4gIFwiUmVuZGVyXCIsXG4gIFwiQW5pbWF0aW9uQ29tcGxldGVcIixcbiAgXCJMYXlvdXRBbmltYXRpb25Db21wbGV0ZVwiLFxuICBcIkFuaW1hdGlvblN0YXJ0XCIsXG4gIFwiU2V0QXhpc1RhcmdldFwiLFxuICBcIlVubW91bnRcIlxuXTtcbmZ1bmN0aW9uIGNyZWF0ZUxpZmVjeWNsZXMoKSB7XG4gIHZhciBtYW5hZ2VycyA9IG5hbWVzLm1hcChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXIoKTtcbiAgfSk7XG4gIHZhciBwcm9wU3Vic2NyaXB0aW9ucyA9IHt9O1xuICB2YXIgbGlmZWN5Y2xlcyA9IHtcbiAgICBjbGVhckFsbExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWFuYWdlcnMuZm9yRWFjaChmdW5jdGlvbihtYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybiBtYW5hZ2VyLmNsZWFyKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHVwZGF0ZVByb3BMaXN0ZW5lcnM6IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICByZXR1cm4gbmFtZXMuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gcHJvcFN1YnNjcmlwdGlvbnNbbmFtZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHByb3BTdWJzY3JpcHRpb25zKTtcbiAgICAgICAgdmFyIG9uID0gXCJvblwiICsgbmFtZTtcbiAgICAgICAgdmFyIHByb3BMaXN0ZW5lciA9IHByb3BzW29uXTtcbiAgICAgICAgaWYgKHByb3BMaXN0ZW5lcikge1xuICAgICAgICAgIHByb3BTdWJzY3JpcHRpb25zW25hbWVdID0gbGlmZWN5Y2xlc1tvbl0ocHJvcExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBtYW5hZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uKG1hbmFnZXIsIGkpIHtcbiAgICBsaWZlY3ljbGVzW1wib25cIiArIG5hbWVzW2ldXSA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBtYW5hZ2VyLmFkZChoYW5kbGVyKTtcbiAgICB9O1xuICAgIGxpZmVjeWNsZXNbXCJub3RpZnlcIiArIG5hbWVzW2ldXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYW5hZ2VyLm5vdGlmeS5hcHBseShtYW5hZ2VyLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJncykpKTtcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIGxpZmVjeWNsZXM7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL21vdGlvbi12YWx1ZXMuanNcbmZ1bmN0aW9uIHVwZGF0ZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhlbGVtZW50LCBuZXh0LCBwcmV2KSB7XG4gIHZhciBfYTtcbiAgZm9yICh2YXIga2V5NiBpbiBuZXh0KSB7XG4gICAgdmFyIG5leHRWYWx1ZSA9IG5leHRba2V5Nl07XG4gICAgdmFyIHByZXZWYWx1ZSA9IHByZXZba2V5Nl07XG4gICAgaWYgKGlzTW90aW9uVmFsdWUobmV4dFZhbHVlKSkge1xuICAgICAgZWxlbWVudC5hZGRWYWx1ZShrZXk2LCBuZXh0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaXNNb3Rpb25WYWx1ZShwcmV2VmFsdWUpKSB7XG4gICAgICBlbGVtZW50LmFkZFZhbHVlKGtleTYsIG1vdGlvblZhbHVlKG5leHRWYWx1ZSkpO1xuICAgIH0gZWxzZSBpZiAocHJldlZhbHVlICE9PSBuZXh0VmFsdWUpIHtcbiAgICAgIGlmIChlbGVtZW50Lmhhc1ZhbHVlKGtleTYpKSB7XG4gICAgICAgIHZhciBleGlzdGluZ1ZhbHVlID0gZWxlbWVudC5nZXRWYWx1ZShrZXk2KTtcbiAgICAgICAgIWV4aXN0aW5nVmFsdWUuaGFzQW5pbWF0ZWQgJiYgZXhpc3RpbmdWYWx1ZS5zZXQobmV4dFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuYWRkVmFsdWUoa2V5NiwgbW90aW9uVmFsdWUoKF9hID0gZWxlbWVudC5nZXRTdGF0aWNWYWx1ZShrZXk2KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV4dFZhbHVlKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGtleTYgaW4gcHJldikge1xuICAgIGlmIChuZXh0W2tleTZdID09PSB2b2lkIDApXG4gICAgICBlbGVtZW50LnJlbW92ZVZhbHVlKGtleTYpO1xuICB9XG4gIHJldHVybiBuZXh0O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9wcm9qZWN0aW9uLmpzXG5mdW5jdGlvbiB1cGRhdGVMYXlvdXREZWx0YXMoX2EsIF9iLCB0cmVlUGF0aCwgdHJhbnNmb3JtT3JpZ2luKSB7XG4gIHZhciBkZWx0YTIgPSBfYS5kZWx0YSwgbGF5b3V0ID0gX2EubGF5b3V0LCBsYXlvdXRDb3JyZWN0ZWQgPSBfYS5sYXlvdXRDb3JyZWN0ZWQsIHRyZWVTY2FsZSA9IF9hLnRyZWVTY2FsZTtcbiAgdmFyIHRhcmdldCA9IF9iLnRhcmdldDtcbiAgcmVzZXRCb3gobGF5b3V0Q29ycmVjdGVkLCBsYXlvdXQpO1xuICBhcHBseVRyZWVEZWx0YXMobGF5b3V0Q29ycmVjdGVkLCB0cmVlU2NhbGUsIHRyZWVQYXRoKTtcbiAgdXBkYXRlQm94RGVsdGEoZGVsdGEyLCBsYXlvdXRDb3JyZWN0ZWQsIHRhcmdldCwgdHJhbnNmb3JtT3JpZ2luKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvZmxhdC10cmVlLmpzXG52YXIgRmxhdFRyZWUgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gRmxhdFRyZWUyKCkge1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgfVxuICBGbGF0VHJlZTIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgYWRkVW5pcXVlSXRlbSh0aGlzLmNoaWxkcmVuLCBjaGlsZCk7XG4gICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcbiAgfTtcbiAgRmxhdFRyZWUyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihjaGlsZCkge1xuICAgIHJlbW92ZUl0ZW0odGhpcy5jaGlsZHJlbiwgY2hpbGQpO1xuICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gIH07XG4gIEZsYXRUcmVlMi5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5pc0RpcnR5ICYmIHRoaXMuY2hpbGRyZW4uc29ydChjb21wYXJlQnlEZXB0aCk7XG4gICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgfTtcbiAgcmV0dXJuIEZsYXRUcmVlMjtcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3Byb2plY3Rpb24vcmVsYXRpdmUtc2V0LmpzXG5mdW5jdGlvbiBzZXRDdXJyZW50Vmlld3BvcnRCb3godmlzdWFsRWxlbWVudDIpIHtcbiAgdmFyIHByb2plY3Rpb25QYXJlbnQgPSB2aXN1YWxFbGVtZW50Mi5nZXRQcm9qZWN0aW9uUGFyZW50KCk7XG4gIGlmICghcHJvamVjdGlvblBhcmVudCkge1xuICAgIHZpc3VhbEVsZW1lbnQyLnJlYmFzZVByb2plY3Rpb25UYXJnZXQoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlbGF0aXZlT2Zmc2V0ID0gY2FsY1JlbGF0aXZlT2Zmc2V0KHByb2plY3Rpb25QYXJlbnQuZ2V0TGF5b3V0U3RhdGUoKS5sYXlvdXQsIHZpc3VhbEVsZW1lbnQyLmdldExheW91dFN0YXRlKCkubGF5b3V0KTtcbiAgZWFjaEF4aXMoZnVuY3Rpb24oYXhpcykge1xuICAgIHZpc3VhbEVsZW1lbnQyLnNldFByb2plY3Rpb25UYXJnZXRBeGlzKGF4aXMsIHJlbGF0aXZlT2Zmc2V0W2F4aXNdLm1pbiwgcmVsYXRpdmVPZmZzZXRbYXhpc10ubWF4LCB0cnVlKTtcbiAgfSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2luZGV4LmpzXG52YXIgdmlzdWFsRWxlbWVudCA9IGZ1bmN0aW9uKF9hKSB7XG4gIHZhciBfYiA9IF9hLnRyZWVUeXBlLCB0cmVlVHlwZSA9IF9iID09PSB2b2lkIDAgPyBcIlwiIDogX2IsIGJ1aWxkID0gX2EuYnVpbGQsIGdldEJhc2VUYXJnZXQgPSBfYS5nZXRCYXNlVGFyZ2V0LCBtYWtlVGFyZ2V0QW5pbWF0YWJsZSA9IF9hLm1ha2VUYXJnZXRBbmltYXRhYmxlLCBtZWFzdXJlVmlld3BvcnRCb3ggPSBfYS5tZWFzdXJlVmlld3BvcnRCb3gsIHJlbmRlckluc3RhbmNlID0gX2EucmVuZGVyLCByZWFkVmFsdWVGcm9tSW5zdGFuY2UgPSBfYS5yZWFkVmFsdWVGcm9tSW5zdGFuY2UsIHJlc2V0VHJhbnNmb3JtID0gX2EucmVzZXRUcmFuc2Zvcm0sIHJlc3RvcmVUcmFuc2Zvcm0gPSBfYS5yZXN0b3JlVHJhbnNmb3JtLCByZW1vdmVWYWx1ZUZyb21SZW5kZXJTdGF0ZSA9IF9hLnJlbW92ZVZhbHVlRnJvbVJlbmRlclN0YXRlLCBzb3J0Tm9kZVBvc2l0aW9uID0gX2Euc29ydE5vZGVQb3NpdGlvbiwgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzMyA9IF9hLnNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcztcbiAgcmV0dXJuIGZ1bmN0aW9uKF9hMiwgb3B0aW9ucykge1xuICAgIHZhciBwYXJlbnQgPSBfYTIucGFyZW50LCBwcm9wcyA9IF9hMi5wcm9wcywgcHJlc2VuY2VJZDIgPSBfYTIucHJlc2VuY2VJZCwgYmxvY2tJbml0aWFsQW5pbWF0aW9uID0gX2EyLmJsb2NrSW5pdGlhbEFuaW1hdGlvbiwgdmlzdWFsU3RhdGUgPSBfYTIudmlzdWFsU3RhdGU7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICB2YXIgbGF0ZXN0VmFsdWVzID0gdmlzdWFsU3RhdGUubGF0ZXN0VmFsdWVzLCByZW5kZXJTdGF0ZSA9IHZpc3VhbFN0YXRlLnJlbmRlclN0YXRlO1xuICAgIHZhciBpbnN0YW5jZTtcbiAgICB2YXIgbGlmZWN5Y2xlcyA9IGNyZWF0ZUxpZmVjeWNsZXMoKTtcbiAgICB2YXIgcHJvamVjdGlvbiA9IGNyZWF0ZVByb2plY3Rpb25TdGF0ZSgpO1xuICAgIHZhciBwcm9qZWN0aW9uUGFyZW50O1xuICAgIHZhciBsZWFkUHJvamVjdGlvbiA9IHByb2plY3Rpb247XG4gICAgdmFyIGxlYWRMYXRlc3RWYWx1ZXMgPSBsYXRlc3RWYWx1ZXM7XG4gICAgdmFyIHVuc3Vic2NyaWJlRnJvbUxlYWRWaXN1YWxFbGVtZW50O1xuICAgIHZhciBsYXlvdXRTdGF0ZSA9IGNyZWF0ZUxheW91dFN0YXRlKCk7XG4gICAgdmFyIGNyb3NzZmFkZXI7XG4gICAgdmFyIGhhc1ZpZXdwb3J0Qm94VXBkYXRlZCA9IGZhbHNlO1xuICAgIHZhciB2YWx1ZXMgPSBuZXcgTWFwKCk7XG4gICAgdmFyIHZhbHVlU3Vic2NyaXB0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB2YXIgcHJldk1vdGlvblZhbHVlcyA9IHt9O1xuICAgIHZhciBwcm9qZWN0aW9uVGFyZ2V0UHJvZ3Jlc3M7XG4gICAgdmFyIGJhc2VUYXJnZXQgPSBfX2Fzc2lnbih7fSwgbGF0ZXN0VmFsdWVzKTtcbiAgICB2YXIgcmVtb3ZlRnJvbVZhcmlhbnRUcmVlO1xuICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIGlmICghaW5zdGFuY2UpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChlbGVtZW50LmlzUHJvamVjdGlvblJlYWR5KCkpIHtcbiAgICAgICAgYXBwbHlCb3hUcmFuc2Zvcm1zKGxlYWRQcm9qZWN0aW9uLnRhcmdldEZpbmFsLCBsZWFkUHJvamVjdGlvbi50YXJnZXQsIGxlYWRMYXRlc3RWYWx1ZXMpO1xuICAgICAgICB1cGRhdGVCb3hEZWx0YShsYXlvdXRTdGF0ZS5kZWx0YUZpbmFsLCBsYXlvdXRTdGF0ZS5sYXlvdXRDb3JyZWN0ZWQsIGxlYWRQcm9qZWN0aW9uLnRhcmdldEZpbmFsLCBsYXRlc3RWYWx1ZXMpO1xuICAgICAgfVxuICAgICAgdHJpZ2dlckJ1aWxkKCk7XG4gICAgICByZW5kZXJJbnN0YW5jZShpbnN0YW5jZSwgcmVuZGVyU3RhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmlnZ2VyQnVpbGQoKSB7XG4gICAgICB2YXIgdmFsdWVzVG9SZW5kZXIgPSBsYXRlc3RWYWx1ZXM7XG4gICAgICBpZiAoY3Jvc3NmYWRlciAmJiBjcm9zc2ZhZGVyLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgdmFyIGNyb3NzZmFkZWRWYWx1ZXMgPSBjcm9zc2ZhZGVyLmdldENyb3NzZmFkZVN0YXRlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoY3Jvc3NmYWRlZFZhbHVlcylcbiAgICAgICAgICB2YWx1ZXNUb1JlbmRlciA9IGNyb3NzZmFkZWRWYWx1ZXM7XG4gICAgICB9XG4gICAgICBidWlsZChlbGVtZW50LCByZW5kZXJTdGF0ZSwgdmFsdWVzVG9SZW5kZXIsIGxlYWRQcm9qZWN0aW9uLCBsYXlvdXRTdGF0ZSwgb3B0aW9ucywgcHJvcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICBsaWZlY3ljbGVzLm5vdGlmeVVwZGF0ZShsYXRlc3RWYWx1ZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVMYXlvdXRQcm9qZWN0aW9uKCkge1xuICAgICAgdmFyIGRlbHRhMiA9IGxheW91dFN0YXRlLmRlbHRhLCB0cmVlU2NhbGUgPSBsYXlvdXRTdGF0ZS50cmVlU2NhbGU7XG4gICAgICB2YXIgcHJldlRyZWVTY2FsZVggPSB0cmVlU2NhbGUueDtcbiAgICAgIHZhciBwcmV2VHJlZVNjYWxlWSA9IHRyZWVTY2FsZS54O1xuICAgICAgdmFyIHByZXZEZWx0YVRyYW5zZm9ybSA9IGxheW91dFN0YXRlLmRlbHRhVHJhbnNmb3JtO1xuICAgICAgdXBkYXRlTGF5b3V0RGVsdGFzKGxheW91dFN0YXRlLCBsZWFkUHJvamVjdGlvbiwgZWxlbWVudC5wYXRoLCBsYXRlc3RWYWx1ZXMpO1xuICAgICAgaGFzVmlld3BvcnRCb3hVcGRhdGVkICYmIGVsZW1lbnQubm90aWZ5Vmlld3BvcnRCb3hVcGRhdGUobGVhZFByb2plY3Rpb24udGFyZ2V0LCBkZWx0YTIpO1xuICAgICAgaGFzVmlld3BvcnRCb3hVcGRhdGVkID0gZmFsc2U7XG4gICAgICB2YXIgZGVsdGFUcmFuc2Zvcm0gPSBidWlsZExheW91dFByb2plY3Rpb25UcmFuc2Zvcm0oZGVsdGEyLCB0cmVlU2NhbGUpO1xuICAgICAgaWYgKGRlbHRhVHJhbnNmb3JtICE9PSBwcmV2RGVsdGFUcmFuc2Zvcm0gfHwgcHJldlRyZWVTY2FsZVggIT09IHRyZWVTY2FsZS54IHx8IHByZXZUcmVlU2NhbGVZICE9PSB0cmVlU2NhbGUueSkge1xuICAgICAgICBlbGVtZW50LnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgICBsYXlvdXRTdGF0ZS5kZWx0YVRyYW5zZm9ybSA9IGRlbHRhVHJhbnNmb3JtO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVUcmVlTGF5b3V0UHJvamVjdGlvbigpIHtcbiAgICAgIGVsZW1lbnQubGF5b3V0VHJlZS5mb3JFYWNoKGZpcmVVcGRhdGVMYXlvdXRQcm9qZWN0aW9uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmluZFRvTW90aW9uVmFsdWUoa2V5NywgdmFsdWUyKSB7XG4gICAgICB2YXIgcmVtb3ZlT25DaGFuZ2UgPSB2YWx1ZTIub25DaGFuZ2UoZnVuY3Rpb24obGF0ZXN0VmFsdWUpIHtcbiAgICAgICAgbGF0ZXN0VmFsdWVzW2tleTddID0gbGF0ZXN0VmFsdWU7XG4gICAgICAgIHByb3BzLm9uVXBkYXRlICYmIGVzX2RlZmF1bHQudXBkYXRlKHVwZGF0ZSwgZmFsc2UsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICB2YXIgcmVtb3ZlT25SZW5kZXJSZXF1ZXN0ID0gdmFsdWUyLm9uUmVuZGVyUmVxdWVzdChlbGVtZW50LnNjaGVkdWxlUmVuZGVyKTtcbiAgICAgIHZhbHVlU3Vic2NyaXB0aW9ucy5zZXQoa2V5NywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlbW92ZU9uQ2hhbmdlKCk7XG4gICAgICAgIHJlbW92ZU9uUmVuZGVyUmVxdWVzdCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBpbml0aWFsTW90aW9uVmFsdWVzID0gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzMyhwcm9wcyk7XG4gICAgZm9yICh2YXIga2V5NiBpbiBpbml0aWFsTW90aW9uVmFsdWVzKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbml0aWFsTW90aW9uVmFsdWVzW2tleTZdO1xuICAgICAgaWYgKGxhdGVzdFZhbHVlc1trZXk2XSAhPT0gdm9pZCAwICYmIGlzTW90aW9uVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLnNldChsYXRlc3RWYWx1ZXNba2V5Nl0sIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGlzQ29udHJvbGxpbmdWYXJpYW50cyA9IGNoZWNrSWZDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKTtcbiAgICB2YXIgaXNWYXJpYW50Tm9kZSA9IGNoZWNrSWZWYXJpYW50Tm9kZShwcm9wcyk7XG4gICAgdmFyIGVsZW1lbnQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7XG4gICAgICB0cmVlVHlwZSxcbiAgICAgIGN1cnJlbnQ6IG51bGwsXG4gICAgICBkZXB0aDogcGFyZW50ID8gcGFyZW50LmRlcHRoICsgMSA6IDAsXG4gICAgICBwYXJlbnQsXG4gICAgICBjaGlsZHJlbjogbmV3IFNldCgpLFxuICAgICAgcGF0aDogcGFyZW50ID8gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQocGFyZW50LnBhdGgpKSwgW3BhcmVudF0pIDogW10sXG4gICAgICBsYXlvdXRUcmVlOiBwYXJlbnQgPyBwYXJlbnQubGF5b3V0VHJlZSA6IG5ldyBGbGF0VHJlZSgpLFxuICAgICAgcHJlc2VuY2VJZDogcHJlc2VuY2VJZDIsXG4gICAgICBwcm9qZWN0aW9uLFxuICAgICAgdmFyaWFudENoaWxkcmVuOiBpc1ZhcmlhbnROb2RlID8gbmV3IFNldCgpIDogdm9pZCAwLFxuICAgICAgaXNWaXNpYmxlOiB2b2lkIDAsXG4gICAgICBtYW51YWxseUFuaW1hdGVPbk1vdW50OiBCb29sZWFuKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5pc01vdW50ZWQoKSksXG4gICAgICBibG9ja0luaXRpYWxBbmltYXRpb24sXG4gICAgICBpc0hvdmVyRXZlbnRzRW5hYmxlZDogdHJ1ZSxcbiAgICAgIGlzTW91bnRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKGluc3RhbmNlKTtcbiAgICAgIH0sXG4gICAgICBtb3VudDogZnVuY3Rpb24obmV3SW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UgPSBlbGVtZW50LmN1cnJlbnQgPSBuZXdJbnN0YW5jZTtcbiAgICAgICAgZWxlbWVudC5wb2ludFRvKGVsZW1lbnQpO1xuICAgICAgICBpZiAoaXNWYXJpYW50Tm9kZSAmJiBwYXJlbnQgJiYgIWlzQ29udHJvbGxpbmdWYXJpYW50cykge1xuICAgICAgICAgIHJlbW92ZUZyb21WYXJpYW50VHJlZSA9IHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5hZGRWYXJpYW50Q2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmNoaWxkcmVuLmFkZChlbGVtZW50KTtcbiAgICAgIH0sXG4gICAgICB1bm1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FuY2VsU3luYy51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgY2FuY2VsU3luYy5yZW5kZXIocmVuZGVyKTtcbiAgICAgICAgY2FuY2VsU3luYy5wcmVSZW5kZXIoZWxlbWVudC51cGRhdGVMYXlvdXRQcm9qZWN0aW9uKTtcbiAgICAgICAgdmFsdWVTdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24ocmVtb3ZlMikge1xuICAgICAgICAgIHJldHVybiByZW1vdmUyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LnN0b3BMYXlvdXRBbmltYXRpb24oKTtcbiAgICAgICAgZWxlbWVudC5sYXlvdXRUcmVlLnJlbW92ZShlbGVtZW50KTtcbiAgICAgICAgcmVtb3ZlRnJvbVZhcmlhbnRUcmVlID09PSBudWxsIHx8IHJlbW92ZUZyb21WYXJpYW50VHJlZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVtb3ZlRnJvbVZhcmlhbnRUcmVlKCk7XG4gICAgICAgIHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5jaGlsZHJlbi5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIHVuc3Vic2NyaWJlRnJvbUxlYWRWaXN1YWxFbGVtZW50ID09PSBudWxsIHx8IHVuc3Vic2NyaWJlRnJvbUxlYWRWaXN1YWxFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1bnN1YnNjcmliZUZyb21MZWFkVmlzdWFsRWxlbWVudCgpO1xuICAgICAgICBsaWZlY3ljbGVzLmNsZWFyQWxsTGlzdGVuZXJzKCk7XG4gICAgICB9LFxuICAgICAgYWRkVmFyaWFudENoaWxkOiBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICB2YXIgX2EzO1xuICAgICAgICB2YXIgY2xvc2VzdFZhcmlhbnROb2RlID0gZWxlbWVudC5nZXRDbG9zZXN0VmFyaWFudE5vZGUoKTtcbiAgICAgICAgaWYgKGNsb3Nlc3RWYXJpYW50Tm9kZSkge1xuICAgICAgICAgIChfYTMgPSBjbG9zZXN0VmFyaWFudE5vZGUudmFyaWFudENoaWxkcmVuKSA9PT0gbnVsbCB8fCBfYTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hMy5hZGQoY2hpbGQpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9zZXN0VmFyaWFudE5vZGUudmFyaWFudENoaWxkcmVuLmRlbGV0ZShjaGlsZCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNvcnROb2RlUG9zaXRpb246IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICAgIGlmICghc29ydE5vZGVQb3NpdGlvbiB8fCB0cmVlVHlwZSAhPT0gb3RoZXIudHJlZVR5cGUpXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiBzb3J0Tm9kZVBvc2l0aW9uKGVsZW1lbnQuZ2V0SW5zdGFuY2UoKSwgb3RoZXIuZ2V0SW5zdGFuY2UoKSk7XG4gICAgICB9LFxuICAgICAgZ2V0Q2xvc2VzdFZhcmlhbnROb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzVmFyaWFudE5vZGUgPyBlbGVtZW50IDogcGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmdldENsb3Nlc3RWYXJpYW50Tm9kZSgpO1xuICAgICAgfSxcbiAgICAgIHNjaGVkdWxlVXBkYXRlTGF5b3V0UHJvamVjdGlvbjogcGFyZW50ID8gcGFyZW50LnNjaGVkdWxlVXBkYXRlTGF5b3V0UHJvamVjdGlvbiA6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZXNfZGVmYXVsdC5wcmVSZW5kZXIoZWxlbWVudC51cGRhdGVUcmVlTGF5b3V0UHJvamVjdGlvbiwgZmFsc2UsIHRydWUpO1xuICAgICAgfSxcbiAgICAgIGdldExheW91dElkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHByb3BzLmxheW91dElkO1xuICAgICAgfSxcbiAgICAgIGdldEluc3RhbmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgfSxcbiAgICAgIGdldFN0YXRpY1ZhbHVlOiBmdW5jdGlvbihrZXk3KSB7XG4gICAgICAgIHJldHVybiBsYXRlc3RWYWx1ZXNba2V5N107XG4gICAgICB9LFxuICAgICAgc2V0U3RhdGljVmFsdWU6IGZ1bmN0aW9uKGtleTcsIHZhbHVlMikge1xuICAgICAgICByZXR1cm4gbGF0ZXN0VmFsdWVzW2tleTddID0gdmFsdWUyO1xuICAgICAgfSxcbiAgICAgIGdldExhdGVzdFZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBsYXRlc3RWYWx1ZXM7XG4gICAgICB9LFxuICAgICAgc2V0VmlzaWJpbGl0eTogZnVuY3Rpb24odmlzaWJpbGl0eSkge1xuICAgICAgICBpZiAoZWxlbWVudC5pc1Zpc2libGUgPT09IHZpc2liaWxpdHkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlbGVtZW50LmlzVmlzaWJsZSA9IHZpc2liaWxpdHk7XG4gICAgICAgIGVsZW1lbnQuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgIH0sXG4gICAgICBtYWtlVGFyZ2V0QW5pbWF0YWJsZTogZnVuY3Rpb24odGFyZ2V0LCBjYW5NdXRhdGUpIHtcbiAgICAgICAgaWYgKGNhbk11dGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY2FuTXV0YXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZVRhcmdldEFuaW1hdGFibGUoZWxlbWVudCwgdGFyZ2V0LCBwcm9wcywgY2FuTXV0YXRlKTtcbiAgICAgIH0sXG4gICAgICBzdXNwZW5kSG92ZXJFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBlbGVtZW50LmlzSG92ZXJFdmVudHNFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIGVzX2RlZmF1bHQucG9zdFJlbmRlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmlzSG92ZXJFdmVudHNFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICB9LCAxMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGFkZFZhbHVlOiBmdW5jdGlvbihrZXk3LCB2YWx1ZTIpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuaGFzVmFsdWUoa2V5NykpXG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVWYWx1ZShrZXk3KTtcbiAgICAgICAgdmFsdWVzLnNldChrZXk3LCB2YWx1ZTIpO1xuICAgICAgICBsYXRlc3RWYWx1ZXNba2V5N10gPSB2YWx1ZTIuZ2V0KCk7XG4gICAgICAgIGJpbmRUb01vdGlvblZhbHVlKGtleTcsIHZhbHVlMik7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlVmFsdWU6IGZ1bmN0aW9uKGtleTcpIHtcbiAgICAgICAgdmFyIF9hMztcbiAgICAgICAgdmFsdWVzLmRlbGV0ZShrZXk3KTtcbiAgICAgICAgKF9hMyA9IHZhbHVlU3Vic2NyaXB0aW9ucy5nZXQoa2V5NykpID09PSBudWxsIHx8IF9hMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EzKCk7XG4gICAgICAgIHZhbHVlU3Vic2NyaXB0aW9ucy5kZWxldGUoa2V5Nyk7XG4gICAgICAgIGRlbGV0ZSBsYXRlc3RWYWx1ZXNba2V5N107XG4gICAgICAgIHJlbW92ZVZhbHVlRnJvbVJlbmRlclN0YXRlKGtleTcsIHJlbmRlclN0YXRlKTtcbiAgICAgIH0sXG4gICAgICBoYXNWYWx1ZTogZnVuY3Rpb24oa2V5Nykge1xuICAgICAgICByZXR1cm4gdmFsdWVzLmhhcyhrZXk3KTtcbiAgICAgIH0sXG4gICAgICBnZXRWYWx1ZTogZnVuY3Rpb24oa2V5NywgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHZhciB2YWx1ZTIgPSB2YWx1ZXMuZ2V0KGtleTcpO1xuICAgICAgICBpZiAodmFsdWUyID09PSB2b2lkIDAgJiYgZGVmYXVsdFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB2YWx1ZTIgPSBtb3Rpb25WYWx1ZShkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgIGVsZW1lbnQuYWRkVmFsdWUoa2V5NywgdmFsdWUyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUyO1xuICAgICAgfSxcbiAgICAgIGZvckVhY2hWYWx1ZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICAgIH0sXG4gICAgICByZWFkVmFsdWU6IGZ1bmN0aW9uKGtleTcpIHtcbiAgICAgICAgdmFyIF9hMztcbiAgICAgICAgcmV0dXJuIChfYTMgPSBsYXRlc3RWYWx1ZXNba2V5N10pICE9PSBudWxsICYmIF9hMyAhPT0gdm9pZCAwID8gX2EzIDogcmVhZFZhbHVlRnJvbUluc3RhbmNlKGluc3RhbmNlLCBrZXk3LCBvcHRpb25zKTtcbiAgICAgIH0sXG4gICAgICBzZXRCYXNlVGFyZ2V0OiBmdW5jdGlvbihrZXk3LCB2YWx1ZTIpIHtcbiAgICAgICAgYmFzZVRhcmdldFtrZXk3XSA9IHZhbHVlMjtcbiAgICAgIH0sXG4gICAgICBnZXRCYXNlVGFyZ2V0OiBmdW5jdGlvbihrZXk3KSB7XG4gICAgICAgIGlmIChnZXRCYXNlVGFyZ2V0KSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IGdldEJhc2VUYXJnZXQocHJvcHMsIGtleTcpO1xuICAgICAgICAgIGlmICh0YXJnZXQgIT09IHZvaWQgMCAmJiAhaXNNb3Rpb25WYWx1ZSh0YXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZVRhcmdldFtrZXk3XTtcbiAgICAgIH1cbiAgICB9LCBsaWZlY3ljbGVzKSwge1xuICAgICAgYnVpbGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0cmlnZ2VyQnVpbGQoKTtcbiAgICAgICAgcmV0dXJuIHJlbmRlclN0YXRlO1xuICAgICAgfSxcbiAgICAgIHNjaGVkdWxlUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZXNfZGVmYXVsdC5yZW5kZXIocmVuZGVyLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgc3luY1JlbmRlcjogcmVuZGVyLFxuICAgICAgc2V0UHJvcHM6IGZ1bmN0aW9uKG5ld1Byb3BzKSB7XG4gICAgICAgIHByb3BzID0gbmV3UHJvcHM7XG4gICAgICAgIGxpZmVjeWNsZXMudXBkYXRlUHJvcExpc3RlbmVycyhuZXdQcm9wcyk7XG4gICAgICAgIHByZXZNb3Rpb25WYWx1ZXMgPSB1cGRhdGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMoZWxlbWVudCwgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzMyhwcm9wcyksIHByZXZNb3Rpb25WYWx1ZXMpO1xuICAgICAgfSxcbiAgICAgIGdldFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgICAgfSxcbiAgICAgIGdldFZhcmlhbnQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIF9hMztcbiAgICAgICAgcmV0dXJuIChfYTMgPSBwcm9wcy52YXJpYW50cykgPT09IG51bGwgfHwgX2EzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTNbbmFtZV07XG4gICAgICB9LFxuICAgICAgZ2V0RGVmYXVsdFRyYW5zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcHJvcHMudHJhbnNpdGlvbjtcbiAgICAgIH0sXG4gICAgICBnZXRWYXJpYW50Q29udGV4dDogZnVuY3Rpb24oc3RhcnRBdFBhcmVudCkge1xuICAgICAgICBpZiAoc3RhcnRBdFBhcmVudCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgc3RhcnRBdFBhcmVudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydEF0UGFyZW50KVxuICAgICAgICAgIHJldHVybiBwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuZ2V0VmFyaWFudENvbnRleHQoKTtcbiAgICAgICAgaWYgKCFpc0NvbnRyb2xsaW5nVmFyaWFudHMpIHtcbiAgICAgICAgICB2YXIgY29udGV4dF8xID0gKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5nZXRWYXJpYW50Q29udGV4dCgpKSB8fCB7fTtcbiAgICAgICAgICBpZiAocHJvcHMuaW5pdGlhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjb250ZXh0XzEuaW5pdGlhbCA9IHByb3BzLmluaXRpYWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb250ZXh0XzE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRleHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1WYXJpYW50UHJvcHM7IGkrKykge1xuICAgICAgICAgIHZhciBuYW1lXzEgPSB2YXJpYW50UHJvcHNbaV07XG4gICAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tuYW1lXzFdO1xuICAgICAgICAgIGlmIChpc1ZhcmlhbnRMYWJlbChwcm9wKSB8fCBwcm9wID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGV4dFtuYW1lXzFdID0gcHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICB9LFxuICAgICAgZW5hYmxlTGF5b3V0UHJvamVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHByb2plY3Rpb24uaXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgZWxlbWVudC5sYXlvdXRUcmVlLmFkZChlbGVtZW50KTtcbiAgICAgIH0sXG4gICAgICBsb2NrUHJvamVjdGlvblRhcmdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHByb2plY3Rpb24uaXNUYXJnZXRMb2NrZWQgPSB0cnVlO1xuICAgICAgfSxcbiAgICAgIHVubG9ja1Byb2plY3Rpb25UYXJnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBlbGVtZW50LnN0b3BMYXlvdXRBbmltYXRpb24oKTtcbiAgICAgICAgcHJvamVjdGlvbi5pc1RhcmdldExvY2tlZCA9IGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGdldExheW91dFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGxheW91dFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHNldENyb3NzZmFkZXI6IGZ1bmN0aW9uKG5ld0Nyb3NzZmFkZXIpIHtcbiAgICAgICAgY3Jvc3NmYWRlciA9IG5ld0Nyb3NzZmFkZXI7XG4gICAgICB9LFxuICAgICAgaXNQcm9qZWN0aW9uUmVhZHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcHJvamVjdGlvbi5pc0VuYWJsZWQgJiYgbGF5b3V0U3RhdGUuaXNIeWRyYXRlZDtcbiAgICAgIH0sXG4gICAgICBzdGFydExheW91dEFuaW1hdGlvbjogZnVuY3Rpb24oYXhpcywgdHJhbnNpdGlvbiwgaXNSZWxhdGl2ZSkge1xuICAgICAgICBpZiAoaXNSZWxhdGl2ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgaXNSZWxhdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9ncmVzczIgPSBlbGVtZW50LmdldFByb2plY3Rpb25BbmltYXRpb25Qcm9ncmVzcygpW2F4aXNdO1xuICAgICAgICB2YXIgX2EzID0gaXNSZWxhdGl2ZSA/IHByb2plY3Rpb24ucmVsYXRpdmVUYXJnZXRbYXhpc10gOiBwcm9qZWN0aW9uLnRhcmdldFtheGlzXSwgbWluID0gX2EzLm1pbiwgbWF4ID0gX2EzLm1heDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IG1heCAtIG1pbjtcbiAgICAgICAgcHJvZ3Jlc3MyLmNsZWFyTGlzdGVuZXJzKCk7XG4gICAgICAgIHByb2dyZXNzMi5zZXQobWluKTtcbiAgICAgICAgcHJvZ3Jlc3MyLnNldChtaW4pO1xuICAgICAgICBwcm9ncmVzczIub25DaGFuZ2UoZnVuY3Rpb24odikge1xuICAgICAgICAgIGVsZW1lbnQuc2V0UHJvamVjdGlvblRhcmdldEF4aXMoYXhpcywgdiwgdiArIGxlbmd0aCwgaXNSZWxhdGl2ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZWxlbWVudC5hbmltYXRlTW90aW9uVmFsdWUoYXhpcywgcHJvZ3Jlc3MyLCAwLCB0cmFuc2l0aW9uKTtcbiAgICAgIH0sXG4gICAgICBzdG9wTGF5b3V0QW5pbWF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZWFjaEF4aXMoZnVuY3Rpb24oYXhpcykge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldFByb2plY3Rpb25BbmltYXRpb25Qcm9ncmVzcygpW2F4aXNdLnN0b3AoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgbWVhc3VyZVZpZXdwb3J0Qm94OiBmdW5jdGlvbih3aXRoVHJhbnNmb3JtKSB7XG4gICAgICAgIGlmICh3aXRoVHJhbnNmb3JtID09PSB2b2lkIDApIHtcbiAgICAgICAgICB3aXRoVHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmlld3BvcnRCb3ggPSBtZWFzdXJlVmlld3BvcnRCb3goaW5zdGFuY2UsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXdpdGhUcmFuc2Zvcm0pXG4gICAgICAgICAgcmVtb3ZlQm94VHJhbnNmb3Jtcyh2aWV3cG9ydEJveCwgbGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgcmV0dXJuIHZpZXdwb3J0Qm94O1xuICAgICAgfSxcbiAgICAgIGdldFByb2plY3Rpb25BbmltYXRpb25Qcm9ncmVzczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHByb2plY3Rpb25UYXJnZXRQcm9ncmVzcyB8fCAocHJvamVjdGlvblRhcmdldFByb2dyZXNzID0ge1xuICAgICAgICAgIHg6IG1vdGlvblZhbHVlKDApLFxuICAgICAgICAgIHk6IG1vdGlvblZhbHVlKDApXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvamVjdGlvblRhcmdldFByb2dyZXNzO1xuICAgICAgfSxcbiAgICAgIHNldFByb2plY3Rpb25UYXJnZXRBeGlzOiBmdW5jdGlvbihheGlzLCBtaW4sIG1heCwgaXNSZWxhdGl2ZSkge1xuICAgICAgICBpZiAoaXNSZWxhdGl2ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgaXNSZWxhdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YXJnZXQ7XG4gICAgICAgIGlmIChpc1JlbGF0aXZlKSB7XG4gICAgICAgICAgaWYgKCFwcm9qZWN0aW9uLnJlbGF0aXZlVGFyZ2V0KSB7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLnJlbGF0aXZlVGFyZ2V0ID0gYXhpc0JveCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQgPSBwcm9qZWN0aW9uLnJlbGF0aXZlVGFyZ2V0W2F4aXNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2plY3Rpb24ucmVsYXRpdmVUYXJnZXQgPSB2b2lkIDA7XG4gICAgICAgICAgdGFyZ2V0ID0gcHJvamVjdGlvbi50YXJnZXRbYXhpc107XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0Lm1pbiA9IG1pbjtcbiAgICAgICAgdGFyZ2V0Lm1heCA9IG1heDtcbiAgICAgICAgaGFzVmlld3BvcnRCb3hVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgbGlmZWN5Y2xlcy5ub3RpZnlTZXRBeGlzVGFyZ2V0KCk7XG4gICAgICB9LFxuICAgICAgcmViYXNlUHJvamVjdGlvblRhcmdldDogZnVuY3Rpb24oZm9yY2UsIGJveCkge1xuICAgICAgICBpZiAoYm94ID09PSB2b2lkIDApIHtcbiAgICAgICAgICBib3ggPSBsYXlvdXRTdGF0ZS5sYXlvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hMyA9IGVsZW1lbnQuZ2V0UHJvamVjdGlvbkFuaW1hdGlvblByb2dyZXNzKCksIHggPSBfYTMueCwgeSA9IF9hMy55O1xuICAgICAgICB2YXIgc2hvdWxkUmViYXNlID0gIXByb2plY3Rpb24ucmVsYXRpdmVUYXJnZXQgJiYgIXByb2plY3Rpb24uaXNUYXJnZXRMb2NrZWQgJiYgIXguaXNBbmltYXRpbmcoKSAmJiAheS5pc0FuaW1hdGluZygpO1xuICAgICAgICBpZiAoZm9yY2UgfHwgc2hvdWxkUmViYXNlKSB7XG4gICAgICAgICAgZWFjaEF4aXMoZnVuY3Rpb24oYXhpcykge1xuICAgICAgICAgICAgdmFyIF9hNCA9IGJveFtheGlzXSwgbWluID0gX2E0Lm1pbiwgbWF4ID0gX2E0Lm1heDtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0UHJvamVjdGlvblRhcmdldEF4aXMoYXhpcywgbWluLCBtYXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbm90aWZ5TGF5b3V0UmVhZHk6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICBzZXRDdXJyZW50Vmlld3BvcnRCb3goZWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnQubm90aWZ5TGF5b3V0VXBkYXRlKGxheW91dFN0YXRlLmxheW91dCwgZWxlbWVudC5wcmV2Vmlld3BvcnRCb3ggfHwgbGF5b3V0U3RhdGUubGF5b3V0LCBjb25maWcpO1xuICAgICAgfSxcbiAgICAgIHJlc2V0VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJlc2V0VHJhbnNmb3JtKGVsZW1lbnQsIGluc3RhbmNlLCBwcm9wcyk7XG4gICAgICB9LFxuICAgICAgcmVzdG9yZVRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZXN0b3JlVHJhbnNmb3JtKGluc3RhbmNlLCByZW5kZXJTdGF0ZSk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlTGF5b3V0UHJvamVjdGlvbixcbiAgICAgIHVwZGF0ZVRyZWVMYXlvdXRQcm9qZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZWxlbWVudC5sYXlvdXRUcmVlLmZvckVhY2goZmlyZVJlc29sdmVSZWxhdGl2ZVRhcmdldEJveCk7XG4gICAgICAgIGVzX2RlZmF1bHQucHJlUmVuZGVyKHVwZGF0ZVRyZWVMYXlvdXRQcm9qZWN0aW9uLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgZ2V0UHJvamVjdGlvblBhcmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChwcm9qZWN0aW9uUGFyZW50ID09PSB2b2lkIDApIHtcbiAgICAgICAgICB2YXIgZm91bmRQYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gZWxlbWVudC5wYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgYW5jZXN0b3IgPSBlbGVtZW50LnBhdGhbaV07XG4gICAgICAgICAgICBpZiAoYW5jZXN0b3IucHJvamVjdGlvbi5pc0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgZm91bmRQYXJlbnQgPSBhbmNlc3RvcjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2plY3Rpb25QYXJlbnQgPSBmb3VuZFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvamVjdGlvblBhcmVudDtcbiAgICAgIH0sXG4gICAgICByZXNvbHZlUmVsYXRpdmVUYXJnZXRCb3g6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVsYXRpdmVQYXJlbnQgPSBlbGVtZW50LmdldFByb2plY3Rpb25QYXJlbnQoKTtcbiAgICAgICAgaWYgKCFwcm9qZWN0aW9uLnJlbGF0aXZlVGFyZ2V0IHx8ICFyZWxhdGl2ZVBhcmVudClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhbGNSZWxhdGl2ZUJveChwcm9qZWN0aW9uLCByZWxhdGl2ZVBhcmVudC5wcm9qZWN0aW9uKTtcbiAgICAgICAgaWYgKGlzRHJhZ2dhYmxlKHJlbGF0aXZlUGFyZW50KSkge1xuICAgICAgICAgIHZhciB0YXJnZXQgPSBwcm9qZWN0aW9uLnRhcmdldDtcbiAgICAgICAgICBhcHBseUJveFRyYW5zZm9ybXModGFyZ2V0LCB0YXJnZXQsIHJlbGF0aXZlUGFyZW50LmdldExhdGVzdFZhbHVlcygpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNob3VsZFJlc2V0VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocHJvcHMuX2xheW91dFJlc2V0VHJhbnNmb3JtKTtcbiAgICAgIH0sXG4gICAgICBwb2ludFRvOiBmdW5jdGlvbihuZXdMZWFkKSB7XG4gICAgICAgIGxlYWRQcm9qZWN0aW9uID0gbmV3TGVhZC5wcm9qZWN0aW9uO1xuICAgICAgICBsZWFkTGF0ZXN0VmFsdWVzID0gbmV3TGVhZC5nZXRMYXRlc3RWYWx1ZXMoKTtcbiAgICAgICAgdW5zdWJzY3JpYmVGcm9tTGVhZFZpc3VhbEVsZW1lbnQgPT09IG51bGwgfHwgdW5zdWJzY3JpYmVGcm9tTGVhZFZpc3VhbEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVuc3Vic2NyaWJlRnJvbUxlYWRWaXN1YWxFbGVtZW50KCk7XG4gICAgICAgIHVuc3Vic2NyaWJlRnJvbUxlYWRWaXN1YWxFbGVtZW50ID0gcGlwZShuZXdMZWFkLm9uU2V0QXhpc1RhcmdldChlbGVtZW50LnNjaGVkdWxlVXBkYXRlTGF5b3V0UHJvamVjdGlvbiksIG5ld0xlYWQub25MYXlvdXRBbmltYXRpb25Db21wbGV0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgX2EzO1xuICAgICAgICAgIGlmIChlbGVtZW50LmlzUHJlc2VudCkge1xuICAgICAgICAgICAgZWxlbWVudC5wcmVzZW5jZSA9IFByZXNlbmNlLlByZXNlbnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIChfYTMgPSBlbGVtZW50LmxheW91dFNhZmVUb1JlbW92ZSkgPT09IG51bGwgfHwgX2EzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYTMuY2FsbChlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICBpc1ByZXNlbnQ6IHRydWUsXG4gICAgICBwcmVzZW5jZTogUHJlc2VuY2UuRW50ZXJpbmdcbiAgICB9KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTtcbn07XG5mdW5jdGlvbiBmaXJlUmVzb2x2ZVJlbGF0aXZlVGFyZ2V0Qm94KGNoaWxkKSB7XG4gIGNoaWxkLnJlc29sdmVSZWxhdGl2ZVRhcmdldEJveCgpO1xufVxuZnVuY3Rpb24gZmlyZVVwZGF0ZUxheW91dFByb2plY3Rpb24oY2hpbGQpIHtcbiAgY2hpbGQudXBkYXRlTGF5b3V0UHJvamVjdGlvbigpO1xufVxudmFyIHZhcmlhbnRQcm9wcyA9IF9fc3ByZWFkQXJyYXkoW1wiaW5pdGlhbFwiXSwgX19yZWFkKHZhcmlhbnRQcmlvcml0eU9yZGVyKSk7XG52YXIgbnVtVmFyaWFudFByb3BzID0gdmFyaWFudFByb3BzLmxlbmd0aDtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL3VuaXQtY29udmVyc2lvbi5qc1xudmFyIHBvc2l0aW9uYWxLZXlzID0gbmV3IFNldChbXG4gIFwid2lkdGhcIixcbiAgXCJoZWlnaHRcIixcbiAgXCJ0b3BcIixcbiAgXCJsZWZ0XCIsXG4gIFwicmlnaHRcIixcbiAgXCJib3R0b21cIixcbiAgXCJ4XCIsXG4gIFwieVwiXG5dKTtcbnZhciBpc1Bvc2l0aW9uYWxLZXkgPSBmdW5jdGlvbihrZXk2KSB7XG4gIHJldHVybiBwb3NpdGlvbmFsS2V5cy5oYXMoa2V5Nik7XG59O1xudmFyIGhhc1Bvc2l0aW9uYWxLZXkgPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCkuc29tZShpc1Bvc2l0aW9uYWxLZXkpO1xufTtcbnZhciBzZXRBbmRSZXNldFZlbG9jaXR5ID0gZnVuY3Rpb24odmFsdWUsIHRvKSB7XG4gIHZhbHVlLnNldCh0bywgZmFsc2UpO1xuICB2YWx1ZS5zZXQodG8pO1xufTtcbnZhciBpc051bU9yUHhUeXBlID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gdiA9PT0gbnVtYmVyIHx8IHYgPT09IHB4O1xufTtcbnZhciBCb3VuZGluZ0JveERpbWVuc2lvbjtcbihmdW5jdGlvbihCb3VuZGluZ0JveERpbWVuc2lvbjIpIHtcbiAgQm91bmRpbmdCb3hEaW1lbnNpb24yW1wid2lkdGhcIl0gPSBcIndpZHRoXCI7XG4gIEJvdW5kaW5nQm94RGltZW5zaW9uMltcImhlaWdodFwiXSA9IFwiaGVpZ2h0XCI7XG4gIEJvdW5kaW5nQm94RGltZW5zaW9uMltcImxlZnRcIl0gPSBcImxlZnRcIjtcbiAgQm91bmRpbmdCb3hEaW1lbnNpb24yW1wicmlnaHRcIl0gPSBcInJpZ2h0XCI7XG4gIEJvdW5kaW5nQm94RGltZW5zaW9uMltcInRvcFwiXSA9IFwidG9wXCI7XG4gIEJvdW5kaW5nQm94RGltZW5zaW9uMltcImJvdHRvbVwiXSA9IFwiYm90dG9tXCI7XG59KShCb3VuZGluZ0JveERpbWVuc2lvbiB8fCAoQm91bmRpbmdCb3hEaW1lbnNpb24gPSB7fSkpO1xudmFyIGdldFBvc0Zyb21NYXRyaXggPSBmdW5jdGlvbihtYXRyaXgsIHBvcykge1xuICByZXR1cm4gcGFyc2VGbG9hdChtYXRyaXguc3BsaXQoXCIsIFwiKVtwb3NdKTtcbn07XG52YXIgZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCA9IGZ1bmN0aW9uKHBvczIsIHBvczMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKF9iYm94LCBfYSkge1xuICAgIHZhciB0cmFuc2Zvcm0yID0gX2EudHJhbnNmb3JtO1xuICAgIGlmICh0cmFuc2Zvcm0yID09PSBcIm5vbmVcIiB8fCAhdHJhbnNmb3JtMilcbiAgICAgIHJldHVybiAwO1xuICAgIHZhciBtYXRyaXgzZCA9IHRyYW5zZm9ybTIubWF0Y2goL15tYXRyaXgzZFxcKCguKylcXCkkLyk7XG4gICAgaWYgKG1hdHJpeDNkKSB7XG4gICAgICByZXR1cm4gZ2V0UG9zRnJvbU1hdHJpeChtYXRyaXgzZFsxXSwgcG9zMyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXRyaXggPSB0cmFuc2Zvcm0yLm1hdGNoKC9ebWF0cml4XFwoKC4rKVxcKSQvKTtcbiAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgcmV0dXJuIGdldFBvc0Zyb21NYXRyaXgobWF0cml4WzFdLCBwb3MyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG52YXIgdHJhbnNmb3JtS2V5cyA9IG5ldyBTZXQoW1wieFwiLCBcInlcIiwgXCJ6XCJdKTtcbnZhciBub25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtS2V5cyA9IHRyYW5zZm9ybVByb3BzLmZpbHRlcihmdW5jdGlvbihrZXk2KSB7XG4gIHJldHVybiAhdHJhbnNmb3JtS2V5cy5oYXMoa2V5Nik7XG59KTtcbmZ1bmN0aW9uIHJlbW92ZU5vblRyYW5zbGF0aW9uYWxUcmFuc2Zvcm0odmlzdWFsRWxlbWVudDIpIHtcbiAgdmFyIHJlbW92ZWRUcmFuc2Zvcm1zID0gW107XG4gIG5vblRyYW5zbGF0aW9uYWxUcmFuc2Zvcm1LZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5Nikge1xuICAgIHZhciB2YWx1ZSA9IHZpc3VhbEVsZW1lbnQyLmdldFZhbHVlKGtleTYpO1xuICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICByZW1vdmVkVHJhbnNmb3Jtcy5wdXNoKFtrZXk2LCB2YWx1ZS5nZXQoKV0pO1xuICAgICAgdmFsdWUuc2V0KGtleTYuc3RhcnRzV2l0aChcInNjYWxlXCIpID8gMSA6IDApO1xuICAgIH1cbiAgfSk7XG4gIGlmIChyZW1vdmVkVHJhbnNmb3Jtcy5sZW5ndGgpXG4gICAgdmlzdWFsRWxlbWVudDIuc3luY1JlbmRlcigpO1xuICByZXR1cm4gcmVtb3ZlZFRyYW5zZm9ybXM7XG59XG52YXIgcG9zaXRpb25hbFZhbHVlcyA9IHtcbiAgd2lkdGg6IGZ1bmN0aW9uKF9hKSB7XG4gICAgdmFyIHggPSBfYS54O1xuICAgIHJldHVybiB4Lm1heCAtIHgubWluO1xuICB9LFxuICBoZWlnaHQ6IGZ1bmN0aW9uKF9hKSB7XG4gICAgdmFyIHkgPSBfYS55O1xuICAgIHJldHVybiB5Lm1heCAtIHkubWluO1xuICB9LFxuICB0b3A6IGZ1bmN0aW9uKF9iYm94LCBfYSkge1xuICAgIHZhciB0b3AgPSBfYS50b3A7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodG9wKTtcbiAgfSxcbiAgbGVmdDogZnVuY3Rpb24oX2Jib3gsIF9hKSB7XG4gICAgdmFyIGxlZnQgPSBfYS5sZWZ0O1xuICAgIHJldHVybiBwYXJzZUZsb2F0KGxlZnQpO1xuICB9LFxuICBib3R0b206IGZ1bmN0aW9uKF9hLCBfYikge1xuICAgIHZhciB5ID0gX2EueTtcbiAgICB2YXIgdG9wID0gX2IudG9wO1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHRvcCkgKyAoeS5tYXggLSB5Lm1pbik7XG4gIH0sXG4gIHJpZ2h0OiBmdW5jdGlvbihfYSwgX2IpIHtcbiAgICB2YXIgeCA9IF9hLng7XG4gICAgdmFyIGxlZnQgPSBfYi5sZWZ0O1xuICAgIHJldHVybiBwYXJzZUZsb2F0KGxlZnQpICsgKHgubWF4IC0geC5taW4pO1xuICB9LFxuICB4OiBnZXRUcmFuc2xhdGVGcm9tTWF0cml4KDQsIDEzKSxcbiAgeTogZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCg1LCAxNClcbn07XG52YXIgY29udmVydENoYW5nZWRWYWx1ZVR5cGVzID0gZnVuY3Rpb24odGFyZ2V0LCB2aXN1YWxFbGVtZW50MiwgY2hhbmdlZEtleXMpIHtcbiAgdmFyIG9yaWdpbkJib3ggPSB2aXN1YWxFbGVtZW50Mi5tZWFzdXJlVmlld3BvcnRCb3goKTtcbiAgdmFyIGVsZW1lbnQgPSB2aXN1YWxFbGVtZW50Mi5nZXRJbnN0YW5jZSgpO1xuICB2YXIgZWxlbWVudENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICB2YXIgZGlzcGxheSA9IGVsZW1lbnRDb21wdXRlZFN0eWxlLmRpc3BsYXksIHRvcCA9IGVsZW1lbnRDb21wdXRlZFN0eWxlLnRvcCwgbGVmdCA9IGVsZW1lbnRDb21wdXRlZFN0eWxlLmxlZnQsIGJvdHRvbSA9IGVsZW1lbnRDb21wdXRlZFN0eWxlLmJvdHRvbSwgcmlnaHQgPSBlbGVtZW50Q29tcHV0ZWRTdHlsZS5yaWdodCwgdHJhbnNmb3JtMiA9IGVsZW1lbnRDb21wdXRlZFN0eWxlLnRyYW5zZm9ybTtcbiAgdmFyIG9yaWdpbkNvbXB1dGVkU3R5bGUgPSB7IHRvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgdHJhbnNmb3JtOiB0cmFuc2Zvcm0yIH07XG4gIGlmIChkaXNwbGF5ID09PSBcIm5vbmVcIikge1xuICAgIHZpc3VhbEVsZW1lbnQyLnNldFN0YXRpY1ZhbHVlKFwiZGlzcGxheVwiLCB0YXJnZXQuZGlzcGxheSB8fCBcImJsb2NrXCIpO1xuICB9XG4gIHZpc3VhbEVsZW1lbnQyLnN5bmNSZW5kZXIoKTtcbiAgdmFyIHRhcmdldEJib3ggPSB2aXN1YWxFbGVtZW50Mi5tZWFzdXJlVmlld3BvcnRCb3goKTtcbiAgY2hhbmdlZEtleXMuZm9yRWFjaChmdW5jdGlvbihrZXk2KSB7XG4gICAgdmFyIHZhbHVlID0gdmlzdWFsRWxlbWVudDIuZ2V0VmFsdWUoa2V5Nik7XG4gICAgc2V0QW5kUmVzZXRWZWxvY2l0eSh2YWx1ZSwgcG9zaXRpb25hbFZhbHVlc1trZXk2XShvcmlnaW5CYm94LCBvcmlnaW5Db21wdXRlZFN0eWxlKSk7XG4gICAgdGFyZ2V0W2tleTZdID0gcG9zaXRpb25hbFZhbHVlc1trZXk2XSh0YXJnZXRCYm94LCBlbGVtZW50Q29tcHV0ZWRTdHlsZSk7XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBjaGVja0FuZENvbnZlcnRDaGFuZ2VkVmFsdWVUeXBlcyA9IGZ1bmN0aW9uKHZpc3VhbEVsZW1lbnQyLCB0YXJnZXQsIG9yaWdpbiwgdHJhbnNpdGlvbkVuZCkge1xuICBpZiAob3JpZ2luID09PSB2b2lkIDApIHtcbiAgICBvcmlnaW4gPSB7fTtcbiAgfVxuICBpZiAodHJhbnNpdGlvbkVuZCA9PT0gdm9pZCAwKSB7XG4gICAgdHJhbnNpdGlvbkVuZCA9IHt9O1xuICB9XG4gIHRhcmdldCA9IF9fYXNzaWduKHt9LCB0YXJnZXQpO1xuICB0cmFuc2l0aW9uRW5kID0gX19hc3NpZ24oe30sIHRyYW5zaXRpb25FbmQpO1xuICB2YXIgdGFyZ2V0UG9zaXRpb25hbEtleXMgPSBPYmplY3Qua2V5cyh0YXJnZXQpLmZpbHRlcihpc1Bvc2l0aW9uYWxLZXkpO1xuICB2YXIgcmVtb3ZlZFRyYW5zZm9ybVZhbHVlcyA9IFtdO1xuICB2YXIgaGFzQXR0ZW1wdGVkVG9SZW1vdmVUcmFuc2Zvcm1WYWx1ZXMgPSBmYWxzZTtcbiAgdmFyIGNoYW5nZWRWYWx1ZVR5cGVLZXlzID0gW107XG4gIHRhcmdldFBvc2l0aW9uYWxLZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5Nikge1xuICAgIHZhciB2YWx1ZSA9IHZpc3VhbEVsZW1lbnQyLmdldFZhbHVlKGtleTYpO1xuICAgIGlmICghdmlzdWFsRWxlbWVudDIuaGFzVmFsdWUoa2V5NikpXG4gICAgICByZXR1cm47XG4gICAgdmFyIGZyb20gPSBvcmlnaW5ba2V5Nl07XG4gICAgdmFyIHRvID0gdGFyZ2V0W2tleTZdO1xuICAgIHZhciBmcm9tVHlwZSA9IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUoZnJvbSk7XG4gICAgdmFyIHRvVHlwZTtcbiAgICBpZiAoaXNLZXlmcmFtZXNUYXJnZXQodG8pKSB7XG4gICAgICB2YXIgbnVtS2V5ZnJhbWVzID0gdG8ubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IHRvWzBdID09PSBudWxsID8gMSA6IDA7IGkgPCBudW1LZXlmcmFtZXM7IGkrKykge1xuICAgICAgICBpZiAoIXRvVHlwZSkge1xuICAgICAgICAgIHRvVHlwZSA9IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUodG9baV0pO1xuICAgICAgICAgIGludmFyaWFudCh0b1R5cGUgPT09IGZyb21UeXBlIHx8IGlzTnVtT3JQeFR5cGUoZnJvbVR5cGUpICYmIGlzTnVtT3JQeFR5cGUodG9UeXBlKSwgXCJLZXlmcmFtZXMgbXVzdCBiZSBvZiB0aGUgc2FtZSBkaW1lbnNpb24gYXMgdGhlIGN1cnJlbnQgdmFsdWVcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW52YXJpYW50KGZpbmREaW1lbnNpb25WYWx1ZVR5cGUodG9baV0pID09PSB0b1R5cGUsIFwiQWxsIGtleWZyYW1lcyBtdXN0IGJlIG9mIHRoZSBzYW1lIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdG9UeXBlID0gZmluZERpbWVuc2lvblZhbHVlVHlwZSh0byk7XG4gICAgfVxuICAgIGlmIChmcm9tVHlwZSAhPT0gdG9UeXBlKSB7XG4gICAgICBpZiAoaXNOdW1PclB4VHlwZShmcm9tVHlwZSkgJiYgaXNOdW1PclB4VHlwZSh0b1R5cGUpKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdmFsdWUuZ2V0KCk7XG4gICAgICAgIGlmICh0eXBlb2YgY3VycmVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHZhbHVlLnNldChwYXJzZUZsb2F0KGN1cnJlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRvID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleTZdID0gcGFyc2VGbG9hdCh0byk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0bykgJiYgdG9UeXBlID09PSBweCkge1xuICAgICAgICAgIHRhcmdldFtrZXk2XSA9IHRvLm1hcChwYXJzZUZsb2F0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoZnJvbVR5cGUgPT09IG51bGwgfHwgZnJvbVR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZyb21UeXBlLnRyYW5zZm9ybSkgJiYgKHRvVHlwZSA9PT0gbnVsbCB8fCB0b1R5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRvVHlwZS50cmFuc2Zvcm0pICYmIChmcm9tID09PSAwIHx8IHRvID09PSAwKSkge1xuICAgICAgICBpZiAoZnJvbSA9PT0gMCkge1xuICAgICAgICAgIHZhbHVlLnNldCh0b1R5cGUudHJhbnNmb3JtKGZyb20pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5Nl0gPSBmcm9tVHlwZS50cmFuc2Zvcm0odG8pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWhhc0F0dGVtcHRlZFRvUmVtb3ZlVHJhbnNmb3JtVmFsdWVzKSB7XG4gICAgICAgICAgcmVtb3ZlZFRyYW5zZm9ybVZhbHVlcyA9IHJlbW92ZU5vblRyYW5zbGF0aW9uYWxUcmFuc2Zvcm0odmlzdWFsRWxlbWVudDIpO1xuICAgICAgICAgIGhhc0F0dGVtcHRlZFRvUmVtb3ZlVHJhbnNmb3JtVmFsdWVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGFuZ2VkVmFsdWVUeXBlS2V5cy5wdXNoKGtleTYpO1xuICAgICAgICB0cmFuc2l0aW9uRW5kW2tleTZdID0gdHJhbnNpdGlvbkVuZFtrZXk2XSAhPT0gdm9pZCAwID8gdHJhbnNpdGlvbkVuZFtrZXk2XSA6IHRhcmdldFtrZXk2XTtcbiAgICAgICAgc2V0QW5kUmVzZXRWZWxvY2l0eSh2YWx1ZSwgdG8pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmIChjaGFuZ2VkVmFsdWVUeXBlS2V5cy5sZW5ndGgpIHtcbiAgICB2YXIgY29udmVydGVkVGFyZ2V0ID0gY29udmVydENoYW5nZWRWYWx1ZVR5cGVzKHRhcmdldCwgdmlzdWFsRWxlbWVudDIsIGNoYW5nZWRWYWx1ZVR5cGVLZXlzKTtcbiAgICBpZiAocmVtb3ZlZFRyYW5zZm9ybVZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIHJlbW92ZWRUcmFuc2Zvcm1WYWx1ZXMuZm9yRWFjaChmdW5jdGlvbihfYSkge1xuICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBrZXk2ID0gX2JbMF0sIHZhbHVlID0gX2JbMV07XG4gICAgICAgIHZpc3VhbEVsZW1lbnQyLmdldFZhbHVlKGtleTYpLnNldCh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmlzdWFsRWxlbWVudDIuc3luY1JlbmRlcigpO1xuICAgIHJldHVybiB7IHRhcmdldDogY29udmVydGVkVGFyZ2V0LCB0cmFuc2l0aW9uRW5kIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgdGFyZ2V0LCB0cmFuc2l0aW9uRW5kIH07XG4gIH1cbn07XG5mdW5jdGlvbiB1bml0Q29udmVyc2lvbih2aXN1YWxFbGVtZW50MiwgdGFyZ2V0LCBvcmlnaW4sIHRyYW5zaXRpb25FbmQpIHtcbiAgcmV0dXJuIGhhc1Bvc2l0aW9uYWxLZXkodGFyZ2V0KSA/IGNoZWNrQW5kQ29udmVydENoYW5nZWRWYWx1ZVR5cGVzKHZpc3VhbEVsZW1lbnQyLCB0YXJnZXQsIG9yaWdpbiwgdHJhbnNpdGlvbkVuZCkgOiB7IHRhcmdldCwgdHJhbnNpdGlvbkVuZCB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvcGFyc2UtZG9tLXZhcmlhbnQuanNcbnZhciBwYXJzZURvbVZhcmlhbnQgPSBmdW5jdGlvbih2aXN1YWxFbGVtZW50MiwgdGFyZ2V0LCBvcmlnaW4sIHRyYW5zaXRpb25FbmQpIHtcbiAgdmFyIHJlc29sdmVkID0gcmVzb2x2ZUNTU1ZhcmlhYmxlcyh2aXN1YWxFbGVtZW50MiwgdGFyZ2V0LCB0cmFuc2l0aW9uRW5kKTtcbiAgdGFyZ2V0ID0gcmVzb2x2ZWQudGFyZ2V0O1xuICB0cmFuc2l0aW9uRW5kID0gcmVzb2x2ZWQudHJhbnNpdGlvbkVuZDtcbiAgcmV0dXJuIHVuaXRDb252ZXJzaW9uKHZpc3VhbEVsZW1lbnQyLCB0YXJnZXQsIG9yaWdpbiwgdHJhbnNpdGlvbkVuZCk7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3Zpc3VhbC1lbGVtZW50LmpzXG5mdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlMihlbGVtZW50KSB7XG4gIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cbnZhciBodG1sQ29uZmlnID0ge1xuICB0cmVlVHlwZTogXCJkb21cIixcbiAgcmVhZFZhbHVlRnJvbUluc3RhbmNlOiBmdW5jdGlvbihkb21FbGVtZW50LCBrZXk2KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChpc1RyYW5zZm9ybVByb3Aoa2V5NikpIHtcbiAgICAgIHZhciBkZWZhdWx0VHlwZSA9IGdldERlZmF1bHRWYWx1ZVR5cGUoa2V5Nik7XG4gICAgICByZXR1cm4gKF9hID0gZGVmYXVsdFR5cGUgPT09IG51bGwgfHwgZGVmYXVsdFR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlZmF1bHRUeXBlLmRlZmF1bHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZTIoZG9tRWxlbWVudCk7XG4gICAgICByZXR1cm4gKGlzQ1NTVmFyaWFibGUoa2V5NikgPyBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoa2V5NikgOiBjb21wdXRlZFN0eWxlW2tleTZdKSB8fCAwO1xuICAgIH1cbiAgfSxcbiAgc29ydE5vZGVQb3NpdGlvbjogZnVuY3Rpb24oYTIsIGIyKSB7XG4gICAgcmV0dXJuIGEyLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIyKSAmIDIgPyAxIDogLTE7XG4gIH0sXG4gIGdldEJhc2VUYXJnZXQ6IGZ1bmN0aW9uKHByb3BzLCBrZXk2KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgZGVmYXVsdFR5cGUgPSBnZXREZWZhdWx0VmFsdWVUeXBlKGtleTYpO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSBwcm9wcy5zdHlsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2tleTZdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBkZWZhdWx0VHlwZSA9PT0gbnVsbCB8fCBkZWZhdWx0VHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmYXVsdFR5cGUuZGVmYXVsdDtcbiAgfSxcbiAgbWVhc3VyZVZpZXdwb3J0Qm94OiBmdW5jdGlvbihlbGVtZW50LCBfYSkge1xuICAgIHZhciB0cmFuc2Zvcm1QYWdlUG9pbnQgPSBfYS50cmFuc2Zvcm1QYWdlUG9pbnQ7XG4gICAgcmV0dXJuIGdldEJvdW5kaW5nQm94KGVsZW1lbnQsIHRyYW5zZm9ybVBhZ2VQb2ludCk7XG4gIH0sXG4gIHJlc2V0VHJhbnNmb3JtOiBmdW5jdGlvbihlbGVtZW50LCBkb21FbGVtZW50LCBwcm9wcykge1xuICAgIGVsZW1lbnQuc3VzcGVuZEhvdmVyRXZlbnRzKCk7XG4gICAgdmFyIHRyYW5zZm9ybVRlbXBsYXRlMiA9IHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlO1xuICAgIGRvbUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtVGVtcGxhdGUyID8gdHJhbnNmb3JtVGVtcGxhdGUyKHt9LCBcIlwiKSA6IFwibm9uZVwiO1xuICAgIGVsZW1lbnQuc2NoZWR1bGVSZW5kZXIoKTtcbiAgfSxcbiAgcmVzdG9yZVRyYW5zZm9ybTogZnVuY3Rpb24oaW5zdGFuY2UsIG11dGFibGVTdGF0ZSkge1xuICAgIGluc3RhbmNlLnN0eWxlLnRyYW5zZm9ybSA9IG11dGFibGVTdGF0ZS5zdHlsZS50cmFuc2Zvcm07XG4gIH0sXG4gIHJlbW92ZVZhbHVlRnJvbVJlbmRlclN0YXRlOiBmdW5jdGlvbihrZXk2LCBfYSkge1xuICAgIHZhciB2YXJzID0gX2EudmFycywgc3R5bGUgPSBfYS5zdHlsZTtcbiAgICBkZWxldGUgdmFyc1trZXk2XTtcbiAgICBkZWxldGUgc3R5bGVba2V5Nl07XG4gIH0sXG4gIG1ha2VUYXJnZXRBbmltYXRhYmxlOiBmdW5jdGlvbihlbGVtZW50LCBfYSwgX2IsIGlzTW91bnRlZCkge1xuICAgIHZhciB0cmFuc2Zvcm1WYWx1ZXMzID0gX2IudHJhbnNmb3JtVmFsdWVzO1xuICAgIGlmIChpc01vdW50ZWQgPT09IHZvaWQgMCkge1xuICAgICAgaXNNb3VudGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHRyYW5zaXRpb24gPSBfYS50cmFuc2l0aW9uLCB0cmFuc2l0aW9uRW5kID0gX2EudHJhbnNpdGlvbkVuZCwgdGFyZ2V0ID0gX19yZXN0KF9hLCBbXCJ0cmFuc2l0aW9uXCIsIFwidHJhbnNpdGlvbkVuZFwiXSk7XG4gICAgdmFyIG9yaWdpbiA9IGdldE9yaWdpbih0YXJnZXQsIHRyYW5zaXRpb24gfHwge30sIGVsZW1lbnQpO1xuICAgIGlmICh0cmFuc2Zvcm1WYWx1ZXMzKSB7XG4gICAgICBpZiAodHJhbnNpdGlvbkVuZClcbiAgICAgICAgdHJhbnNpdGlvbkVuZCA9IHRyYW5zZm9ybVZhbHVlczModHJhbnNpdGlvbkVuZCk7XG4gICAgICBpZiAodGFyZ2V0KVxuICAgICAgICB0YXJnZXQgPSB0cmFuc2Zvcm1WYWx1ZXMzKHRhcmdldCk7XG4gICAgICBpZiAob3JpZ2luKVxuICAgICAgICBvcmlnaW4gPSB0cmFuc2Zvcm1WYWx1ZXMzKG9yaWdpbik7XG4gICAgfVxuICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgIGNoZWNrVGFyZ2V0Rm9yTmV3VmFsdWVzKGVsZW1lbnQsIHRhcmdldCwgb3JpZ2luKTtcbiAgICAgIHZhciBwYXJzZWQgPSBwYXJzZURvbVZhcmlhbnQoZWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4sIHRyYW5zaXRpb25FbmQpO1xuICAgICAgdHJhbnNpdGlvbkVuZCA9IHBhcnNlZC50cmFuc2l0aW9uRW5kO1xuICAgICAgdGFyZ2V0ID0gcGFyc2VkLnRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIF9fYXNzaWduKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICB0cmFuc2l0aW9uRW5kXG4gICAgfSwgdGFyZ2V0KTtcbiAgfSxcbiAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzLFxuICBidWlsZDogZnVuY3Rpb24oZWxlbWVudCwgcmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgcHJvamVjdGlvbiwgbGF5b3V0U3RhdGUsIG9wdGlvbnMsIHByb3BzKSB7XG4gICAgaWYgKGVsZW1lbnQuaXNWaXNpYmxlICE9PSB2b2lkIDApIHtcbiAgICAgIHJlbmRlclN0YXRlLnN0eWxlLnZpc2liaWxpdHkgPSBlbGVtZW50LmlzVmlzaWJsZSA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIjtcbiAgICB9XG4gICAgdmFyIGlzUHJvamVjdGlvblRyYW5mb3JtID0gcHJvamVjdGlvbi5pc0VuYWJsZWQgJiYgbGF5b3V0U3RhdGUuaXNIeWRyYXRlZDtcbiAgICBidWlsZEhUTUxTdHlsZXMocmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgcHJvamVjdGlvbiwgbGF5b3V0U3RhdGUsIG9wdGlvbnMsIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlLCBpc1Byb2plY3Rpb25UcmFuZm9ybSA/IGJ1aWxkTGF5b3V0UHJvamVjdGlvblRyYW5zZm9ybSA6IHZvaWQgMCwgaXNQcm9qZWN0aW9uVHJhbmZvcm0gPyBidWlsZExheW91dFByb2plY3Rpb25UcmFuc2Zvcm1PcmlnaW4gOiB2b2lkIDApO1xuICB9LFxuICByZW5kZXI6IHJlbmRlckhUTUxcbn07XG52YXIgaHRtbFZpc3VhbEVsZW1lbnQgPSB2aXN1YWxFbGVtZW50KGh0bWxDb25maWcpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdmlzdWFsLWVsZW1lbnQuanNcbnZhciBzdmdWaXN1YWxFbGVtZW50ID0gdmlzdWFsRWxlbWVudChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaHRtbENvbmZpZyksIHtcbiAgZ2V0QmFzZVRhcmdldDogZnVuY3Rpb24ocHJvcHMsIGtleTYpIHtcbiAgICByZXR1cm4gcHJvcHNba2V5Nl07XG4gIH0sXG4gIHJlYWRWYWx1ZUZyb21JbnN0YW5jZTogZnVuY3Rpb24oZG9tRWxlbWVudCwga2V5Nikge1xuICAgIHZhciBfYTtcbiAgICBpZiAoaXNUcmFuc2Zvcm1Qcm9wKGtleTYpKSB7XG4gICAgICByZXR1cm4gKChfYSA9IGdldERlZmF1bHRWYWx1ZVR5cGUoa2V5NikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWZhdWx0KSB8fCAwO1xuICAgIH1cbiAgICBrZXk2ID0gIWNhbWVsQ2FzZUF0dHJpYnV0ZXMuaGFzKGtleTYpID8gY2FtZWxUb0Rhc2goa2V5NikgOiBrZXk2O1xuICAgIHJldHVybiBkb21FbGVtZW50LmdldEF0dHJpYnV0ZShrZXk2KTtcbiAgfSxcbiAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzOiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMyLFxuICBidWlsZDogZnVuY3Rpb24oX2VsZW1lbnQsIHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIHByb2plY3Rpb24sIGxheW91dFN0YXRlLCBvcHRpb25zLCBwcm9wcykge1xuICAgIHZhciBpc1Byb2plY3Rpb25UcmFuZm9ybSA9IHByb2plY3Rpb24uaXNFbmFibGVkICYmIGxheW91dFN0YXRlLmlzSHlkcmF0ZWQ7XG4gICAgYnVpbGRTVkdBdHRycyhyZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzLCBwcm9qZWN0aW9uLCBsYXlvdXRTdGF0ZSwgb3B0aW9ucywgcHJvcHMudHJhbnNmb3JtVGVtcGxhdGUsIGlzUHJvamVjdGlvblRyYW5mb3JtID8gYnVpbGRMYXlvdXRQcm9qZWN0aW9uVHJhbnNmb3JtIDogdm9pZCAwLCBpc1Byb2plY3Rpb25UcmFuZm9ybSA/IGJ1aWxkTGF5b3V0UHJvamVjdGlvblRyYW5zZm9ybU9yaWdpbiA6IHZvaWQgMCk7XG4gIH0sXG4gIHJlbmRlcjogcmVuZGVyU1ZHXG59KSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS9jcmVhdGUtdmlzdWFsLWVsZW1lbnQuanNcbnZhciBjcmVhdGVEb21WaXN1YWxFbGVtZW50ID0gZnVuY3Rpb24oQ29tcG9uZW50MTksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGlzU1ZHQ29tcG9uZW50KENvbXBvbmVudDE5KSA/IHN2Z1Zpc3VhbEVsZW1lbnQob3B0aW9ucywgeyBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbjogZmFsc2UgfSkgOiBodG1sVmlzdWFsRWxlbWVudChvcHRpb25zLCB7IGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uOiB0cnVlIH0pO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL21vdGlvbi5qc1xudmFyIGZlYXR1cmVCdW5kbGUgPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYW5pbWF0aW9ucyksIGdlc3R1cmVBbmltYXRpb25zKSwgZHJhZyksIGxheW91dEFuaW1hdGlvbnMpO1xudmFyIG1vdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVNb3Rpb25Qcm94eShmdW5jdGlvbihDb21wb25lbnQxOSwgY29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVEb21Nb3Rpb25Db25maWcoQ29tcG9uZW50MTksIGNvbmZpZywgZmVhdHVyZUJ1bmRsZSwgY3JlYXRlRG9tVmlzdWFsRWxlbWVudCk7XG59KTtcbmZ1bmN0aW9uIGNyZWF0ZURvbU1vdGlvbkNvbXBvbmVudChrZXk2KSB7XG4gIHJldHVybiBjcmVhdGVNb3Rpb25Db21wb25lbnQoY3JlYXRlRG9tTW90aW9uQ29uZmlnKGtleTYsIHsgZm9yd2FyZE1vdGlvblByb3BzOiBmYWxzZSB9LCBmZWF0dXJlQnVuZGxlLCBjcmVhdGVEb21WaXN1YWxFbGVtZW50KSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS9tb3Rpb24tbWluaW1hbC5qc1xudmFyIG0gPSBjcmVhdGVNb3Rpb25Qcm94eShjcmVhdGVEb21Nb3Rpb25Db25maWcpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbXBvbmVudHMvQW5pbWF0ZVByZXNlbmNlL2luZGV4LmpzXG5pbXBvcnQge1xuICBGcmFnbWVudCBhcyBGcmFnbWVudDIsXG4gIGNyZWF0ZUVsZW1lbnQgYXMgY3JlYXRlRWxlbWVudDZcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxMiwgdXNlUmVmIGFzIHVzZVJlZjYsIGNsb25lRWxlbWVudCwgQ2hpbGRyZW4sIGlzVmFsaWRFbGVtZW50IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLWZvcmNlLXVwZGF0ZS5qc1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2syLCB1c2VSZWYgYXMgdXNlUmVmNSwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZUZvcmNlVXBkYXRlKCkge1xuICB2YXIgdW5sb2FkaW5nUmVmID0gdXNlUmVmNShmYWxzZSk7XG4gIHZhciBfYSA9IF9fcmVhZCh1c2VTdGF0ZSgwKSwgMiksIGZvcmNlZFJlbmRlckNvdW50ID0gX2FbMF0sIHNldEZvcmNlZFJlbmRlckNvdW50ID0gX2FbMV07XG4gIHVzZVVubW91bnRFZmZlY3QoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHVubG9hZGluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiB1c2VDYWxsYmFjazIoZnVuY3Rpb24oKSB7XG4gICAgIXVubG9hZGluZ1JlZi5jdXJyZW50ICYmIHNldEZvcmNlZFJlbmRlckNvdW50KGZvcmNlZFJlbmRlckNvdW50ICsgMSk7XG4gIH0sIFtmb3JjZWRSZW5kZXJDb3VudF0pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbXBvbmVudHMvQW5pbWF0ZVByZXNlbmNlL1ByZXNlbmNlQ2hpbGQuanNcbmltcG9ydCB7XG4gIGNyZWF0ZUVsZW1lbnQgYXMgY3JlYXRlRWxlbWVudDUsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q5XG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlTWVtbyBhcyB1c2VNZW1vNCB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHByZXNlbmNlSWQgPSAwO1xuZnVuY3Rpb24gZ2V0UHJlc2VuY2VJZCgpIHtcbiAgdmFyIGlkID0gcHJlc2VuY2VJZDtcbiAgcHJlc2VuY2VJZCsrO1xuICByZXR1cm4gaWQ7XG59XG52YXIgUHJlc2VuY2VDaGlsZCA9IGZ1bmN0aW9uKF9hKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBpbml0aWFsID0gX2EuaW5pdGlhbCwgaXNQcmVzZW50MiA9IF9hLmlzUHJlc2VudCwgb25FeGl0Q29tcGxldGUgPSBfYS5vbkV4aXRDb21wbGV0ZSwgY3VzdG9tID0gX2EuY3VzdG9tLCBwcmVzZW5jZUFmZmVjdHNMYXlvdXQgPSBfYS5wcmVzZW5jZUFmZmVjdHNMYXlvdXQ7XG4gIHZhciBwcmVzZW5jZUNoaWxkcmVuID0gdXNlQ29uc3RhbnQobmV3Q2hpbGRyZW5NYXApO1xuICB2YXIgaWQgPSB1c2VDb25zdGFudChnZXRQcmVzZW5jZUlkKTtcbiAgdmFyIGNvbnRleHQgPSB1c2VNZW1vNChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQsXG4gICAgICBpbml0aWFsLFxuICAgICAgaXNQcmVzZW50OiBpc1ByZXNlbnQyLFxuICAgICAgY3VzdG9tLFxuICAgICAgb25FeGl0Q29tcGxldGU6IGZ1bmN0aW9uKGNoaWxkSWQpIHtcbiAgICAgICAgcHJlc2VuY2VDaGlsZHJlbi5zZXQoY2hpbGRJZCwgdHJ1ZSk7XG4gICAgICAgIHZhciBhbGxDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIHByZXNlbmNlQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihpc0NvbXBsZXRlKSB7XG4gICAgICAgICAgaWYgKCFpc0NvbXBsZXRlKVxuICAgICAgICAgICAgYWxsQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFsbENvbXBsZXRlICYmIChvbkV4aXRDb21wbGV0ZSA9PT0gbnVsbCB8fCBvbkV4aXRDb21wbGV0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25FeGl0Q29tcGxldGUoKSk7XG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKGNoaWxkSWQpIHtcbiAgICAgICAgcHJlc2VuY2VDaGlsZHJlbi5zZXQoY2hpbGRJZCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXNlbmNlQ2hpbGRyZW4uZGVsZXRlKGNoaWxkSWQpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH0sIHByZXNlbmNlQWZmZWN0c0xheW91dCA/IHZvaWQgMCA6IFtpc1ByZXNlbnQyXSk7XG4gIHVzZU1lbW80KGZ1bmN0aW9uKCkge1xuICAgIHByZXNlbmNlQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihfLCBrZXk2KSB7XG4gICAgICByZXR1cm4gcHJlc2VuY2VDaGlsZHJlbi5zZXQoa2V5NiwgZmFsc2UpO1xuICAgIH0pO1xuICB9LCBbaXNQcmVzZW50Ml0pO1xuICB1c2VFZmZlY3Q5KGZ1bmN0aW9uKCkge1xuICAgICFpc1ByZXNlbnQyICYmICFwcmVzZW5jZUNoaWxkcmVuLnNpemUgJiYgKG9uRXhpdENvbXBsZXRlID09PSBudWxsIHx8IG9uRXhpdENvbXBsZXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkV4aXRDb21wbGV0ZSgpKTtcbiAgfSwgW2lzUHJlc2VudDJdKTtcbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQ1KFByZXNlbmNlQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dCB9LCBjaGlsZHJlbik7XG59O1xuZnVuY3Rpb24gbmV3Q2hpbGRyZW5NYXAoKSB7XG4gIHJldHVybiBuZXcgTWFwKCk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29tcG9uZW50cy9BbmltYXRlUHJlc2VuY2UvaW5kZXguanNcbmZ1bmN0aW9uIGdldENoaWxkS2V5KGNoaWxkKSB7XG4gIHJldHVybiBjaGlsZC5rZXkgfHwgXCJcIjtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkTG9va3VwKGNoaWxkcmVuLCBhbGxDaGlsZHJlbikge1xuICB2YXIgc2VlbkNoaWxkcmVuID0gdHJ1ZSA/IG5ldyBTZXQoKSA6IG51bGw7XG4gIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICB2YXIga2V5NiA9IGdldENoaWxkS2V5KGNoaWxkKTtcbiAgICBpZiAoc2VlbkNoaWxkcmVuKSB7XG4gICAgICBpZiAoc2VlbkNoaWxkcmVuLmhhcyhrZXk2KSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NoaWxkcmVuIG9mIEFuaW1hdGVQcmVzZW5jZSByZXF1aXJlIHVuaXF1ZSBrZXlzLiBcIicgKyBrZXk2ICsgJ1wiIGlzIGEgZHVwbGljYXRlLicpO1xuICAgICAgfVxuICAgICAgc2VlbkNoaWxkcmVuLmFkZChrZXk2KTtcbiAgICB9XG4gICAgYWxsQ2hpbGRyZW4uc2V0KGtleTYsIGNoaWxkKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBvbmx5RWxlbWVudHMoY2hpbGRyZW4pIHtcbiAgdmFyIGZpbHRlcmVkID0gW107XG4gIENoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSlcbiAgICAgIGZpbHRlcmVkLnB1c2goY2hpbGQpO1xuICB9KTtcbiAgcmV0dXJuIGZpbHRlcmVkO1xufVxudmFyIEFuaW1hdGVQcmVzZW5jZSA9IGZ1bmN0aW9uKF9hKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBjdXN0b20gPSBfYS5jdXN0b20sIF9iID0gX2EuaW5pdGlhbCwgaW5pdGlhbCA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2IsIG9uRXhpdENvbXBsZXRlID0gX2Eub25FeGl0Q29tcGxldGUsIGV4aXRCZWZvcmVFbnRlciA9IF9hLmV4aXRCZWZvcmVFbnRlciwgX2MgPSBfYS5wcmVzZW5jZUFmZmVjdHNMYXlvdXQsIHByZXNlbmNlQWZmZWN0c0xheW91dCA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2M7XG4gIHZhciBmb3JjZVJlbmRlciA9IHVzZUZvcmNlVXBkYXRlKCk7XG4gIHZhciBsYXlvdXRDb250ZXh0ID0gdXNlQ29udGV4dDEyKFNoYXJlZExheW91dENvbnRleHQpO1xuICBpZiAoaXNTaGFyZWRMYXlvdXQobGF5b3V0Q29udGV4dCkpIHtcbiAgICBmb3JjZVJlbmRlciA9IGxheW91dENvbnRleHQuZm9yY2VVcGRhdGU7XG4gIH1cbiAgdmFyIGlzSW5pdGlhbFJlbmRlciA9IHVzZVJlZjYodHJ1ZSk7XG4gIHZhciBmaWx0ZXJlZENoaWxkcmVuID0gb25seUVsZW1lbnRzKGNoaWxkcmVuKTtcbiAgdmFyIHByZXNlbnRDaGlsZHJlbiA9IHVzZVJlZjYoZmlsdGVyZWRDaGlsZHJlbik7XG4gIHZhciBhbGxDaGlsZHJlbiA9IHVzZVJlZjYobmV3IE1hcCgpKS5jdXJyZW50O1xuICB2YXIgZXhpdGluZyA9IHVzZVJlZjYobmV3IFNldCgpKS5jdXJyZW50O1xuICB1cGRhdGVDaGlsZExvb2t1cChmaWx0ZXJlZENoaWxkcmVuLCBhbGxDaGlsZHJlbik7XG4gIGlmIChpc0luaXRpYWxSZW5kZXIuY3VycmVudCkge1xuICAgIGlzSW5pdGlhbFJlbmRlci5jdXJyZW50ID0gZmFsc2U7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQ2KEZyYWdtZW50MiwgbnVsbCwgZmlsdGVyZWRDaGlsZHJlbi5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50NihQcmVzZW5jZUNoaWxkLCB7IGtleTogZ2V0Q2hpbGRLZXkoY2hpbGQpLCBpc1ByZXNlbnQ6IHRydWUsIGluaXRpYWw6IGluaXRpYWwgPyB2b2lkIDAgOiBmYWxzZSwgcHJlc2VuY2VBZmZlY3RzTGF5b3V0IH0sIGNoaWxkKTtcbiAgICB9KSk7XG4gIH1cbiAgdmFyIGNoaWxkcmVuVG9SZW5kZXIgPSBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoZmlsdGVyZWRDaGlsZHJlbikpO1xuICB2YXIgcHJlc2VudEtleXMgPSBwcmVzZW50Q2hpbGRyZW4uY3VycmVudC5tYXAoZ2V0Q2hpbGRLZXkpO1xuICB2YXIgdGFyZ2V0S2V5cyA9IGZpbHRlcmVkQ2hpbGRyZW4ubWFwKGdldENoaWxkS2V5KTtcbiAgdmFyIG51bVByZXNlbnQgPSBwcmVzZW50S2V5cy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUHJlc2VudDsgaSsrKSB7XG4gICAgdmFyIGtleTYgPSBwcmVzZW50S2V5c1tpXTtcbiAgICBpZiAodGFyZ2V0S2V5cy5pbmRleE9mKGtleTYpID09PSAtMSkge1xuICAgICAgZXhpdGluZy5hZGQoa2V5Nik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXRpbmcuZGVsZXRlKGtleTYpO1xuICAgIH1cbiAgfVxuICBpZiAoZXhpdEJlZm9yZUVudGVyICYmIGV4aXRpbmcuc2l6ZSkge1xuICAgIGNoaWxkcmVuVG9SZW5kZXIgPSBbXTtcbiAgfVxuICBleGl0aW5nLmZvckVhY2goZnVuY3Rpb24oa2V5Nykge1xuICAgIGlmICh0YXJnZXRLZXlzLmluZGV4T2Yoa2V5NykgIT09IC0xKVxuICAgICAgcmV0dXJuO1xuICAgIHZhciBjaGlsZCA9IGFsbENoaWxkcmVuLmdldChrZXk3KTtcbiAgICBpZiAoIWNoaWxkKVxuICAgICAgcmV0dXJuO1xuICAgIHZhciBpbnNlcnRpb25JbmRleCA9IHByZXNlbnRLZXlzLmluZGV4T2Yoa2V5Nyk7XG4gICAgdmFyIG9uRXhpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgYWxsQ2hpbGRyZW4uZGVsZXRlKGtleTcpO1xuICAgICAgZXhpdGluZy5kZWxldGUoa2V5Nyk7XG4gICAgICB2YXIgcmVtb3ZlSW5kZXggPSBwcmVzZW50Q2hpbGRyZW4uY3VycmVudC5maW5kSW5kZXgoZnVuY3Rpb24ocHJlc2VudENoaWxkKSB7XG4gICAgICAgIHJldHVybiBwcmVzZW50Q2hpbGQua2V5ID09PSBrZXk3O1xuICAgICAgfSk7XG4gICAgICBwcmVzZW50Q2hpbGRyZW4uY3VycmVudC5zcGxpY2UocmVtb3ZlSW5kZXgsIDEpO1xuICAgICAgaWYgKCFleGl0aW5nLnNpemUpIHtcbiAgICAgICAgcHJlc2VudENoaWxkcmVuLmN1cnJlbnQgPSBmaWx0ZXJlZENoaWxkcmVuO1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgICBvbkV4aXRDb21wbGV0ZSAmJiBvbkV4aXRDb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY2hpbGRyZW5Ub1JlbmRlci5zcGxpY2UoaW5zZXJ0aW9uSW5kZXgsIDAsIGNyZWF0ZUVsZW1lbnQ2KFByZXNlbmNlQ2hpbGQsIHsga2V5OiBnZXRDaGlsZEtleShjaGlsZCksIGlzUHJlc2VudDogZmFsc2UsIG9uRXhpdENvbXBsZXRlOiBvbkV4aXQsIGN1c3RvbSwgcHJlc2VuY2VBZmZlY3RzTGF5b3V0IH0sIGNoaWxkKSk7XG4gIH0pO1xuICBjaGlsZHJlblRvUmVuZGVyID0gY2hpbGRyZW5Ub1JlbmRlci5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICB2YXIga2V5NyA9IGNoaWxkLmtleTtcbiAgICByZXR1cm4gZXhpdGluZy5oYXMoa2V5NykgPyBjaGlsZCA6IGNyZWF0ZUVsZW1lbnQ2KFByZXNlbmNlQ2hpbGQsIHsga2V5OiBnZXRDaGlsZEtleShjaGlsZCksIGlzUHJlc2VudDogdHJ1ZSwgcHJlc2VuY2VBZmZlY3RzTGF5b3V0IH0sIGNoaWxkKTtcbiAgfSk7XG4gIHByZXNlbnRDaGlsZHJlbi5jdXJyZW50ID0gY2hpbGRyZW5Ub1JlbmRlcjtcbiAgaWYgKGV4aXRCZWZvcmVFbnRlciAmJiBjaGlsZHJlblRvUmVuZGVyLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zb2xlLndhcm4oXCJZb3UncmUgYXR0ZW1wdGluZyB0byBhbmltYXRlIG11bHRpcGxlIGNoaWxkcmVuIHdpdGhpbiBBbmltYXRlUHJlc2VuY2UsIGJ1dCBpdHMgZXhpdEJlZm9yZUVudGVyIHByb3AgaXMgc2V0IHRvIHRydWUuIFRoaXMgd2lsbCBsZWFkIHRvIG9kZCB2aXN1YWwgYmVoYXZpb3VyLlwiKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRWxlbWVudDYoRnJhZ21lbnQyLCBudWxsLCBleGl0aW5nLnNpemUgPyBjaGlsZHJlblRvUmVuZGVyIDogY2hpbGRyZW5Ub1JlbmRlci5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICByZXR1cm4gY2xvbmVFbGVtZW50KGNoaWxkKTtcbiAgfSkpO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb21wb25lbnRzL0FuaW1hdGVTaGFyZWRMYXlvdXQvaW5kZXguanNcbmltcG9ydCB7XG4gIENvbXBvbmVudCBhcyBDb21wb25lbnQyLFxuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQ3XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi9hbmltYXRlLmpzXG5mdW5jdGlvbiBhbmltYXRlMihmcm9tLCB0bywgdHJhbnNpdGlvbikge1xuICBpZiAodHJhbnNpdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgdHJhbnNpdGlvbiA9IHt9O1xuICB9XG4gIHZhciB2YWx1ZSA9IGlzTW90aW9uVmFsdWUoZnJvbSkgPyBmcm9tIDogbW90aW9uVmFsdWUoZnJvbSk7XG4gIHN0YXJ0QW5pbWF0aW9uKFwiXCIsIHZhbHVlLCB0bywgdHJhbnNpdGlvbik7XG4gIHJldHVybiB7XG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWUuc3RvcCgpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb21wb25lbnRzL0FuaW1hdGVTaGFyZWRMYXlvdXQvdXRpbHMvY3Jvc3NmYWRlci5qc1xuZnVuY3Rpb24gY3JlYXRlQ3Jvc3NmYWRlcigpIHtcbiAgdmFyIHByb2dyZXNzMiA9IG1vdGlvblZhbHVlKDEpO1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBsZWFkOiB2b2lkIDAsXG4gICAgZm9sbG93OiB2b2lkIDAsXG4gICAgY3Jvc3NmYWRlT3BhY2l0eTogZmFsc2UsXG4gICAgcHJlc2VydmVGb2xsb3dPcGFjaXR5OiBmYWxzZVxuICB9O1xuICB2YXIgcHJldk9wdGlvbnMgPSBfX2Fzc2lnbih7fSwgb3B0aW9ucyk7XG4gIHZhciBsZWFkU3RhdGUgPSB7fTtcbiAgdmFyIGZvbGxvd1N0YXRlID0ge307XG4gIHZhciBpc0FjdGl2ZSA9IGZhbHNlO1xuICB2YXIgZmluYWxDcm9zc2ZhZGVGcmFtZSA9IG51bGw7XG4gIHZhciBwcmV2VXBkYXRlID0gMDtcbiAgZnVuY3Rpb24gc3RhcnRDcm9zc2ZhZGVBbmltYXRpb24odGFyZ2V0LCB0cmFuc2l0aW9uKSB7XG4gICAgdmFyIGxlYWQgPSBvcHRpb25zLmxlYWQsIGZvbGxvdyA9IG9wdGlvbnMuZm9sbG93O1xuICAgIGlzQWN0aXZlID0gdHJ1ZTtcbiAgICBmaW5hbENyb3NzZmFkZUZyYW1lID0gbnVsbDtcbiAgICB2YXIgaGFzVXBkYXRlZCA9IGZhbHNlO1xuICAgIHZhciBvblVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaGFzVXBkYXRlZCA9IHRydWU7XG4gICAgICBsZWFkICYmIGxlYWQuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgIGZvbGxvdyAmJiBmb2xsb3cuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICB9O1xuICAgIHZhciBvbkNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgZmluYWxDcm9zc2ZhZGVGcmFtZSA9IGdldEZyYW1lRGF0YSgpLnRpbWVzdGFtcDtcbiAgICB9O1xuICAgIHRyYW5zaXRpb24gPSB0cmFuc2l0aW9uICYmIGdldFZhbHVlVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBcImNyb3NzZmFkZVwiKTtcbiAgICByZXR1cm4gYW5pbWF0ZTIocHJvZ3Jlc3MyLCB0YXJnZXQsIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0cmFuc2l0aW9uKSwgeyBvblVwZGF0ZSwgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWhhc1VwZGF0ZWQpIHtcbiAgICAgICAgcHJvZ3Jlc3MyLnNldCh0YXJnZXQpO1xuICAgICAgICBlc19kZWZhdWx0LnJlYWQob25Db21wbGV0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgICBvblVwZGF0ZSgpO1xuICAgIH0gfSkpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZUNyb3NzZmFkZSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciB0aW1lc3RhbXAgPSBnZXRGcmFtZURhdGEoKS50aW1lc3RhbXA7XG4gICAgdmFyIGxlYWQgPSBvcHRpb25zLmxlYWQsIGZvbGxvdyA9IG9wdGlvbnMuZm9sbG93O1xuICAgIGlmICh0aW1lc3RhbXAgPT09IHByZXZVcGRhdGUgfHwgIWxlYWQpXG4gICAgICByZXR1cm47XG4gICAgcHJldlVwZGF0ZSA9IHRpbWVzdGFtcDtcbiAgICB2YXIgbGF0ZXN0TGVhZFZhbHVlcyA9IGxlYWQuZ2V0TGF0ZXN0VmFsdWVzKCk7XG4gICAgT2JqZWN0LmFzc2lnbihsZWFkU3RhdGUsIGxhdGVzdExlYWRWYWx1ZXMpO1xuICAgIHZhciBsYXRlc3RGb2xsb3dWYWx1ZXMgPSBmb2xsb3cgPyBmb2xsb3cuZ2V0TGF0ZXN0VmFsdWVzKCkgOiBvcHRpb25zLnByZXZWYWx1ZXM7XG4gICAgT2JqZWN0LmFzc2lnbihmb2xsb3dTdGF0ZSwgbGF0ZXN0Rm9sbG93VmFsdWVzKTtcbiAgICB2YXIgcCA9IHByb2dyZXNzMi5nZXQoKTtcbiAgICB2YXIgbGVhZFRhcmdldE9wYWNpdHkgPSAoX2EgPSBsYXRlc3RMZWFkVmFsdWVzLm9wYWNpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDE7XG4gICAgdmFyIGZvbGxvd1RhcmdldE9wYWNpdHkgPSAoX2IgPSBsYXRlc3RGb2xsb3dWYWx1ZXMgPT09IG51bGwgfHwgbGF0ZXN0Rm9sbG93VmFsdWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXRlc3RGb2xsb3dWYWx1ZXMub3BhY2l0eSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTtcbiAgICBpZiAob3B0aW9ucy5jcm9zc2ZhZGVPcGFjaXR5ICYmIGZvbGxvdykge1xuICAgICAgbGVhZFN0YXRlLm9wYWNpdHkgPSBtaXgoZm9sbG93LmlzVmlzaWJsZSAhPT0gZmFsc2UgPyAwIDogZm9sbG93VGFyZ2V0T3BhY2l0eSwgbGVhZFRhcmdldE9wYWNpdHksIGVhc2VDcm9zc2ZhZGVJbihwKSk7XG4gICAgICBmb2xsb3dTdGF0ZS5vcGFjaXR5ID0gb3B0aW9ucy5wcmVzZXJ2ZUZvbGxvd09wYWNpdHkgPyBmb2xsb3dUYXJnZXRPcGFjaXR5IDogbWl4KGZvbGxvd1RhcmdldE9wYWNpdHksIDAsIGVhc2VDcm9zc2ZhZGVPdXQocCkpO1xuICAgIH0gZWxzZSBpZiAoIWZvbGxvdykge1xuICAgICAgbGVhZFN0YXRlLm9wYWNpdHkgPSBtaXgoZm9sbG93VGFyZ2V0T3BhY2l0eSwgbGVhZFRhcmdldE9wYWNpdHksIHApO1xuICAgIH1cbiAgICBtaXhWYWx1ZXMobGVhZFN0YXRlLCBmb2xsb3dTdGF0ZSwgbGF0ZXN0TGVhZFZhbHVlcywgbGF0ZXN0Rm9sbG93VmFsdWVzIHx8IHt9LCBCb29sZWFuKGZvbGxvdyksIHApO1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNBY3RpdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGxlYWRTdGF0ZSAmJiAoaXNBY3RpdmUgfHwgZ2V0RnJhbWVEYXRhKCkudGltZXN0YW1wID09PSBmaW5hbENyb3NzZmFkZUZyYW1lKTtcbiAgICB9LFxuICAgIGZyb21MZWFkOiBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gc3RhcnRDcm9zc2ZhZGVBbmltYXRpb24oMCwgdHJhbnNpdGlvbik7XG4gICAgfSxcbiAgICB0b0xlYWQ6IGZ1bmN0aW9uKHRyYW5zaXRpb24pIHtcbiAgICAgIHZhciBpbml0aWFsUHJvZ3Jlc3MgPSAwO1xuICAgICAgaWYgKCFvcHRpb25zLnByZXZWYWx1ZXMgJiYgIW9wdGlvbnMuZm9sbG93KSB7XG4gICAgICAgIGluaXRpYWxQcm9ncmVzcyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHByZXZPcHRpb25zLmxlYWQgPT09IG9wdGlvbnMuZm9sbG93ICYmIHByZXZPcHRpb25zLmZvbGxvdyA9PT0gb3B0aW9ucy5sZWFkKSB7XG4gICAgICAgIGluaXRpYWxQcm9ncmVzcyA9IDEgLSBwcm9ncmVzczIuZ2V0KCk7XG4gICAgICB9XG4gICAgICBwcm9ncmVzczIuc2V0KGluaXRpYWxQcm9ncmVzcyk7XG4gICAgICByZXR1cm4gc3RhcnRDcm9zc2ZhZGVBbmltYXRpb24oMSwgdHJhbnNpdGlvbik7XG4gICAgfSxcbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcHJvZ3Jlc3MyLnNldCgxKTtcbiAgICB9LFxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHByb2dyZXNzMi5zdG9wKCk7XG4gICAgfSxcbiAgICBnZXRDcm9zc2ZhZGVTdGF0ZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgdXBkYXRlQ3Jvc3NmYWRlKCk7XG4gICAgICBpZiAoZWxlbWVudCA9PT0gb3B0aW9ucy5sZWFkKSB7XG4gICAgICAgIHJldHVybiBsZWFkU3RhdGU7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgPT09IG9wdGlvbnMuZm9sbG93KSB7XG4gICAgICAgIHJldHVybiBmb2xsb3dTdGF0ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uKG5ld09wdGlvbnMpIHtcbiAgICAgIHByZXZPcHRpb25zID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgICAgbGVhZFN0YXRlID0ge307XG4gICAgICBmb2xsb3dTdGF0ZSA9IHt9O1xuICAgIH0sXG4gICAgZ2V0TGF0ZXN0VmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBsZWFkU3RhdGU7XG4gICAgfVxuICB9O1xufVxudmFyIGVhc2VDcm9zc2ZhZGVJbiA9IGNvbXByZXNzKDAsIDAuNSwgY2lyY091dCk7XG52YXIgZWFzZUNyb3NzZmFkZU91dCA9IGNvbXByZXNzKDAuNSwgMC45NSwgbGluZWFyKTtcbmZ1bmN0aW9uIGNvbXByZXNzKG1pbiwgbWF4LCBlYXNpbmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHApIHtcbiAgICBpZiAocCA8IG1pbilcbiAgICAgIHJldHVybiAwO1xuICAgIGlmIChwID4gbWF4KVxuICAgICAgcmV0dXJuIDE7XG4gICAgcmV0dXJuIGVhc2luZyhwcm9ncmVzcyhtaW4sIG1heCwgcCkpO1xuICB9O1xufVxudmFyIGJvcmRlcnMgPSBbXCJUb3BMZWZ0XCIsIFwiVG9wUmlnaHRcIiwgXCJCb3R0b21MZWZ0XCIsIFwiQm90dG9tUmlnaHRcIl07XG52YXIgbnVtQm9yZGVycyA9IGJvcmRlcnMubGVuZ3RoO1xuZnVuY3Rpb24gbWl4VmFsdWVzKGxlYWRTdGF0ZSwgZm9sbG93U3RhdGUsIGxhdGVzdExlYWRWYWx1ZXMsIGxhdGVzdEZvbGxvd1ZhbHVlcywgaGFzRm9sbG93RWxlbWVudCwgcCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUJvcmRlcnM7IGkrKykge1xuICAgIHZhciBib3JkZXJMYWJlbCA9IFwiYm9yZGVyXCIgKyBib3JkZXJzW2ldICsgXCJSYWRpdXNcIjtcbiAgICB2YXIgZm9sbG93UmFkaXVzID0gZ2V0UmFkaXVzKGxhdGVzdEZvbGxvd1ZhbHVlcywgYm9yZGVyTGFiZWwpO1xuICAgIHZhciBsZWFkUmFkaXVzID0gZ2V0UmFkaXVzKGxhdGVzdExlYWRWYWx1ZXMsIGJvcmRlckxhYmVsKTtcbiAgICBpZiAoZm9sbG93UmFkaXVzID09PSB2b2lkIDAgJiYgbGVhZFJhZGl1cyA9PT0gdm9pZCAwKVxuICAgICAgY29udGludWU7XG4gICAgZm9sbG93UmFkaXVzIHx8IChmb2xsb3dSYWRpdXMgPSAwKTtcbiAgICBsZWFkUmFkaXVzIHx8IChsZWFkUmFkaXVzID0gMCk7XG4gICAgaWYgKHR5cGVvZiBmb2xsb3dSYWRpdXMgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGxlYWRSYWRpdXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhciByYWRpdXMgPSBNYXRoLm1heChtaXgoZm9sbG93UmFkaXVzLCBsZWFkUmFkaXVzLCBwKSwgMCk7XG4gICAgICBsZWFkU3RhdGVbYm9yZGVyTGFiZWxdID0gZm9sbG93U3RhdGVbYm9yZGVyTGFiZWxdID0gcmFkaXVzO1xuICAgIH1cbiAgfVxuICBpZiAobGF0ZXN0Rm9sbG93VmFsdWVzLnJvdGF0ZSB8fCBsYXRlc3RMZWFkVmFsdWVzLnJvdGF0ZSkge1xuICAgIHZhciByb3RhdGUgPSBtaXgobGF0ZXN0Rm9sbG93VmFsdWVzLnJvdGF0ZSB8fCAwLCBsYXRlc3RMZWFkVmFsdWVzLnJvdGF0ZSB8fCAwLCBwKTtcbiAgICBsZWFkU3RhdGUucm90YXRlID0gZm9sbG93U3RhdGUucm90YXRlID0gcm90YXRlO1xuICB9XG4gIGlmICghaGFzRm9sbG93RWxlbWVudCAmJiBsYXRlc3RMZWFkVmFsdWVzLmJhY2tncm91bmRDb2xvciAmJiBsYXRlc3RGb2xsb3dWYWx1ZXMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgbGVhZFN0YXRlLmJhY2tncm91bmRDb2xvciA9IGZvbGxvd1N0YXRlLmJhY2tncm91bmRDb2xvciA9IG1peENvbG9yKGxhdGVzdEZvbGxvd1ZhbHVlcy5iYWNrZ3JvdW5kQ29sb3IsIGxhdGVzdExlYWRWYWx1ZXMuYmFja2dyb3VuZENvbG9yKShwKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UmFkaXVzKHZhbHVlcywgcmFkaXVzTmFtZSkge1xuICB2YXIgX2E7XG4gIHJldHVybiAoX2EgPSB2YWx1ZXNbcmFkaXVzTmFtZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlcy5ib3JkZXJSYWRpdXM7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29tcG9uZW50cy9BbmltYXRlU2hhcmVkTGF5b3V0L3V0aWxzL3N0YWNrLmpzXG5mdW5jdGlvbiBsYXlvdXRTdGFjaygpIHtcbiAgdmFyIHN0YWNrID0gbmV3IFNldCgpO1xuICB2YXIgc3RhdGUgPSB7IGxlYWRJc0V4aXRpbmc6IGZhbHNlIH07XG4gIHZhciBwcmV2U3RhdGUgPSBfX2Fzc2lnbih7fSwgc3RhdGUpO1xuICB2YXIgcHJldlZhbHVlcztcbiAgdmFyIHByZXZWaWV3cG9ydEJveDtcbiAgdmFyIHByZXZEcmFnQ3Vyc29yO1xuICB2YXIgY3Jvc3NmYWRlciA9IGNyZWF0ZUNyb3NzZmFkZXIoKTtcbiAgdmFyIG5lZWRzQ3Jvc3NmYWRlQW5pbWF0aW9uID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGdldEZvbGxvd1ZpZXdwb3J0Qm94KCkge1xuICAgIHJldHVybiBzdGF0ZS5mb2xsb3cgPyBzdGF0ZS5mb2xsb3cucHJldlZpZXdwb3J0Qm94IDogcHJldlZpZXdwb3J0Qm94O1xuICB9XG4gIGZ1bmN0aW9uIGdldEZvbGxvd0xheW91dCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHN0YXRlLmZvbGxvdykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldExheW91dFN0YXRlKCkubGF5b3V0O1xuICB9XG4gIHJldHVybiB7XG4gICAgYWRkOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LnNldENyb3NzZmFkZXIoY3Jvc3NmYWRlcik7XG4gICAgICBzdGFjay5hZGQoZWxlbWVudCk7XG4gICAgICBpZiAocHJldkRyYWdDdXJzb3IpXG4gICAgICAgIGVsZW1lbnQucHJldkRyYWdDdXJzb3IgPSBwcmV2RHJhZ0N1cnNvcjtcbiAgICAgIGlmICghc3RhdGUubGVhZClcbiAgICAgICAgc3RhdGUubGVhZCA9IGVsZW1lbnQ7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHN0YWNrLmRlbGV0ZShlbGVtZW50KTtcbiAgICB9LFxuICAgIGdldExlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0YXRlLmxlYWQ7XG4gICAgfSxcbiAgICB1cGRhdGVTbmFwc2hvdDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXN0YXRlLmxlYWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHByZXZWYWx1ZXMgPSBjcm9zc2ZhZGVyLmlzQWN0aXZlKCkgPyBjcm9zc2ZhZGVyLmdldExhdGVzdFZhbHVlcygpIDogc3RhdGUubGVhZC5nZXRMYXRlc3RWYWx1ZXMoKTtcbiAgICAgIHByZXZWaWV3cG9ydEJveCA9IHN0YXRlLmxlYWQucHJldlZpZXdwb3J0Qm94O1xuICAgICAgdmFyIGRyYWdDb250cm9scyA9IGVsZW1lbnREcmFnQ29udHJvbHMuZ2V0KHN0YXRlLmxlYWQpO1xuICAgICAgaWYgKGRyYWdDb250cm9scyAmJiBkcmFnQ29udHJvbHMuaXNEcmFnZ2luZykge1xuICAgICAgICBwcmV2RHJhZ0N1cnNvciA9IGRyYWdDb250cm9scy5jdXJzb3JQcm9ncmVzcztcbiAgICAgIH1cbiAgICB9LFxuICAgIGNsZWFyU25hcHNob3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldkRyYWdDdXJzb3IgPSBwcmV2Vmlld3BvcnRCb3ggPSB2b2lkIDA7XG4gICAgfSxcbiAgICB1cGRhdGVMZWFkQW5kRm9sbG93OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHByZXZTdGF0ZSA9IF9fYXNzaWduKHt9LCBzdGF0ZSk7XG4gICAgICB2YXIgbGVhZDtcbiAgICAgIHZhciBmb2xsb3c7XG4gICAgICB2YXIgb3JkZXIyID0gQXJyYXkuZnJvbShzdGFjayk7XG4gICAgICBmb3IgKHZhciBpID0gb3JkZXIyLmxlbmd0aDsgaS0tOyBpID49IDApIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBvcmRlcjJbaV07XG4gICAgICAgIGlmIChsZWFkKVxuICAgICAgICAgIGZvbGxvdyAhPT0gbnVsbCAmJiBmb2xsb3cgIT09IHZvaWQgMCA/IGZvbGxvdyA6IGZvbGxvdyA9IGVsZW1lbnQ7XG4gICAgICAgIGxlYWQgIT09IG51bGwgJiYgbGVhZCAhPT0gdm9pZCAwID8gbGVhZCA6IGxlYWQgPSBlbGVtZW50O1xuICAgICAgICBpZiAobGVhZCAmJiBmb2xsb3cpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5sZWFkID0gbGVhZDtcbiAgICAgIHN0YXRlLmZvbGxvdyA9IGZvbGxvdztcbiAgICAgIHN0YXRlLmxlYWRJc0V4aXRpbmcgPSAoKF9hID0gc3RhdGUubGVhZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByZXNlbmNlKSA9PT0gUHJlc2VuY2UuRXhpdGluZztcbiAgICAgIGNyb3NzZmFkZXIuc2V0T3B0aW9ucyh7XG4gICAgICAgIGxlYWQsXG4gICAgICAgIGZvbGxvdyxcbiAgICAgICAgcHJldlZhbHVlcyxcbiAgICAgICAgY3Jvc3NmYWRlT3BhY2l0eTogKGZvbGxvdyA9PT0gbnVsbCB8fCBmb2xsb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvbGxvdy5pc1ByZXNlbmNlUm9vdCkgfHwgKGxlYWQgPT09IG51bGwgfHwgbGVhZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVhZC5pc1ByZXNlbmNlUm9vdClcbiAgICAgIH0pO1xuICAgICAgaWYgKHN0YXRlLmxlYWQgIT09IHByZXZTdGF0ZS5mb2xsb3cgJiYgKHByZXZTdGF0ZS5sZWFkICE9PSBzdGF0ZS5sZWFkIHx8IHByZXZTdGF0ZS5sZWFkSXNFeGl0aW5nICE9PSBzdGF0ZS5sZWFkSXNFeGl0aW5nKSkge1xuICAgICAgICBuZWVkc0Nyb3NzZmFkZUFuaW1hdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBhbmltYXRlOiBmdW5jdGlvbihjaGlsZCwgc2hvdWxkQ3Jvc3NmYWRlKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoc2hvdWxkQ3Jvc3NmYWRlID09PSB2b2lkIDApIHtcbiAgICAgICAgc2hvdWxkQ3Jvc3NmYWRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQgPT09IHN0YXRlLmxlYWQpIHtcbiAgICAgICAgaWYgKHNob3VsZENyb3NzZmFkZSkge1xuICAgICAgICAgIGNoaWxkLnBvaW50VG8oc3RhdGUubGVhZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hpbGQuc2V0VmlzaWJpbGl0eSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29uZmlnID0ge307XG4gICAgICAgIHZhciBwcmV2UGFyZW50ID0gKF9hID0gc3RhdGUuZm9sbG93KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UHJvamVjdGlvblBhcmVudCgpO1xuICAgICAgICBpZiAocHJldlBhcmVudCkge1xuICAgICAgICAgIGNvbmZpZy5wcmV2UGFyZW50ID0gcHJldlBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQucHJlc2VuY2UgPT09IFByZXNlbmNlLkVudGVyaW5nKSB7XG4gICAgICAgICAgY29uZmlnLm9yaWdpbkJveCA9IGdldEZvbGxvd1ZpZXdwb3J0Qm94KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGQucHJlc2VuY2UgPT09IFByZXNlbmNlLkV4aXRpbmcpIHtcbiAgICAgICAgICBjb25maWcudGFyZ2V0Qm94ID0gZ2V0Rm9sbG93TGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRzQ3Jvc3NmYWRlQW5pbWF0aW9uKSB7XG4gICAgICAgICAgbmVlZHNDcm9zc2ZhZGVBbmltYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IGNoaWxkLmdldERlZmF1bHRUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgY2hpbGQucHJlc2VuY2UgPT09IFByZXNlbmNlLkVudGVyaW5nID8gY3Jvc3NmYWRlci50b0xlYWQodHJhbnNpdGlvbikgOiBjcm9zc2ZhZGVyLmZyb21MZWFkKHRyYW5zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkLm5vdGlmeUxheW91dFJlYWR5KGNvbmZpZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2hvdWxkQ3Jvc3NmYWRlKSB7XG4gICAgICAgICAgc3RhdGUubGVhZCAmJiBjaGlsZC5wb2ludFRvKHN0YXRlLmxlYWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoaWxkLnNldFZpc2liaWxpdHkoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbXBvbmVudHMvQW5pbWF0ZVNoYXJlZExheW91dC91dGlscy9yb3RhdGUuanNcbmZ1bmN0aW9uIHJlc2V0Um90YXRlKGNoaWxkKSB7XG4gIHZhciBoYXNSb3RhdGUgPSBmYWxzZTtcbiAgdmFyIHJlc2V0VmFsdWVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtQXhlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBheGlzID0gdHJhbnNmb3JtQXhlc1tpXTtcbiAgICB2YXIga2V5NiA9IFwicm90YXRlXCIgKyBheGlzO1xuICAgIGlmICghY2hpbGQuaGFzVmFsdWUoa2V5NikgfHwgY2hpbGQuZ2V0U3RhdGljVmFsdWUoa2V5NikgPT09IDApXG4gICAgICBjb250aW51ZTtcbiAgICBoYXNSb3RhdGUgPSB0cnVlO1xuICAgIHJlc2V0VmFsdWVzW2tleTZdID0gY2hpbGQuZ2V0U3RhdGljVmFsdWUoa2V5Nik7XG4gICAgY2hpbGQuc2V0U3RhdGljVmFsdWUoa2V5NiwgMCk7XG4gIH1cbiAgaWYgKCFoYXNSb3RhdGUpXG4gICAgcmV0dXJuO1xuICBjaGlsZC5zeW5jUmVuZGVyKCk7XG4gIGZvciAodmFyIGtleTYgaW4gcmVzZXRWYWx1ZXMpIHtcbiAgICBjaGlsZC5zZXRTdGF0aWNWYWx1ZShrZXk2LCByZXNldFZhbHVlc1trZXk2XSk7XG4gIH1cbiAgY2hpbGQuc2NoZWR1bGVSZW5kZXIoKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb21wb25lbnRzL0FuaW1hdGVTaGFyZWRMYXlvdXQvaW5kZXguanNcbnZhciBBbmltYXRlU2hhcmVkTGF5b3V0ID0gZnVuY3Rpb24oX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhBbmltYXRlU2hhcmVkTGF5b3V0MiwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gQW5pbWF0ZVNoYXJlZExheW91dDIoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuY2hpbGRyZW4gPSBuZXcgU2V0KCk7XG4gICAgX3RoaXMuc3RhY2tzID0gbmV3IE1hcCgpO1xuICAgIF90aGlzLmhhc01vdW50ZWQgPSBmYWxzZTtcbiAgICBfdGhpcy51cGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBfdGhpcy5yZW5kZXJTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBfdGhpcy5zeW5jQ29udGV4dCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBjcmVhdGVCYXRjaGVyKCkpLCB7IHN5bmNVcGRhdGU6IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICByZXR1cm4gX3RoaXMuc2NoZWR1bGVVcGRhdGUoZm9yY2UpO1xuICAgIH0sIGZvcmNlVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIF90aGlzLnN5bmNDb250ZXh0ID0gX19hc3NpZ24oe30sIF90aGlzLnN5bmNDb250ZXh0KTtcbiAgICAgIF90aGlzLnNjaGVkdWxlVXBkYXRlKHRydWUpO1xuICAgIH0sIHJlZ2lzdGVyOiBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgcmV0dXJuIF90aGlzLmFkZENoaWxkKGNoaWxkKTtcbiAgICB9LCByZW1vdmU6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4gX3RoaXMucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgIH0gfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIEFuaW1hdGVTaGFyZWRMYXlvdXQyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaGFzTW91bnRlZCA9IHRydWU7XG4gIH07XG4gIEFuaW1hdGVTaGFyZWRMYXlvdXQyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0YXJ0TGF5b3V0QW5pbWF0aW9uKCk7XG4gIH07XG4gIEFuaW1hdGVTaGFyZWRMYXlvdXQyLnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbmRlclNjaGVkdWxlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIEFuaW1hdGVTaGFyZWRMYXlvdXQyLnByb3RvdHlwZS5zdGFydExheW91dEFuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5yZW5kZXJTY2hlZHVsZWQgPSB0aGlzLnVwZGF0ZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHZhciB0eXBlID0gdGhpcy5wcm9wcy50eXBlO1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgaWYgKCFjaGlsZC5pc1ByZXNlbnQpIHtcbiAgICAgICAgY2hpbGQucHJlc2VuY2UgPSBQcmVzZW5jZS5FeGl0aW5nO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC5wcmVzZW5jZSAhPT0gUHJlc2VuY2UuRW50ZXJpbmcpIHtcbiAgICAgICAgY2hpbGQucHJlc2VuY2UgPSBjaGlsZC5wcmVzZW5jZSA9PT0gUHJlc2VuY2UuRXhpdGluZyA/IFByZXNlbmNlLkVudGVyaW5nIDogUHJlc2VuY2UuUHJlc2VudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZVN0YWNrcygpO1xuICAgIHZhciBoYW5kbGVyID0ge1xuICAgICAgbGF5b3V0UmVhZHk6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZC5nZXRMYXlvdXRJZCgpICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBfdGhpcy5nZXRTdGFjayhjaGlsZCk7XG4gICAgICAgICAgc3RhY2suYW5pbWF0ZShjaGlsZCwgdHlwZSA9PT0gXCJjcm9zc2ZhZGVcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hpbGQubm90aWZ5TGF5b3V0UmVhZHkoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBhcmVudDogdGhpcy5jb250ZXh0LnZpc3VhbEVsZW1lbnRcbiAgICB9O1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgcmV0dXJuIF90aGlzLnN5bmNDb250ZXh0LmFkZChjaGlsZCk7XG4gICAgfSk7XG4gICAgdGhpcy5zeW5jQ29udGV4dC5mbHVzaChoYW5kbGVyKTtcbiAgICB0aGlzLnN0YWNrcy5mb3JFYWNoKGZ1bmN0aW9uKHN0YWNrKSB7XG4gICAgICByZXR1cm4gc3RhY2suY2xlYXJTbmFwc2hvdCgpO1xuICAgIH0pO1xuICB9O1xuICBBbmltYXRlU2hhcmVkTGF5b3V0Mi5wcm90b3R5cGUudXBkYXRlU3RhY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdGFja3MuZm9yRWFjaChmdW5jdGlvbihzdGFjaykge1xuICAgICAgcmV0dXJuIHN0YWNrLnVwZGF0ZUxlYWRBbmRGb2xsb3coKTtcbiAgICB9KTtcbiAgfTtcbiAgQW5pbWF0ZVNoYXJlZExheW91dDIucHJvdG90eXBlLnNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24oZm9yY2UpIHtcbiAgICBpZiAoZm9yY2UgPT09IHZvaWQgMCkge1xuICAgICAgZm9yY2UgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCEoZm9yY2UgfHwgIXRoaXMudXBkYXRlU2NoZWR1bGVkKSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnVwZGF0ZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXNldFJvdGF0ZShjaGlsZCk7XG4gICAgICBpZiAoY2hpbGQuc2hvdWxkUmVzZXRUcmFuc2Zvcm0oKSlcbiAgICAgICAgY2hpbGQucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICB9KTtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goc25hcHNob3RWaWV3cG9ydEJveCk7XG4gICAgdGhpcy5zdGFja3MuZm9yRWFjaChmdW5jdGlvbihzdGFjaykge1xuICAgICAgcmV0dXJuIHN0YWNrLnVwZGF0ZVNuYXBzaG90KCk7XG4gICAgfSk7XG4gICAgaWYgKGZvcmNlIHx8ICF0aGlzLnJlbmRlclNjaGVkdWxlZCkge1xuICAgICAgdGhpcy5yZW5kZXJTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcbiAgQW5pbWF0ZVNoYXJlZExheW91dDIucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICB0aGlzLmNoaWxkcmVuLmFkZChjaGlsZCk7XG4gICAgdGhpcy5hZGRUb1N0YWNrKGNoaWxkKTtcbiAgICBjaGlsZC5wcmVzZW5jZSA9IHRoaXMuaGFzTW91bnRlZCA/IFByZXNlbmNlLkVudGVyaW5nIDogUHJlc2VuY2UuUHJlc2VudDtcbiAgfTtcbiAgQW5pbWF0ZVNoYXJlZExheW91dDIucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICB0aGlzLnNjaGVkdWxlVXBkYXRlKCk7XG4gICAgdGhpcy5jaGlsZHJlbi5kZWxldGUoY2hpbGQpO1xuICAgIHRoaXMucmVtb3ZlRnJvbVN0YWNrKGNoaWxkKTtcbiAgfTtcbiAgQW5pbWF0ZVNoYXJlZExheW91dDIucHJvdG90eXBlLmFkZFRvU3RhY2sgPSBmdW5jdGlvbihjaGlsZCkge1xuICAgIHZhciBzdGFjayA9IHRoaXMuZ2V0U3RhY2soY2hpbGQpO1xuICAgIHN0YWNrID09PSBudWxsIHx8IHN0YWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGFjay5hZGQoY2hpbGQpO1xuICB9O1xuICBBbmltYXRlU2hhcmVkTGF5b3V0Mi5wcm90b3R5cGUucmVtb3ZlRnJvbVN0YWNrID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICB2YXIgc3RhY2sgPSB0aGlzLmdldFN0YWNrKGNoaWxkKTtcbiAgICBzdGFjayA9PT0gbnVsbCB8fCBzdGFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhY2sucmVtb3ZlKGNoaWxkKTtcbiAgfTtcbiAgQW5pbWF0ZVNoYXJlZExheW91dDIucHJvdG90eXBlLmdldFN0YWNrID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICB2YXIgaWQgPSBjaGlsZC5nZXRMYXlvdXRJZCgpO1xuICAgIGlmIChpZCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgICF0aGlzLnN0YWNrcy5oYXMoaWQpICYmIHRoaXMuc3RhY2tzLnNldChpZCwgbGF5b3V0U3RhY2soKSk7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2tzLmdldChpZCk7XG4gIH07XG4gIEFuaW1hdGVTaGFyZWRMYXlvdXQyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudDcoU2hhcmVkTGF5b3V0Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdGhpcy5zeW5jQ29udGV4dCB9LCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgfTtcbiAgQW5pbWF0ZVNoYXJlZExheW91dDIuY29udGV4dFR5cGUgPSBNb3Rpb25Db250ZXh0O1xuICByZXR1cm4gQW5pbWF0ZVNoYXJlZExheW91dDI7XG59KENvbXBvbmVudDIpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbXBvbmVudHMvTW90aW9uQ29uZmlnL2luZGV4LmpzXG5pbXBvcnQge1xuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQ4XG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTMsIHVzZU1lbW8gYXMgdXNlTWVtbzUgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIE1vdGlvbkNvbmZpZyhfYSkge1xuICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgY29uZmlnID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiXSk7XG4gIGNvbmZpZyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB1c2VDb250ZXh0MTMoTW90aW9uQ29uZmlnQ29udGV4dCkpLCBjb25maWcpO1xuICBjb25maWcuaXNTdGF0aWMgPSB1c2VDb25zdGFudChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29uZmlnLmlzU3RhdGljO1xuICB9KTtcbiAgdmFyIHRyYW5zaXRpb25EZXBlbmRlbmN5ID0gdHlwZW9mIGNvbmZpZy50cmFuc2l0aW9uID09PSBcIm9iamVjdFwiID8gY29uZmlnLnRyYW5zaXRpb24udG9TdHJpbmcoKSA6IFwiXCI7XG4gIHZhciBjb250ZXh0ID0gdXNlTWVtbzUoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfSwgW1xuICAgIHRyYW5zaXRpb25EZXBlbmRlbmN5LFxuICAgIGNvbmZpZy50cmFuc2Zvcm1QYWdlUG9pbnRcbiAgXSk7XG4gIHJldHVybiBjcmVhdGVFbGVtZW50OChNb3Rpb25Db25maWdDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0IH0sIGNoaWxkcmVuKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb21wb25lbnRzL0xhenlNb3Rpb24vaW5kZXguanNcbmltcG9ydCB7XG4gIGNyZWF0ZUVsZW1lbnQgYXMgY3JlYXRlRWxlbWVudDlcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTIsIHVzZVJlZiBhcyB1c2VSZWY3LCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MTAgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIExhenlNb3Rpb24oX2EpIHtcbiAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGZlYXR1cmVzID0gX2EuZmVhdHVyZXMsIF9iID0gX2Euc3RyaWN0LCBzdHJpY3QgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYjtcbiAgdmFyIF9jID0gX19yZWFkKHVzZVN0YXRlMighaXNMYXp5QnVuZGxlKGZlYXR1cmVzKSksIDIpLCBzZXRJc0xvYWRlZCA9IF9jWzFdO1xuICB2YXIgbG9hZGVkUmVuZGVyZXIgPSB1c2VSZWY3KHZvaWQgMCk7XG4gIGlmICghaXNMYXp5QnVuZGxlKGZlYXR1cmVzKSkge1xuICAgIHZhciByZW5kZXJlciA9IGZlYXR1cmVzLnJlbmRlcmVyLCBsb2FkZWRGZWF0dXJlcyA9IF9fcmVzdChmZWF0dXJlcywgW1wicmVuZGVyZXJcIl0pO1xuICAgIGxvYWRlZFJlbmRlcmVyLmN1cnJlbnQgPSByZW5kZXJlcjtcbiAgICBsb2FkRmVhdHVyZXMobG9hZGVkRmVhdHVyZXMpO1xuICB9XG4gIHVzZUVmZmVjdDEwKGZ1bmN0aW9uKCkge1xuICAgIGlmIChpc0xhenlCdW5kbGUoZmVhdHVyZXMpKSB7XG4gICAgICBmZWF0dXJlcygpLnRoZW4oZnVuY3Rpb24oX2EyKSB7XG4gICAgICAgIHZhciByZW5kZXJlcjIgPSBfYTIucmVuZGVyZXIsIGxvYWRlZEZlYXR1cmVzMiA9IF9fcmVzdChfYTIsIFtcInJlbmRlcmVyXCJdKTtcbiAgICAgICAgbG9hZEZlYXR1cmVzKGxvYWRlZEZlYXR1cmVzMik7XG4gICAgICAgIGxvYWRlZFJlbmRlcmVyLmN1cnJlbnQgPSByZW5kZXJlcjI7XG4gICAgICAgIHNldElzTG9hZGVkKHRydWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBbXSk7XG4gIHJldHVybiBjcmVhdGVFbGVtZW50OShMYXp5Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogeyByZW5kZXJlcjogbG9hZGVkUmVuZGVyZXIuY3VycmVudCwgc3RyaWN0IH0gfSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gaXNMYXp5QnVuZGxlKGZlYXR1cmVzKSB7XG4gIHJldHVybiB0eXBlb2YgZmVhdHVyZXMgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL2ZlYXR1cmVzLWFuaW1hdGlvbi5qc1xudmFyIGRvbUFuaW1hdGlvbiA9IF9fYXNzaWduKF9fYXNzaWduKHsgcmVuZGVyZXI6IGNyZWF0ZURvbVZpc3VhbEVsZW1lbnQgfSwgYW5pbWF0aW9ucyksIGdlc3R1cmVBbmltYXRpb25zKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL2ZlYXR1cmVzLW1heC5qc1xudmFyIGRvbU1heCA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBkb21BbmltYXRpb24pLCBkcmFnKSwgbGF5b3V0QW5pbWF0aW9ucyk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdXNlLW1vdGlvbi12YWx1ZS5qc1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTQsIHVzZVN0YXRlIGFzIHVzZVN0YXRlMywgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDExIH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VNb3Rpb25WYWx1ZShpbml0aWFsKSB7XG4gIHZhciB2YWx1ZSA9IHVzZUNvbnN0YW50KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBtb3Rpb25WYWx1ZShpbml0aWFsKTtcbiAgfSk7XG4gIHZhciBpc1N0YXRpYyA9IHVzZUNvbnRleHQxNChNb3Rpb25Db25maWdDb250ZXh0KS5pc1N0YXRpYztcbiAgaWYgKGlzU3RhdGljKSB7XG4gICAgdmFyIF9hID0gX19yZWFkKHVzZVN0YXRlMyhpbml0aWFsKSwgMiksIHNldExhdGVzdF8xID0gX2FbMV07XG4gICAgdXNlRWZmZWN0MTEoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWUub25DaGFuZ2Uoc2V0TGF0ZXN0XzEpO1xuICAgIH0sIFtdKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdXNlLW9uLWNoYW5nZS5qc1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDEyIH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VPbkNoYW5nZSh2YWx1ZSwgY2FsbGJhY2spIHtcbiAgdXNlRWZmZWN0MTIoZnVuY3Rpb24oKSB7XG4gICAgaWYgKGlzTW90aW9uVmFsdWUodmFsdWUpKVxuICAgICAgcmV0dXJuIHZhbHVlLm9uQ2hhbmdlKGNhbGxiYWNrKTtcbiAgfSwgW2NhbGxiYWNrXSk7XG59XG5mdW5jdGlvbiB1c2VNdWx0aU9uQ2hhbmdlKHZhbHVlcywgaGFuZGxlcikge1xuICB1c2VFZmZlY3QxMihmdW5jdGlvbigpIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5vbkNoYW5nZShoYW5kbGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHVuc3Vic2NyaWJlKSB7XG4gICAgICAgIHJldHVybiB1bnN1YnNjcmliZSgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdXNlLWNvbWJpbmUtdmFsdWVzLmpzXG5mdW5jdGlvbiB1c2VDb21iaW5lTW90aW9uVmFsdWVzKHZhbHVlcywgY29tYmluZVZhbHVlcykge1xuICB2YXIgdmFsdWUgPSB1c2VNb3Rpb25WYWx1ZShjb21iaW5lVmFsdWVzKCkpO1xuICB2YXIgdXBkYXRlVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWUuc2V0KGNvbWJpbmVWYWx1ZXMoKSk7XG4gIH07XG4gIHVwZGF0ZVZhbHVlKCk7XG4gIHVzZU11bHRpT25DaGFuZ2UodmFsdWVzLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZXNfZGVmYXVsdC51cGRhdGUodXBkYXRlVmFsdWUsIGZhbHNlLCB0cnVlKTtcbiAgfSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS91c2UtbW90aW9uLXRlbXBsYXRlLmpzXG5mdW5jdGlvbiB1c2VNb3Rpb25UZW1wbGF0ZShmcmFnbWVudHMpIHtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIHZhbHVlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgfVxuICB2YXIgbnVtRnJhZ21lbnRzID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgZnVuY3Rpb24gYnVpbGRWYWx1ZSgpIHtcbiAgICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUZyYWdtZW50czsgaSsrKSB7XG4gICAgICBvdXRwdXQgKz0gZnJhZ21lbnRzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgaWYgKHZhbHVlKVxuICAgICAgICBvdXRwdXQgKz0gdmFsdWVzW2ldLmdldCgpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHJldHVybiB1c2VDb21iaW5lTW90aW9uVmFsdWVzKHZhbHVlcywgYnVpbGRWYWx1ZSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdHJhbnNmb3JtLmpzXG52YXIgaXNDdXN0b21WYWx1ZVR5cGUgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2Lm1peDtcbn07XG52YXIgZ2V0TWl4ZXIyID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gaXNDdXN0b21WYWx1ZVR5cGUodikgPyB2Lm1peCA6IHZvaWQgMDtcbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm0oKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICB9XG4gIHZhciB1c2VJbW1lZGlhdGUgPSAhQXJyYXkuaXNBcnJheShhcmdzWzBdKTtcbiAgdmFyIGFyZ09mZnNldCA9IHVzZUltbWVkaWF0ZSA/IDAgOiAtMTtcbiAgdmFyIGlucHV0VmFsdWUgPSBhcmdzWzAgKyBhcmdPZmZzZXRdO1xuICB2YXIgaW5wdXRSYW5nZSA9IGFyZ3NbMSArIGFyZ09mZnNldF07XG4gIHZhciBvdXRwdXRSYW5nZSA9IGFyZ3NbMiArIGFyZ09mZnNldF07XG4gIHZhciBvcHRpb25zID0gYXJnc1szICsgYXJnT2Zmc2V0XTtcbiAgdmFyIGludGVycG9sYXRvciA9IGludGVycG9sYXRlKGlucHV0UmFuZ2UsIG91dHB1dFJhbmdlLCBfX2Fzc2lnbih7IG1peGVyOiBnZXRNaXhlcjIob3V0cHV0UmFuZ2VbMF0pIH0sIG9wdGlvbnMpKTtcbiAgcmV0dXJuIHVzZUltbWVkaWF0ZSA/IGludGVycG9sYXRvcihpbnB1dFZhbHVlKSA6IGludGVycG9sYXRvcjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS91c2UtdHJhbnNmb3JtLmpzXG5mdW5jdGlvbiB1c2VUcmFuc2Zvcm0oaW5wdXQsIGlucHV0UmFuZ2VPclRyYW5zZm9ybWVyLCBvdXRwdXRSYW5nZSwgb3B0aW9ucykge1xuICB2YXIgdHJhbnNmb3JtZXIgPSB0eXBlb2YgaW5wdXRSYW5nZU9yVHJhbnNmb3JtZXIgPT09IFwiZnVuY3Rpb25cIiA/IGlucHV0UmFuZ2VPclRyYW5zZm9ybWVyIDogdHJhbnNmb3JtKGlucHV0UmFuZ2VPclRyYW5zZm9ybWVyLCBvdXRwdXRSYW5nZSwgb3B0aW9ucyk7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KSA/IHVzZUxpc3RUcmFuc2Zvcm0oaW5wdXQsIHRyYW5zZm9ybWVyKSA6IHVzZUxpc3RUcmFuc2Zvcm0oW2lucHV0XSwgZnVuY3Rpb24oX2EpIHtcbiAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDEpLCBsYXRlc3QgPSBfYlswXTtcbiAgICByZXR1cm4gdHJhbnNmb3JtZXIobGF0ZXN0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiB1c2VMaXN0VHJhbnNmb3JtKHZhbHVlcywgdHJhbnNmb3JtZXIpIHtcbiAgdmFyIGxhdGVzdCA9IHVzZUNvbnN0YW50KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBbXTtcbiAgfSk7XG4gIHJldHVybiB1c2VDb21iaW5lTW90aW9uVmFsdWVzKHZhbHVlcywgZnVuY3Rpb24oKSB7XG4gICAgbGF0ZXN0Lmxlbmd0aCA9IDA7XG4gICAgdmFyIG51bVZhbHVlcyA9IHZhbHVlcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1WYWx1ZXM7IGkrKykge1xuICAgICAgbGF0ZXN0W2ldID0gdmFsdWVzW2ldLmdldCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmb3JtZXIobGF0ZXN0KTtcbiAgfSk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdXNlLXNwcmluZy5qc1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTUsIHVzZVJlZiBhcyB1c2VSZWY4LCB1c2VNZW1vIGFzIHVzZU1lbW82IH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VTcHJpbmcoc291cmNlLCBjb25maWcpIHtcbiAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgY29uZmlnID0ge307XG4gIH1cbiAgdmFyIGlzU3RhdGljID0gdXNlQ29udGV4dDE1KE1vdGlvbkNvbmZpZ0NvbnRleHQpLmlzU3RhdGljO1xuICB2YXIgYWN0aXZlU3ByaW5nQW5pbWF0aW9uID0gdXNlUmVmOChudWxsKTtcbiAgdmFyIHZhbHVlID0gdXNlTW90aW9uVmFsdWUoaXNNb3Rpb25WYWx1ZShzb3VyY2UpID8gc291cmNlLmdldCgpIDogc291cmNlKTtcbiAgdXNlTWVtbzYoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlLmF0dGFjaChmdW5jdGlvbih2LCBzZXQpIHtcbiAgICAgIGlmIChpc1N0YXRpYylcbiAgICAgICAgcmV0dXJuIHNldCh2KTtcbiAgICAgIGlmIChhY3RpdmVTcHJpbmdBbmltYXRpb24uY3VycmVudCkge1xuICAgICAgICBhY3RpdmVTcHJpbmdBbmltYXRpb24uY3VycmVudC5zdG9wKCk7XG4gICAgICB9XG4gICAgICBhY3RpdmVTcHJpbmdBbmltYXRpb24uY3VycmVudCA9IGFuaW1hdGUoX19hc3NpZ24oX19hc3NpZ24oeyBmcm9tOiB2YWx1ZS5nZXQoKSwgdG86IHYsIHZlbG9jaXR5OiB2YWx1ZS5nZXRWZWxvY2l0eSgpIH0sIGNvbmZpZyksIHsgb25VcGRhdGU6IHNldCB9KSk7XG4gICAgICByZXR1cm4gdmFsdWUuZ2V0KCk7XG4gICAgfSk7XG4gIH0sIE9iamVjdC52YWx1ZXMoY29uZmlnKSk7XG4gIHVzZU9uQ2hhbmdlKHNvdXJjZSwgZnVuY3Rpb24odikge1xuICAgIHJldHVybiB2YWx1ZS5zZXQocGFyc2VGbG9hdCh2KSk7XG4gIH0pO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdXNlLXZlbG9jaXR5LmpzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MTMgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZVZlbG9jaXR5KHZhbHVlKSB7XG4gIHZhciB2ZWxvY2l0eSA9IHVzZU1vdGlvblZhbHVlKHZhbHVlLmdldFZlbG9jaXR5KCkpO1xuICB1c2VFZmZlY3QxMyhmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWUudmVsb2NpdHlVcGRhdGVTdWJzY3JpYmVycy5hZGQoZnVuY3Rpb24obmV3VmVsb2NpdHkpIHtcbiAgICAgIHZlbG9jaXR5LnNldChuZXdWZWxvY2l0eSk7XG4gICAgfSk7XG4gIH0sIFt2YWx1ZV0pO1xuICByZXR1cm4gdmVsb2NpdHk7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvc2Nyb2xsL3V0aWxzLmpzXG5mdW5jdGlvbiBjcmVhdGVTY3JvbGxNb3Rpb25WYWx1ZXMoKSB7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsWDogbW90aW9uVmFsdWUoMCksXG4gICAgc2Nyb2xsWTogbW90aW9uVmFsdWUoMCksXG4gICAgc2Nyb2xsWFByb2dyZXNzOiBtb3Rpb25WYWx1ZSgwKSxcbiAgICBzY3JvbGxZUHJvZ3Jlc3M6IG1vdGlvblZhbHVlKDApXG4gIH07XG59XG5mdW5jdGlvbiBzZXRQcm9ncmVzcyhvZmZzZXQsIG1heE9mZnNldCwgdmFsdWUpIHtcbiAgdmFsdWUuc2V0KCFvZmZzZXQgfHwgIW1heE9mZnNldCA/IDAgOiBvZmZzZXQgLyBtYXhPZmZzZXQpO1xufVxuZnVuY3Rpb24gY3JlYXRlU2Nyb2xsVXBkYXRlcih2YWx1ZXMsIGdldE9mZnNldHMpIHtcbiAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfYSA9IGdldE9mZnNldHMoKSwgeE9mZnNldCA9IF9hLnhPZmZzZXQsIHlPZmZzZXQgPSBfYS55T2Zmc2V0LCB4TWF4T2Zmc2V0ID0gX2EueE1heE9mZnNldCwgeU1heE9mZnNldCA9IF9hLnlNYXhPZmZzZXQ7XG4gICAgdmFsdWVzLnNjcm9sbFguc2V0KHhPZmZzZXQpO1xuICAgIHZhbHVlcy5zY3JvbGxZLnNldCh5T2Zmc2V0KTtcbiAgICBzZXRQcm9ncmVzcyh4T2Zmc2V0LCB4TWF4T2Zmc2V0LCB2YWx1ZXMuc2Nyb2xsWFByb2dyZXNzKTtcbiAgICBzZXRQcm9ncmVzcyh5T2Zmc2V0LCB5TWF4T2Zmc2V0LCB2YWx1ZXMuc2Nyb2xsWVByb2dyZXNzKTtcbiAgfTtcbiAgdXBkYXRlKCk7XG4gIHJldHVybiB1cGRhdGU7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvc2Nyb2xsL3VzZS1lbGVtZW50LXNjcm9sbC5qc1xudmFyIGdldEVsZW1lbnRTY3JvbGxPZmZzZXRzID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHhPZmZzZXQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHlPZmZzZXQ6IGVsZW1lbnQuc2Nyb2xsVG9wLFxuICAgICAgeE1heE9mZnNldDogZWxlbWVudC5zY3JvbGxXaWR0aCAtIGVsZW1lbnQub2Zmc2V0V2lkdGgsXG4gICAgICB5TWF4T2Zmc2V0OiBlbGVtZW50LnNjcm9sbEhlaWdodCAtIGVsZW1lbnQub2Zmc2V0SGVpZ2h0XG4gICAgfTtcbiAgfTtcbn07XG5mdW5jdGlvbiB1c2VFbGVtZW50U2Nyb2xsKHJlZikge1xuICB2YXIgdmFsdWVzID0gdXNlQ29uc3RhbnQoY3JlYXRlU2Nyb2xsTW90aW9uVmFsdWVzKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbigpIHtcbiAgICB2YXIgZWxlbWVudCA9IHJlZi5jdXJyZW50O1xuICAgIGludmFyaWFudCghIWVsZW1lbnQsIFwicmVmIHByb3ZpZGVkIHRvIHVzZVNjcm9sbCBtdXN0IGJlIHBhc3NlZCBpbnRvIGEgSFRNTCBlbGVtZW50LlwiKTtcbiAgICBpZiAoIWVsZW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgdmFyIHVwZGF0ZVNjcm9sbFZhbHVlcyA9IGNyZWF0ZVNjcm9sbFVwZGF0ZXIodmFsdWVzLCBnZXRFbGVtZW50U2Nyb2xsT2Zmc2V0cyhlbGVtZW50KSk7XG4gICAgdmFyIHNjcm9sbExpc3RlbmVyID0gYWRkRG9tRXZlbnQoZWxlbWVudCwgXCJzY3JvbGxcIiwgdXBkYXRlU2Nyb2xsVmFsdWVzLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgdmFyIHJlc2l6ZUxpc3RlbmVyID0gYWRkRG9tRXZlbnQoZWxlbWVudCwgXCJyZXNpemVcIiwgdXBkYXRlU2Nyb2xsVmFsdWVzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBzY3JvbGxMaXN0ZW5lciAmJiBzY3JvbGxMaXN0ZW5lcigpO1xuICAgICAgcmVzaXplTGlzdGVuZXIgJiYgcmVzaXplTGlzdGVuZXIoKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiB2YWx1ZXM7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvc2Nyb2xsL3VzZS12aWV3cG9ydC1zY3JvbGwuanNcbnZhciB2aWV3cG9ydFNjcm9sbFZhbHVlcztcbmZ1bmN0aW9uIGdldFZpZXdwb3J0U2Nyb2xsT2Zmc2V0cygpIHtcbiAgcmV0dXJuIHtcbiAgICB4T2Zmc2V0OiB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgeU9mZnNldDogd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgIHhNYXhPZmZzZXQ6IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGggLSB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICB5TWF4T2Zmc2V0OiBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCAtIHdpbmRvdy5pbm5lckhlaWdodFxuICB9O1xufVxudmFyIGhhc0xpc3RlbmVycyA9IGZhbHNlO1xuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGhhc0xpc3RlbmVycyA9IHRydWU7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKVxuICAgIHJldHVybjtcbiAgdmFyIHVwZGF0ZVNjcm9sbFZhbHVlcyA9IGNyZWF0ZVNjcm9sbFVwZGF0ZXIodmlld3BvcnRTY3JvbGxWYWx1ZXMsIGdldFZpZXdwb3J0U2Nyb2xsT2Zmc2V0cyk7XG4gIGFkZERvbUV2ZW50KHdpbmRvdywgXCJzY3JvbGxcIiwgdXBkYXRlU2Nyb2xsVmFsdWVzLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIGFkZERvbUV2ZW50KHdpbmRvdywgXCJyZXNpemVcIiwgdXBkYXRlU2Nyb2xsVmFsdWVzKTtcbn1cbmZ1bmN0aW9uIHVzZVZpZXdwb3J0U2Nyb2xsKCkge1xuICBpZiAoIXZpZXdwb3J0U2Nyb2xsVmFsdWVzKSB7XG4gICAgdmlld3BvcnRTY3JvbGxWYWx1ZXMgPSBjcmVhdGVTY3JvbGxNb3Rpb25WYWx1ZXMoKTtcbiAgfVxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uKCkge1xuICAgICFoYXNMaXN0ZW5lcnMgJiYgYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfSwgW10pO1xuICByZXR1cm4gdmlld3BvcnRTY3JvbGxWYWx1ZXM7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLXJlZHVjZWQtbW90aW9uLmpzXG5pbXBvcnQgeyB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTQgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBwcmVmZXJzUmVkdWNlZE1vdGlvbjtcbmZ1bmN0aW9uIGluaXRQcmVmZXJzUmVkdWNlZE1vdGlvbigpIHtcbiAgcHJlZmVyc1JlZHVjZWRNb3Rpb24gPSBtb3Rpb25WYWx1ZShudWxsKTtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgcmV0dXJuO1xuICBpZiAod2luZG93Lm1hdGNoTWVkaWEpIHtcbiAgICB2YXIgbW90aW9uTWVkaWFRdWVyeV8xID0gd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbilcIik7XG4gICAgdmFyIHNldFJlZHVjZWRNb3Rpb25QcmVmZXJlbmNlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHByZWZlcnNSZWR1Y2VkTW90aW9uLnNldChtb3Rpb25NZWRpYVF1ZXJ5XzEubWF0Y2hlcyk7XG4gICAgfTtcbiAgICBtb3Rpb25NZWRpYVF1ZXJ5XzEuYWRkTGlzdGVuZXIoc2V0UmVkdWNlZE1vdGlvblByZWZlcmVuY2VzKTtcbiAgICBzZXRSZWR1Y2VkTW90aW9uUHJlZmVyZW5jZXMoKTtcbiAgfSBlbHNlIHtcbiAgICBwcmVmZXJzUmVkdWNlZE1vdGlvbi5zZXQoZmFsc2UpO1xuICB9XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VkTW90aW9uKCkge1xuICAhcHJlZmVyc1JlZHVjZWRNb3Rpb24gJiYgaW5pdFByZWZlcnNSZWR1Y2VkTW90aW9uKCk7XG4gIHZhciBfYSA9IF9fcmVhZCh1c2VTdGF0ZTQocHJlZmVyc1JlZHVjZWRNb3Rpb24uZ2V0KCkpLCAyKSwgc2hvdWxkUmVkdWNlTW90aW9uID0gX2FbMF0sIHNldFNob3VsZFJlZHVjZU1vdGlvbiA9IF9hWzFdO1xuICB1c2VPbkNoYW5nZShwcmVmZXJzUmVkdWNlZE1vdGlvbiwgc2V0U2hvdWxkUmVkdWNlTW90aW9uKTtcbiAgcmV0dXJuIHNob3VsZFJlZHVjZU1vdGlvbjtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vYW5pbWF0aW9uLWNvbnRyb2xzLmpzXG5mdW5jdGlvbiBhbmltYXRpb25Db250cm9scygpIHtcbiAgdmFyIGhhc01vdW50ZWQgPSBmYWxzZTtcbiAgdmFyIHBlbmRpbmdBbmltYXRpb25zID0gW107XG4gIHZhciBzdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbiAgdmFyIGNvbnRyb2xzID0ge1xuICAgIHN1YnNjcmliZTogZnVuY3Rpb24odmlzdWFsRWxlbWVudDIpIHtcbiAgICAgIHN1YnNjcmliZXJzLmFkZCh2aXN1YWxFbGVtZW50Mik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2b2lkIHN1YnNjcmliZXJzLmRlbGV0ZSh2aXN1YWxFbGVtZW50Mik7XG4gICAgICB9O1xuICAgIH0sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKGRlZmluaXRpb24sIHRyYW5zaXRpb25PdmVycmlkZSkge1xuICAgICAgaWYgKGhhc01vdW50ZWQpIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbnNfMSA9IFtdO1xuICAgICAgICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uKHZpc3VhbEVsZW1lbnQyKSB7XG4gICAgICAgICAgYW5pbWF0aW9uc18xLnB1c2goYW5pbWF0ZVZpc3VhbEVsZW1lbnQodmlzdWFsRWxlbWVudDIsIGRlZmluaXRpb24sIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25PdmVycmlkZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChhbmltYXRpb25zXzEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICBwZW5kaW5nQW5pbWF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIGFuaW1hdGlvbjogW2RlZmluaXRpb24sIHRyYW5zaXRpb25PdmVycmlkZV0sXG4gICAgICAgICAgICByZXNvbHZlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihkZWZpbml0aW9uKSB7XG4gICAgICBpbnZhcmlhbnQoaGFzTW91bnRlZCwgXCJjb250cm9scy5zZXQoKSBzaG91bGQgb25seSBiZSBjYWxsZWQgYWZ0ZXIgYSBjb21wb25lbnQgaGFzIG1vdW50ZWQuIENvbnNpZGVyIGNhbGxpbmcgd2l0aGluIGEgdXNlRWZmZWN0IGhvb2suXCIpO1xuICAgICAgcmV0dXJuIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24odmlzdWFsRWxlbWVudDIpIHtcbiAgICAgICAgc2V0VmFsdWVzKHZpc3VhbEVsZW1lbnQyLCBkZWZpbml0aW9uKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uKHZpc3VhbEVsZW1lbnQyKSB7XG4gICAgICAgIHN0b3BBbmltYXRpb24odmlzdWFsRWxlbWVudDIpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBtb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICBoYXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIHBlbmRpbmdBbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24oX2EpIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IF9hLmFuaW1hdGlvbiwgcmVzb2x2ZSA9IF9hLnJlc29sdmU7XG4gICAgICAgIGNvbnRyb2xzLnN0YXJ0LmFwcGx5KGNvbnRyb2xzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYW5pbWF0aW9uKSkpLnRoZW4ocmVzb2x2ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaGFzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICBjb250cm9scy5zdG9wKCk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGNvbnRyb2xzO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi91c2UtYW5pbWF0aW9uLmpzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MTQgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZUFuaW1hdGlvbigpIHtcbiAgdmFyIGNvbnRyb2xzID0gdXNlQ29uc3RhbnQoYW5pbWF0aW9uQ29udHJvbHMpO1xuICB1c2VFZmZlY3QxNChjb250cm9scy5tb3VudCwgW10pO1xuICByZXR1cm4gY29udHJvbHM7XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLWN5Y2xlLmpzXG5pbXBvcnQgeyB1c2VSZWYgYXMgdXNlUmVmOSwgdXNlU3RhdGUgYXMgdXNlU3RhdGU1IH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VDeWNsZSgpIHtcbiAgdmFyIGl0ZW1zID0gW107XG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgaXRlbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgfVxuICB2YXIgaW5kZXggPSB1c2VSZWY5KDApO1xuICB2YXIgX2EgPSBfX3JlYWQodXNlU3RhdGU1KGl0ZW1zW2luZGV4LmN1cnJlbnRdKSwgMiksIGl0ZW0gPSBfYVswXSwgc2V0SXRlbSA9IF9hWzFdO1xuICByZXR1cm4gW1xuICAgIGl0ZW0sXG4gICAgZnVuY3Rpb24obmV4dCkge1xuICAgICAgaW5kZXguY3VycmVudCA9IHR5cGVvZiBuZXh0ICE9PSBcIm51bWJlclwiID8gd3JhcCgwLCBpdGVtcy5sZW5ndGgsIGluZGV4LmN1cnJlbnQgKyAxKSA6IG5leHQ7XG4gICAgICBzZXRJdGVtKGl0ZW1zW2luZGV4LmN1cnJlbnRdKTtcbiAgICB9XG4gIF07XG59XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvZHJhZy91c2UtZHJhZy1jb250cm9scy5qc1xudmFyIERyYWdDb250cm9scyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBEcmFnQ29udHJvbHMyKCkge1xuICAgIHRoaXMuY29tcG9uZW50Q29udHJvbHMgPSBuZXcgU2V0KCk7XG4gIH1cbiAgRHJhZ0NvbnRyb2xzMi5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24oY29udHJvbHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuY29tcG9uZW50Q29udHJvbHMuYWRkKGNvbnRyb2xzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX3RoaXMuY29tcG9uZW50Q29udHJvbHMuZGVsZXRlKGNvbnRyb2xzKTtcbiAgICB9O1xuICB9O1xuICBEcmFnQ29udHJvbHMyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGV2ZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5jb21wb25lbnRDb250cm9scy5mb3JFYWNoKGZ1bmN0aW9uKGNvbnRyb2xzKSB7XG4gICAgICBjb250cm9scy5zdGFydChldmVudC5uYXRpdmVFdmVudCB8fCBldmVudCwgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH07XG4gIERyYWdDb250cm9sczIucHJvdG90eXBlLnVwZGF0ZUNvbnN0cmFpbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jb21wb25lbnRDb250cm9scy5mb3JFYWNoKGZ1bmN0aW9uKGNvbnRyb2xzKSB7XG4gICAgICBjb250cm9scy51cGRhdGVMYXlvdXRNZWFzdXJlbWVudHMoKTtcbiAgICAgIGNvbnRyb2xzLnJlc29sdmVEcmFnQ29uc3RyYWludHMoKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIERyYWdDb250cm9sczI7XG59KCk7XG52YXIgY3JlYXRlRHJhZ0NvbnRyb2xzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgRHJhZ0NvbnRyb2xzKCk7XG59O1xuZnVuY3Rpb24gdXNlRHJhZ0NvbnRyb2xzKCkge1xuICByZXR1cm4gdXNlQ29uc3RhbnQoY3JlYXRlRHJhZ0NvbnRyb2xzKTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vdXNlLWFuaW1hdGVkLXN0YXRlLmpzXG5pbXBvcnQgeyB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTYsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxNSB9IGZyb20gXCJyZWFjdFwiO1xudmFyIGNyZWF0ZU9iamVjdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge307XG59O1xudmFyIHN0YXRlVmlzdWFsRWxlbWVudCA9IHZpc3VhbEVsZW1lbnQoe1xuICBidWlsZDogZnVuY3Rpb24oKSB7XG4gIH0sXG4gIG1lYXN1cmVWaWV3cG9ydEJveDogYXhpc0JveCxcbiAgcmVzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xuICB9LFxuICByZXN0b3JlVHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgfSxcbiAgcmVtb3ZlVmFsdWVGcm9tUmVuZGVyU3RhdGU6IGZ1bmN0aW9uKCkge1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICB9LFxuICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHM6IGNyZWF0ZU9iamVjdCxcbiAgcmVhZFZhbHVlRnJvbUluc3RhbmNlOiBmdW5jdGlvbihfc3RhdGUsIGtleTYsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5pbml0aWFsU3RhdGVba2V5Nl0gfHwgMDtcbiAgfSxcbiAgbWFrZVRhcmdldEFuaW1hdGFibGU6IGZ1bmN0aW9uKGVsZW1lbnQsIF9hKSB7XG4gICAgdmFyIHRyYW5zaXRpb24gPSBfYS50cmFuc2l0aW9uLCB0cmFuc2l0aW9uRW5kID0gX2EudHJhbnNpdGlvbkVuZCwgdGFyZ2V0ID0gX19yZXN0KF9hLCBbXCJ0cmFuc2l0aW9uXCIsIFwidHJhbnNpdGlvbkVuZFwiXSk7XG4gICAgdmFyIG9yaWdpbiA9IGdldE9yaWdpbih0YXJnZXQsIHRyYW5zaXRpb24gfHwge30sIGVsZW1lbnQpO1xuICAgIGNoZWNrVGFyZ2V0Rm9yTmV3VmFsdWVzKGVsZW1lbnQsIHRhcmdldCwgb3JpZ2luKTtcbiAgICByZXR1cm4gX19hc3NpZ24oeyB0cmFuc2l0aW9uLCB0cmFuc2l0aW9uRW5kIH0sIHRhcmdldCk7XG4gIH1cbn0pO1xudmFyIHVzZVZpc3VhbFN0YXRlID0gbWFrZVVzZVZpc3VhbFN0YXRlKHtcbiAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzOiBjcmVhdGVPYmplY3QsXG4gIGNyZWF0ZVJlbmRlclN0YXRlOiBjcmVhdGVPYmplY3Rcbn0pO1xuZnVuY3Rpb24gdXNlQW5pbWF0ZWRTdGF0ZShpbml0aWFsU3RhdGUyKSB7XG4gIHZhciBfYSA9IF9fcmVhZCh1c2VTdGF0ZTYoaW5pdGlhbFN0YXRlMiksIDIpLCBhbmltYXRpb25TdGF0ZSA9IF9hWzBdLCBzZXRBbmltYXRpb25TdGF0ZSA9IF9hWzFdO1xuICB2YXIgdmlzdWFsU3RhdGUgPSB1c2VWaXN1YWxTdGF0ZSh7fSwgZmFsc2UpO1xuICB2YXIgZWxlbWVudCA9IHVzZUNvbnN0YW50KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzdGF0ZVZpc3VhbEVsZW1lbnQoeyBwcm9wczoge30sIHZpc3VhbFN0YXRlIH0sIHsgaW5pdGlhbFN0YXRlOiBpbml0aWFsU3RhdGUyIH0pO1xuICB9KTtcbiAgdXNlRWZmZWN0MTUoZnVuY3Rpb24oKSB7XG4gICAgZWxlbWVudC5tb3VudCh7fSk7XG4gICAgcmV0dXJuIGVsZW1lbnQudW5tb3VudCgpO1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdDE1KGZ1bmN0aW9uKCkge1xuICAgIGVsZW1lbnQuc2V0UHJvcHMoe1xuICAgICAgb25VcGRhdGU6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIHNldEFuaW1hdGlvblN0YXRlKF9fYXNzaWduKHt9LCB2KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICB2YXIgc3RhcnRBbmltYXRpb24zID0gdXNlQ29uc3RhbnQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFuaW1hdGlvbkRlZmluaXRpb24pIHtcbiAgICAgIHJldHVybiBhbmltYXRlVmlzdWFsRWxlbWVudChlbGVtZW50LCBhbmltYXRpb25EZWZpbml0aW9uKTtcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIFthbmltYXRpb25TdGF0ZSwgc3RhcnRBbmltYXRpb24zXTtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS91c2UtaW52ZXJ0ZWQtc2NhbGUuanNcbnZhciBtYXhTY2FsZSA9IDFlNTtcbnZhciBpbnZlcnRTY2FsZSA9IGZ1bmN0aW9uKHNjYWxlMikge1xuICByZXR1cm4gc2NhbGUyID4gMWUtMyA/IDEgLyBzY2FsZTIgOiBtYXhTY2FsZTtcbn07XG52YXIgaGFzV2FybmVkID0gZmFsc2U7XG5mdW5jdGlvbiB1c2VJbnZlcnRlZFNjYWxlKHNjYWxlMikge1xuICB2YXIgcGFyZW50U2NhbGVYID0gdXNlTW90aW9uVmFsdWUoMSk7XG4gIHZhciBwYXJlbnRTY2FsZVkgPSB1c2VNb3Rpb25WYWx1ZSgxKTtcbiAgdmFyIHZpc3VhbEVsZW1lbnQyID0gdXNlVmlzdWFsRWxlbWVudENvbnRleHQoKTtcbiAgaW52YXJpYW50KCEhKHNjYWxlMiB8fCB2aXN1YWxFbGVtZW50MiksIFwiSWYgbm8gc2NhbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgdXNlSW52ZXJ0ZWRTY2FsZSBtdXN0IGJlIHVzZWQgd2l0aGluIGEgY2hpbGQgb2YgYW5vdGhlciBtb3Rpb24gY29tcG9uZW50LlwiKTtcbiAgd2FybmluZyhoYXNXYXJuZWQsIFwidXNlSW52ZXJ0ZWRTY2FsZSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gMy4wLiBVc2UgdGhlIGxheW91dCBwcm9wIGluc3RlYWQuXCIpO1xuICBoYXNXYXJuZWQgPSB0cnVlO1xuICBpZiAoc2NhbGUyKSB7XG4gICAgcGFyZW50U2NhbGVYID0gc2NhbGUyLnNjYWxlWCB8fCBwYXJlbnRTY2FsZVg7XG4gICAgcGFyZW50U2NhbGVZID0gc2NhbGUyLnNjYWxlWSB8fCBwYXJlbnRTY2FsZVk7XG4gIH0gZWxzZSBpZiAodmlzdWFsRWxlbWVudDIpIHtcbiAgICBwYXJlbnRTY2FsZVggPSB2aXN1YWxFbGVtZW50Mi5nZXRWYWx1ZShcInNjYWxlWFwiLCAxKTtcbiAgICBwYXJlbnRTY2FsZVkgPSB2aXN1YWxFbGVtZW50Mi5nZXRWYWx1ZShcInNjYWxlWVwiLCAxKTtcbiAgfVxuICB2YXIgc2NhbGVYID0gdXNlVHJhbnNmb3JtKHBhcmVudFNjYWxlWCwgaW52ZXJ0U2NhbGUpO1xuICB2YXIgc2NhbGVZID0gdXNlVHJhbnNmb3JtKHBhcmVudFNjYWxlWSwgaW52ZXJ0U2NhbGUpO1xuICByZXR1cm4geyBzY2FsZVgsIHNjYWxlWSB9O1xufVxuXG4vLyBzcmMvYW5pbWF0aW9uL01vdGlvbi9hZGRDaGlsZEhhY2sudHNcbk1vdGlvblZhbHVlLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uKHsgdHJhbnNmb3JtZXIgPSAodikgPT4gdiB9KSB7XG4gIGNvbnN0IGNoaWxkID0gbmV3IE1vdGlvblZhbHVlKHRyYW5zZm9ybWVyKHRoaXMuZ2V0KCkpKTtcbiAgdGhpcy5vbkNoYW5nZSgodikgPT4gY2hpbGQuc2V0KHRyYW5zZm9ybWVyKHYpKSk7XG4gIHJldHVybiBjaGlsZDtcbn07XG5cbi8vIHNyYy9jb21wb25lbnRzL1Njcm9sbC9TY3JvbGwudHN4XG5pbXBvcnQge1xuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQyNSxcbiAgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmNlxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3JlbmRlci90eXBlcy9Qcm9wZXJ0eUNvbnRyb2xzLnRzXG52YXIgQ29udHJvbFR5cGU7XG4oZnVuY3Rpb24oQ29udHJvbFR5cGUyKSB7XG4gIENvbnRyb2xUeXBlMltcIkJvb2xlYW5cIl0gPSBcImJvb2xlYW5cIjtcbiAgQ29udHJvbFR5cGUyW1wiTnVtYmVyXCJdID0gXCJudW1iZXJcIjtcbiAgQ29udHJvbFR5cGUyW1wiU3RyaW5nXCJdID0gXCJzdHJpbmdcIjtcbiAgQ29udHJvbFR5cGUyW1wiRnVzZWROdW1iZXJcIl0gPSBcImZ1c2VkbnVtYmVyXCI7XG4gIENvbnRyb2xUeXBlMltcIkVudW1cIl0gPSBcImVudW1cIjtcbiAgQ29udHJvbFR5cGUyW1wiU2VnbWVudGVkRW51bVwiXSA9IFwic2VnbWVudGVkZW51bVwiO1xuICBDb250cm9sVHlwZTJbXCJDb2xvclwiXSA9IFwiY29sb3JcIjtcbiAgQ29udHJvbFR5cGUyW1wiSW1hZ2VcIl0gPSBcImltYWdlXCI7XG4gIENvbnRyb2xUeXBlMltcIkZpbGVcIl0gPSBcImZpbGVcIjtcbiAgQ29udHJvbFR5cGUyW1wiQ29tcG9uZW50SW5zdGFuY2VcIl0gPSBcImNvbXBvbmVudGluc3RhbmNlXCI7XG4gIENvbnRyb2xUeXBlMltcIkFycmF5XCJdID0gXCJhcnJheVwiO1xuICBDb250cm9sVHlwZTJbXCJFdmVudEhhbmRsZXJcIl0gPSBcImV2ZW50aGFuZGxlclwiO1xuICBDb250cm9sVHlwZTJbXCJUcmFuc2l0aW9uXCJdID0gXCJ0cmFuc2l0aW9uXCI7XG4gIENvbnRyb2xUeXBlMltcIk9iamVjdFwiXSA9IFwib2JqZWN0XCI7XG59KShDb250cm9sVHlwZSB8fCAoQ29udHJvbFR5cGUgPSB7fSkpO1xuXG4vLyBzcmMvdXRpbHMvYWRkUHJvcGVydHlDb250cm9scy50c1xuZnVuY3Rpb24gYWRkUHJvcGVydHlDb250cm9scyhjb21wb25lbnQsIHByb3BlcnR5Q29udHJvbHMpIHtcbiAgT2JqZWN0LmFzc2lnbihjb21wb25lbnQsIHsgcHJvcGVydHlDb250cm9scyB9KTtcbn1cbmZ1bmN0aW9uIGdldFByb3BlcnR5Q29udHJvbHMoY29tcG9uZW50KSB7XG4gIHJldHVybiBjb21wb25lbnQucHJvcGVydHlDb250cm9scztcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvU2Nyb2xsL0VtdWxhdGVkU2Nyb2xsLnRzeFxuaW1wb3J0IHtcbiAgQ2hpbGRyZW4gYXMgQ2hpbGRyZW42LFxuICBjbG9uZUVsZW1lbnQgYXMgY2xvbmVFbGVtZW50NCxcbiAgY3JlYXRlRWxlbWVudCBhcyBjcmVhdGVFbGVtZW50MjMsXG4gIGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjQsXG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrNixcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDE3LFxuICB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0NVxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZU1lbW8gYXMgdXNlTWVtbzEwLCB1c2VSZWYgYXMgdXNlUmVmMTYsIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrNyB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvcmVuZGVyL3ByZXNlbnRhdGlvbi9GcmFtZS9GcmFtZVdpdGhNb3Rpb24udHN4XG52YXIgaW1wb3J0X2lzX3Byb3BfdmFsaWQgPSBfX3RvTW9kdWxlKHJlcXVpcmVfaXNfcHJvcF92YWxpZF9icm93c2VyX2NqcygpKTtcbmltcG9ydCB7XG4gIENoaWxkcmVuIGFzIENoaWxkcmVuMyxcbiAgRnJhZ21lbnQgYXMgRnJhZ21lbnQ1LFxuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQxNVxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjIsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDIwLCB1c2VSZWYgYXMgdXNlUmVmMTQgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3V0aWxzL3NhZmVXaW5kb3cudHNcbnZhciBtb2NrV2luZG93ID0ge1xuICBhZGRFdmVudExpc3RlbmVyOiAoKSA9PiB7XG4gIH0sXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXI6ICgpID0+IHtcbiAgfSxcbiAgZGlzcGF0Y2hFdmVudDogKCkgPT4gZmFsc2UsXG4gIG9ucG9pbnRlcmRvd246IGZhbHNlLFxuICBvbnBvaW50ZXJtb3ZlOiBmYWxzZSxcbiAgb25wb2ludGVydXA6IGZhbHNlLFxuICBvbnRvdWNoc3RhcnQ6IGZhbHNlLFxuICBvbnRvdWNobW92ZTogZmFsc2UsXG4gIG9udG91Y2hlbmQ6IGZhbHNlLFxuICBvbm1vdXNlZG93bjogZmFsc2UsXG4gIG9ubW91c2Vtb3ZlOiBmYWxzZSxcbiAgb25tb3VzZXVwOiBmYWxzZSxcbiAgZGV2aWNlUGl4ZWxSYXRpbzogMSxcbiAgc2Nyb2xsWDogMCxcbiAgc2Nyb2xsWTogMCxcbiAgbG9jYXRpb246IHtcbiAgICBocmVmOiBcIlwiXG4gIH0sXG4gIHNldFRpbWVvdXQ6ICgpID0+IDAsXG4gIGNsZWFyVGltZW91dDogKCkgPT4ge1xuICB9LFxuICBzZXRJbnRlcnZhbDogKCkgPT4gMCxcbiAgY2xlYXJJbnRlcnZhbDogKCkgPT4ge1xuICB9LFxuICB3ZWJraXRDb252ZXJ0UG9pbnRGcm9tUGFnZVRvTm9kZTogKF8sIHB0KSA9PiBwdFxufTtcbnZhciBzYWZlV2luZG93ID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IG1vY2tXaW5kb3cgOiB3aW5kb3c7XG5cbi8vIHNyYy9yZW5kZXIvc3R5bGUvQm9yZGVyQ29tcG9uZW50LnRzeFxuaW1wb3J0IHtcbiAgY3JlYXRlRWxlbWVudCBhcyBjcmVhdGVFbGVtZW50MTBcbn0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBjb2xsZWN0Qm9yZGVyU3R5bGVGb3JQcm9wcyhwcm9wcywgc3R5bGUsIGNvbGxhcHNlRXF1YWxCb3JkZXJzID0gdHJ1ZSkge1xuICBjb25zdCB7IGJvcmRlcldpZHRoLCBib3JkZXJTdHlsZSwgYm9yZGVyQ29sb3IgfSA9IHByb3BzO1xuICBpZiAoIWJvcmRlcldpZHRoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBib3JkZXJUb3A7XG4gIGxldCBib3JkZXJCb3R0b207XG4gIGxldCBib3JkZXJMZWZ0O1xuICBsZXQgYm9yZGVyUmlnaHQ7XG4gIGlmICh0eXBlb2YgYm9yZGVyV2lkdGggPT09IFwibnVtYmVyXCIpIHtcbiAgICBib3JkZXJUb3AgPSBib3JkZXJCb3R0b20gPSBib3JkZXJMZWZ0ID0gYm9yZGVyUmlnaHQgPSBib3JkZXJXaWR0aDtcbiAgfSBlbHNlIHtcbiAgICBib3JkZXJUb3AgPSBib3JkZXJXaWR0aC50b3AgfHwgMDtcbiAgICBib3JkZXJCb3R0b20gPSBib3JkZXJXaWR0aC5ib3R0b20gfHwgMDtcbiAgICBib3JkZXJMZWZ0ID0gYm9yZGVyV2lkdGgubGVmdCB8fCAwO1xuICAgIGJvcmRlclJpZ2h0ID0gYm9yZGVyV2lkdGgucmlnaHQgfHwgMDtcbiAgfVxuICBpZiAoYm9yZGVyVG9wID09PSAwICYmIGJvcmRlckJvdHRvbSA9PT0gMCAmJiBib3JkZXJMZWZ0ID09PSAwICYmIGJvcmRlclJpZ2h0ID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChjb2xsYXBzZUVxdWFsQm9yZGVycyAmJiBib3JkZXJUb3AgPT09IGJvcmRlckJvdHRvbSAmJiBib3JkZXJUb3AgPT09IGJvcmRlckxlZnQgJiYgYm9yZGVyVG9wID09PSBib3JkZXJSaWdodCkge1xuICAgIHN0eWxlLmJvcmRlciA9IGAke2JvcmRlclRvcH1weCAke2JvcmRlclN0eWxlfSAke2JvcmRlckNvbG9yfWA7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN0eWxlLmJvcmRlclN0eWxlID0gcHJvcHMuYm9yZGVyU3R5bGU7XG4gIHN0eWxlLmJvcmRlckNvbG9yID0gcHJvcHMuYm9yZGVyQ29sb3I7XG4gIHN0eWxlLmJvcmRlclRvcFdpZHRoID0gYCR7Ym9yZGVyVG9wfXB4YDtcbiAgc3R5bGUuYm9yZGVyQm90dG9tV2lkdGggPSBgJHtib3JkZXJCb3R0b219cHhgO1xuICBzdHlsZS5ib3JkZXJMZWZ0V2lkdGggPSBgJHtib3JkZXJMZWZ0fXB4YDtcbiAgc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCA9IGAke2JvcmRlclJpZ2h0fXB4YDtcbn1cbmZ1bmN0aW9uIEJvcmRlcihwcm9wcykge1xuICBjb25zdCBsYXlvdXRJZCA9IHByb3BzLmxheW91dElkID8gYCR7cHJvcHMubGF5b3V0SWR9LWJvcmRlcmAgOiB2b2lkIDA7XG4gIGlmICghcHJvcHMuYm9yZGVyV2lkdGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBzdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIGxlZnQ6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBib3JkZXJSYWRpdXM6IFwiaW5oZXJpdFwiLFxuICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gIH07XG4gIGlmIChwcm9wcy5ib3JkZXIpIHtcbiAgICA7XG4gICAgc3R5bGUuYm9yZGVyID0gcHJvcHMuYm9yZGVyO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDEwKG1vdGlvbi5kaXYsIHtcbiAgICAgIHN0eWxlXG4gICAgfSk7XG4gIH1cbiAgY29sbGVjdEJvcmRlclN0eWxlRm9yUHJvcHMocHJvcHMsIHN0eWxlLCBmYWxzZSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDEwKG1vdGlvbi5kaXYsIHtcbiAgICBcImRhdGEtZnJhbWUtYm9yZGVyXCI6IHRydWUsXG4gICAgc3R5bGUsXG4gICAgbGF5b3V0SWRcbiAgfSk7XG59XG5cbi8vIHNyYy9yZW5kZXIvdHlwZXMvQmFja2dyb3VuZEltYWdlLnRzXG52YXIga2V5ID0gXCJzcmNcIjtcbnZhciBCYWNrZ3JvdW5kSW1hZ2U7XG4oZnVuY3Rpb24oQmFja2dyb3VuZEltYWdlMikge1xuICBCYWNrZ3JvdW5kSW1hZ2UyLmlzSW1hZ2VPYmplY3QgPSBmdW5jdGlvbihpbWFnZSkge1xuICAgIGlmICghaW1hZ2UgfHwgdHlwZW9mIGltYWdlID09PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBrZXkgaW4gaW1hZ2U7XG4gIH07XG59KShCYWNrZ3JvdW5kSW1hZ2UgfHwgKEJhY2tncm91bmRJbWFnZSA9IHt9KSk7XG5cbi8vIHNyYy9hbmltYXRpb24vQW5pbWF0YWJsZS9PYnNlcnZlcnMudHNcbnZhciBPYnNlcnZlcnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMub2JzZXJ2ZXJzID0gbmV3IFNldCgpO1xuICAgIHRoaXMudHJhbnNhY3Rpb25zID0ge307XG4gIH1cbiAgYWRkKG9ic2VydmVyKSB7XG4gICAgdGhpcy5vYnNlcnZlcnMuYWRkKG9ic2VydmVyKTtcbiAgICBsZXQgaXNDYWxsZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVtb3ZlKG9ic2VydmVyKTtcbiAgICB9O1xuICB9XG4gIHJlbW92ZShvYnNlcnZlcikge1xuICAgIHRoaXMub2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlcik7XG4gIH1cbiAgbm90aWZ5KGNoYW5nZSwgdHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24pIHtcbiAgICAgIGNvbnN0IGFjY3VtdWxhdGVkQ2hhbmdlID0gdGhpcy50cmFuc2FjdGlvbnNbdHJhbnNhY3Rpb25dIHx8IGNoYW5nZTtcbiAgICAgIGFjY3VtdWxhdGVkQ2hhbmdlLnZhbHVlID0gY2hhbmdlLnZhbHVlO1xuICAgICAgdGhpcy50cmFuc2FjdGlvbnNbdHJhbnNhY3Rpb25dID0gYWNjdW11bGF0ZWRDaGFuZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2FsbE9ic2VydmVycyhjaGFuZ2UpO1xuICAgIH1cbiAgfVxuICBmaW5pc2hUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgIGNvbnN0IGFjY3VtdWxhdGVkQ2hhbmdlID0gdGhpcy50cmFuc2FjdGlvbnNbdHJhbnNhY3Rpb25dO1xuICAgIGRlbGV0ZSB0aGlzLnRyYW5zYWN0aW9uc1t0cmFuc2FjdGlvbl07XG4gICAgcmV0dXJuIHRoaXMuY2FsbE9ic2VydmVycyhhY2N1bXVsYXRlZENoYW5nZSwgdHJhbnNhY3Rpb24pO1xuICB9XG4gIGNhbGxPYnNlcnZlcnMoY2hhbmdlLCB0cmFuc2FjdGlvbikge1xuICAgIGNvbnN0IGZpbmlzaE9ic2VydmVycyA9IFtdO1xuICAgIG5ldyBTZXQodGhpcy5vYnNlcnZlcnMpLmZvckVhY2goKG9ic2VydmVyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9ic2VydmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgb2JzZXJ2ZXIoY2hhbmdlLCB0cmFuc2FjdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYnNlcnZlci51cGRhdGUoY2hhbmdlLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIGZpbmlzaE9ic2VydmVycy5wdXNoKG9ic2VydmVyLmZpbmlzaCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbmlzaE9ic2VydmVycztcbiAgfVxufTtcblxuLy8gLi4vc2hhcmVkL3NyYy9hc3NlcnQudHNcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIC4uLm1zZzIpIHtcbiAgaWYgKGNvbmRpdGlvbilcbiAgICByZXR1cm47XG4gIGNvbnN0IGUgPSBFcnJvcihcIkFzc2VydGlvbiBFcnJvclwiICsgKG1zZzIubGVuZ3RoID4gMCA/IFwiOiBcIiArIG1zZzIuam9pbihcIiBcIikgOiBcIlwiKSk7XG4gIGlmIChlLnN0YWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGxpbmVzID0gZS5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgIGlmIChsaW5lc1sxXS5pbmNsdWRlcyhcImFzc2VydFwiKSkge1xuICAgICAgICBsaW5lcy5zcGxpY2UoMSwgMSk7XG4gICAgICAgIGUuc3RhY2sgPSBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgICAgfSBlbHNlIGlmIChsaW5lc1swXS5pbmNsdWRlcyhcImFzc2VydFwiKSkge1xuICAgICAgICBsaW5lcy5zcGxpY2UoMCwgMSk7XG4gICAgICAgIGUuc3RhY2sgPSBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICB0aHJvdyBlO1xufVxuXG4vLyAuLi9zaGFyZWQvc3JjL3dhcm5PbmNlLnRzXG52YXIgd2FybmluZ01lc3NhZ2VzID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gd2Fybk9uY2Uoa2V5TWVzc2FnZSwgLi4ucmVzdCkge1xuICBpZiAod2FybmluZ01lc3NhZ2VzLmhhcyhrZXlNZXNzYWdlKSlcbiAgICByZXR1cm47XG4gIHdhcm5pbmdNZXNzYWdlcy5hZGQoa2V5TWVzc2FnZSk7XG4gIGNvbnNvbGUud2FybihrZXlNZXNzYWdlLCAuLi5yZXN0KTtcbn1cblxuLy8gLi4vc2hhcmVkL3NyYy9kZXByZWNhdGlvbi50c1xuZnVuY3Rpb24gZGVwcmVjYXRpb25XYXJuaW5nKHJlbW92ZWRJdGVtLCByZW1vdmFsVmVyc2lvbiwgcmVwbGFjZW1lbnQpIHtcbiAgY29uc3QgcmVwbGFjZW1lbnRUZXh0ID0gcmVwbGFjZW1lbnQgPyBgLCB1c2UgJHtyZXBsYWNlbWVudH0gaW5zdGVhZGAgOiBcIlwiO1xuICBjb25zdCB3YXJuaW5nVGV4dCA9IGBEZXByZWNhdGlvbiB3YXJuaW5nOiAke3JlbW92ZWRJdGVtfSB3aWxsIGJlIHJlbW92ZWQgaW4gdmVyc2lvbiAke3JlbW92YWxWZXJzaW9ufSR7cmVwbGFjZW1lbnRUZXh0fS5gO1xuICB3YXJuT25jZSh3YXJuaW5nVGV4dCk7XG59XG5cbi8vIC4uL3NoYXJlZC9zcmMvZXJyb3JzLnRzXG52YXIgZXJyb3JSZXBvcnRlcjtcbmZ1bmN0aW9uIHJlcG9ydEVycm9yKHtcbiAgZXJyb3I6IG1heWJlRXJyb3IsXG4gIHRhZ3MsXG4gIGV4dHJhcyxcbiAgY2FsbGVyXG59KSB7XG4gIGFzc2VydChlcnJvclJlcG9ydGVyLCBcIlNldCB1cCBhbiBlcnJvciBjYWxsYmFjayB3aXRoIHNldEVycm9yUmVwb3J0ZXIsIG9yIGNvbmZpZ3VyZSBTZW50cnkgd2l0aCBpbml0aWFsaXplRW52aXJvbm1lbnRcIik7XG4gIGNvbnN0IGVycm9yID0gcmVwb3J0YWJsZUVycm9yKG1heWJlRXJyb3IsIGNhbGxlcik7XG4gIGVycm9yUmVwb3J0ZXIoeyBlcnJvciwgdGFnczogeyAuLi5lcnJvci50YWdzLCAuLi50YWdzIH0sIGV4dHJhczogeyAuLi5lcnJvci5leHRyYXMsIC4uLmV4dHJhcyB9IH0pO1xuICByZXR1cm4gZXJyb3I7XG59XG5mdW5jdGlvbiByZXBvcnRhYmxlRXJyb3IoZXJyb3IsIGNhbGxlcikge1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICByZXR1cm4gbmV3IFVuaGFuZGxlZEVycm9yKGVycm9yLCBjYWxsZXIpO1xufVxudmFyIFVuaGFuZGxlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGVycm9yLCBjYWxsZXIpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IgPyBKU09OLnN0cmluZ2lmeShlcnJvcikgOiBcIk5vIGVycm9yIG1lc3NhZ2UgcHJvdmlkZWRcIjtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIGlmIChjYWxsZXIgJiYgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGNhbGxlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLnN0YWNrID0gZS5zdGFjaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIC4uL3NoYXJlZC9zcmMvU2VydmljZU1hcC50c1xudmFyIGNhY2hlZFNlcnZpY2VNYXA7XG5mdW5jdGlvbiBnZXRTZXJ2aWNlTWFwKCkge1xuICBpZiAoY2FjaGVkU2VydmljZU1hcClcbiAgICByZXR1cm4gY2FjaGVkU2VydmljZU1hcDtcbiAgY2FjaGVkU2VydmljZU1hcCA9IGV4dHJhY3RTZXJ2aWNlTWFwKCk7XG4gIHJldHVybiBjYWNoZWRTZXJ2aWNlTWFwO1xufVxuZnVuY3Rpb24gZXh0cmFjdFNlcnZpY2VNYXAoKSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICBjb25zdCBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgbGV0IHNlcnZpY2VzID0gKF9hID0gd2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cuYm9vdHN0cmFwKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2VydmljZXM7XG4gIGlmIChzZXJ2aWNlcykge1xuICAgIHJldHVybiBzZXJ2aWNlcztcbiAgfVxuICBsZXQgdG9wT3JpZ2luO1xuICB0cnkge1xuICAgIGNvbnN0IHRvcFdpbmRvdyA9IHdpbmRvdy50b3A7XG4gICAgdG9wT3JpZ2luID0gdG9wV2luZG93LmxvY2F0aW9uLm9yaWdpbjtcbiAgICBzZXJ2aWNlcyA9IChfYyA9IChfYiA9IHdpbmRvdy50b3ApID09IG51bGwgPyB2b2lkIDAgOiBfYi5ib290c3RyYXApID09IG51bGwgPyB2b2lkIDAgOiBfYy5zZXJ2aWNlcztcbiAgICBpZiAoc2VydmljZXMpIHtcbiAgICAgIHJldHVybiBzZXJ2aWNlcztcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICBpZiAodG9wT3JpZ2luICYmIHRvcE9yaWdpbiAhPT0gbG9jYXRpb24ub3JpZ2luKSB7XG4gICAgdGhyb3cgRXJyb3IoYFVuZXhwZWN0ZWRseSBlbWJlZGRlZCBieSAke3RvcE9yaWdpbn0gKGV4cGVjdGVkICR7bG9jYXRpb24ub3JpZ2lufSlgKTtcbiAgfVxuICBpZiAobG9jYXRpb24ub3JpZ2luLmVuZHNXaXRoKFwiZnJhbWVyLmNvbVwiKSB8fCBsb2NhdGlvbi5vcmlnaW4uZW5kc1dpdGgoXCJmcmFtZXIuZGV2XCIpKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJTZXJ2aWNlTWFwIGRhdGEgd2FzIG5vdCBwcm92aWRlZCBpbiBkb2N1bWVudFwiKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHNlcnZpY2VzSlNPTiA9IG5ldyBVUkxTZWFyY2hQYXJhbXMobG9jYXRpb24uc2VhcmNoKS5nZXQoXCJzZXJ2aWNlc1wiKSB8fCBuZXcgVVJMU2VhcmNoUGFyYW1zKGxvY2F0aW9uLmhhc2guc3Vic3RyaW5nKDEpKS5nZXQoXCJzZXJ2aWNlc1wiKTtcbiAgICBpZiAoc2VydmljZXNKU09OKSB7XG4gICAgICBzZXJ2aWNlcyA9IEpTT04ucGFyc2Uoc2VydmljZXNKU09OKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICBpZiAoc2VydmljZXMgJiYgdHlwZW9mIHNlcnZpY2VzID09PSBcIm9iamVjdFwiICYmIHNlcnZpY2VzLmFwaSkge1xuICAgIHJldHVybiBzZXJ2aWNlcztcbiAgfVxuICB0aHJvdyBFcnJvcihcIlNlcnZpY2VNYXAgcmVxdWVzdGVkIGJ1dCBub3QgYXZhaWxhYmxlXCIpO1xufVxuXG4vLyAuLi9zaGFyZWQvc3JjL2xvZ2dlci50c1xuZnVuY3Rpb24ganNvblNhZmVDb3B5KG9iaiwgZGVwdGggPSAwLCBzZWVuID0gbmV3IFNldCgpKSB7XG4gIHZhciBfYSwgX2I7XG4gIGlmIChvYmogPT09IG51bGwpXG4gICAgcmV0dXJuIG9iajtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiBvYmo7XG4gIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIGBbRnVuY3Rpb246ICR7KF9hID0gb2JqLm5hbWUpICE9IG51bGwgPyBfYSA6IFwidW5rbm93blwifV1gO1xuICBpZiAodHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gb2JqO1xuICBpZiAob2JqIGluc3RhbmNlb2YgRXJyb3IpXG4gICAgcmV0dXJuIGBbJHtvYmoudG9TdHJpbmcoKX1dYDtcbiAgaWYgKHNlZW4uaGFzKG9iaikpXG4gICAgcmV0dXJuIFwiW0NpcmN1bGFyXVwiO1xuICBpZiAoZGVwdGggPiAyKVxuICAgIHJldHVybiBcIi4uLlwiO1xuICBzZWVuLmFkZChvYmopO1xuICB0cnkge1xuICAgIGlmICh0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4ganNvblNhZmVDb3B5KG9iai50b0pTT04oKSwgZGVwdGggKyAxLCBzZWVuKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgcmV0dXJuIG9iai5tYXAoKHYpID0+IGpzb25TYWZlQ29weSh2LCBkZXB0aCArIDEsIHNlZW4pKTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopICE9PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gYFtPYmplY3Q6ICR7b2JqLl9fY2xhc3MgfHwgKChfYiA9IG9iai5jb25zdHJ1Y3RvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm5hbWUpfV1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgW2tleTYsIHZdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICAgICAgcmVzdWx0W2tleTZdID0ganNvblNhZmVDb3B5KHYsIGRlcHRoICsgMSwgc2Vlbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBgW1Rocm93czogJHtlLm1lc3NhZ2V9XWA7XG4gIH0gZmluYWxseSB7XG4gICAgc2Vlbi5kZWxldGUob2JqKTtcbiAgfVxufVxudmFyIExvZ0xldmVsO1xuKGZ1bmN0aW9uKExvZ0xldmVsMikge1xuICBMb2dMZXZlbDJbTG9nTGV2ZWwyW1wiVHJhY2VcIl0gPSAwXSA9IFwiVHJhY2VcIjtcbiAgTG9nTGV2ZWwyW0xvZ0xldmVsMltcIkRlYnVnXCJdID0gMV0gPSBcIkRlYnVnXCI7XG4gIExvZ0xldmVsMltMb2dMZXZlbDJbXCJJbmZvXCJdID0gMl0gPSBcIkluZm9cIjtcbiAgTG9nTGV2ZWwyW0xvZ0xldmVsMltcIldhcm5cIl0gPSAzXSA9IFwiV2FyblwiO1xuICBMb2dMZXZlbDJbTG9nTGV2ZWwyW1wiRXJyb3JcIl0gPSA0XSA9IFwiRXJyb3JcIjtcbiAgTG9nTGV2ZWwyW0xvZ0xldmVsMltcIk5vdExvZ2dpbmdcIl0gPSA1XSA9IFwiTm90TG9nZ2luZ1wiO1xufSkoTG9nTGV2ZWwgfHwgKExvZ0xldmVsID0ge30pKTtcbnZhciBsZXZlbE5hbWVzID0gW1widHJhY2VcIiwgXCJkZWJ1Z1wiLCBcImluZm9cIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIl07XG52YXIgcG9zdGZpeE5hbWVzID0gW1wiOnRyYWNlXCIsIFwiOmRlYnVnXCIsIFwiOmluZm9cIiwgXCI6d2FyblwiLCBcIjplcnJvclwiXTtcbmZ1bmN0aW9uIGFwcGx5TG9nTGV2ZWxTcGVjKHNwZWMsIGFsbCkge1xuICBmb3IgKGNvbnN0IHMgb2Ygc3BlYy5zcGxpdCgvWyAsXS8pKSB7XG4gICAgbGV0IG1hdGNoID0gcy50cmltKCk7XG4gICAgaWYgKG1hdGNoLmxlbmd0aCA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuICAgIGxldCBsZXZlbCA9IDE7XG4gICAgbGV0IGludmVydGVkID0gZmFsc2U7XG4gICAgaWYgKG1hdGNoLnN0YXJ0c1dpdGgoXCItXCIpKSB7XG4gICAgICBtYXRjaCA9IG1hdGNoLnNsaWNlKDEpO1xuICAgICAgbGV2ZWwgPSAzO1xuICAgICAgaW52ZXJ0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSA0OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvc3RmaXggPSBwb3N0Zml4TmFtZXNbaV07XG4gICAgICBpZiAobWF0Y2guZW5kc1dpdGgocG9zdGZpeCkpIHtcbiAgICAgICAgbGV2ZWwgPSBpO1xuICAgICAgICBpZiAoaW52ZXJ0ZWQpIHtcbiAgICAgICAgICBsZXZlbCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gbWF0Y2guc2xpY2UoMCwgbWF0Y2gubGVuZ3RoIC0gcG9zdGZpeC5sZW5ndGgpO1xuICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgbWF0Y2ggPSBcIipcIjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKFwiXlwiICsgbWF0Y2gucmVwbGFjZSgvWypdL2csIFwiLipcIikgKyBcIiRcIik7XG4gICAgZm9yIChjb25zdCBsb2dnZXIgb2YgYWxsKSB7XG4gICAgICBpZiAobG9nZ2VyLmlkLm1hdGNoKHJlZ2V4KSkge1xuICAgICAgICBsb2dnZXIubGV2ZWwgPSBsZXZlbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbnZhciBMb2dFbnRyeSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobG9nZ2VyLCBsZXZlbCwgcGFydHMpIHtcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICAgIHRoaXMudGltZSA9IERhdGUubm93KCk7XG4gIH1cbiAgdG9NZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLnN0cmluZ1ByZWZpeClcbiAgICAgIHJldHVybiB0aGlzLnBhcnRzO1xuICAgIGNvbnN0IHIgPSBbXG4gICAgICBuZXcgRGF0ZSh0aGlzLnRpbWUpLnRvSVNPU3RyaW5nKCkuc3Vic3RyKC0xNCwgMTQpLFxuICAgICAgbGV2ZWxOYW1lc1t0aGlzLmxldmVsXSArIFwiOiBbXCIgKyB0aGlzLmxvZ2dlci5pZCArIFwiXVwiXG4gICAgXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yICg7IGkgPCB0aGlzLnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0ID0gdGhpcy5wYXJ0c1tpXTtcbiAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByLnB1c2gocGFydCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuc3RyaW5nUHJlZml4ID0gci5qb2luKFwiIFwiKTtcbiAgICB0aGlzLnBhcnRzLnNwbGljZSgwLCBpLCB0aGlzLnN0cmluZ1ByZWZpeCk7XG4gICAgcmV0dXJuIHRoaXMucGFydHM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9NZXNzYWdlKCkubWFwKChwYXJ0KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiBwYXJ0O1xuICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIGBbRnVuY3Rpb246ICR7KF9hID0gcGFydC5uYW1lKSAhPSBudWxsID8gX2EgOiBcInVua25vd25cIn1dYDtcbiAgICAgIGlmIChwYXJ0IGluc3RhbmNlb2YgRXJyb3IpXG4gICAgICAgIHJldHVybiAoX2IgPSBwYXJ0LnN0YWNrKSAhPSBudWxsID8gX2IgOiBwYXJ0LnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkoanNvblNhZmVDb3B5KHBhcnQpKTtcbiAgICAgIGlmICgoanNvbiA9PSBudWxsID8gdm9pZCAwIDoganNvbi5sZW5ndGgpID4gMjUzKSB7XG4gICAgICAgIHJldHVybiBqc29uLnNsaWNlKDAsIDI1MCkgKyBcIi4uLlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSkuam9pbihcIiBcIik7XG4gIH1cbn07XG52YXIgbG9nTGV2ZWxTcGVjID0gXCJhcHA6aW5mb1wiO1xudmFyIGlzTm9kZSA9IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmICEhcHJvY2Vzcy5raWxsO1xudmFyIGlzQ0kgPSBpc05vZGUgJiYgISFwcm9jZXNzLmVudi5DSTtcbmlmIChpc0NJKSB7XG4gIGxvZ0xldmVsU3BlYyA9IFwiLTp3YXJuXCI7XG59IGVsc2UgaWYgKGlzTm9kZSkge1xuICBsb2dMZXZlbFNwZWMgPSBcIlwiO1xufVxudHJ5IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgIGxvZ0xldmVsU3BlYyA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UubG9nTGV2ZWwgfHwgbG9nTGV2ZWxTcGVjO1xuICB9XG59IGNhdGNoIHtcbn1cbnRyeSB7XG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGxvZ0xldmVsU3BlYyA9IHByb2Nlc3MuZW52LkRFQlVHIHx8IGxvZ0xldmVsU3BlYztcbiAgfVxufSBjYXRjaCB7XG59XG50cnkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIE9iamVjdC5hc3NpZ24od2luZG93LCB7IHNldExvZ0xldmVsIH0pO1xuICB9XG59IGNhdGNoIHtcbn1cbnRyeSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cudG9wID09PSB3aW5kb3cpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKG1zZzIpID0+IHtcbiAgICAgIGlmICghbXNnMi5kYXRhIHx8IHR5cGVvZiBtc2cyLmRhdGEgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHsgbG9nZ2VySWQsIGxldmVsLCBwYXJ0cywgcHJpbnRlZCB9ID0gbXNnMi5kYXRhO1xuICAgICAgaWYgKHR5cGVvZiBsb2dnZXJJZCAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcnRzKSB8fCBwYXJ0cy5sZW5ndGggPCAxIHx8IHR5cGVvZiBsZXZlbCAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgcGFydHNbMF0gPSBwYXJ0c1swXS5yZXBsYWNlKFwiW1wiLCBcIipbXCIpO1xuICAgICAgY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKGxvZ2dlcklkKTtcbiAgICAgIGNvbnN0IGVudHJ5ID0gbmV3IExvZ0VudHJ5KGxvZ2dlciwgbGV2ZWwsIHBhcnRzKTtcbiAgICAgIGVudHJ5LnN0cmluZ1ByZWZpeCA9IHBhcnRzWzBdO1xuICAgICAgcmVwbGF5QnVmZmVyLnB1c2goZW50cnkpO1xuICAgICAgaWYgKHByaW50ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChsb2dnZXIubGV2ZWwgPiBsZXZlbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc29sZSA9PSBudWxsID8gdm9pZCAwIDogY29uc29sZS5sb2coLi4uZW50cnkudG9NZXNzYWdlKCkpO1xuICAgIH0pO1xuICB9XG59IGNhdGNoIHtcbn1cbnZhciBwb3N0TG9nRW50cnk7XG50cnkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LnRvcCAhPT0gd2luZG93KSB7XG4gICAgcG9zdExvZ0VudHJ5ID0gKGVudHJ5KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGVudHJ5LnRvTWVzc2FnZSgpLm1hcCgocCkgPT4ganNvblNhZmVDb3B5KHApKTtcbiAgICAgICAgY29uc3QgbG9nZ2VyID0gZW50cnkubG9nZ2VyO1xuICAgICAgICBjb25zdCBsZXZlbCA9IGVudHJ5LmxldmVsO1xuICAgICAgICBjb25zdCBwcmludGVkID0gbG9nZ2VyLmxldmVsIDw9IGVudHJ5LmxldmVsO1xuICAgICAgICBjb25zdCBkYXRhID0geyBsb2dnZXJJZDogbG9nZ2VyLmlkLCBsZXZlbCwgcGFydHMsIHByaW50ZWQgfTtcbiAgICAgICAgd2luZG93LnRvcC5wb3N0TWVzc2FnZShkYXRhLCBnZXRTZXJ2aWNlTWFwKCkuYXBwKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0gY2F0Y2gge1xufVxudmFyIGxvZ2dlcnMgPSB7fTtcbnZhciByZXBsYXlCdWZmZXIgPSBbXTtcbmZ1bmN0aW9uIGNyZWF0ZUxvZ0VudHJ5KGxvZ2dlciwgbGV2ZWwsIHBhcnRzKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgZW50cnkgPSBuZXcgTG9nRW50cnkobG9nZ2VyLCBsZXZlbCwgcGFydHMpO1xuICByZXBsYXlCdWZmZXIucHVzaChlbnRyeSk7XG4gIHBvc3RMb2dFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogcG9zdExvZ0VudHJ5KGVudHJ5KTtcbiAgY29uc3Qgb2xkZXN0ID0gRGF0ZS5ub3coKSAtIDFlMyAqIDYwICogNjA7XG4gIHdoaWxlIChyZXBsYXlCdWZmZXIubGVuZ3RoID4gMWUzIHx8ICgoX2EgPSByZXBsYXlCdWZmZXJbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS50aW1lKSA8IG9sZGVzdCkge1xuICAgIHJlcGxheUJ1ZmZlci5zaGlmdCgpO1xuICB9XG4gIHJldHVybiBlbnRyeTtcbn1cbmZ1bmN0aW9uIGdldExvZ1JlcGxheUJ1ZmZlcigpIHtcbiAgcmV0dXJuIHJlcGxheUJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIGdldExvZ2dlcihpZCkge1xuICBjb25zdCBleGlzdGluZyA9IGxvZ2dlcnNbaWRdO1xuICBpZiAoZXhpc3RpbmcpXG4gICAgcmV0dXJuIGV4aXN0aW5nO1xuICBjb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKGlkKTtcbiAgbG9nZ2Vyc1tpZF0gPSBsb2dnZXI7XG4gIGFwcGx5TG9nTGV2ZWxTcGVjKGxvZ0xldmVsU3BlYywgW2xvZ2dlcl0pO1xuICByZXR1cm4gbG9nZ2VyO1xufVxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwoc3BlYywgcmVwbGF5ID0gdHJ1ZSkge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UubG9nTGV2ZWwgPSBzcGVjO1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gIH1cbiAgY29uc3QgcHJldmlvdXNTcGVjID0gbG9nTGV2ZWxTcGVjO1xuICBsb2dMZXZlbFNwZWMgPSBzcGVjO1xuICBjb25zdCBhbGwgPSBPYmplY3QudmFsdWVzKGxvZ2dlcnMpO1xuICBmb3IgKGNvbnN0IGxvZ2dlciBvZiBhbGwpIHtcbiAgICBsb2dnZXIubGV2ZWwgPSAzO1xuICB9XG4gIGFwcGx5TG9nTGV2ZWxTcGVjKHNwZWMsIGFsbCk7XG4gIGlmIChyZXBsYXkgJiYgcmVwbGF5QnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICBjb25zb2xlID09IG51bGwgPyB2b2lkIDAgOiBjb25zb2xlLmxvZyhcIi0tLSBMT0cgUkVQTEFZIC0tLVwiKTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHJlcGxheUJ1ZmZlcikge1xuICAgICAgaWYgKGVudHJ5LmxvZ2dlci5sZXZlbCA+IGVudHJ5LmxldmVsKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChlbnRyeS5sZXZlbCA+PSAzKSB7XG4gICAgICAgIGNvbnNvbGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnNvbGUud2FybiguLi5lbnRyeS50b01lc3NhZ2UoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlID09IG51bGwgPyB2b2lkIDAgOiBjb25zb2xlLmxvZyguLi5lbnRyeS50b01lc3NhZ2UoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnNvbGUubG9nKFwiLS0tIEVORCBPRiBMT0cgUkVQTEFZIC0tLVwiKTtcbiAgfVxuICByZXR1cm4gcHJldmlvdXNTcGVjO1xufVxudmFyIExvZ2dlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaWQpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5sZXZlbCA9IDM7XG4gICAgdGhpcy5kaWRMb2cgPSB7fTtcbiAgICB0aGlzLnRyYWNlID0gKC4uLnBhcnRzKSA9PiB7XG4gICAgICBpZiAodGhpcy5sZXZlbCA+IDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGVudHJ5ID0gbmV3IExvZ0VudHJ5KHRoaXMsIDAsIHBhcnRzKTtcbiAgICAgIGNvbnNvbGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnNvbGUubG9nKC4uLmVudHJ5LnRvTWVzc2FnZSgpKTtcbiAgICB9O1xuICAgIHRoaXMuZGVidWcgPSAoLi4ucGFydHMpID0+IHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gY3JlYXRlTG9nRW50cnkodGhpcywgMSwgcGFydHMpO1xuICAgICAgaWYgKHRoaXMubGV2ZWwgPiAxKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zb2xlID09IG51bGwgPyB2b2lkIDAgOiBjb25zb2xlLmxvZyguLi5lbnRyeS50b01lc3NhZ2UoKSk7XG4gICAgfTtcbiAgICB0aGlzLmluZm8gPSAoLi4ucGFydHMpID0+IHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gY3JlYXRlTG9nRW50cnkodGhpcywgMiwgcGFydHMpO1xuICAgICAgaWYgKHRoaXMubGV2ZWwgPiAyKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zb2xlID09IG51bGwgPyB2b2lkIDAgOiBjb25zb2xlLmluZm8oLi4uZW50cnkudG9NZXNzYWdlKCkpO1xuICAgIH07XG4gICAgdGhpcy53YXJuID0gKC4uLnBhcnRzKSA9PiB7XG4gICAgICBjb25zdCBlbnRyeSA9IGNyZWF0ZUxvZ0VudHJ5KHRoaXMsIDMsIHBhcnRzKTtcbiAgICAgIGlmICh0aGlzLmxldmVsID4gMylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc29sZSA9PSBudWxsID8gdm9pZCAwIDogY29uc29sZS53YXJuKC4uLmVudHJ5LnRvTWVzc2FnZSgpKTtcbiAgICB9O1xuICAgIHRoaXMud2Fybk9uY2VQZXJNaW51dGUgPSAoZmlyc3RQYXJ0LCAuLi5wYXJ0cykgPT4ge1xuICAgICAgaWYgKHRoaXMuZGlkTG9nW2ZpcnN0UGFydF0gPiBEYXRlLm5vdygpKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLmRpZExvZ1tmaXJzdFBhcnRdID0gRGF0ZS5ub3coKSArIDFlMyAqIDYwO1xuICAgICAgcGFydHMudW5zaGlmdChmaXJzdFBhcnQpO1xuICAgICAgY29uc3QgZW50cnkgPSBjcmVhdGVMb2dFbnRyeSh0aGlzLCAzLCBwYXJ0cyk7XG4gICAgICBpZiAodGhpcy5sZXZlbCA+IDMpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnNvbGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnNvbGUud2FybiguLi5lbnRyeS50b01lc3NhZ2UoKSk7XG4gICAgfTtcbiAgICB0aGlzLmVycm9yID0gKC4uLnBhcnRzKSA9PiB7XG4gICAgICBjb25zdCBlbnRyeSA9IGNyZWF0ZUxvZ0VudHJ5KHRoaXMsIDQsIHBhcnRzKTtcbiAgICAgIGlmICh0aGlzLmxldmVsID4gNClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc29sZSA9PSBudWxsID8gdm9pZCAwIDogY29uc29sZS5lcnJvciguLi5lbnRyeS50b01lc3NhZ2UoKSk7XG4gICAgfTtcbiAgICB0aGlzLmVycm9yT25jZVBlck1pbnV0ZSA9IChmaXJzdFBhcnQsIC4uLnBhcnRzKSA9PiB7XG4gICAgICBpZiAodGhpcy5kaWRMb2dbZmlyc3RQYXJ0XSA+IERhdGUubm93KCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuZGlkTG9nW2ZpcnN0UGFydF0gPSBEYXRlLm5vdygpICsgMWUzICogNjA7XG4gICAgICBwYXJ0cy51bnNoaWZ0KGZpcnN0UGFydCk7XG4gICAgICBjb25zdCBlbnRyeSA9IGNyZWF0ZUxvZ0VudHJ5KHRoaXMsIDQsIHBhcnRzKTtcbiAgICAgIGlmICh0aGlzLmxldmVsID4gNClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc29sZSA9PSBudWxsID8gdm9pZCAwIDogY29uc29sZS5lcnJvciguLi5lbnRyeS50b01lc3NhZ2UoKSk7XG4gICAgfTtcbiAgICB0aGlzLnJlcG9ydEVycm9yID0gKG1heWJlRXJyb3IsIGV4dHJhcykgPT4ge1xuICAgICAgY29uc3QgbG9ncyA9IGdldExvZ1JlcGxheUJ1ZmZlcigpLnNsaWNlKC0xMDApLm1hcCgoZW50cnkpID0+IGVudHJ5LnRvU3RyaW5nKCkuc2xpY2UoMCwgMWUzKSkuam9pbihcIlxcblwiKTtcbiAgICAgIGNvbnN0IHJlcG9ydGVkRXJyb3IgPSByZXBvcnRFcnJvcih7XG4gICAgICAgIGNhbGxlcjogdGhpcy5yZXBvcnRFcnJvcixcbiAgICAgICAgZXJyb3I6IG1heWJlRXJyb3IsXG4gICAgICAgIHRhZ3M6IHtcbiAgICAgICAgICBoYW5kbGVyOiBcImxvZ2dlclwiLFxuICAgICAgICAgIHdoZXJlOiB0aGlzLmlkXG4gICAgICAgIH0sXG4gICAgICAgIGV4dHJhczogeyAuLi5leHRyYXMsIGxvZ3MgfVxuICAgICAgfSk7XG4gICAgICBleHRyYXMgPyB0aGlzLmVycm9yKHJlcG9ydGVkRXJyb3IsIGV4dHJhcykgOiB0aGlzLmVycm9yKHJlcG9ydGVkRXJyb3IpO1xuICAgIH07XG4gICAgdGhpcy5yZXBvcnRFcnJvck9uY2VQZXJNaW51dGUgPSAoZXJyb3IsIGV4dHJhcykgPT4ge1xuICAgICAgaWYgKCFpc0Vycm9yV2l0aE1lc3NhZ2UoZXJyb3IpIHx8IHRoaXMuZGlkTG9nW2Vycm9yLm1lc3NhZ2VdID4gRGF0ZS5ub3coKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5kaWRMb2dbZXJyb3IubWVzc2FnZV0gPSBEYXRlLm5vdygpICsgMWUzICogNjA7XG4gICAgICB0aGlzLnJlcG9ydEVycm9yKGVycm9yLCBleHRyYXMpO1xuICAgIH07XG4gIH1cbiAgZXh0ZW5kKG5hbWUpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuaWQgKyBcIjpcIiArIG5hbWU7XG4gICAgcmV0dXJuIGdldExvZ2dlcihpZCk7XG4gIH1cbiAgZ2V0QnVmZmVyZWRNZXNzYWdlcygpIHtcbiAgICByZXR1cm4gcmVwbGF5QnVmZmVyLmZpbHRlcigoZW50cnkpID0+IGVudHJ5LmxvZ2dlciA9PT0gdGhpcyk7XG4gIH1cbiAgc2V0TGV2ZWwobGV2ZWwpIHtcbiAgICBjb25zdCBwcmV2aW91cyA9IHRoaXMubGV2ZWw7XG4gICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfVxuICBpc0xvZ2dpbmdUcmFjZU1lc3NhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsID49IDA7XG4gIH1cbn07XG5mdW5jdGlvbiBpc0Vycm9yV2l0aE1lc3NhZ2UobWF5YmVFcnJvcikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1heWJlRXJyb3IsIFwibWVzc2FnZVwiKTtcbn1cblxuLy8gLi4vc2hhcmVkL3NyYy9tb2R1bGVJZGVudGlmaWVycy50c1xudmFyIE1vZHVsZVR5cGU7XG4oZnVuY3Rpb24oTW9kdWxlVHlwZTIpIHtcbiAgTW9kdWxlVHlwZTJbXCJDYW52YXNcIl0gPSBcImNhbnZhc0NvbXBvbmVudFwiO1xuICBNb2R1bGVUeXBlMltcIkNvZGVcIl0gPSBcImNvZGVGaWxlXCI7XG4gIE1vZHVsZVR5cGUyW1wiU2NyZWVuXCJdID0gXCJzY3JlZW5cIjtcbn0pKE1vZHVsZVR5cGUgfHwgKE1vZHVsZVR5cGUgPSB7fSkpO1xuXG4vLyAuLi9zaGFyZWQvc3JjL1Rhc2tRdWV1ZXMudHNcbnZhciBsb2cgPSBnZXRMb2dnZXIoXCJ0YXNrLXF1ZXVlXCIpO1xuXG4vLyBzcmMvYW5pbWF0aW9uL0FuaW1hdGFibGUvQW5pbWF0YWJsZS50c1xuZnVuY3Rpb24gQW5pbWF0YWJsZSh2YWx1ZSkge1xuICBkZXByZWNhdGlvbldhcm5pbmcoXCJBbmltYXRhYmxlKClcIiwgXCIyLjAuMFwiLCBcInRoZSBuZXcgYW5pbWF0aW9uIEFQSSAoaHR0cHM6Ly93d3cuZnJhbWVyLmNvbS9hcGkvYW5pbWF0aW9uLylcIik7XG4gIHJldHVybiBpc0FuaW1hdGFibGUyKHZhbHVlKSA/IHZhbHVlIDogbmV3IEFuaW1hdGFibGVWYWx1ZSh2YWx1ZSk7XG59XG4oZnVuY3Rpb24oQW5pbWF0YWJsZTMpIHtcbiAgZnVuY3Rpb24gdHJhbnNhY3Rpb24odXBkYXRlKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IE1hdGgucmFuZG9tKCk7XG4gICAgY29uc3QgdXBkYXRlZFZhbHVlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB1cGRhdGVyID0gKGFuaW1hdGFibGUsIHZhbHVlKSA9PiB7XG4gICAgICBhbmltYXRhYmxlLnNldCh2YWx1ZSwgdHJhbnNhY3Rpb25JZCk7XG4gICAgICB1cGRhdGVkVmFsdWVzLmFkZChhbmltYXRhYmxlKTtcbiAgICB9O1xuICAgIHVwZGF0ZSh1cGRhdGVyLCB0cmFuc2FjdGlvbklkKTtcbiAgICBjb25zdCBmaW5pc2hPYnNlcnZlcnMgPSBbXTtcbiAgICB1cGRhdGVkVmFsdWVzLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICBmaW5pc2hPYnNlcnZlcnMucHVzaCguLi52YWx1ZS5maW5pc2hUcmFuc2FjdGlvbih0cmFuc2FjdGlvbklkKSk7XG4gICAgfSk7XG4gICAgZmluaXNoT2JzZXJ2ZXJzLmZvckVhY2goKGZpbmlzaCkgPT4ge1xuICAgICAgZmluaXNoKHRyYW5zYWN0aW9uSWQpO1xuICAgIH0pO1xuICB9XG4gIEFuaW1hdGFibGUzLnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gIGZ1bmN0aW9uIGdldE51bWJlcjIodmFsdWUsIGRlZmF1bHRWYWx1ZSA9IDApIHtcbiAgICByZXR1cm4gQW5pbWF0YWJsZTMuZ2V0KHZhbHVlLCBkZWZhdWx0VmFsdWUpO1xuICB9XG4gIEFuaW1hdGFibGUzLmdldE51bWJlciA9IGdldE51bWJlcjI7XG4gIGZ1bmN0aW9uIGdldCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDAgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIGlmIChpc0FuaW1hdGFibGUyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLmdldCgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgQW5pbWF0YWJsZTMuZ2V0ID0gZ2V0O1xuICBmdW5jdGlvbiBvYmplY3RUb1ZhbHVlcyhvYmplY3QpIHtcbiAgICBpZiAoIW9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXk2IGluIG9iamVjdCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5Nl07XG4gICAgICBpZiAoaXNBbmltYXRhYmxlMih2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0W2tleTZdID0gdmFsdWUuZ2V0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRba2V5Nl0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBBbmltYXRhYmxlMy5vYmplY3RUb1ZhbHVlcyA9IG9iamVjdFRvVmFsdWVzO1xufSkoQW5pbWF0YWJsZSB8fCAoQW5pbWF0YWJsZSA9IHt9KSk7XG52YXIgb25VcGRhdGVLZXkgPSBcIm9uVXBkYXRlXCI7XG52YXIgZmluaXNoVHJhbnNhY3Rpb25LZXkgPSBcImZpbmlzaFRyYW5zYWN0aW9uXCI7XG5mdW5jdGlvbiBpc0FuaW1hdGFibGUyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgb25VcGRhdGVLZXkgaW4gdmFsdWUgJiYgdmFsdWVbb25VcGRhdGVLZXldIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgZmluaXNoVHJhbnNhY3Rpb25LZXkgaW4gdmFsdWUgJiYgdmFsdWVbZmluaXNoVHJhbnNhY3Rpb25LZXldIGluc3RhbmNlb2YgRnVuY3Rpb247XG59XG5mdW5jdGlvbiBhbmltYXRhYmxlSW50ZXJwb2xhdGlvbih2YWx1ZSwgY3VycmVudEludGVycG9sYXRpb24pIHtcbiAgcmV0dXJuIHtcbiAgICBpbnRlcnBvbGF0ZShmcm9tLCB0bykge1xuICAgICAgY29uc3QgZnJvbVZhbHVlID0gZnJvbS5nZXQoKTtcbiAgICAgIGNvbnN0IHRvVmFsdWUgPSB0by5nZXQoKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IEFuaW1hdGFibGUoZnJvbVZhbHVlKTtcbiAgICAgIHJldHVybiAocHJvZ3Jlc3MyKSA9PiB7XG4gICAgICAgIGNvbnN0IHYgPSBjdXJyZW50SW50ZXJwb2xhdGlvbi5pbnRlcnBvbGF0ZShmcm9tVmFsdWUsIHRvVmFsdWUpKHByb2dyZXNzMik7XG4gICAgICAgIHJlc3VsdC5zZXQodik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0sXG4gICAgZGlmZmVyZW5jZShmcm9tLCB0bykge1xuICAgICAgY29uc3QgdiA9IGZyb20uZ2V0KCk7XG4gICAgICByZXR1cm4gY3VycmVudEludGVycG9sYXRpb24uZGlmZmVyZW5jZSh2LCB0by5nZXQoKSk7XG4gICAgfVxuICB9O1xufVxudmFyIEFuaW1hdGFibGVWYWx1ZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5vYnNlcnZlcnMgPSBuZXcgT2JzZXJ2ZXJzKCk7XG4gIH1cbiAgc3RhdGljIGludGVycG9sYXRpb25Gb3IodmFsdWUsIGN1cnJlbnRJbnRlcnBvbGF0aW9uKSB7XG4gICAgaWYgKGlzQW5pbWF0YWJsZTIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gYW5pbWF0YWJsZUludGVycG9sYXRpb24odmFsdWUsIGN1cnJlbnRJbnRlcnBvbGF0aW9uKTtcbiAgICB9XG4gIH1cbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG4gIHNldCh2YWx1ZSwgdHJhbnNhY3Rpb24pIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgaWYgKGlzQW5pbWF0YWJsZTIodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLmdldCgpO1xuICAgIH1cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgY29uc3QgY2hhbmdlID0ge1xuICAgICAgdmFsdWUsXG4gICAgICBvbGRWYWx1ZVxuICAgIH07XG4gICAgdGhpcy5vYnNlcnZlcnMubm90aWZ5KGNoYW5nZSwgdHJhbnNhY3Rpb24pO1xuICB9XG4gIGZpbmlzaFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLmZpbmlzaFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgfVxuICBvblVwZGF0ZShoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLmFkZChoYW5kbGVyKTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL3V0aWxzLnRzXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xufVxuZnVuY3Rpb24gaXNTdHJpbmcyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBBcnJheTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59XG5cbi8vIHNyYy9yZW5kZXIvc3R5bGUvYmFja2dyb3VuZEltYWdlRnJvbVByb3BzLnRzXG5mdW5jdGlvbiBhcHBseUZvcndhcmRPdmVycmlkZXMoYmFja2dyb3VuZCwgcHJvcHMpIHtcbiAgY29uc3QgeyBfZm9yd2FyZGVkT3ZlcnJpZGVJZCwgX2ZvcndhcmRlZE92ZXJyaWRlcywgaWQgfSA9IHByb3BzO1xuICBjb25zdCBmb3J3YXJkZWRPdmVycmlkZUlkID0gX2ZvcndhcmRlZE92ZXJyaWRlSWQgIT0gbnVsbCA/IF9mb3J3YXJkZWRPdmVycmlkZUlkIDogaWQ7XG4gIGNvbnN0IHNyYyA9IF9mb3J3YXJkZWRPdmVycmlkZXMgJiYgZm9yd2FyZGVkT3ZlcnJpZGVJZCA/IF9mb3J3YXJkZWRPdmVycmlkZXNbZm9yd2FyZGVkT3ZlcnJpZGVJZF0gOiB2b2lkIDA7XG4gIGlmIChzcmMgJiYgdHlwZW9mIHNyYyA9PT0gXCJzdHJpbmdcIikge1xuICAgIGJhY2tncm91bmQgPSB7IC4uLmJhY2tncm91bmQsIHNyYyB9O1xuICB9XG4gIHJldHVybiBiYWNrZ3JvdW5kO1xufVxuZnVuY3Rpb24gYmFja2dyb3VuZEltYWdlRnJvbVByb3BzKHByb3BzKSB7XG4gIGNvbnN0IHsgYmFja2dyb3VuZCwgaW1hZ2UgfSA9IHByb3BzO1xuICBpZiAoaW1hZ2UgIT09IHZvaWQgMCAmJiBiYWNrZ3JvdW5kICYmICFCYWNrZ3JvdW5kSW1hZ2UuaXNJbWFnZU9iamVjdChiYWNrZ3JvdW5kKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgYmFja2dyb3VuZEltYWdlID0gbnVsbDtcbiAgaWYgKGlzU3RyaW5nMihpbWFnZSkpIHtcbiAgICBiYWNrZ3JvdW5kSW1hZ2UgPSB7IHNyYzogaW1hZ2UgfTtcbiAgfSBlbHNlIHtcbiAgICBiYWNrZ3JvdW5kSW1hZ2UgPSBBbmltYXRhYmxlLmdldChiYWNrZ3JvdW5kLCBudWxsKTtcbiAgfVxuICBpZiAoIUJhY2tncm91bmRJbWFnZS5pc0ltYWdlT2JqZWN0KGJhY2tncm91bmRJbWFnZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIGFwcGx5Rm9yd2FyZE92ZXJyaWRlcyhiYWNrZ3JvdW5kSW1hZ2UsIHByb3BzKTtcbn1cblxuLy8gc3JjL3JlbmRlci90eXBlcy9OZXdDb25zdHJhaW50cy50c3hcbmltcG9ydCB7XG4gIEZyYWdtZW50IGFzIEZyYWdtZW50MyxcbiAgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0NyxcbiAgY3JlYXRlRWxlbWVudCBhcyBjcmVhdGVFbGVtZW50MTEsXG4gIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDE2LFxuICB1c2VNZW1vIGFzIHVzZU1lbW83XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvcmVuZGVyL3V0aWxzL3JvdW5kZWROdW1iZXIudHNcbmZ1bmN0aW9uIHJvdW5kZWROdW1iZXIodmFsdWUsIGRlY2ltYWxzKSB7XG4gIGNvbnN0IGQgPSBNYXRoLnJvdW5kKE1hdGguYWJzKGRlY2ltYWxzKSk7XG4gIGNvbnN0IG11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgZCk7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogbXVsdGlwbGllcikgLyBtdWx0aXBsaWVyO1xufVxuZnVuY3Rpb24gcm91bmRlZE51bWJlclN0cmluZyh2YWx1ZSwgZGVjaW1hbHMpIHtcbiAgY29uc3QgcmVzdWx0ID0gdmFsdWUudG9GaXhlZChkZWNpbWFscyk7XG4gIGlmIChkZWNpbWFscyA9PT0gMCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5yZXBsYWNlKC9cXC4/MCskLywgXCJcIik7XG59XG5mdW5jdGlvbiByb3VuZFdpdGhPZmZzZXQodmFsdWUsIG9mZnNldCkge1xuICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpO1xuICB9XG4gIG9mZnNldCAtPSBvZmZzZXQgfCAwO1xuICBpZiAob2Zmc2V0IDwgMCkge1xuICAgIG9mZnNldCA9IDEgLSBvZmZzZXQ7XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgLSBvZmZzZXQpICsgb2Zmc2V0O1xufVxuXG4vLyBzcmMvcmVuZGVyL3R5cGVzL1BvaW50LnRzXG5mdW5jdGlvbiBQb2ludCh4LCB5KSB7XG4gIHJldHVybiB7IHgsIHkgfTtcbn1cbihmdW5jdGlvbihQb2ludDIpIHtcbiAgUG9pbnQyLmFkZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKChwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpID0+IHtcbiAgICAgIHJldHVybiB7IHg6IHByZXZpb3VzVmFsdWUueCArIGN1cnJlbnRWYWx1ZS54LCB5OiBwcmV2aW91c1ZhbHVlLnkgKyBjdXJyZW50VmFsdWUueSB9O1xuICAgIH0sIHsgeDogMCwgeTogMCB9KTtcbiAgfTtcbiAgUG9pbnQyLnN1YnRyYWN0ID0gKGEyLCBiMikgPT4ge1xuICAgIHJldHVybiB7IHg6IGEyLnggLSBiMi54LCB5OiBhMi55IC0gYjIueSB9O1xuICB9O1xuICBQb2ludDIubXVsdGlwbHkgPSAoYTIsIGIyKSA9PiB7XG4gICAgcmV0dXJuIHsgeDogYTIueCAqIGIyLCB5OiBhMi55ICogYjIgfTtcbiAgfTtcbiAgUG9pbnQyLmRpdmlkZSA9IChhMiwgYjIpID0+IHtcbiAgICByZXR1cm4geyB4OiBhMi54IC8gYjIsIHk6IGEyLnkgLyBiMiB9O1xuICB9O1xuICBQb2ludDIuYWJzb2x1dGUgPSAocG9pbnQpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5hYnMocG9pbnQueCksXG4gICAgICB5OiBNYXRoLmFicyhwb2ludC55KVxuICAgIH07XG4gIH07XG4gIFBvaW50Mi5yZXZlcnNlID0gKHBvaW50KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHBvaW50LnggKiAtMSxcbiAgICAgIHk6IHBvaW50LnkgKiAtMVxuICAgIH07XG4gIH07XG4gIFBvaW50Mi5waXhlbEFsaWduZWQgPSAocG9pbnQsIG9mZnNldCA9IHsgeDogMCwgeTogMCB9KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHJvdW5kV2l0aE9mZnNldChwb2ludC54LCBvZmZzZXQueCksXG4gICAgICB5OiByb3VuZFdpdGhPZmZzZXQocG9pbnQueSwgb2Zmc2V0LnkpXG4gICAgfTtcbiAgfTtcbiAgUG9pbnQyLmRpc3RhbmNlID0gKGEyLCBiMikgPT4ge1xuICAgIGNvbnN0IGRlbHRhWCA9IE1hdGguYWJzKGEyLnggLSBiMi54KTtcbiAgICBjb25zdCBkZWx0YVkgPSBNYXRoLmFicyhhMi55IC0gYjIueSk7XG4gICAgcmV0dXJuIE1hdGguc3FydChkZWx0YVggKiBkZWx0YVggKyBkZWx0YVkgKiBkZWx0YVkpO1xuICB9O1xuICBQb2ludDIuYW5nbGUgPSAoYTIsIGIyKSA9PiB7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoYjIueSAtIGEyLnksIGIyLnggLSBhMi54KSAqIDE4MCAvIE1hdGguUEkgLSA5MDtcbiAgfTtcbiAgUG9pbnQyLmlzRXF1YWwgPSAoYTIsIGIyKSA9PiB7XG4gICAgcmV0dXJuIGEyLnggPT09IGIyLnggJiYgYTIueSA9PT0gYjIueTtcbiAgfTtcbiAgUG9pbnQyLnJvdGF0aW9uTm9ybWFsaXplciA9ICgpID0+IHtcbiAgICBsZXQgbGFzdFZhbHVlO1xuICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgbGFzdFZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlmZiA9IGxhc3RWYWx1ZSAtIHZhbHVlO1xuICAgICAgY29uc3QgbWF4RGlmZiA9IE1hdGguYWJzKGRpZmYpICsgMTgwO1xuICAgICAgY29uc3QgblRpbWVzID0gTWF0aC5mbG9vcihtYXhEaWZmIC8gMzYwKTtcbiAgICAgIGlmIChkaWZmIDwgMTgwKSB7XG4gICAgICAgIHZhbHVlIC09IG5UaW1lcyAqIDM2MDtcbiAgICAgIH1cbiAgICAgIGlmIChkaWZmID4gMTgwKSB7XG4gICAgICAgIHZhbHVlICs9IG5UaW1lcyAqIDM2MDtcbiAgICAgIH1cbiAgICAgIGxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH07XG4gIGZ1bmN0aW9uIGNlbnRlcihhMiwgYjIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogKGEyLnggKyBiMi54KSAvIDIsXG4gICAgICB5OiAoYTIueSArIGIyLnkpIC8gMlxuICAgIH07XG4gIH1cbiAgUG9pbnQyLmNlbnRlciA9IGNlbnRlcjtcbn0pKFBvaW50IHx8IChQb2ludCA9IHt9KSk7XG5cbi8vIHNyYy9yZW5kZXIvdHlwZXMvUmVjdC50c1xudmFyIFJlY3Q7XG4oZnVuY3Rpb24oUmVjdDIpIHtcbiAgZnVuY3Rpb24gZXF1YWxzKHJlY3QsIG90aGVyKSB7XG4gICAgaWYgKHJlY3QgPT09IG90aGVyKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFyZWN0IHx8ICFvdGhlcilcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gcmVjdC54ID09PSBvdGhlci54ICYmIHJlY3QueSA9PT0gb3RoZXIueSAmJiByZWN0LndpZHRoID09PSBvdGhlci53aWR0aCAmJiByZWN0LmhlaWdodCA9PT0gb3RoZXIuaGVpZ2h0O1xuICB9XG4gIFJlY3QyLmVxdWFscyA9IGVxdWFscztcbiAgUmVjdDIuYXRPcmlnaW4gPSAoc2l6ZTIpID0+IHtcbiAgICByZXR1cm4geyAuLi5zaXplMiwgeDogMCwgeTogMCB9O1xuICB9O1xuICBSZWN0Mi5mcm9tVHdvUG9pbnRzID0gKGEyLCBiMikgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLm1pbihhMi54LCBiMi54KSxcbiAgICAgIHk6IE1hdGgubWluKGEyLnksIGIyLnkpLFxuICAgICAgd2lkdGg6IE1hdGguYWJzKGEyLnggLSBiMi54KSxcbiAgICAgIGhlaWdodDogTWF0aC5hYnMoYTIueSAtIGIyLnkpXG4gICAgfTtcbiAgfTtcbiAgUmVjdDIuZnJvbVJlY3QgPSAocmVjdCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB4OiByZWN0LmxlZnQsXG4gICAgICB5OiByZWN0LnRvcCxcbiAgICAgIHdpZHRoOiByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LFxuICAgICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gICAgfTtcbiAgfTtcbiAgUmVjdDIubXVsdGlwbHkgPSAocmVjdCwgbikgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB4OiByZWN0LnggKiBuLFxuICAgICAgeTogcmVjdC55ICogbixcbiAgICAgIHdpZHRoOiByZWN0LndpZHRoICogbixcbiAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQgKiBuXG4gICAgfTtcbiAgfTtcbiAgUmVjdDIuZGl2aWRlID0gKHJlY3QsIG4pID0+IHtcbiAgICByZXR1cm4gUmVjdDIubXVsdGlwbHkocmVjdCwgMSAvIG4pO1xuICB9O1xuICBSZWN0Mi5vZmZzZXQgPSAocmVjdCwgZGVsdGEyKSA9PiB7XG4gICAgY29uc3QgeE9mZnNldCA9IHR5cGVvZiBkZWx0YTIueCA9PT0gXCJudW1iZXJcIiA/IGRlbHRhMi54IDogMDtcbiAgICBjb25zdCB5T2Zmc2V0ID0gdHlwZW9mIGRlbHRhMi55ID09PSBcIm51bWJlclwiID8gZGVsdGEyLnkgOiAwO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZWN0LFxuICAgICAgeDogcmVjdC54ICsgeE9mZnNldCxcbiAgICAgIHk6IHJlY3QueSArIHlPZmZzZXRcbiAgICB9O1xuICB9O1xuICBmdW5jdGlvbiBpbmZsYXRlKHJlY3QsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSAwKVxuICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgY29uc3QgZG91YmxlVmFsdWUgPSAyICogdmFsdWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHJlY3QueCAtIHZhbHVlLFxuICAgICAgeTogcmVjdC55IC0gdmFsdWUsXG4gICAgICB3aWR0aDogcmVjdC53aWR0aCArIGRvdWJsZVZhbHVlLFxuICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCArIGRvdWJsZVZhbHVlXG4gICAgfTtcbiAgfVxuICBSZWN0Mi5pbmZsYXRlID0gaW5mbGF0ZTtcbiAgUmVjdDIucGl4ZWxBbGlnbmVkID0gKHJlY3QpID0+IHtcbiAgICBjb25zdCB4ID0gTWF0aC5yb3VuZChyZWN0LngpO1xuICAgIGNvbnN0IHkgPSBNYXRoLnJvdW5kKHJlY3QueSk7XG4gICAgY29uc3QgcmVjdE1heFggPSBNYXRoLnJvdW5kKHJlY3QueCArIHJlY3Qud2lkdGgpO1xuICAgIGNvbnN0IHJlY3RNYXhZID0gTWF0aC5yb3VuZChyZWN0LnkgKyByZWN0LmhlaWdodCk7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heChyZWN0TWF4WCAtIHgsIDApO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KHJlY3RNYXhZIC0geSwgMCk7XG4gICAgcmV0dXJuIHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9O1xuICB9O1xuICBSZWN0Mi5oYWxmUGl4ZWxBbGlnbmVkID0gKHJlY3QpID0+IHtcbiAgICBjb25zdCB4ID0gTWF0aC5yb3VuZChyZWN0LnggKiAyKSAvIDI7XG4gICAgY29uc3QgeSA9IE1hdGgucm91bmQocmVjdC55ICogMikgLyAyO1xuICAgIGNvbnN0IHJlY3RNYXhYID0gTWF0aC5yb3VuZCgocmVjdC54ICsgcmVjdC53aWR0aCkgKiAyKSAvIDI7XG4gICAgY29uc3QgcmVjdE1heFkgPSBNYXRoLnJvdW5kKChyZWN0LnkgKyByZWN0LmhlaWdodCkgKiAyKSAvIDI7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heChyZWN0TWF4WCAtIHgsIDEpO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KHJlY3RNYXhZIC0geSwgMSk7XG4gICAgcmV0dXJuIHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9O1xuICB9O1xuICBSZWN0Mi5yb3VuZCA9IChyZWN0LCBkZWNpbWFscyA9IDApID0+IHtcbiAgICBjb25zdCB4ID0gcm91bmRlZE51bWJlcihyZWN0LngsIGRlY2ltYWxzKTtcbiAgICBjb25zdCB5ID0gcm91bmRlZE51bWJlcihyZWN0LnksIGRlY2ltYWxzKTtcbiAgICBjb25zdCB3aWR0aCA9IHJvdW5kZWROdW1iZXIocmVjdC53aWR0aCwgZGVjaW1hbHMpO1xuICAgIGNvbnN0IGhlaWdodCA9IHJvdW5kZWROdW1iZXIocmVjdC5oZWlnaHQsIGRlY2ltYWxzKTtcbiAgICByZXR1cm4geyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH07XG4gIH07XG4gIFJlY3QyLnJvdW5kVG9PdXRzaWRlID0gKHJlY3QpID0+IHtcbiAgICBjb25zdCB4ID0gTWF0aC5mbG9vcihyZWN0LngpO1xuICAgIGNvbnN0IHkgPSBNYXRoLmZsb29yKHJlY3QueSk7XG4gICAgY29uc3QgcmVjdE1heFggPSBNYXRoLmNlaWwocmVjdC54ICsgcmVjdC53aWR0aCk7XG4gICAgY29uc3QgcmVjdE1heFkgPSBNYXRoLmNlaWwocmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgocmVjdE1heFggLSB4LCAwKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heChyZWN0TWF4WSAtIHksIDApO1xuICAgIHJldHVybiB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfTtcbiAgfTtcbiAgUmVjdDIubWluWCA9IChyZWN0KSA9PiB7XG4gICAgcmV0dXJuIHJlY3QueDtcbiAgfTtcbiAgUmVjdDIubWF4WCA9IChyZWN0KSA9PiB7XG4gICAgcmV0dXJuIHJlY3QueCArIHJlY3Qud2lkdGg7XG4gIH07XG4gIFJlY3QyLm1pblkgPSAocmVjdCkgPT4ge1xuICAgIHJldHVybiByZWN0Lnk7XG4gIH07XG4gIFJlY3QyLm1heFkgPSAocmVjdCkgPT4ge1xuICAgIHJldHVybiByZWN0LnkgKyByZWN0LmhlaWdodDtcbiAgfTtcbiAgUmVjdDIucG9zaXRpb25zID0gKHJlY3QpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgbWluWDogcmVjdC54LFxuICAgICAgbWlkWDogcmVjdC54ICsgcmVjdC53aWR0aCAvIDIsXG4gICAgICBtYXhYOiBSZWN0Mi5tYXhYKHJlY3QpLFxuICAgICAgbWluWTogcmVjdC55LFxuICAgICAgbWlkWTogcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyLFxuICAgICAgbWF4WTogUmVjdDIubWF4WShyZWN0KVxuICAgIH07XG4gIH07XG4gIFJlY3QyLmNlbnRlciA9IChyZWN0KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHJlY3QueCArIHJlY3Qud2lkdGggLyAyLFxuICAgICAgeTogcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyXG4gICAgfTtcbiAgfTtcbiAgUmVjdDIuZnJvbVBvaW50cyA9IChwcykgPT4ge1xuICAgIGNvbnN0IHhWYWx1ZXMgPSBwcy5tYXAoKHBvaW50KSA9PiBwb2ludC54KTtcbiAgICBjb25zdCB5VmFsdWVzID0gcHMubWFwKChwb2ludCkgPT4gcG9pbnQueSk7XG4gICAgY29uc3QgeCA9IE1hdGgubWluKC4uLnhWYWx1ZXMpO1xuICAgIGNvbnN0IHkgPSBNYXRoLm1pbiguLi55VmFsdWVzKTtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgubWF4KC4uLnhWYWx1ZXMpIC0geDtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heCguLi55VmFsdWVzKSAtIHk7XG4gICAgcmV0dXJuIHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9O1xuICB9O1xuICBSZWN0Mi5tZXJnZSA9ICguLi5yZWN0KSA9PiB7XG4gICAgY29uc3QgbWluID0ge1xuICAgICAgeDogTWF0aC5taW4oLi4ucmVjdC5tYXAoUmVjdDIubWluWCkpLFxuICAgICAgeTogTWF0aC5taW4oLi4ucmVjdC5tYXAoUmVjdDIubWluWSkpXG4gICAgfTtcbiAgICBjb25zdCBtYXggPSB7XG4gICAgICB4OiBNYXRoLm1heCguLi5yZWN0Lm1hcChSZWN0Mi5tYXhYKSksXG4gICAgICB5OiBNYXRoLm1heCguLi5yZWN0Lm1hcChSZWN0Mi5tYXhZKSlcbiAgICB9O1xuICAgIHJldHVybiBSZWN0Mi5mcm9tVHdvUG9pbnRzKG1pbiwgbWF4KTtcbiAgfTtcbiAgUmVjdDIuaW50ZXJzZWN0aW9uID0gKHJlY3QxLCByZWN0MikgPT4ge1xuICAgIGNvbnN0IHggPSBNYXRoLm1heChyZWN0MS54LCByZWN0Mi54KTtcbiAgICBjb25zdCB4MiA9IE1hdGgubWluKHJlY3QxLnggKyByZWN0MS53aWR0aCwgcmVjdDIueCArIHJlY3QyLndpZHRoKTtcbiAgICBjb25zdCB5ID0gTWF0aC5tYXgocmVjdDEueSwgcmVjdDIueSk7XG4gICAgY29uc3QgeTIgPSBNYXRoLm1pbihyZWN0MS55ICsgcmVjdDEuaGVpZ2h0LCByZWN0Mi55ICsgcmVjdDIuaGVpZ2h0KTtcbiAgICByZXR1cm4geyB4LCB5LCB3aWR0aDogeDIgLSB4LCBoZWlnaHQ6IHkyIC0geSB9O1xuICB9O1xuICBSZWN0Mi5wb2ludHMgPSAocmVjdCkgPT4ge1xuICAgIHJldHVybiBbXG4gICAgICB7IHg6IFJlY3QyLm1pblgocmVjdCksIHk6IFJlY3QyLm1pblkocmVjdCkgfSxcbiAgICAgIHsgeDogUmVjdDIubWluWChyZWN0KSwgeTogUmVjdDIubWF4WShyZWN0KSB9LFxuICAgICAgeyB4OiBSZWN0Mi5tYXhYKHJlY3QpLCB5OiBSZWN0Mi5taW5ZKHJlY3QpIH0sXG4gICAgICB7IHg6IFJlY3QyLm1heFgocmVjdCksIHk6IFJlY3QyLm1heFkocmVjdCkgfVxuICAgIF07XG4gIH07XG4gIFJlY3QyLnRyYW5zZm9ybSA9IChyZWN0LCBtYXRyaXgpID0+IHtcbiAgICBjb25zdCB7IHg6IHgxLCB5OiB5MSB9ID0gbWF0cml4LnRyYW5zZm9ybVBvaW50KHsgeDogcmVjdC54LCB5OiByZWN0LnkgfSk7XG4gICAgY29uc3QgeyB4OiB4MiwgeTogeTIgfSA9IG1hdHJpeC50cmFuc2Zvcm1Qb2ludCh7IHg6IHJlY3QueCArIHJlY3Qud2lkdGgsIHk6IHJlY3QueSB9KTtcbiAgICBjb25zdCB7IHg6IHgzLCB5OiB5MyB9ID0gbWF0cml4LnRyYW5zZm9ybVBvaW50KHsgeDogcmVjdC54ICsgcmVjdC53aWR0aCwgeTogcmVjdC55ICsgcmVjdC5oZWlnaHQgfSk7XG4gICAgY29uc3QgeyB4OiB4NCwgeTogeTQgfSA9IG1hdHJpeC50cmFuc2Zvcm1Qb2ludCh7IHg6IHJlY3QueCwgeTogcmVjdC55ICsgcmVjdC5oZWlnaHQgfSk7XG4gICAgY29uc3QgeCA9IE1hdGgubWluKHgxLCB4MiwgeDMsIHg0KTtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgubWF4KHgxLCB4MiwgeDMsIHg0KSAtIHg7XG4gICAgY29uc3QgeSA9IE1hdGgubWluKHkxLCB5MiwgeTMsIHk0KTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heCh5MSwgeTIsIHkzLCB5NCkgLSB5O1xuICAgIHJldHVybiB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfTtcbiAgfTtcbiAgUmVjdDIuY29udGFpbnNQb2ludCA9IChyZWN0LCBwb2ludCkgPT4ge1xuICAgIGlmIChwb2ludC54IDwgUmVjdDIubWluWChyZWN0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocG9pbnQueCA+IFJlY3QyLm1heFgocmVjdCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBvaW50LnkgPCBSZWN0Mi5taW5ZKHJlY3QpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwb2ludC55ID4gUmVjdDIubWF4WShyZWN0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXNOYU4ocmVjdC54KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXNOYU4ocmVjdC55KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgUmVjdDIuY29udGFpbnNSZWN0ID0gKHJlY3RBLCByZWN0QikgPT4ge1xuICAgIGZvciAoY29uc3QgcG9pbnQgb2YgUmVjdDIucG9pbnRzKHJlY3RCKSkge1xuICAgICAgaWYgKCFSZWN0Mi5jb250YWluc1BvaW50KHJlY3RBLCBwb2ludCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgUmVjdDIudG9DU1MgPSAocmVjdCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtyZWN0Lnh9cHgsICR7cmVjdC55fXB4KWAsXG4gICAgICB3aWR0aDogYCR7cmVjdC53aWR0aH1weGAsXG4gICAgICBoZWlnaHQ6IGAke3JlY3QuaGVpZ2h0fXB4YFxuICAgIH07XG4gIH07XG4gIFJlY3QyLmluc2V0ID0gKHJlY3QsIG4pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcmVjdC54ICsgbixcbiAgICAgIHk6IHJlY3QueSArIG4sXG4gICAgICB3aWR0aDogTWF0aC5tYXgoMCwgcmVjdC53aWR0aCAtIDIgKiBuKSxcbiAgICAgIGhlaWdodDogTWF0aC5tYXgoMCwgcmVjdC5oZWlnaHQgLSAyICogbilcbiAgICB9O1xuICB9O1xuICBSZWN0Mi5pbnRlcnNlY3RzID0gKHJlY3RBLCByZWN0QikgPT4ge1xuICAgIHJldHVybiAhKHJlY3RCLnggPj0gUmVjdDIubWF4WChyZWN0QSkgfHwgUmVjdDIubWF4WChyZWN0QikgPD0gcmVjdEEueCB8fCByZWN0Qi55ID49IFJlY3QyLm1heFkocmVjdEEpIHx8IFJlY3QyLm1heFkocmVjdEIpIDw9IHJlY3RBLnkpO1xuICB9O1xuICBSZWN0Mi5vdmVybGFwSG9yaXpvbnRhbGx5ID0gKHJlY3RBLCByZWN0QikgPT4ge1xuICAgIGNvbnN0IGFNYXggPSBSZWN0Mi5tYXhYKHJlY3RBKTtcbiAgICBjb25zdCBiTWF4ID0gUmVjdDIubWF4WChyZWN0Qik7XG4gICAgcmV0dXJuIGFNYXggPiByZWN0Qi54ICYmIGJNYXggPiByZWN0QS54O1xuICB9O1xuICBSZWN0Mi5vdmVybGFwVmVydGljYWxseSA9IChyZWN0QSwgcmVjdEIpID0+IHtcbiAgICBjb25zdCBhTWF4ID0gUmVjdDIubWF4WShyZWN0QSk7XG4gICAgY29uc3QgYk1heCA9IFJlY3QyLm1heFkocmVjdEIpO1xuICAgIHJldHVybiBhTWF4ID4gcmVjdEIueSAmJiBiTWF4ID4gcmVjdEEueTtcbiAgfTtcbiAgUmVjdDIuZG9lc05vdEludGVyc2VjdCA9IChyZWN0LCByZWN0cykgPT4ge1xuICAgIHJldHVybiByZWN0cy5maW5kKChjb21wYXJpbmdSZWN0KSA9PiB7XG4gICAgICByZXR1cm4gUmVjdDIuaW50ZXJzZWN0cyhjb21wYXJpbmdSZWN0LCByZWN0KTtcbiAgICB9KSA9PT0gdm9pZCAwO1xuICB9O1xuICBSZWN0Mi5pc0VxdWFsID0gKHJlY3RBLCByZWN0QikgPT4ge1xuICAgIGlmIChyZWN0QSAmJiByZWN0Qikge1xuICAgICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSByZWN0QTtcbiAgICAgIHJldHVybiByZWN0Qi54ID09PSB4ICYmIHJlY3RCLnkgPT09IHkgJiYgcmVjdEIud2lkdGggPT09IHdpZHRoICYmIHJlY3RCLmhlaWdodCA9PT0gaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVjdEEgPT09IHJlY3RCO1xuICAgIH1cbiAgfTtcbiAgUmVjdDIuY29ybmVyUG9pbnRzID0gKHJlY3QpID0+IHtcbiAgICBjb25zdCByZWN0TWluWCA9IHJlY3QueDtcbiAgICBjb25zdCByZWN0TWF4WCA9IHJlY3QueCArIHJlY3Qud2lkdGg7XG4gICAgY29uc3QgcmVjdE1pblkgPSByZWN0Lnk7XG4gICAgY29uc3QgcmVjdE1heFkgPSByZWN0LnkgKyByZWN0LmhlaWdodDtcbiAgICBjb25zdCBjb3JuZXIxID0geyB4OiByZWN0TWluWCwgeTogcmVjdE1pblkgfTtcbiAgICBjb25zdCBjb3JuZXIyID0geyB4OiByZWN0TWF4WCwgeTogcmVjdE1pblkgfTtcbiAgICBjb25zdCBjb3JuZXIzID0geyB4OiByZWN0TWF4WCwgeTogcmVjdE1heFkgfTtcbiAgICBjb25zdCBjb3JuZXI0ID0geyB4OiByZWN0TWluWCwgeTogcmVjdE1heFkgfTtcbiAgICByZXR1cm4gW2Nvcm5lcjEsIGNvcm5lcjIsIGNvcm5lcjMsIGNvcm5lcjRdO1xuICB9O1xuICBSZWN0Mi5taWRQb2ludHMgPSAocmVjdCkgPT4ge1xuICAgIGNvbnN0IHJlY3RNaW5YID0gcmVjdC54O1xuICAgIGNvbnN0IHJlY3RNaWRYID0gcmVjdC54ICsgcmVjdC53aWR0aCAvIDI7XG4gICAgY29uc3QgcmVjdE1heFggPSByZWN0LnggKyByZWN0LndpZHRoO1xuICAgIGNvbnN0IHJlY3RNaW5ZID0gcmVjdC55O1xuICAgIGNvbnN0IHJlY3RNaWRZID0gcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyO1xuICAgIGNvbnN0IHJlY3RNYXhZID0gcmVjdC55ICsgcmVjdC5oZWlnaHQ7XG4gICAgY29uc3QgY29ybmVyMSA9IHsgeDogcmVjdE1pZFgsIHk6IHJlY3RNaW5ZIH07XG4gICAgY29uc3QgY29ybmVyMiA9IHsgeDogcmVjdE1heFgsIHk6IHJlY3RNaWRZIH07XG4gICAgY29uc3QgY29ybmVyMyA9IHsgeDogcmVjdE1pZFgsIHk6IHJlY3RNYXhZIH07XG4gICAgY29uc3QgY29ybmVyNCA9IHsgeDogcmVjdE1pblgsIHk6IHJlY3RNaWRZIH07XG4gICAgcmV0dXJuIFtjb3JuZXIxLCBjb3JuZXIyLCBjb3JuZXIzLCBjb3JuZXI0XTtcbiAgfTtcbiAgUmVjdDIucG9pbnREaXN0YW5jZSA9IChyZWN0LCBwb2ludCkgPT4ge1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeSA9IDA7XG4gICAgaWYgKHBvaW50LnggPCByZWN0LngpIHtcbiAgICAgIHggPSByZWN0LnggLSBwb2ludC54O1xuICAgIH0gZWxzZSBpZiAocG9pbnQueCA+IFJlY3QyLm1heFgocmVjdCkpIHtcbiAgICAgIHggPSBwb2ludC54IC0gUmVjdDIubWF4WChyZWN0KTtcbiAgICB9XG4gICAgaWYgKHBvaW50LnkgPCByZWN0LnkpIHtcbiAgICAgIHkgPSByZWN0LnkgLSBwb2ludC55O1xuICAgIH0gZWxzZSBpZiAocG9pbnQueSA+IFJlY3QyLm1heFkocmVjdCkpIHtcbiAgICAgIHkgPSBwb2ludC55IC0gUmVjdDIubWF4WShyZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIFBvaW50LmRpc3RhbmNlKHsgeCwgeSB9LCB7IHg6IDAsIHk6IDAgfSk7XG4gIH07XG4gIGNvbnN0IGZyb21BbnlEZWZhdWx0cyA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH07XG4gIFJlY3QyLmZyb21BbnkgPSAocmVjdCwgZGVmYXVsdHMgPSBmcm9tQW55RGVmYXVsdHMpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcmVjdC54IHx8IGRlZmF1bHRzLngsXG4gICAgICB5OiByZWN0LnkgfHwgZGVmYXVsdHMueSxcbiAgICAgIHdpZHRoOiByZWN0LndpZHRoIHx8IGRlZmF1bHRzLndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCB8fCBkZWZhdWx0cy5oZWlnaHRcbiAgICB9O1xuICB9O1xufSkoUmVjdCB8fCAoUmVjdCA9IHt9KSk7XG5cbi8vIHNyYy9yZW5kZXIvdXRpbHMvaXNGaW5pdGVOdW1iZXIudHNcbmZ1bmN0aW9uIGlzRmluaXRlTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsdWUpO1xufVxuZnVuY3Rpb24gZmluaXRlTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiBpc0Zpbml0ZU51bWJlcih2YWx1ZSkgPyB2YWx1ZSA6IHZvaWQgMDtcbn1cblxuLy8gc3JjL3V0aWxzL3R5cGUtZ3VhcmRzLnRzXG5mdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICByZXR1cm4gIW9iaiB8fCAhT2JqZWN0LmtleXMob2JqKS5sZW5ndGggJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG5mdW5jdGlvbiBpc1JlYWN0RWxlbWVudCh0ZXN0Mikge1xuICByZXR1cm4gdHlwZW9mIHRlc3QyICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB0ZXN0MiAhPT0gXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIGlzUmVhY3RDaGlsZCh0ZXN0Mikge1xuICByZXR1cm4gdGVzdDIgIT09IG51bGwgJiYgdHlwZW9mIHRlc3QyICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB0ZXN0MiAhPT0gXCJib29sZWFuXCIgJiYgIWlzRW1wdHkodGVzdDIpO1xufVxuXG4vLyBzcmMvcmVuZGVyL3R5cGVzL0NvbnN0cmFpbnRzLnRzXG52YXIgY29uc3RyYWludERlZmF1bHRzID0ge1xuICBsZWZ0OiBudWxsLFxuICByaWdodDogbnVsbCxcbiAgdG9wOiBudWxsLFxuICBib3R0b206IG51bGwsXG4gIGNlbnRlclg6IFwiNTAlXCIsXG4gIGNlbnRlclk6IFwiNTAlXCIsXG4gIGFzcGVjdFJhdGlvOiBudWxsLFxuICBwYXJlbnRTaXplOiBudWxsLFxuICB3aWR0aDogMTAwLFxuICBoZWlnaHQ6IDEwMFxufTtcbnZhciBEaW1lbnNpb25UeXBlO1xuKGZ1bmN0aW9uKERpbWVuc2lvblR5cGUyKSB7XG4gIERpbWVuc2lvblR5cGUyW0RpbWVuc2lvblR5cGUyW1wiRml4ZWROdW1iZXJcIl0gPSAwXSA9IFwiRml4ZWROdW1iZXJcIjtcbiAgRGltZW5zaW9uVHlwZTJbRGltZW5zaW9uVHlwZTJbXCJQZXJjZW50YWdlXCJdID0gMV0gPSBcIlBlcmNlbnRhZ2VcIjtcbiAgRGltZW5zaW9uVHlwZTJbRGltZW5zaW9uVHlwZTJbXCJBdXRvXCJdID0gMl0gPSBcIkF1dG9cIjtcbiAgRGltZW5zaW9uVHlwZTJbRGltZW5zaW9uVHlwZTJbXCJGcmFjdGlvbk9mRnJlZVNwYWNlXCJdID0gM10gPSBcIkZyYWN0aW9uT2ZGcmVlU3BhY2VcIjtcbn0pKERpbWVuc2lvblR5cGUgfHwgKERpbWVuc2lvblR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gaXNDb25zdHJhaW50U3VwcG9ydGluZ0NoaWxkKGNoaWxkKSB7XG4gIGlmICghaXNSZWFjdENoaWxkKGNoaWxkKSB8fCAhaXNSZWFjdEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxudmFyIENvbnN0cmFpbnRNYXNrO1xuKGZ1bmN0aW9uKENvbnN0cmFpbnRNYXNrMikge1xuICBDb25zdHJhaW50TWFzazIucXVpY2tmaXggPSAoY29uc3RyYWludHMpID0+IHtcbiAgICBpZiAoY29uc3RyYWludHMud2lkdGhUeXBlID09PSAyIHx8IGNvbnN0cmFpbnRzLmhlaWdodFR5cGUgPT09IDIpIHtcbiAgICAgIGNvbnN0cmFpbnRzLmFzcGVjdFJhdGlvID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKGNvbnN0cmFpbnRzLmFzcGVjdFJhdGlvKSkge1xuICAgICAgaWYgKGNvbnN0cmFpbnRzLmxlZnQgJiYgY29uc3RyYWludHMucmlnaHQgfHwgY29uc3RyYWludHMudG9wICYmIGNvbnN0cmFpbnRzLmJvdHRvbSkge1xuICAgICAgICBjb25zdHJhaW50cy53aWR0aFR5cGUgPSAwO1xuICAgICAgICBjb25zdHJhaW50cy5oZWlnaHRUeXBlID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChjb25zdHJhaW50cy5sZWZ0ICYmIGNvbnN0cmFpbnRzLnJpZ2h0ICYmIGNvbnN0cmFpbnRzLnRvcCAmJiBjb25zdHJhaW50cy5ib3R0b20pIHtcbiAgICAgICAgY29uc3RyYWludHMuYm90dG9tID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoY29uc3RyYWludHMud2lkdGhUeXBlICE9PSAwICYmIGNvbnN0cmFpbnRzLmhlaWdodFR5cGUgIT09IDApIHtcbiAgICAgICAgY29uc3RyYWludHMuaGVpZ2h0VHlwZSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb25zdHJhaW50cy5sZWZ0ICYmIGNvbnN0cmFpbnRzLnJpZ2h0KSB7XG4gICAgICBpZiAoY29uc3RyYWludHMuZml4ZWRTaXplIHx8IGNvbnN0cmFpbnRzLndpZHRoVHlwZSA9PT0gMikge1xuICAgICAgICBjb25zdHJhaW50cy5yaWdodCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3RyYWludHMud2lkdGhUeXBlID0gMDtcbiAgICB9XG4gICAgaWYgKGNvbnN0cmFpbnRzLnRvcCAmJiBjb25zdHJhaW50cy5ib3R0b20pIHtcbiAgICAgIGlmIChjb25zdHJhaW50cy5maXhlZFNpemUgfHwgY29uc3RyYWludHMuaGVpZ2h0VHlwZSA9PT0gMikge1xuICAgICAgICBjb25zdHJhaW50cy5ib3R0b20gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0cmFpbnRzLmhlaWdodFR5cGUgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gY29uc3RyYWludHM7XG4gIH07XG59KShDb25zdHJhaW50TWFzayB8fCAoQ29uc3RyYWludE1hc2sgPSB7fSkpO1xuZnVuY3Rpb24gdmFsdWVUb0RpbWVuc2lvblR5cGUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHRyaW1tZWRWYWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICBpZiAodHJpbW1lZFZhbHVlID09PSBcImF1dG9cIilcbiAgICAgIHJldHVybiAyO1xuICAgIGlmICh0cmltbWVkVmFsdWUuZW5kc1dpdGgoXCJmclwiKSlcbiAgICAgIHJldHVybiAzO1xuICAgIGlmICh0cmltbWVkVmFsdWUuZW5kc1dpdGgoXCIlXCIpKVxuICAgICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG52YXIgQ29uc3RyYWludFZhbHVlcztcbihmdW5jdGlvbihDb25zdHJhaW50VmFsdWVzMikge1xuICBDb25zdHJhaW50VmFsdWVzMi5mcm9tUHJvcGVydGllcyA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBhc3BlY3RSYXRpbywgYXV0b1NpemUgfSA9IHByb3BzO1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gQ29uc3RyYWludE1hc2sucXVpY2tmaXgoe1xuICAgICAgbGVmdDogaXNGaW5pdGVOdW1iZXIobGVmdCkgfHwgaXNBbmltYXRhYmxlMihsZWZ0KSxcbiAgICAgIHJpZ2h0OiBpc0Zpbml0ZU51bWJlcihyaWdodCkgfHwgaXNBbmltYXRhYmxlMihyaWdodCksXG4gICAgICB0b3A6IGlzRmluaXRlTnVtYmVyKHRvcCkgfHwgaXNBbmltYXRhYmxlMih0b3ApLFxuICAgICAgYm90dG9tOiBpc0Zpbml0ZU51bWJlcihib3R0b20pIHx8IGlzQW5pbWF0YWJsZTIoYm90dG9tKSxcbiAgICAgIHdpZHRoVHlwZTogdmFsdWVUb0RpbWVuc2lvblR5cGUod2lkdGgpLFxuICAgICAgaGVpZ2h0VHlwZTogdmFsdWVUb0RpbWVuc2lvblR5cGUoaGVpZ2h0KSxcbiAgICAgIGFzcGVjdFJhdGlvOiBhc3BlY3RSYXRpbyB8fCBudWxsLFxuICAgICAgZml4ZWRTaXplOiBhdXRvU2l6ZSA9PT0gdHJ1ZVxuICAgIH0pO1xuICAgIGxldCB3aWR0aFZhbHVlID0gbnVsbDtcbiAgICBsZXQgaGVpZ2h0VmFsdWUgPSBudWxsO1xuICAgIGxldCB3aWR0aFR5cGUgPSAwO1xuICAgIGxldCBoZWlnaHRUeXBlID0gMDtcbiAgICBpZiAoY29uc3RyYWludHMud2lkdGhUeXBlICE9PSAwICYmIHR5cGVvZiB3aWR0aCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgcGFyc2VkV2lkdGggPSBwYXJzZUZsb2F0KHdpZHRoKTtcbiAgICAgIGlmICh3aWR0aC5lbmRzV2l0aChcImZyXCIpKSB7XG4gICAgICAgIHdpZHRoVHlwZSA9IDM7XG4gICAgICAgIHdpZHRoVmFsdWUgPSBwYXJzZWRXaWR0aDtcbiAgICAgIH0gZWxzZSBpZiAod2lkdGggPT09IFwiYXV0b1wiKSB7XG4gICAgICAgIHdpZHRoVHlwZSA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aFR5cGUgPSAxO1xuICAgICAgICB3aWR0aFZhbHVlID0gcGFyc2VkV2lkdGggLyAxMDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh3aWR0aCAhPT0gdm9pZCAwICYmIHR5cGVvZiB3aWR0aCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgd2lkdGhWYWx1ZSA9IEFuaW1hdGFibGUuZ2V0TnVtYmVyKHdpZHRoKTtcbiAgICB9XG4gICAgaWYgKGNvbnN0cmFpbnRzLmhlaWdodFR5cGUgIT09IDAgJiYgdHlwZW9mIGhlaWdodCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgcGFyc2VkSGVpZ2h0ID0gcGFyc2VGbG9hdChoZWlnaHQpO1xuICAgICAgaWYgKGhlaWdodC5lbmRzV2l0aChcImZyXCIpKSB7XG4gICAgICAgIGhlaWdodFR5cGUgPSAzO1xuICAgICAgICBoZWlnaHRWYWx1ZSA9IHBhcnNlZEhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0ID09PSBcImF1dG9cIikge1xuICAgICAgICBoZWlnaHRUeXBlID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlaWdodFR5cGUgPSAxO1xuICAgICAgICBoZWlnaHRWYWx1ZSA9IHBhcnNlRmxvYXQoaGVpZ2h0KSAvIDEwMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhlaWdodCAhPT0gdm9pZCAwICYmIHR5cGVvZiBoZWlnaHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGhlaWdodFZhbHVlID0gQW5pbWF0YWJsZS5nZXROdW1iZXIoaGVpZ2h0KTtcbiAgICB9XG4gICAgbGV0IGNlbnRlckFuY2hvclggPSAwLjU7XG4gICAgbGV0IGNlbnRlckFuY2hvclkgPSAwLjU7XG4gICAgaWYgKGNlbnRlclgpIHtcbiAgICAgIGNlbnRlckFuY2hvclggPSBwYXJzZUZsb2F0KGNlbnRlclgpIC8gMTAwO1xuICAgIH1cbiAgICBpZiAoY2VudGVyWSkge1xuICAgICAgY2VudGVyQW5jaG9yWSA9IHBhcnNlRmxvYXQoY2VudGVyWSkgLyAxMDA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBjb25zdHJhaW50cy5sZWZ0ID8gQW5pbWF0YWJsZS5nZXROdW1iZXIobGVmdCkgOiBudWxsLFxuICAgICAgcmlnaHQ6IGNvbnN0cmFpbnRzLnJpZ2h0ID8gQW5pbWF0YWJsZS5nZXROdW1iZXIocmlnaHQpIDogbnVsbCxcbiAgICAgIHRvcDogY29uc3RyYWludHMudG9wID8gQW5pbWF0YWJsZS5nZXROdW1iZXIodG9wKSA6IG51bGwsXG4gICAgICBib3R0b206IGNvbnN0cmFpbnRzLmJvdHRvbSA/IEFuaW1hdGFibGUuZ2V0TnVtYmVyKGJvdHRvbSkgOiBudWxsLFxuICAgICAgd2lkdGhUeXBlLFxuICAgICAgaGVpZ2h0VHlwZSxcbiAgICAgIHdpZHRoOiB3aWR0aFZhbHVlLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRWYWx1ZSxcbiAgICAgIGFzcGVjdFJhdGlvOiBjb25zdHJhaW50cy5hc3BlY3RSYXRpbyB8fCBudWxsLFxuICAgICAgY2VudGVyQW5jaG9yWCxcbiAgICAgIGNlbnRlckFuY2hvcllcbiAgICB9O1xuICB9O1xuICBDb25zdHJhaW50VmFsdWVzMi50b01pblNpemUgPSAodmFsdWVzLCBwYXJlbnRTaXplLCBhdXRvU2l6ZSA9IG51bGwpID0+IHtcbiAgICBsZXQgd2lkdGggPSBudWxsO1xuICAgIGxldCBoZWlnaHQgPSBudWxsO1xuICAgIGNvbnN0IHBhcmVudFdpZHRoID0gcGFyZW50U2l6ZSA/IHBhcmVudFNpemUud2lkdGggOiBudWxsO1xuICAgIGNvbnN0IHBhcmVudEhlaWdodCA9IHBhcmVudFNpemUgPyBwYXJlbnRTaXplLmhlaWdodCA6IG51bGw7XG4gICAgY29uc3QgaE9wcG9zaW5nUGluc09mZnNldCA9IHBpbm5lZE9mZnNldCh2YWx1ZXMubGVmdCwgdmFsdWVzLnJpZ2h0KTtcbiAgICBpZiAocGFyZW50V2lkdGggJiYgaXNGaW5pdGVOdW1iZXIoaE9wcG9zaW5nUGluc09mZnNldCkpIHtcbiAgICAgIHdpZHRoID0gcGFyZW50V2lkdGggLSBoT3Bwb3NpbmdQaW5zT2Zmc2V0O1xuICAgIH0gZWxzZSBpZiAoYXV0b1NpemUgJiYgdmFsdWVzLndpZHRoVHlwZSA9PT0gMikge1xuICAgICAgd2lkdGggPSBhdXRvU2l6ZS53aWR0aDtcbiAgICB9IGVsc2UgaWYgKGlzRmluaXRlTnVtYmVyKHZhbHVlcy53aWR0aCkpIHtcbiAgICAgIHN3aXRjaCAodmFsdWVzLndpZHRoVHlwZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgd2lkdGggPSB2YWx1ZXMud2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAocGFyZW50V2lkdGgpIHtcbiAgICAgICAgICAgIHdpZHRoID0gcGFyZW50V2lkdGggKiB2YWx1ZXMud2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2T3Bwb3NpbmdQaW5zT2Zmc2V0ID0gcGlubmVkT2Zmc2V0KHZhbHVlcy50b3AsIHZhbHVlcy5ib3R0b20pO1xuICAgIGlmIChwYXJlbnRIZWlnaHQgJiYgaXNGaW5pdGVOdW1iZXIodk9wcG9zaW5nUGluc09mZnNldCkpIHtcbiAgICAgIGhlaWdodCA9IHBhcmVudEhlaWdodCAtIHZPcHBvc2luZ1BpbnNPZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChhdXRvU2l6ZSAmJiB2YWx1ZXMuaGVpZ2h0VHlwZSA9PT0gMikge1xuICAgICAgaGVpZ2h0ID0gYXV0b1NpemUuaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAoaXNGaW5pdGVOdW1iZXIodmFsdWVzLmhlaWdodCkpIHtcbiAgICAgIHN3aXRjaCAodmFsdWVzLmhlaWdodFR5cGUpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGhlaWdodCA9IHZhbHVlcy5oZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBoZWlnaHQgPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKHBhcmVudEhlaWdodCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gcGFyZW50SGVpZ2h0ICogdmFsdWVzLmhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaXplQWZ0ZXJBcHBseWluZ0RlZmF1bHRzQW5kQXNwZWN0UmF0aW8od2lkdGgsIGhlaWdodCwgdmFsdWVzKTtcbiAgfTtcbiAgQ29uc3RyYWludFZhbHVlczIudG9TaXplID0gKHZhbHVlcywgcGFyZW50U2l6ZSwgYXV0b1NpemUsIGZyZWVTcGFjZSkgPT4ge1xuICAgIGxldCB3aWR0aCA9IG51bGw7XG4gICAgbGV0IGhlaWdodCA9IG51bGw7XG4gICAgY29uc3QgcGFyZW50V2lkdGggPSBwYXJlbnRTaXplID8gQW5pbWF0YWJsZS5nZXROdW1iZXIocGFyZW50U2l6ZS53aWR0aCkgOiBudWxsO1xuICAgIGNvbnN0IHBhcmVudEhlaWdodCA9IHBhcmVudFNpemUgPyBBbmltYXRhYmxlLmdldE51bWJlcihwYXJlbnRTaXplLmhlaWdodCkgOiBudWxsO1xuICAgIGNvbnN0IGhPcHBvc2luZ1BpbnNPZmZzZXQgPSBwaW5uZWRPZmZzZXQodmFsdWVzLmxlZnQsIHZhbHVlcy5yaWdodCk7XG4gICAgaWYgKHBhcmVudFdpZHRoICYmIGlzRmluaXRlTnVtYmVyKGhPcHBvc2luZ1BpbnNPZmZzZXQpKSB7XG4gICAgICB3aWR0aCA9IHBhcmVudFdpZHRoIC0gaE9wcG9zaW5nUGluc09mZnNldDtcbiAgICB9IGVsc2UgaWYgKGF1dG9TaXplICYmIHZhbHVlcy53aWR0aFR5cGUgPT09IDIpIHtcbiAgICAgIHdpZHRoID0gYXV0b1NpemUud2lkdGg7XG4gICAgfSBlbHNlIGlmIChpc0Zpbml0ZU51bWJlcih2YWx1ZXMud2lkdGgpKSB7XG4gICAgICBzd2l0Y2ggKHZhbHVlcy53aWR0aFR5cGUpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHdpZHRoID0gdmFsdWVzLndpZHRoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgd2lkdGggPSBmcmVlU3BhY2UgPyBmcmVlU3BhY2UuZnJlZVNwYWNlSW5QYXJlbnQud2lkdGggLyBmcmVlU3BhY2UuZnJlZVNwYWNlVW5pdERpdmlzb3Iud2lkdGggKiB2YWx1ZXMud2lkdGggOiAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKHBhcmVudFdpZHRoKSB7XG4gICAgICAgICAgICB3aWR0aCA9IHBhcmVudFdpZHRoICogdmFsdWVzLndpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgdk9wcG9zaW5nUGluc09mZnNldCA9IHBpbm5lZE9mZnNldCh2YWx1ZXMudG9wLCB2YWx1ZXMuYm90dG9tKTtcbiAgICBpZiAocGFyZW50SGVpZ2h0ICYmIGlzRmluaXRlTnVtYmVyKHZPcHBvc2luZ1BpbnNPZmZzZXQpKSB7XG4gICAgICBoZWlnaHQgPSBwYXJlbnRIZWlnaHQgLSB2T3Bwb3NpbmdQaW5zT2Zmc2V0O1xuICAgIH0gZWxzZSBpZiAoYXV0b1NpemUgJiYgdmFsdWVzLmhlaWdodFR5cGUgPT09IDIpIHtcbiAgICAgIGhlaWdodCA9IGF1dG9TaXplLmhlaWdodDtcbiAgICB9IGVsc2UgaWYgKGlzRmluaXRlTnVtYmVyKHZhbHVlcy5oZWlnaHQpKSB7XG4gICAgICBzd2l0Y2ggKHZhbHVlcy5oZWlnaHRUeXBlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBoZWlnaHQgPSB2YWx1ZXMuaGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgaGVpZ2h0ID0gZnJlZVNwYWNlID8gZnJlZVNwYWNlLmZyZWVTcGFjZUluUGFyZW50LmhlaWdodCAvIGZyZWVTcGFjZS5mcmVlU3BhY2VVbml0RGl2aXNvci5oZWlnaHQgKiB2YWx1ZXMuaGVpZ2h0IDogMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChwYXJlbnRIZWlnaHQpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IHBhcmVudEhlaWdodCAqIHZhbHVlcy5oZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2l6ZUFmdGVyQXBwbHlpbmdEZWZhdWx0c0FuZEFzcGVjdFJhdGlvKHdpZHRoLCBoZWlnaHQsIHZhbHVlcyk7XG4gIH07XG4gIENvbnN0cmFpbnRWYWx1ZXMyLnRvUmVjdCA9ICh2YWx1ZXMsIHBhcmVudFNpemUsIGF1dG9TaXplID0gbnVsbCwgcGl4ZWxBbGlnbiA9IGZhbHNlLCBmcmVlU3BhY2UgPSBudWxsKSA9PiB7XG4gICAgbGV0IHggPSB2YWx1ZXMubGVmdCB8fCAwO1xuICAgIGxldCB5ID0gdmFsdWVzLnRvcCB8fCAwO1xuICAgIGxldCB3aWR0aCA9IG51bGw7XG4gICAgbGV0IGhlaWdodCA9IG51bGw7XG4gICAgY29uc3QgcGFyZW50V2lkdGggPSBwYXJlbnRTaXplID8gQW5pbWF0YWJsZS5nZXROdW1iZXIocGFyZW50U2l6ZS53aWR0aCkgOiBudWxsO1xuICAgIGNvbnN0IHBhcmVudEhlaWdodCA9IHBhcmVudFNpemUgPyBBbmltYXRhYmxlLmdldE51bWJlcihwYXJlbnRTaXplLmhlaWdodCkgOiBudWxsO1xuICAgIGNvbnN0IGhPcHBvc2luZ1BpbnNPZmZzZXQgPSBwaW5uZWRPZmZzZXQodmFsdWVzLmxlZnQsIHZhbHVlcy5yaWdodCk7XG4gICAgaWYgKHBhcmVudFdpZHRoICYmIGlzRmluaXRlTnVtYmVyKGhPcHBvc2luZ1BpbnNPZmZzZXQpKSB7XG4gICAgICB3aWR0aCA9IHBhcmVudFdpZHRoIC0gaE9wcG9zaW5nUGluc09mZnNldDtcbiAgICB9IGVsc2UgaWYgKGF1dG9TaXplICYmIHZhbHVlcy53aWR0aFR5cGUgPT09IDIpIHtcbiAgICAgIHdpZHRoID0gYXV0b1NpemUud2lkdGg7XG4gICAgfSBlbHNlIGlmIChpc0Zpbml0ZU51bWJlcih2YWx1ZXMud2lkdGgpKSB7XG4gICAgICBzd2l0Y2ggKHZhbHVlcy53aWR0aFR5cGUpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHdpZHRoID0gdmFsdWVzLndpZHRoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgd2lkdGggPSBmcmVlU3BhY2UgPyBmcmVlU3BhY2UuZnJlZVNwYWNlSW5QYXJlbnQud2lkdGggLyBmcmVlU3BhY2UuZnJlZVNwYWNlVW5pdERpdmlzb3Iud2lkdGggKiB2YWx1ZXMud2lkdGggOiBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKHBhcmVudFdpZHRoKSB7XG4gICAgICAgICAgICB3aWR0aCA9IHBhcmVudFdpZHRoICogdmFsdWVzLndpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgdk9wcG9zaW5nUGluc09mZnNldCA9IHBpbm5lZE9mZnNldCh2YWx1ZXMudG9wLCB2YWx1ZXMuYm90dG9tKTtcbiAgICBpZiAocGFyZW50SGVpZ2h0ICYmIGlzRmluaXRlTnVtYmVyKHZPcHBvc2luZ1BpbnNPZmZzZXQpKSB7XG4gICAgICBoZWlnaHQgPSBwYXJlbnRIZWlnaHQgLSB2T3Bwb3NpbmdQaW5zT2Zmc2V0O1xuICAgIH0gZWxzZSBpZiAoYXV0b1NpemUgJiYgdmFsdWVzLmhlaWdodFR5cGUgPT09IDIpIHtcbiAgICAgIGhlaWdodCA9IGF1dG9TaXplLmhlaWdodDtcbiAgICB9IGVsc2UgaWYgKGlzRmluaXRlTnVtYmVyKHZhbHVlcy5oZWlnaHQpKSB7XG4gICAgICBzd2l0Y2ggKHZhbHVlcy5oZWlnaHRUeXBlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBoZWlnaHQgPSB2YWx1ZXMuaGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgaGVpZ2h0ID0gZnJlZVNwYWNlID8gZnJlZVNwYWNlLmZyZWVTcGFjZUluUGFyZW50LmhlaWdodCAvIGZyZWVTcGFjZS5mcmVlU3BhY2VVbml0RGl2aXNvci5oZWlnaHQgKiB2YWx1ZXMuaGVpZ2h0IDogbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChwYXJlbnRIZWlnaHQpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IHBhcmVudEhlaWdodCAqIHZhbHVlcy5oZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzaXplV2l0aERlZmF1bHRzID0gc2l6ZUFmdGVyQXBwbHlpbmdEZWZhdWx0c0FuZEFzcGVjdFJhdGlvKHdpZHRoLCBoZWlnaHQsIHZhbHVlcyk7XG4gICAgd2lkdGggPSBzaXplV2l0aERlZmF1bHRzLndpZHRoO1xuICAgIGhlaWdodCA9IHNpemVXaXRoRGVmYXVsdHMuaGVpZ2h0O1xuICAgIGlmICh2YWx1ZXMubGVmdCAhPT0gbnVsbCkge1xuICAgICAgeCA9IHZhbHVlcy5sZWZ0O1xuICAgIH0gZWxzZSBpZiAocGFyZW50V2lkdGggJiYgdmFsdWVzLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICB4ID0gcGFyZW50V2lkdGggLSB2YWx1ZXMucmlnaHQgLSB3aWR0aDtcbiAgICB9IGVsc2UgaWYgKHBhcmVudFdpZHRoKSB7XG4gICAgICB4ID0gdmFsdWVzLmNlbnRlckFuY2hvclggKiBwYXJlbnRXaWR0aCAtIHdpZHRoIC8gMjtcbiAgICB9XG4gICAgaWYgKHZhbHVlcy50b3AgIT09IG51bGwpIHtcbiAgICAgIHkgPSB2YWx1ZXMudG9wO1xuICAgIH0gZWxzZSBpZiAocGFyZW50SGVpZ2h0ICYmIHZhbHVlcy5ib3R0b20gIT09IG51bGwpIHtcbiAgICAgIHkgPSBwYXJlbnRIZWlnaHQgLSB2YWx1ZXMuYm90dG9tIC0gaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAocGFyZW50SGVpZ2h0KSB7XG4gICAgICB5ID0gdmFsdWVzLmNlbnRlckFuY2hvclkgKiBwYXJlbnRIZWlnaHQgLSBoZWlnaHQgLyAyO1xuICAgIH1cbiAgICBjb25zdCBmID0geyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH07XG4gICAgaWYgKHBpeGVsQWxpZ24pIHtcbiAgICAgIHJldHVybiBSZWN0LnBpeGVsQWxpZ25lZChmKTtcbiAgICB9XG4gICAgcmV0dXJuIGY7XG4gIH07XG59KShDb25zdHJhaW50VmFsdWVzIHx8IChDb25zdHJhaW50VmFsdWVzID0ge30pKTtcbnZhciBkZWZhdWx0V2lkdGggPSAyMDA7XG52YXIgZGVmYXVsdEhlaWdodCA9IDIwMDtcbmZ1bmN0aW9uIHNpemVBZnRlckFwcGx5aW5nRGVmYXVsdHNBbmRBc3BlY3RSYXRpbyh3aWR0aCwgaGVpZ2h0LCB2YWx1ZXMpIHtcbiAgbGV0IHcgPSBpc0Zpbml0ZU51bWJlcih3aWR0aCkgPyB3aWR0aCA6IGRlZmF1bHRXaWR0aDtcbiAgbGV0IGggPSBpc0Zpbml0ZU51bWJlcihoZWlnaHQpID8gaGVpZ2h0IDogZGVmYXVsdEhlaWdodDtcbiAgaWYgKGlzRmluaXRlTnVtYmVyKHZhbHVlcy5hc3BlY3RSYXRpbykgJiYgdmFsdWVzLmFzcGVjdFJhdGlvID4gMCkge1xuICAgIGlmIChpc0Zpbml0ZU51bWJlcih2YWx1ZXMubGVmdCkgJiYgaXNGaW5pdGVOdW1iZXIodmFsdWVzLnJpZ2h0KSkge1xuICAgICAgaCA9IHcgLyB2YWx1ZXMuYXNwZWN0UmF0aW87XG4gICAgfSBlbHNlIGlmIChpc0Zpbml0ZU51bWJlcih2YWx1ZXMudG9wKSAmJiBpc0Zpbml0ZU51bWJlcih2YWx1ZXMuYm90dG9tKSkge1xuICAgICAgdyA9IGggKiB2YWx1ZXMuYXNwZWN0UmF0aW87XG4gICAgfSBlbHNlIGlmICh2YWx1ZXMud2lkdGhUeXBlICE9PSAwKSB7XG4gICAgICBoID0gdyAvIHZhbHVlcy5hc3BlY3RSYXRpbztcbiAgICB9IGVsc2Uge1xuICAgICAgdyA9IGggKiB2YWx1ZXMuYXNwZWN0UmF0aW87XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHcsXG4gICAgaGVpZ2h0OiBoXG4gIH07XG59XG5mdW5jdGlvbiBwaW5uZWRPZmZzZXQoc3RhcnQsIGVuZCkge1xuICBpZiAoIWlzRmluaXRlTnVtYmVyKHN0YXJ0KSB8fCAhaXNGaW5pdGVOdW1iZXIoZW5kKSlcbiAgICByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHN0YXJ0ICsgZW5kO1xufVxuZnVuY3Rpb24gZ2V0TWVyZ2VkQ29uc3RyYWludHNQcm9wcyhwcm9wcywgY29uc3RyYWludHMpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGlmIChwcm9wcy5jb25zdHJhaW50cykge1xuICAgIHJlc3VsdC5jb25zdHJhaW50cyA9IHsgLi4ucHJvcHMuY29uc3RyYWludHMsIC4uLmNvbnN0cmFpbnRzIH07XG4gIH0gZWxzZSB7XG4gICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIGNvbnN0cmFpbnRzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvcmVuZGVyL3R5cGVzL05ld0NvbnN0cmFpbnRzLnRzeFxuZnVuY3Rpb24gaXNTdHJpbmczKHQpIHtcbiAgcmV0dXJuIHR5cGVvZiB0ID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gY29udGFpbnNJbnZhbGlkU3RyaW5nVmFsdWVzKHByb3BzKSB7XG4gIGNvbnN0IHsgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBjZW50ZXIgfSA9IHByb3BzO1xuICBpZiAoW3JpZ2h0LCBib3R0b21dLnNvbWUoaXNTdHJpbmczKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc1N0cmluZzMobGVmdCkgJiYgKCFjZW50ZXIgfHwgY2VudGVyID09PSBcInlcIikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNTdHJpbmczKHRvcCkgJiYgKCFjZW50ZXIgfHwgY2VudGVyID09PSBcInhcIikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb25zdHJhaW50c0VuYWJsZWQocHJvcHMpIHtcbiAgY29uc3QgeyBfY29uc3RyYWludHMgfSA9IHByb3BzO1xuICBpZiAoIV9jb25zdHJhaW50cykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoY29udGFpbnNJbnZhbGlkU3RyaW5nVmFsdWVzKHByb3BzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gX2NvbnN0cmFpbnRzLmVuYWJsZWQ7XG59XG5mdW5jdGlvbiBzaXplRnJvbUZpbml0ZU51bWJlclByb3BzKHByb3BzKSB7XG4gIGNvbnN0IHsgc2l6ZTogc2l6ZTIgfSA9IHByb3BzO1xuICBsZXQgeyB3aWR0aCwgaGVpZ2h0IH0gPSBwcm9wcztcbiAgaWYgKGlzRmluaXRlTnVtYmVyKHNpemUyKSkge1xuICAgIGlmICh3aWR0aCA9PT0gdm9pZCAwKSB7XG4gICAgICB3aWR0aCA9IHNpemUyO1xuICAgIH1cbiAgICBpZiAoaGVpZ2h0ID09PSB2b2lkIDApIHtcbiAgICAgIGhlaWdodCA9IHNpemUyO1xuICAgIH1cbiAgfVxuICBpZiAoaXNGaW5pdGVOdW1iZXIod2lkdGgpICYmIGlzRmluaXRlTnVtYmVyKGhlaWdodCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcmVjdEZyb21GaW5pdGVOdW1iZXJQcm9wcyhwcm9wcykge1xuICBjb25zdCBzaXplMiA9IHNpemVGcm9tRmluaXRlTnVtYmVyUHJvcHMocHJvcHMpO1xuICBpZiAoc2l6ZTIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB7IGxlZnQsIHRvcCB9ID0gcHJvcHM7XG4gIGlmIChpc0Zpbml0ZU51bWJlcihsZWZ0KSAmJiBpc0Zpbml0ZU51bWJlcih0b3ApKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGxlZnQsXG4gICAgICB5OiB0b3AsXG4gICAgICAuLi5zaXplMlxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVSZWN0KHByb3BzLCBwYXJlbnRTaXplLCBwaXhlbEFsaWduID0gdHJ1ZSkge1xuICBpZiAoIWNvbnN0cmFpbnRzRW5hYmxlZChwcm9wcykgfHwgcGFyZW50U2l6ZSA9PT0gUGFyZW50U2l6ZVN0YXRlLkRpc2FibGVkIHx8IHBhcmVudFNpemUgPT09IFBhcmVudFNpemVTdGF0ZS5EaXNhYmxlZEZvckN1cnJlbnRMZXZlbCkge1xuICAgIHJldHVybiByZWN0RnJvbUZpbml0ZU51bWJlclByb3BzKHByb3BzKTtcbiAgfVxuICBjb25zdCBjb25zdHJhaW50VmFsdWVzID0gZ2V0Q29uc3RyYWludFZhbHVlcyhwcm9wcyk7XG4gIHJldHVybiBDb25zdHJhaW50VmFsdWVzLnRvUmVjdChjb25zdHJhaW50VmFsdWVzLCBkZXByZWNhdGVkUGFyZW50U2l6ZShwYXJlbnRTaXplKSwgbnVsbCwgcGl4ZWxBbGlnbik7XG59XG5mdW5jdGlvbiBnZXRDb25zdHJhaW50VmFsdWVzKHByb3BzKSB7XG4gIGNvbnN0IHsgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBjZW50ZXIsIF9jb25zdHJhaW50cywgc2l6ZTogc2l6ZTIgfSA9IHByb3BzO1xuICBsZXQgeyB3aWR0aCwgaGVpZ2h0IH0gPSBwcm9wcztcbiAgaWYgKHdpZHRoID09PSB2b2lkIDApIHtcbiAgICB3aWR0aCA9IHNpemUyO1xuICB9XG4gIGlmIChoZWlnaHQgPT09IHZvaWQgMCkge1xuICAgIGhlaWdodCA9IHNpemUyO1xuICB9XG4gIGNvbnN0IHsgYXNwZWN0UmF0aW8sIGF1dG9TaXplIH0gPSBfY29uc3RyYWludHM7XG4gIGNvbnN0IGNvbnN0cmFpbnRNYXNrID0gQ29uc3RyYWludE1hc2sucXVpY2tmaXgoe1xuICAgIGxlZnQ6IGlzRmluaXRlTnVtYmVyKGxlZnQpLFxuICAgIHJpZ2h0OiBpc0Zpbml0ZU51bWJlcihyaWdodCksXG4gICAgdG9wOiBpc0Zpbml0ZU51bWJlcih0b3ApLFxuICAgIGJvdHRvbTogaXNGaW5pdGVOdW1iZXIoYm90dG9tKSxcbiAgICB3aWR0aFR5cGU6IHZhbHVlVG9EaW1lbnNpb25UeXBlKHdpZHRoKSxcbiAgICBoZWlnaHRUeXBlOiB2YWx1ZVRvRGltZW5zaW9uVHlwZShoZWlnaHQpLFxuICAgIGFzcGVjdFJhdGlvOiBhc3BlY3RSYXRpbyB8fCBudWxsLFxuICAgIGZpeGVkU2l6ZTogYXV0b1NpemUgPT09IHRydWVcbiAgfSk7XG4gIGxldCB3aWR0aFZhbHVlID0gbnVsbDtcbiAgbGV0IGhlaWdodFZhbHVlID0gbnVsbDtcbiAgbGV0IHdpZHRoVHlwZSA9IERpbWVuc2lvblR5cGUuRml4ZWROdW1iZXI7XG4gIGxldCBoZWlnaHRUeXBlID0gRGltZW5zaW9uVHlwZS5GaXhlZE51bWJlcjtcbiAgaWYgKGNvbnN0cmFpbnRNYXNrLndpZHRoVHlwZSAhPT0gRGltZW5zaW9uVHlwZS5GaXhlZE51bWJlciAmJiB0eXBlb2Ygd2lkdGggPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBwYXJzZWRXaWR0aCA9IHBhcnNlRmxvYXQod2lkdGgpO1xuICAgIGlmICh3aWR0aC5lbmRzV2l0aChcImZyXCIpKSB7XG4gICAgICB3aWR0aFR5cGUgPSBEaW1lbnNpb25UeXBlLkZyYWN0aW9uT2ZGcmVlU3BhY2U7XG4gICAgICB3aWR0aFZhbHVlID0gcGFyc2VkV2lkdGg7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA9PT0gXCJhdXRvXCIpIHtcbiAgICAgIHdpZHRoVHlwZSA9IERpbWVuc2lvblR5cGUuQXV0bztcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGhUeXBlID0gRGltZW5zaW9uVHlwZS5QZXJjZW50YWdlO1xuICAgICAgd2lkdGhWYWx1ZSA9IHBhcnNlZFdpZHRoIC8gMTAwO1xuICAgIH1cbiAgfSBlbHNlIGlmICh3aWR0aCAhPT0gdm9pZCAwICYmIHR5cGVvZiB3aWR0aCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHdpZHRoVmFsdWUgPSB3aWR0aDtcbiAgfVxuICBpZiAoY29uc3RyYWludE1hc2suaGVpZ2h0VHlwZSAhPT0gRGltZW5zaW9uVHlwZS5GaXhlZE51bWJlciAmJiB0eXBlb2YgaGVpZ2h0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgcGFyc2VkSGVpZ2h0ID0gcGFyc2VGbG9hdChoZWlnaHQpO1xuICAgIGlmIChoZWlnaHQuZW5kc1dpdGgoXCJmclwiKSkge1xuICAgICAgaGVpZ2h0VHlwZSA9IERpbWVuc2lvblR5cGUuRnJhY3Rpb25PZkZyZWVTcGFjZTtcbiAgICAgIGhlaWdodFZhbHVlID0gcGFyc2VkSGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAoaGVpZ2h0ID09PSBcImF1dG9cIikge1xuICAgICAgaGVpZ2h0VHlwZSA9IERpbWVuc2lvblR5cGUuQXV0bztcbiAgICB9IGVsc2Uge1xuICAgICAgaGVpZ2h0VHlwZSA9IERpbWVuc2lvblR5cGUuUGVyY2VudGFnZTtcbiAgICAgIGhlaWdodFZhbHVlID0gcGFyc2VGbG9hdChoZWlnaHQpIC8gMTAwO1xuICAgIH1cbiAgfSBlbHNlIGlmIChoZWlnaHQgIT09IHZvaWQgMCAmJiB0eXBlb2YgaGVpZ2h0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgaGVpZ2h0VmFsdWUgPSBoZWlnaHQ7XG4gIH1cbiAgbGV0IGNlbnRlckFuY2hvclggPSAwLjU7XG4gIGxldCBjZW50ZXJBbmNob3JZID0gMC41O1xuICBpZiAoY2VudGVyID09PSB0cnVlIHx8IGNlbnRlciA9PT0gXCJ4XCIpIHtcbiAgICBjb25zdHJhaW50TWFzay5sZWZ0ID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBsZWZ0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjZW50ZXJBbmNob3JYID0gcGFyc2VGbG9hdChsZWZ0KSAvIDEwMDtcbiAgICB9XG4gIH1cbiAgaWYgKGNlbnRlciA9PT0gdHJ1ZSB8fCBjZW50ZXIgPT09IFwieVwiKSB7XG4gICAgY29uc3RyYWludE1hc2sudG9wID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiB0b3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNlbnRlckFuY2hvclkgPSBwYXJzZUZsb2F0KHRvcCkgLyAxMDA7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbGVmdDogY29uc3RyYWludE1hc2subGVmdCA/IGxlZnQgOiBudWxsLFxuICAgIHJpZ2h0OiBjb25zdHJhaW50TWFzay5yaWdodCA/IHJpZ2h0IDogbnVsbCxcbiAgICB0b3A6IGNvbnN0cmFpbnRNYXNrLnRvcCA/IHRvcCA6IG51bGwsXG4gICAgYm90dG9tOiBjb25zdHJhaW50TWFzay5ib3R0b20gPyBib3R0b20gOiBudWxsLFxuICAgIHdpZHRoVHlwZSxcbiAgICBoZWlnaHRUeXBlLFxuICAgIHdpZHRoOiB3aWR0aFZhbHVlLFxuICAgIGhlaWdodDogaGVpZ2h0VmFsdWUsXG4gICAgYXNwZWN0UmF0aW86IGNvbnN0cmFpbnRNYXNrLmFzcGVjdFJhdGlvIHx8IG51bGwsXG4gICAgY2VudGVyQW5jaG9yWCxcbiAgICBjZW50ZXJBbmNob3JZXG4gIH07XG59XG52YXIgUGFyZW50U2l6ZVN0YXRlO1xuKGZ1bmN0aW9uKFBhcmVudFNpemVTdGF0ZTIpIHtcbiAgUGFyZW50U2l6ZVN0YXRlMltQYXJlbnRTaXplU3RhdGUyW1wiVW5rbm93blwiXSA9IDBdID0gXCJVbmtub3duXCI7XG4gIFBhcmVudFNpemVTdGF0ZTJbUGFyZW50U2l6ZVN0YXRlMltcIkRpc2FibGVkXCJdID0gMV0gPSBcIkRpc2FibGVkXCI7XG4gIFBhcmVudFNpemVTdGF0ZTJbUGFyZW50U2l6ZVN0YXRlMltcIkRpc2FibGVkRm9yQ3VycmVudExldmVsXCJdID0gMl0gPSBcIkRpc2FibGVkRm9yQ3VycmVudExldmVsXCI7XG59KShQYXJlbnRTaXplU3RhdGUgfHwgKFBhcmVudFNpemVTdGF0ZSA9IHt9KSk7XG52YXIgQ29uc3RyYWludHNDb250ZXh0ID0gY3JlYXRlQ29udGV4dDcoeyBzaXplOiAwIH0pO1xuZnVuY3Rpb24gZGVwcmVjYXRlZFBhcmVudFNpemUocGFyZW50U2l6ZSkge1xuICBpZiAocGFyZW50U2l6ZSA9PT0gMCB8fCBwYXJlbnRTaXplID09PSAxIHx8IHBhcmVudFNpemUgPT09IDIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gcGFyZW50U2l6ZTtcbn1cbmZ1bmN0aW9uIHVzZVBhcmVudFNpemUoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0MTYoQ29uc3RyYWludHNDb250ZXh0KS5zaXplO1xufVxuZnVuY3Rpb24gaXNTaXplKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcIm9iamVjdFwiO1xufVxudmFyIFByb3ZpZGVQYXJlbnRTaXplID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRQYXJlbnRTaXplID0gdXNlUGFyZW50U2l6ZSgpO1xuICBjb25zdCB7IHBhcmVudFNpemUsIGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgY29uc3QgbWVtb0tleSA9IGlzU2l6ZShwYXJlbnRTaXplKSA/IFtwYXJlbnRTaXplLndpZHRoLCBwYXJlbnRTaXplLmhlaWdodF0gOiBbcGFyZW50U2l6ZSwgLTFdO1xuICBjb25zdCB2YWx1ZSA9IHVzZU1lbW83KCgpID0+ICh7IHNpemU6IHBhcmVudFNpemUgfSksIG1lbW9LZXkpO1xuICBpZiAoY3VycmVudFBhcmVudFNpemUgPT09IDEpIHtcbiAgICByZXR1cm4gY2hpbGRyZW4gPyAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDExKEZyYWdtZW50MywgbnVsbCwgY2hpbGRyZW4pIDogbnVsbDtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQxMShDb25zdHJhaW50c0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZVxuICB9LCBjaGlsZHJlbik7XG59O1xudmFyIENvbnN1bWVQYXJlbnRTaXplID0gQ29uc3RyYWludHNDb250ZXh0LkNvbnN1bWVyO1xuZnVuY3Rpb24gdXNlUHJvdmlkZVBhcmVudFNpemUobm9kZSwgcGFyZW50U2l6ZSkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQxMShQcm92aWRlUGFyZW50U2l6ZSwge1xuICAgIHBhcmVudFNpemVcbiAgfSwgbm9kZSk7XG59XG5mdW5jdGlvbiB1c2VDb25zdHJhaW50cyhwcm9wcykge1xuICBjb25zdCBwYXJlbnRTaXplID0gdXNlUGFyZW50U2l6ZSgpO1xuICByZXR1cm4gY2FsY3VsYXRlUmVjdChwcm9wcywgcGFyZW50U2l6ZSk7XG59XG5cbi8vIHNyYy9yZW5kZXIvdXRpbHMvc2V0RG9jdW1lbnRTdHlsZXMudHNcbnZhciBjYWNoZSA9IG5ldyBTZXQoKTtcbnZhciBzdHlsZUVsZW1lbnQ7XG5mdW5jdGlvbiBzZXREb2N1bWVudFN0eWxlcyhjc3MpIHtcbiAgaWYgKGNhY2hlLmhhcyhjc3MpIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICByZXR1cm47XG4gIGNhY2hlLmFkZChjc3MpO1xuICBpZiAoIXN0eWxlRWxlbWVudCkge1xuICAgIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICBzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcbiAgICBkb2N1bWVudC5oZWFkICYmIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcbiAgfVxuICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG59XG5cbi8vIHNyYy9yZW5kZXIvdHlwZXMvUmVuZGVyRW52aXJvbm1lbnQudHNcbnZhciBSZW5kZXJUYXJnZXQ7XG4oZnVuY3Rpb24oUmVuZGVyVGFyZ2V0Mikge1xuICBSZW5kZXJUYXJnZXQyW1wiY2FudmFzXCJdID0gXCJDQU5WQVNcIjtcbiAgUmVuZGVyVGFyZ2V0MltcImV4cG9ydFwiXSA9IFwiRVhQT1JUXCI7XG4gIFJlbmRlclRhcmdldDJbXCJ0aHVtYm5haWxcIl0gPSBcIlRIVU1CTkFJTFwiO1xuICBSZW5kZXJUYXJnZXQyW1wicHJldmlld1wiXSA9IFwiUFJFVklFV1wiO1xufSkoUmVuZGVyVGFyZ2V0IHx8IChSZW5kZXJUYXJnZXQgPSB7fSkpO1xudmFyIFJlbmRlckVudmlyb25tZW50ID0ge1xuICBpbWFnZUJhc2VVUkw6IFwiXCIsXG4gIHRhcmdldDogUmVuZGVyVGFyZ2V0LnByZXZpZXcsXG4gIHpvb206IDFcbn07XG5mdW5jdGlvbiBleGVjdXRlSW5SZW5kZXJFbnZpcm9ubWVudChjdXN0b21FbnZpcm9ubWVudCwgdGFzaykge1xuICBjb25zdCBwcmV2aW91c0Vudmlyb25tZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgUmVuZGVyRW52aXJvbm1lbnQpO1xuICBPYmplY3QuYXNzaWduKFJlbmRlckVudmlyb25tZW50LCBjdXN0b21FbnZpcm9ubWVudCk7XG4gIGNvbnN0IHJlc3VsdCA9IHRhc2soKTtcbiAgT2JqZWN0LmFzc2lnbihSZW5kZXJFbnZpcm9ubWVudCwgcHJldmlvdXNFbnZpcm9ubWVudCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzZXRHbG9iYWxSZW5kZXJFbnZpcm9ubWVudChlbnZpcm9ubWVudDMpIHtcbiAgT2JqZWN0LmFzc2lnbihSZW5kZXJFbnZpcm9ubWVudCwgZW52aXJvbm1lbnQzKTtcbn1cbmZ1bmN0aW9uIHVzZVJlbmRlckVudmlyb25tZW50KHRhcmdldCwgaW1hZ2VCYXNlVVJMLCB6b29tKSB7XG4gIGxldCB3aWxsQ2hhbmdlRWxlbWVudHMgPSBmYWxzZTtcbiAgaWYgKFJlbmRlckVudmlyb25tZW50LmltYWdlQmFzZVVSTCAhPT0gaW1hZ2VCYXNlVVJMKSB7XG4gICAgUmVuZGVyRW52aXJvbm1lbnQuaW1hZ2VCYXNlVVJMID0gaW1hZ2VCYXNlVVJMO1xuICAgIHdpbGxDaGFuZ2VFbGVtZW50cyA9IHRydWU7XG4gIH1cbiAgaWYgKFJlbmRlckVudmlyb25tZW50LnRhcmdldCAhPT0gdGFyZ2V0KSB7XG4gICAgUmVuZGVyRW52aXJvbm1lbnQudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHdpbGxDaGFuZ2VFbGVtZW50cyA9IHRydWU7XG4gIH1cbiAgaWYgKFJlbmRlckVudmlyb25tZW50Lnpvb20gIT09IHpvb20pIHtcbiAgICBSZW5kZXJFbnZpcm9ubWVudC56b29tID0gem9vbTtcbiAgfVxuICByZXR1cm4geyB3aWxsQ2hhbmdlRWxlbWVudHMgfTtcbn1cbihmdW5jdGlvbihSZW5kZXJUYXJnZXQyKSB7XG4gIGZ1bmN0aW9uIGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIFJlbmRlckVudmlyb25tZW50LnRhcmdldDtcbiAgfVxuICBSZW5kZXJUYXJnZXQyLmN1cnJlbnQgPSBjdXJyZW50O1xuICBmdW5jdGlvbiBoYXNSZXN0cmljdGlvbnMoKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gUmVuZGVyRW52aXJvbm1lbnQudGFyZ2V0O1xuICAgIGlmICh0YXJnZXQgPT09IFJlbmRlclRhcmdldDIuY2FudmFzKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRhcmdldCA9PT0gUmVuZGVyVGFyZ2V0Mi5leHBvcnQpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgUmVuZGVyVGFyZ2V0Mi5oYXNSZXN0cmljdGlvbnMgPSBoYXNSZXN0cmljdGlvbnM7XG59KShSZW5kZXJUYXJnZXQgfHwgKFJlbmRlclRhcmdldCA9IHt9KSk7XG5cbi8vIHNyYy9yZW5kZXIvdXRpbHMvaW5qZWN0Q29tcG9uZW50Q1NTUnVsZXMudHNcbnZhciBjb21wb25lbnRDU1NSdWxlcyA9IGBcblxuW2RhdGEtZnJhbWVyLWNvbXBvbmVudC10eXBlXSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xufVxuYDtcbnZhciB0ZXh0Q1NTUnVsZXMgPSBgXG5bZGF0YS1mcmFtZXItY29tcG9uZW50LXR5cGU9XCJUZXh0XCJdIHtcbiAgICBjdXJzb3I6IGluaGVyaXQ7XG59XG5cbltkYXRhLWZyYW1lci1jb21wb25lbnQtdGV4dC1hdXRvc2l6ZWRdICoge1xuICAgIHdoaXRlLXNwYWNlOiBwcmU7XG59XG5gO1xudmFyIHN0YWNrQ1NTUnVsZXMgPSBgXG46bm90KFtkYXRhLWZyYW1lci1nZW5lcmF0ZWRdKSA+IFtkYXRhLWZyYW1lci1zdGFjay1jb250ZW50LXdyYXBwZXJdID4gKixcbjpub3QoW2RhdGEtZnJhbWVyLWdlbmVyYXRlZF0pID4gW2RhdGEtZnJhbWVyLXN0YWNrLWNvbnRlbnQtd3JhcHBlcl0gPiBbZGF0YS1mcmFtZXItY29tcG9uZW50LXR5cGVdLFxuOm5vdChbZGF0YS1mcmFtZXItZ2VuZXJhdGVkXSkgPiBbZGF0YS1mcmFtZXItc3RhY2stY29udGVudC13cmFwcGVyXSA+IFtkYXRhLWZyYW1lci1zdGFjay1nYXBdID4gKixcbjpub3QoW2RhdGEtZnJhbWVyLWdlbmVyYXRlZF0pID4gW2RhdGEtZnJhbWVyLXN0YWNrLWNvbnRlbnQtd3JhcHBlcl0gPiBbZGF0YS1mcmFtZXItc3RhY2stZ2FwXSA+IFtkYXRhLWZyYW1lci1jb21wb25lbnQtdHlwZV0ge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbn1cblxuW2RhdGEtZnJhbWVyLXN0YWNrLWdhcF0gPiAqIHtcbiAgICBtYXJnaW4tdG9wOiBjYWxjKHZhcigtLXN0YWNrLWdhcC15KSAvIDIpO1xuICAgIG1hcmdpbi1ib3R0b206IGNhbGModmFyKC0tc3RhY2stZ2FwLXkpIC8gMik7XG4gICAgbWFyZ2luLXJpZ2h0OiBjYWxjKHZhcigtLXN0YWNrLWdhcC14KSAvIDIpO1xuICAgIG1hcmdpbi1sZWZ0OiBjYWxjKHZhcigtLXN0YWNrLWdhcC14KSAvIDIpO1xufVxuXG4vKiBUaGlzIHNob3VsZCB0YWtlIHRoZSBsYW5ndWFnZSBkaXJlY3Rpb24gaW50byBhY2NvdW50ICovXG5bZGF0YS1mcmFtZXItc3RhY2stZGlyZWN0aW9uLXJldmVyc2U9XCJmYWxzZVwiXVxuW2RhdGEtZnJhbWVyLXN0YWNrLWdhcF1cbj4gKjpmaXJzdC1jaGlsZCxcbltkYXRhLWZyYW1lci1zdGFjay1kaXJlY3Rpb24tcmV2ZXJzZT1cInRydWVcIl1cbltkYXRhLWZyYW1lci1zdGFjay1nYXBdXG4+ICo6bGFzdC1jaGlsZCB7XG4gICAgbWFyZ2luLXRvcDogMDtcbiAgICBtYXJnaW4tbGVmdDogMDtcbn1cblxuLyogVGhpcyBzaG91bGQgdGFrZSB0aGUgbGFuZ3VhZ2UgZGlyZWN0aW9uIGludG8gYWNjb3VudCAqL1xuW2RhdGEtZnJhbWVyLXN0YWNrLWRpcmVjdGlvbi1yZXZlcnNlPVwiZmFsc2VcIl1cbltkYXRhLWZyYW1lci1zdGFjay1nYXBdXG4+ICo6bGFzdC1jaGlsZCxcbltkYXRhLWZyYW1lci1zdGFjay1kaXJlY3Rpb24tcmV2ZXJzZT1cInRydWVcIl1cbltkYXRhLWZyYW1lci1zdGFjay1nYXBdXG4+ICo6Zmlyc3QtY2hpbGQge1xuICAgIG1hcmdpbi1yaWdodDogMDtcbiAgICBtYXJnaW4tYm90dG9tOiAwO1xufVxuYDtcbnZhciBuYXZpZ2F0aW9uQ1NTUnVsZXMgPSBgXG5OYXZpZ2F0aW9uQ29udGFpbmVyXG5bZGF0YS1mcmFtZXItY29tcG9uZW50LXR5cGU9XCJOYXZpZ2F0aW9uQ29udGFpbmVyXCJdID4gKixcbltkYXRhLWZyYW1lci1jb21wb25lbnQtdHlwZT1cIk5hdmlnYXRpb25Db250YWluZXJcIl0gPiBbZGF0YS1mcmFtZXItY29tcG9uZW50LXR5cGVdIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG5gO1xudmFyIHNjcm9sbENTU1J1bGVzID0gYFxuW2RhdGEtZnJhbWVyLWNvbXBvbmVudC10eXBlPVwiU2Nyb2xsXCJdOjotd2Via2l0LXNjcm9sbGJhciB7XG4gICAgZGlzcGxheTogbm9uZTtcbn1cbltkYXRhLWZyYW1lci1jb21wb25lbnQtdHlwZT1cIlNjcm9sbENvbnRlbnRXcmFwcGVyXCJdID4gKiB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xufVxuYDtcbnZhciBuYXRpdmVTY3JvbGxDU1NSdWxlcyA9IGBcbltkYXRhLWZyYW1lci1jb21wb25lbnQtdHlwZT1cIk5hdGl2ZVNjcm9sbFwiXSB7XG4gICAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoO1xufVxuXG5bZGF0YS1mcmFtZXItY29tcG9uZW50LXR5cGU9XCJOYXRpdmVTY3JvbGxcIl0gPiAqIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG5cbltkYXRhLWZyYW1lci1jb21wb25lbnQtdHlwZT1cIk5hdGl2ZVNjcm9sbFwiXS5kaXJlY3Rpb24tYm90aCB7XG4gICAgb3ZlcmZsb3cteDogc2Nyb2xsO1xuICAgIG92ZXJmbG93LXk6IHNjcm9sbDtcbn1cblxuW2RhdGEtZnJhbWVyLWNvbXBvbmVudC10eXBlPVwiTmF0aXZlU2Nyb2xsXCJdLmRpcmVjdGlvbi12ZXJ0aWNhbCB7XG4gICAgb3ZlcmZsb3cteDogaGlkZGVuO1xuICAgIG92ZXJmbG93LXk6IHNjcm9sbDtcbn1cblxuW2RhdGEtZnJhbWVyLWNvbXBvbmVudC10eXBlPVwiTmF0aXZlU2Nyb2xsXCJdLmRpcmVjdGlvbi1ob3Jpem9udGFsIHtcbiAgICBvdmVyZmxvdy14OiBzY3JvbGw7XG4gICAgb3ZlcmZsb3cteTogaGlkZGVuO1xufVxuXG5bZGF0YS1mcmFtZXItY29tcG9uZW50LXR5cGU9XCJOYXRpdmVTY3JvbGxcIl0uZGlyZWN0aW9uLXZlcnRpY2FsID4gKiB7XG4gICAgd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcbn1cblxuW2RhdGEtZnJhbWVyLWNvbXBvbmVudC10eXBlPVwiTmF0aXZlU2Nyb2xsXCJdLmRpcmVjdGlvbi1ob3Jpem9udGFsID4gKiB7XG4gICAgaGVpZ2h0OiAxMDAlICFpbXBvcnRhbnQ7XG59XG5cbltkYXRhLWZyYW1lci1jb21wb25lbnQtdHlwZT1cIk5hdGl2ZVNjcm9sbFwiXS5zY3JvbGxiYXItaGlkZGVuOjotd2Via2l0LXNjcm9sbGJhciB7XG4gICAgZGlzcGxheTogbm9uZTtcbn1cbmA7XG52YXIgcGFnZUNvbnRlbnRXcmFwcGVyV3JhcHBlckNTU1J1bGVzID0gYFxuW2RhdGEtZnJhbWVyLWNvbXBvbmVudC10eXBlPVwiUGFnZUNvbnRlbnRXcmFwcGVyXCJdID4gKixcbltkYXRhLWZyYW1lci1jb21wb25lbnQtdHlwZT1cIlBhZ2VDb250ZW50V3JhcHBlclwiXSA+IFtkYXRhLWZyYW1lci1jb21wb25lbnQtdHlwZV0ge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbn1cbmA7XG52YXIgcHJlc2VuY2VDU1MgPSBgXG5bZGF0YS1pcy1wcmVzZW50PVwiZmFsc2VcIl0sIFtkYXRhLWlzLXByZXNlbnQ9XCJmYWxzZVwiXSAqIHtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZSAhaW1wb3J0YW50O1xufVxuYDtcbnZhciBjdXJzb3JDU1MgPSBgXG5bZGF0YS1mcmFtZXItY3Vyc29yPVwicG9pbnRlclwiXSB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xufVxuW2RhdGEtZnJhbWVyLWN1cnNvcj1cImdyYWJcIl0ge1xuICAgIGN1cnNvcjogZ3JhYjtcbn1cbltkYXRhLWZyYW1lci1jdXJzb3I9XCJncmFiXCJdOmFjdGl2ZSB7XG4gICAgY3Vyc29yOiBncmFiYmluZztcbn1cbmA7XG52YXIgZnJhbWVDU1NSdWxlcyA9IChpc1ByZXZpZXcpID0+IHtcbiAgcmV0dXJuIGlzUHJldmlldyA/IGAgW2RhdGEtZnJhbWVyLWNvbXBvbmVudC10eXBlPVwiRnJhbWVcIl0gKiB7IHBvaW50ZXItZXZlbnRzOiBhdXRvOyB9IGAgOiBgYDtcbn07XG52YXIgdGV4dFNlbGVjdGlvbkNTU1J1bGVzID0gKGlzUHJldmlldykgPT4ge1xuICByZXR1cm4gaXNQcmV2aWV3ID8gYFxuICAgICAgICBib2R5IDpub3QoaW5wdXQpOm5vdCh0ZXh0YXJlYSk6bm90KFtjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdKSB7XG4gICAgICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICBbZGF0YS1mcmFtZXItY29tcG9uZW50LXR5cGU9XCJUZXh0XCJdLCBbZGF0YS1mcmFtZXItY29tcG9uZW50LXR5cGU9XCJUZXh0XCJdICoge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcbiAgICB9YCA6IGBgO1xufTtcbnZhciBjb21iaW5lQ1NTUnVsZXMgPSAoaXNQcmV2aWV3KSA9PiBgXG4ke2NvbXBvbmVudENTU1J1bGVzfVxuJHt0ZXh0Q1NTUnVsZXN9XG4ke3N0YWNrQ1NTUnVsZXN9XG4ke25hdmlnYXRpb25DU1NSdWxlc31cbiR7c2Nyb2xsQ1NTUnVsZXN9XG4ke25hdGl2ZVNjcm9sbENTU1J1bGVzfVxuJHtwYWdlQ29udGVudFdyYXBwZXJXcmFwcGVyQ1NTUnVsZXN9XG4ke3ByZXNlbmNlQ1NTfVxuJHtjdXJzb3JDU1N9XG4ke2ZyYW1lQ1NTUnVsZXMoaXNQcmV2aWV3KX1cbiR7dGV4dFNlbGVjdGlvbkNTU1J1bGVzKGlzUHJldmlldyl9XG5gO1xudmFyIGNvbWJpbmVkQ1NTUnVsZXMgPSBjb21iaW5lQ1NTUnVsZXMoZmFsc2UpO1xudmFyIGNvbWJpbmVkQ1NTUnVsZXNGb3JQcmV2aWV3ID0gY29tYmluZUNTU1J1bGVzKHRydWUpO1xudmFyIGluamVjdENvbXBvbmVudENTU1J1bGVzID0gKCkgPT4ge1xuICBjb25zdCBzdHlsZXMgPSBSZW5kZXJUYXJnZXQuY3VycmVudCgpID09PSBSZW5kZXJUYXJnZXQucHJldmlldyA/IGNvbWJpbmVkQ1NTUnVsZXNGb3JQcmV2aWV3IDogY29tYmluZWRDU1NSdWxlcztcbiAgc2V0RG9jdW1lbnRTdHlsZXMoc3R5bGVzKTtcbn07XG5cbi8vIHNyYy9yZW5kZXIvdXRpbHMvcHJvY2Vzc092ZXJyaWRlRm9yd2FyZGluZy50c1xuaW1wb3J0IHtcbiAgQ2hpbGRyZW4gYXMgQ2hpbGRyZW4yLFxuICBjbG9uZUVsZW1lbnQgYXMgY2xvbmVFbGVtZW50MixcbiAgaXNWYWxpZEVsZW1lbnQgYXMgaXNWYWxpZEVsZW1lbnQyXG59IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gcHJvY2Vzc092ZXJyaWRlRm9yd2FyZGluZyhwcm9wcywgY2hpbGRyZW4pIHtcbiAgaWYgKCFjaGlsZHJlbikge1xuICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgaWYgKCFjaGlsZHJlbilcbiAgICAgIHJldHVybiB7IHByb3BzLCBjaGlsZHJlbiB9O1xuICB9XG4gIGxldCBfZm9yd2FyZGVkT3ZlcnJpZGVzID0gcHJvcHMuX2ZvcndhcmRlZE92ZXJyaWRlcztcbiAgY29uc3QgZXh0cmFjdGlvbnMgPSBwcm9wcy5fb3ZlcnJpZGVGb3J3YXJkaW5nRGVzY3JpcHRpb247XG4gIGlmIChleHRyYWN0aW9ucykge1xuICAgIF9mb3J3YXJkZWRPdmVycmlkZXMgPSB2b2lkIDA7XG4gICAgZm9yIChjb25zdCBrZXk2IGluIGV4dHJhY3Rpb25zKSB7XG4gICAgICBjb25zdCBwcm9wTmFtZSA9IGV4dHJhY3Rpb25zW2tleTZdO1xuICAgICAgY29uc3QgdmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoIV9mb3J3YXJkZWRPdmVycmlkZXMpIHtcbiAgICAgICAgICBfZm9yd2FyZGVkT3ZlcnJpZGVzID0ge307XG4gICAgICAgICAgcHJvcHMgPSB7IC4uLnByb3BzIH07XG4gICAgICAgIH1cbiAgICAgICAgX2ZvcndhcmRlZE92ZXJyaWRlc1trZXk2XSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgZGVsZXRlIHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFfZm9yd2FyZGVkT3ZlcnJpZGVzKVxuICAgIHJldHVybiB7IHByb3BzLCBjaGlsZHJlbiB9O1xuICBjaGlsZHJlbiA9IENoaWxkcmVuMi5tYXAoY2hpbGRyZW4sIChjaGlsZCkgPT4ge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnQyKGNoaWxkKSlcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICByZXR1cm4gY2xvbmVFbGVtZW50MihjaGlsZCwgeyBfZm9yd2FyZGVkT3ZlcnJpZGVzIH0pO1xuICB9KTtcbiAgcmV0dXJuIHsgcHJvcHMsIGNoaWxkcmVuIH07XG59XG5cbi8vIHNyYy9yZW5kZXIvdHlwZXMvQ29sb3IvVXRpbHMudHNcbmZ1bmN0aW9uIG1vZHVsYXRlKHZhbHVlLCByYW5nZUEsIHJhbmdlQiwgbGltaXQgPSBmYWxzZSkge1xuICBjb25zdCBbZnJvbUxvdywgZnJvbUhpZ2hdID0gcmFuZ2VBO1xuICBjb25zdCBbdG9Mb3csIHRvSGlnaF0gPSByYW5nZUI7XG4gIGNvbnN0IHJlc3VsdCA9IHRvTG93ICsgKHZhbHVlIC0gZnJvbUxvdykgLyAoZnJvbUhpZ2ggLSBmcm9tTG93KSAqICh0b0hpZ2ggLSB0b0xvdyk7XG4gIGlmIChsaW1pdCA9PT0gdHJ1ZSkge1xuICAgIGlmICh0b0xvdyA8IHRvSGlnaCkge1xuICAgICAgaWYgKHJlc3VsdCA8IHRvTG93KSB7XG4gICAgICAgIHJldHVybiB0b0xvdztcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgPiB0b0hpZ2gpIHtcbiAgICAgICAgcmV0dXJuIHRvSGlnaDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlc3VsdCA+IHRvTG93KSB7XG4gICAgICAgIHJldHVybiB0b0xvdztcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgPCB0b0hpZ2gpIHtcbiAgICAgICAgcmV0dXJuIHRvSGlnaDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzTnVtZXJpYyh2YWx1ZSkge1xuICByZXR1cm4gIWlzTmFOKHZhbHVlKSAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBwZXJjZW50VG9GcmFjdGlvbih2YWwpIHtcbiAgY29uc3QgZGlnaXRzID0gbnVtYmVyRnJvbVN0cmluZyh2YWwpO1xuICBpZiAoZGlnaXRzICE9PSB2b2lkIDApIHtcbiAgICBpZiAodmFsLmluY2x1ZGVzKFwiJVwiKSkge1xuICAgICAgcmV0dXJuIGRpZ2l0cyAvIDEwMDtcbiAgICB9XG4gICAgcmV0dXJuIGRpZ2l0cztcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIG51bWJlckZyb21TdHJpbmcoaW5wdXQpIHtcbiAgY29uc3QgbWF0Y2ggPSBpbnB1dC5tYXRjaCgvXFxkP1xcLj9cXGQrLyk7XG4gIHJldHVybiBtYXRjaCA/IE51bWJlcihtYXRjaFswXSkgOiB2b2lkIDA7XG59XG5cbi8vIHNyYy9yZW5kZXIvdHlwZXMvQ29sb3IvY29udmVydGVycy50c1xudmFyIGltcG9ydF9oc2x1diA9IF9fdG9Nb2R1bGUocmVxdWlyZV9oc2x1digpKTtcblxuLy8gc3JjL3JlbmRlci90eXBlcy9Db2xvci90eXBlcy50c1xudmFyIENvbG9yRm9ybWF0O1xuKGZ1bmN0aW9uKENvbG9yRm9ybWF0Mikge1xuICBDb2xvckZvcm1hdDJbXCJSR0JcIl0gPSBcInJnYlwiO1xuICBDb2xvckZvcm1hdDJbXCJIU0xcIl0gPSBcImhzbFwiO1xuICBDb2xvckZvcm1hdDJbXCJIU1ZcIl0gPSBcImhzdlwiO1xuICBDb2xvckZvcm1hdDJbXCJIRVhcIl0gPSBcImhleFwiO1xuICBDb2xvckZvcm1hdDJbXCJOQU1FXCJdID0gXCJuYW1lXCI7XG59KShDb2xvckZvcm1hdCB8fCAoQ29sb3JGb3JtYXQgPSB7fSkpO1xudmFyIENvbG9yTWl4TW9kZWxUeXBlO1xuKGZ1bmN0aW9uKENvbG9yTWl4TW9kZWxUeXBlMikge1xuICBDb2xvck1peE1vZGVsVHlwZTJbXCJSR0JcIl0gPSBcInJnYlwiO1xuICBDb2xvck1peE1vZGVsVHlwZTJbXCJSR0JBXCJdID0gXCJyZ2JhXCI7XG4gIENvbG9yTWl4TW9kZWxUeXBlMltcIkhTTFwiXSA9IFwiaHNsXCI7XG4gIENvbG9yTWl4TW9kZWxUeXBlMltcIkhTTEFcIl0gPSBcImhzbGFcIjtcbiAgQ29sb3JNaXhNb2RlbFR5cGUyW1wiSFVTTFwiXSA9IFwiaHVzbFwiO1xufSkoQ29sb3JNaXhNb2RlbFR5cGUgfHwgKENvbG9yTWl4TW9kZWxUeXBlID0ge30pKTtcblxuLy8gc3JjL3JlbmRlci90eXBlcy9Db2xvci9DU1NOYW1lcy50c1xudmFyIGNzc05hbWVzID0ge1xuICBhbGljZWJsdWU6IFwiZjBmOGZmXCIsXG4gIGFudGlxdWV3aGl0ZTogXCJmYWViZDdcIixcbiAgYXF1YTogXCIwZmZcIixcbiAgYXF1YW1hcmluZTogXCI3ZmZmZDRcIixcbiAgYXp1cmU6IFwiZjBmZmZmXCIsXG4gIGJlaWdlOiBcImY1ZjVkY1wiLFxuICBiaXNxdWU6IFwiZmZlNGM0XCIsXG4gIGJsYWNrOiBcIjAwMFwiLFxuICBibGFuY2hlZGFsbW9uZDogXCJmZmViY2RcIixcbiAgYmx1ZTogXCIwMGZcIixcbiAgYmx1ZXZpb2xldDogXCI4YTJiZTJcIixcbiAgYnJvd246IFwiYTUyYTJhXCIsXG4gIGJ1cmx5d29vZDogXCJkZWI4ODdcIixcbiAgYnVybnRzaWVubmE6IFwiZWE3ZTVkXCIsXG4gIGNhZGV0Ymx1ZTogXCI1ZjllYTBcIixcbiAgY2hhcnRyZXVzZTogXCI3ZmZmMDBcIixcbiAgY2hvY29sYXRlOiBcImQyNjkxZVwiLFxuICBjb3JhbDogXCJmZjdmNTBcIixcbiAgY29ybmZsb3dlcmJsdWU6IFwiNjQ5NWVkXCIsXG4gIGNvcm5zaWxrOiBcImZmZjhkY1wiLFxuICBjcmltc29uOiBcImRjMTQzY1wiLFxuICBjeWFuOiBcIjBmZlwiLFxuICBkYXJrYmx1ZTogXCIwMDAwOGJcIixcbiAgZGFya2N5YW46IFwiMDA4YjhiXCIsXG4gIGRhcmtnb2xkZW5yb2Q6IFwiYjg4NjBiXCIsXG4gIGRhcmtncmF5OiBcImE5YTlhOVwiLFxuICBkYXJrZ3JlZW46IFwiMDA2NDAwXCIsXG4gIGRhcmtncmV5OiBcImE5YTlhOVwiLFxuICBkYXJra2hha2k6IFwiYmRiNzZiXCIsXG4gIGRhcmttYWdlbnRhOiBcIjhiMDA4YlwiLFxuICBkYXJrb2xpdmVncmVlbjogXCI1NTZiMmZcIixcbiAgZGFya29yYW5nZTogXCJmZjhjMDBcIixcbiAgZGFya29yY2hpZDogXCI5OTMyY2NcIixcbiAgZGFya3JlZDogXCI4YjAwMDBcIixcbiAgZGFya3NhbG1vbjogXCJlOTk2N2FcIixcbiAgZGFya3NlYWdyZWVuOiBcIjhmYmM4ZlwiLFxuICBkYXJrc2xhdGVibHVlOiBcIjQ4M2Q4YlwiLFxuICBkYXJrc2xhdGVncmF5OiBcIjJmNGY0ZlwiLFxuICBkYXJrc2xhdGVncmV5OiBcIjJmNGY0ZlwiLFxuICBkYXJrdHVycXVvaXNlOiBcIjAwY2VkMVwiLFxuICBkYXJrdmlvbGV0OiBcIjk0MDBkM1wiLFxuICBkZWVwcGluazogXCJmZjE0OTNcIixcbiAgZGVlcHNreWJsdWU6IFwiMDBiZmZmXCIsXG4gIGRpbWdyYXk6IFwiNjk2OTY5XCIsXG4gIGRpbWdyZXk6IFwiNjk2OTY5XCIsXG4gIGRvZGdlcmJsdWU6IFwiMWU5MGZmXCIsXG4gIGZpcmVicmljazogXCJiMjIyMjJcIixcbiAgZmxvcmFsd2hpdGU6IFwiZmZmYWYwXCIsXG4gIGZvcmVzdGdyZWVuOiBcIjIyOGIyMlwiLFxuICBmdWNoc2lhOiBcImYwZlwiLFxuICBnYWluc2Jvcm86IFwiZGNkY2RjXCIsXG4gIGdob3N0d2hpdGU6IFwiZjhmOGZmXCIsXG4gIGdvbGQ6IFwiZmZkNzAwXCIsXG4gIGdvbGRlbnJvZDogXCJkYWE1MjBcIixcbiAgZ3JheTogXCI4MDgwODBcIixcbiAgZ3JlZW46IFwiMDA4MDAwXCIsXG4gIGdyZWVueWVsbG93OiBcImFkZmYyZlwiLFxuICBncmV5OiBcIjgwODA4MFwiLFxuICBob25leWRldzogXCJmMGZmZjBcIixcbiAgaG90cGluazogXCJmZjY5YjRcIixcbiAgaW5kaWFucmVkOiBcImNkNWM1Y1wiLFxuICBpbmRpZ286IFwiNGIwMDgyXCIsXG4gIGl2b3J5OiBcImZmZmZmMFwiLFxuICBraGFraTogXCJmMGU2OGNcIixcbiAgbGF2ZW5kZXI6IFwiZTZlNmZhXCIsXG4gIGxhdmVuZGVyYmx1c2g6IFwiZmZmMGY1XCIsXG4gIGxhd25ncmVlbjogXCI3Y2ZjMDBcIixcbiAgbGVtb25jaGlmZm9uOiBcImZmZmFjZFwiLFxuICBsaWdodGJsdWU6IFwiYWRkOGU2XCIsXG4gIGxpZ2h0Y29yYWw6IFwiZjA4MDgwXCIsXG4gIGxpZ2h0Y3lhbjogXCJlMGZmZmZcIixcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFwiZmFmYWQyXCIsXG4gIGxpZ2h0Z3JheTogXCJkM2QzZDNcIixcbiAgbGlnaHRncmVlbjogXCI5MGVlOTBcIixcbiAgbGlnaHRncmV5OiBcImQzZDNkM1wiLFxuICBsaWdodHBpbms6IFwiZmZiNmMxXCIsXG4gIGxpZ2h0c2FsbW9uOiBcImZmYTA3YVwiLFxuICBsaWdodHNlYWdyZWVuOiBcIjIwYjJhYVwiLFxuICBsaWdodHNreWJsdWU6IFwiODdjZWZhXCIsXG4gIGxpZ2h0c2xhdGVncmF5OiBcIjc4OVwiLFxuICBsaWdodHNsYXRlZ3JleTogXCI3ODlcIixcbiAgbGlnaHRzdGVlbGJsdWU6IFwiYjBjNGRlXCIsXG4gIGxpZ2h0eWVsbG93OiBcImZmZmZlMFwiLFxuICBsaW1lOiBcIjBmMFwiLFxuICBsaW1lZ3JlZW46IFwiMzJjZDMyXCIsXG4gIGxpbmVuOiBcImZhZjBlNlwiLFxuICBtYWdlbnRhOiBcImYwZlwiLFxuICBtYXJvb246IFwiODAwMDAwXCIsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IFwiNjZjZGFhXCIsXG4gIG1lZGl1bWJsdWU6IFwiMDAwMGNkXCIsXG4gIG1lZGl1bW9yY2hpZDogXCJiYTU1ZDNcIixcbiAgbWVkaXVtcHVycGxlOiBcIjkzNzBkYlwiLFxuICBtZWRpdW1zZWFncmVlbjogXCIzY2IzNzFcIixcbiAgbWVkaXVtc2xhdGVibHVlOiBcIjdiNjhlZVwiLFxuICBtZWRpdW1zcHJpbmdncmVlbjogXCIwMGZhOWFcIixcbiAgbWVkaXVtdHVycXVvaXNlOiBcIjQ4ZDFjY1wiLFxuICBtZWRpdW12aW9sZXRyZWQ6IFwiYzcxNTg1XCIsXG4gIG1pZG5pZ2h0Ymx1ZTogXCIxOTE5NzBcIixcbiAgbWludGNyZWFtOiBcImY1ZmZmYVwiLFxuICBtaXN0eXJvc2U6IFwiZmZlNGUxXCIsXG4gIG1vY2Nhc2luOiBcImZmZTRiNVwiLFxuICBuYXZham93aGl0ZTogXCJmZmRlYWRcIixcbiAgbmF2eTogXCIwMDAwODBcIixcbiAgb2xkbGFjZTogXCJmZGY1ZTZcIixcbiAgb2xpdmU6IFwiODA4MDAwXCIsXG4gIG9saXZlZHJhYjogXCI2YjhlMjNcIixcbiAgb3JhbmdlOiBcImZmYTUwMFwiLFxuICBvcmFuZ2VyZWQ6IFwiZmY0NTAwXCIsXG4gIG9yY2hpZDogXCJkYTcwZDZcIixcbiAgcGFsZWdvbGRlbnJvZDogXCJlZWU4YWFcIixcbiAgcGFsZWdyZWVuOiBcIjk4ZmI5OFwiLFxuICBwYWxldHVycXVvaXNlOiBcImFmZWVlZVwiLFxuICBwYWxldmlvbGV0cmVkOiBcImRiNzA5M1wiLFxuICBwYXBheWF3aGlwOiBcImZmZWZkNVwiLFxuICBwZWFjaHB1ZmY6IFwiZmZkYWI5XCIsXG4gIHBlcnU6IFwiY2Q4NTNmXCIsXG4gIHBpbms6IFwiZmZjMGNiXCIsXG4gIHBsdW06IFwiZGRhMGRkXCIsXG4gIHBvd2RlcmJsdWU6IFwiYjBlMGU2XCIsXG4gIHB1cnBsZTogXCI4MDAwODBcIixcbiAgcmViZWNjYXB1cnBsZTogXCI2NjMzOTlcIixcbiAgcmVkOiBcImYwMFwiLFxuICByb3N5YnJvd246IFwiYmM4ZjhmXCIsXG4gIHJveWFsYmx1ZTogXCI0MTY5ZTFcIixcbiAgc2FkZGxlYnJvd246IFwiOGI0NTEzXCIsXG4gIHNhbG1vbjogXCJmYTgwNzJcIixcbiAgc2FuZHlicm93bjogXCJmNGE0NjBcIixcbiAgc2VhZ3JlZW46IFwiMmU4YjU3XCIsXG4gIHNlYXNoZWxsOiBcImZmZjVlZVwiLFxuICBzaWVubmE6IFwiYTA1MjJkXCIsXG4gIHNpbHZlcjogXCJjMGMwYzBcIixcbiAgc2t5Ymx1ZTogXCI4N2NlZWJcIixcbiAgc2xhdGVibHVlOiBcIjZhNWFjZFwiLFxuICBzbGF0ZWdyYXk6IFwiNzA4MDkwXCIsXG4gIHNsYXRlZ3JleTogXCI3MDgwOTBcIixcbiAgc25vdzogXCJmZmZhZmFcIixcbiAgc3ByaW5nZ3JlZW46IFwiMDBmZjdmXCIsXG4gIHN0ZWVsYmx1ZTogXCI0NjgyYjRcIixcbiAgdGFuOiBcImQyYjQ4Y1wiLFxuICB0ZWFsOiBcIjAwODA4MFwiLFxuICB0aGlzdGxlOiBcImQ4YmZkOFwiLFxuICB0b21hdG86IFwiZmY2MzQ3XCIsXG4gIHR1cnF1b2lzZTogXCI0MGUwZDBcIixcbiAgdmlvbGV0OiBcImVlODJlZVwiLFxuICB3aGVhdDogXCJmNWRlYjNcIixcbiAgd2hpdGU6IFwiZmZmXCIsXG4gIHdoaXRlc21va2U6IFwiZjVmNWY1XCIsXG4gIHllbGxvdzogXCJmZjBcIixcbiAgeWVsbG93Z3JlZW46IFwiOWFjZDMyXCJcbn07XG5cbi8vIHNyYy9yZW5kZXIvdHlwZXMvQ29sb3IvY29udmVydGVycy50c1xuZnVuY3Rpb24gcmdiVG9Ic2x1dihyLCBnLCBiMikge1xuICBjb25zdCBbaCwgcywgbF0gPSAoMCwgaW1wb3J0X2hzbHV2LnJnYlRvSHNsdXYpKFtyIC8gMjU1LCBnIC8gMjU1LCBiMiAvIDI1NV0pO1xuICByZXR1cm4geyBoLCBzLCBsIH07XG59XG5mdW5jdGlvbiByZ2JhRnJvbUh1c2woaCwgcywgbCwgYTIgPSAxKSB7XG4gIGNvbnN0IHJnYiA9ICgwLCBpbXBvcnRfaHNsdXYuaHNsdXZUb1JnYikoW2gsIHMsIGxdKTtcbiAgcmV0dXJuIHtcbiAgICByOiByZ2JbMF0gKiAyNTUsXG4gICAgZzogcmdiWzFdICogMjU1LFxuICAgIGI6IHJnYlsyXSAqIDI1NSxcbiAgICBhOiBhMlxuICB9O1xufVxuZnVuY3Rpb24gaHN2VG9TdHIoaCwgcywgdiwgYTIpIHtcbiAgY29uc3QgX2ggPSBNYXRoLnJvdW5kKGgpO1xuICBjb25zdCBfcyA9IE1hdGgucm91bmQocyAqIDEwMCk7XG4gIGNvbnN0IF92ID0gTWF0aC5yb3VuZCh2ICogMTAwKTtcbiAgcmV0dXJuIGEyID09PSB2b2lkIDAgfHwgYTIgPT09IDEgPyBcImhzdihcIiArIF9oICsgXCIsIFwiICsgX3MgKyBcIiUsIFwiICsgX3YgKyBcIiUpXCIgOiBcImhzdmEoXCIgKyBfaCArIFwiLCBcIiArIF9zICsgXCIlLCBcIiArIF92ICsgXCIlLCBcIiArIGEyICsgXCIpXCI7XG59XG5mdW5jdGlvbiByZ2JUb1JnYihyLCBnLCBiMikge1xuICByZXR1cm4ge1xuICAgIHI6IGlzTnVtZXJpYyhyKSA/IGJvdW5kMDEociwgMjU1KSAqIDI1NSA6IDAsXG4gICAgZzogaXNOdW1lcmljKGcpID8gYm91bmQwMShnLCAyNTUpICogMjU1IDogMCxcbiAgICBiOiBpc051bWVyaWMoYjIpID8gYm91bmQwMShiMiwgMjU1KSAqIDI1NSA6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIHJnYlRvSGV4KHIsIGcsIGIyLCBhbGxvdzNDaGFyKSB7XG4gIGNvbnN0IGhleDIgPSBbcGFkMihNYXRoLnJvdW5kKHIpLnRvU3RyaW5nKDE2KSksIHBhZDIoTWF0aC5yb3VuZChnKS50b1N0cmluZygxNikpLCBwYWQyKE1hdGgucm91bmQoYjIpLnRvU3RyaW5nKDE2KSldO1xuICBpZiAoYWxsb3czQ2hhciAmJiBoZXgyWzBdLmNoYXJBdCgwKSA9PT0gaGV4MlswXS5jaGFyQXQoMSkgJiYgaGV4MlsxXS5jaGFyQXQoMCkgPT09IGhleDJbMV0uY2hhckF0KDEpICYmIGhleDJbMl0uY2hhckF0KDApID09PSBoZXgyWzJdLmNoYXJBdCgxKSkge1xuICAgIHJldHVybiBoZXgyWzBdLmNoYXJBdCgwKSArIGhleDJbMV0uY2hhckF0KDApICsgaGV4MlsyXS5jaGFyQXQoMCk7XG4gIH1cbiAgcmV0dXJuIGhleDIuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHJnYlRvSHNsKHIsIGcsIGIyKSB7XG4gIGxldCBsO1xuICBsZXQgcztcbiAgY29uc3QgX3IgPSBib3VuZDAxKHIsIDI1NSk7XG4gIGNvbnN0IF9nID0gYm91bmQwMShnLCAyNTUpO1xuICBjb25zdCBfYiA9IGJvdW5kMDEoYjIsIDI1NSk7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KF9yLCBfZywgX2IpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihfciwgX2csIF9iKTtcbiAgbGV0IGggPSBzID0gbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgaCA9IHMgPSAwO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGQgPSBtYXggLSBtaW47XG4gICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICBjYXNlIF9yOlxuICAgICAgICBoID0gKF9nIC0gX2IpIC8gZCArIChfZyA8IF9iID8gNiA6IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX2c6XG4gICAgICAgIGggPSAoX2IgLSBfcikgLyBkICsgMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF9iOlxuICAgICAgICBoID0gKF9yIC0gX2cpIC8gZCArIDQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBoIC89IDY7XG4gIH1cbiAgcmV0dXJuIHsgaDogaCAqIDM2MCwgcywgbCB9O1xufVxuZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gIGlmICh0IDwgMCkge1xuICAgIHQgKz0gMTtcbiAgfVxuICBpZiAodCA+IDEpIHtcbiAgICB0IC09IDE7XG4gIH1cbiAgaWYgKHQgPCAxIC8gNikge1xuICAgIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICB9XG4gIGlmICh0IDwgMSAvIDIpIHtcbiAgICByZXR1cm4gcTtcbiAgfVxuICBpZiAodCA8IDIgLyAzKSB7XG4gICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuICB9XG4gIHJldHVybiBwO1xufVxuZnVuY3Rpb24gaHNsVG9SZ2IoaCwgcywgbCkge1xuICBsZXQgcjtcbiAgbGV0IGc7XG4gIGxldCBiMjtcbiAgaCA9IGJvdW5kMDEoaCwgMzYwKTtcbiAgcyA9IGJvdW5kMDEocyAqIDEwMCwgMTAwKTtcbiAgbCA9IGJvdW5kMDEobCAqIDEwMCwgMTAwKTtcbiAgaWYgKHMgPT09IDApIHtcbiAgICByID0gZyA9IGIyID0gbDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICBjb25zdCBwID0gMiAqIGwgLSBxO1xuICAgIHIgPSBodWUycmdiKHAsIHEsIGggKyAxIC8gMyk7XG4gICAgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XG4gICAgYjIgPSBodWUycmdiKHAsIHEsIGggLSAxIC8gMyk7XG4gIH1cbiAgcmV0dXJuIHsgcjogciAqIDI1NSwgZzogZyAqIDI1NSwgYjogYjIgKiAyNTUgfTtcbn1cbmZ1bmN0aW9uIHJnYlRvSHN2KHIsIGcsIGIyKSB7XG4gIHIgPSBib3VuZDAxKHIsIDI1NSk7XG4gIGcgPSBib3VuZDAxKGcsIDI1NSk7XG4gIGIyID0gYm91bmQwMShiMiwgMjU1KTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYjIpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiMik7XG4gIGNvbnN0IGQgPSBtYXggLSBtaW47XG4gIGxldCBoO1xuICBjb25zdCBzID0gbWF4ID09PSAwID8gMCA6IGQgLyBtYXg7XG4gIGNvbnN0IHYgPSBtYXg7XG4gIGlmIChtYXggPT09IG1pbikge1xuICAgIGggPSAwO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICBjYXNlIHI6XG4gICAgICAgIGggPSAoZyAtIGIyKSAvIGQgKyAoZyA8IGIyID8gNiA6IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZzpcbiAgICAgICAgaCA9IChiMiAtIHIpIC8gZCArIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBiMjpcbiAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGggLz0gNjtcbiAgfVxuICByZXR1cm4geyBoLCBzLCB2IH07XG59XG5mdW5jdGlvbiBoc3ZUb1JnYihoLCBzLCB2KSB7XG4gIGggPSBib3VuZDAxKGgsIDM2MCkgKiA2O1xuICBzID0gYm91bmQwMShzICogMTAwLCAxMDApO1xuICB2ID0gYm91bmQwMSh2ICogMTAwLCAxMDApO1xuICBjb25zdCBpID0gTWF0aC5mbG9vcihoKSwgZiA9IGggLSBpLCBwID0gdiAqICgxIC0gcyksIHEgPSB2ICogKDEgLSBmICogcyksIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyksIG1vZCA9IGkgJSA2LCByID0gW3YsIHEsIHAsIHAsIHQsIHZdW21vZF0sIGcgPSBbdCwgdiwgdiwgcSwgcCwgcF1bbW9kXSwgYjIgPSBbcCwgcCwgdCwgdiwgdiwgcV1bbW9kXTtcbiAgcmV0dXJuIHsgcjogciAqIDI1NSwgZzogZyAqIDI1NSwgYjogYjIgKiAyNTUgfTtcbn1cbmZ1bmN0aW9uIGJvdW5kMDEobiwgbWF4KSB7XG4gIGxldCBfbWF4O1xuICBsZXQgX247XG4gIGlmICh0eXBlb2YgbWF4ID09PSBcInN0cmluZ1wiKVxuICAgIF9tYXggPSBwYXJzZUZsb2F0KG1heCk7XG4gIGVsc2VcbiAgICBfbWF4ID0gbWF4O1xuICBpZiAodHlwZW9mIG4gPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoaXNPbmVQb2ludFplcm8obikpIHtcbiAgICAgIG4gPSBcIjEwMCVcIjtcbiAgICB9XG4gICAgY29uc3QgcHJvY2Vzc1BlcmNlbnQgPSBpc1BlcmNlbnRhZ2Uobik7XG4gICAgX24gPSBNYXRoLm1pbihfbWF4LCBNYXRoLm1heCgwLCBwYXJzZUZsb2F0KG4pKSk7XG4gICAgaWYgKHByb2Nlc3NQZXJjZW50KSB7XG4gICAgICBfbiA9IE1hdGguZmxvb3IoX24gKiBfbWF4KSAvIDEwMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgX24gPSBuO1xuICB9XG4gIGlmIChNYXRoLmFicyhfbiAtIF9tYXgpIDwgMWUtNikge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiBfbiAlIF9tYXggLyBfbWF4O1xufVxuZnVuY3Rpb24gaXNPbmVQb2ludFplcm8obikge1xuICByZXR1cm4gdHlwZW9mIG4gPT09IFwic3RyaW5nXCIgJiYgbi5pbmNsdWRlcyhcIi5cIikgJiYgcGFyc2VGbG9hdChuKSA9PT0gMTtcbn1cbmZ1bmN0aW9uIGlzUGVyY2VudGFnZShuKSB7XG4gIHJldHVybiB0eXBlb2YgbiA9PT0gXCJzdHJpbmdcIiAmJiBuLmluY2x1ZGVzKFwiJVwiKTtcbn1cbmZ1bmN0aW9uIHBhZDIoY2hhcikge1xuICBpZiAoY2hhci5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gXCIwXCIgKyBjaGFyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlwiICsgY2hhcjtcbiAgfVxufVxudmFyIG1hdGNoZXJzID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGNzc0ludGVnZXIgPSBcIlstXFxcXCtdP1xcXFxkKyU/XCI7XG4gIGNvbnN0IGNzc051bWJlciA9IFwiWy1cXFxcK10/XFxcXGQqXFxcXC5cXFxcZCslP1wiO1xuICBjb25zdCBjc3NVbml0ID0gXCIoPzpcIiArIGNzc051bWJlciArIFwiKXwoPzpcIiArIGNzc0ludGVnZXIgKyBcIilcIjtcbiAgY29uc3QgcGVybWlzc2l2ZU1hdGNoMyA9IFwiW1xcXFxzfFxcXFwoXSsoXCIgKyBjc3NVbml0ICsgXCIpWyx8XFxcXHNdKyhcIiArIGNzc1VuaXQgKyBcIilbLHxcXFxcc10rKFwiICsgY3NzVW5pdCArIFwiKVxcXFxzKlxcXFwpP1wiO1xuICBjb25zdCBwZXJtaXNzaXZlTWF0Y2g0ID0gXCJbXFxcXHN8XFxcXChdKyhcIiArIGNzc1VuaXQgKyBcIilbLHxcXFxcc10rKFwiICsgY3NzVW5pdCArIFwiKVssfFxcXFxzXSsoXCIgKyBjc3NVbml0ICsgXCIpWyx8XFxcXHNdKyhcIiArIGNzc1VuaXQgKyBcIilcXFxccypcXFxcKT9cIjtcbiAgcmV0dXJuIHtcbiAgICByZ2I6IG5ldyBSZWdFeHAoXCJyZ2JcIiArIHBlcm1pc3NpdmVNYXRjaDMpLFxuICAgIHJnYmE6IG5ldyBSZWdFeHAoXCJyZ2JhXCIgKyBwZXJtaXNzaXZlTWF0Y2g0KSxcbiAgICBoc2w6IG5ldyBSZWdFeHAoXCJoc2xcIiArIHBlcm1pc3NpdmVNYXRjaDMpLFxuICAgIGhzbGE6IG5ldyBSZWdFeHAoXCJoc2xhXCIgKyBwZXJtaXNzaXZlTWF0Y2g0KSxcbiAgICBoc3Y6IG5ldyBSZWdFeHAoXCJoc3ZcIiArIHBlcm1pc3NpdmVNYXRjaDMpLFxuICAgIGhzdmE6IG5ldyBSZWdFeHAoXCJoc3ZhXCIgKyBwZXJtaXNzaXZlTWF0Y2g0KSxcbiAgICBoZXgzOiAvXihbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvLFxuICAgIGhleDY6IC9eKFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pJC8sXG4gICAgaGV4NDogL14jPyhbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLyxcbiAgICBoZXg4OiAvXiM/KFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KSQvXG4gIH07XG59KCk7XG5mdW5jdGlvbiBzdHJpbmdUb09iamVjdChpbnB1dENvbG9yKSB7XG4gIGlmIChpbnB1dENvbG9yLmluY2x1ZGVzKFwiZ3JhZGllbnQoXCIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGlucHV0Q29sb3IuaW5jbHVkZXMoXCJ2YXIoXCIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgdHJpbUxlZnQgPSAvXltcXHMsI10rLztcbiAgY29uc3QgdHJpbVJpZ2h0ID0gL1xccyskLztcbiAgbGV0IGNvbG9yMiA9IGlucHV0Q29sb3IucmVwbGFjZSh0cmltTGVmdCwgXCJcIikucmVwbGFjZSh0cmltUmlnaHQsIFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gIGxldCBuYW1lZCA9IGZhbHNlO1xuICBpZiAoY3NzTmFtZXNbY29sb3IyXSkge1xuICAgIGNvbG9yMiA9IGNzc05hbWVzW2NvbG9yMl07XG4gICAgbmFtZWQgPSB0cnVlO1xuICB9XG4gIGlmIChjb2xvcjIgPT09IFwidHJhbnNwYXJlbnRcIikge1xuICAgIHJldHVybiB7XG4gICAgICByOiAwLFxuICAgICAgZzogMCxcbiAgICAgIGI6IDAsXG4gICAgICBhOiAwLFxuICAgICAgZm9ybWF0OiBDb2xvckZvcm1hdC5OQU1FXG4gICAgfTtcbiAgfVxuICBsZXQgbWF0Y2g7XG4gIGlmIChtYXRjaCA9IG1hdGNoZXJzLnJnYi5leGVjKGNvbG9yMikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcjogcGFyc2VJbnQobWF0Y2hbMV0pLFxuICAgICAgZzogcGFyc2VJbnQobWF0Y2hbMl0pLFxuICAgICAgYjogcGFyc2VJbnQobWF0Y2hbM10pLFxuICAgICAgYTogMSxcbiAgICAgIGZvcm1hdDogQ29sb3JGb3JtYXQuUkdCXG4gICAgfTtcbiAgfVxuICBpZiAobWF0Y2ggPSBtYXRjaGVycy5yZ2JhLmV4ZWMoY29sb3IyKSkge1xuICAgIHJldHVybiB7XG4gICAgICByOiBwYXJzZUludChtYXRjaFsxXSksXG4gICAgICBnOiBwYXJzZUludChtYXRjaFsyXSksXG4gICAgICBiOiBwYXJzZUludChtYXRjaFszXSksXG4gICAgICBhOiBwYXJzZUZsb2F0KG1hdGNoWzRdKSxcbiAgICAgIGZvcm1hdDogQ29sb3JGb3JtYXQuUkdCXG4gICAgfTtcbiAgfVxuICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oc2wuZXhlYyhjb2xvcjIpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGg6IHBhcnNlSW50KG1hdGNoWzFdKSxcbiAgICAgIHM6IHBlcmNlbnRUb0ZyYWN0aW9uKG1hdGNoWzJdKSxcbiAgICAgIGw6IHBlcmNlbnRUb0ZyYWN0aW9uKG1hdGNoWzNdKSxcbiAgICAgIGE6IDEsXG4gICAgICBmb3JtYXQ6IENvbG9yRm9ybWF0LkhTTFxuICAgIH07XG4gIH1cbiAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaHNsYS5leGVjKGNvbG9yMikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaDogcGFyc2VJbnQobWF0Y2hbMV0pLFxuICAgICAgczogcGVyY2VudFRvRnJhY3Rpb24obWF0Y2hbMl0pLFxuICAgICAgbDogcGVyY2VudFRvRnJhY3Rpb24obWF0Y2hbM10pLFxuICAgICAgYTogcGFyc2VGbG9hdChtYXRjaFs0XSksXG4gICAgICBmb3JtYXQ6IENvbG9yRm9ybWF0LkhTTFxuICAgIH07XG4gIH1cbiAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaHN2LmV4ZWMoY29sb3IyKSkge1xuICAgIHJldHVybiB7XG4gICAgICBoOiBwYXJzZUludChtYXRjaFsxXSksXG4gICAgICBzOiBwZXJjZW50VG9GcmFjdGlvbihtYXRjaFsyXSksXG4gICAgICB2OiBwZXJjZW50VG9GcmFjdGlvbihtYXRjaFszXSksXG4gICAgICBhOiAxLFxuICAgICAgZm9ybWF0OiBDb2xvckZvcm1hdC5IU1ZcbiAgICB9O1xuICB9XG4gIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhzdmEuZXhlYyhjb2xvcjIpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGg6IHBhcnNlSW50KG1hdGNoWzFdKSxcbiAgICAgIHM6IHBlcmNlbnRUb0ZyYWN0aW9uKG1hdGNoWzJdKSxcbiAgICAgIHY6IHBlcmNlbnRUb0ZyYWN0aW9uKG1hdGNoWzNdKSxcbiAgICAgIGE6IHBhcnNlRmxvYXQobWF0Y2hbNF0pLFxuICAgICAgZm9ybWF0OiBDb2xvckZvcm1hdC5IU1ZcbiAgICB9O1xuICB9XG4gIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDguZXhlYyhjb2xvcjIpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHI6IHBhcnNlSW50RnJvbUhleChtYXRjaFsxXSksXG4gICAgICBnOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMl0pLFxuICAgICAgYjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzNdKSxcbiAgICAgIGE6IGNvbnZlcnRIZXhUb0RlY2ltYWwobWF0Y2hbNF0pLFxuICAgICAgZm9ybWF0OiBuYW1lZCA/IENvbG9yRm9ybWF0Lk5BTUUgOiBDb2xvckZvcm1hdC5IRVhcbiAgICB9O1xuICB9XG4gIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDYuZXhlYyhjb2xvcjIpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHI6IHBhcnNlSW50RnJvbUhleChtYXRjaFsxXSksXG4gICAgICBnOiBwYXJzZUludEZyb21IZXgobWF0Y2hbMl0pLFxuICAgICAgYjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzNdKSxcbiAgICAgIGE6IDEsXG4gICAgICBmb3JtYXQ6IG5hbWVkID8gQ29sb3JGb3JtYXQuTkFNRSA6IENvbG9yRm9ybWF0LkhFWFxuICAgIH07XG4gIH1cbiAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaGV4NC5leGVjKGNvbG9yMikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcjogcGFyc2VJbnRGcm9tSGV4KGAke21hdGNoWzFdfSR7bWF0Y2hbMV19YCksXG4gICAgICBnOiBwYXJzZUludEZyb21IZXgoYCR7bWF0Y2hbMl19JHttYXRjaFsyXX1gKSxcbiAgICAgIGI6IHBhcnNlSW50RnJvbUhleChgJHttYXRjaFszXX0ke21hdGNoWzNdfWApLFxuICAgICAgYTogY29udmVydEhleFRvRGVjaW1hbChtYXRjaFs0XSArIFwiXCIgKyBtYXRjaFs0XSksXG4gICAgICBmb3JtYXQ6IG5hbWVkID8gQ29sb3JGb3JtYXQuTkFNRSA6IENvbG9yRm9ybWF0LkhFWFxuICAgIH07XG4gIH1cbiAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaGV4My5leGVjKGNvbG9yMikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcjogcGFyc2VJbnRGcm9tSGV4KGAke21hdGNoWzFdfSR7bWF0Y2hbMV19YCksXG4gICAgICBnOiBwYXJzZUludEZyb21IZXgoYCR7bWF0Y2hbMl19JHttYXRjaFsyXX1gKSxcbiAgICAgIGI6IHBhcnNlSW50RnJvbUhleChgJHttYXRjaFszXX0ke21hdGNoWzNdfWApLFxuICAgICAgYTogMSxcbiAgICAgIGZvcm1hdDogbmFtZWQgPyBDb2xvckZvcm1hdC5OQU1FIDogQ29sb3JGb3JtYXQuSEVYXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSW50RnJvbUhleChoZXgyKSB7XG4gIHJldHVybiBwYXJzZUludChoZXgyLCAxNik7XG59XG5mdW5jdGlvbiBjb252ZXJ0SGV4VG9EZWNpbWFsKGgpIHtcbiAgcmV0dXJuIHBhcnNlSW50RnJvbUhleChoKSAvIDI1NTtcbn1cblxuLy8gc3JjL3JlbmRlci90eXBlcy9Db2xvci9Db2xvci50c1xudmFyIGNhY2hlMiA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIENvbG9yKGNvbG9yMiwgciwgZywgYjIpIHtcbiAgaWYgKHR5cGVvZiBjb2xvcjIgPT09IFwic3RyaW5nXCIpIHtcbiAgICBsZXQgYzIgPSBjYWNoZTIuZ2V0KGNvbG9yMik7XG4gICAgaWYgKGMyKVxuICAgICAgcmV0dXJuIGMyO1xuICAgIGMyID0gY3JlYXRlQ29sb3IoY29sb3IyKTtcbiAgICBpZiAoYzIgPT09IHZvaWQgMClcbiAgICAgIHJldHVybiB7IC4uLkNvbG9yKFwiYmxhY2tcIiksIGlzVmFsaWQ6IGZhbHNlIH07XG4gICAgY2FjaGUyLnNldChjb2xvcjIsIGMyKTtcbiAgICByZXR1cm4gYzI7XG4gIH1cbiAgY29uc3QgY3JlYXRlZCA9IGNyZWF0ZUNvbG9yKGNvbG9yMiwgciwgZywgYjIpO1xuICByZXR1cm4gY3JlYXRlZCAhPT0gdm9pZCAwID8gY3JlYXRlZCA6IHsgLi4uQ29sb3IoXCJibGFja1wiKSwgaXNWYWxpZDogZmFsc2UgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbG9yKGNvbG9yMiwgciwgZywgYjIpIHtcbiAgaWYgKGNvbG9yMiA9PT0gXCJcIilcbiAgICByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBjb2xvckRhdGEgPSBnZXRDb21wbGV0ZUNvbG9yU3RyYXRlZ3koY29sb3IyLCByLCBnLCBiMik7XG4gIGlmIChjb2xvckRhdGEpIHtcbiAgICBjb25zdCBuZXdDb2xvciA9IHtcbiAgICAgIHI6IGNvbG9yRGF0YS5yLFxuICAgICAgZzogY29sb3JEYXRhLmcsXG4gICAgICBiOiBjb2xvckRhdGEuYixcbiAgICAgIGE6IGNvbG9yRGF0YS5hLFxuICAgICAgaDogY29sb3JEYXRhLmgsXG4gICAgICBzOiBjb2xvckRhdGEucyxcbiAgICAgIGw6IGNvbG9yRGF0YS5sLFxuICAgICAgaW5pdGlhbFZhbHVlOiB0eXBlb2YgY29sb3IyID09PSBcInN0cmluZ1wiICYmIGNvbG9yRGF0YS5mb3JtYXQgIT09IENvbG9yRm9ybWF0LkhTViA/IGNvbG9yMiA6IHZvaWQgMCxcbiAgICAgIHJvdW5kQTogTWF0aC5yb3VuZCgxMDAgKiBjb2xvckRhdGEuYSkgLyAxMDAsXG4gICAgICBmb3JtYXQ6IGNvbG9yRGF0YS5mb3JtYXQsXG4gICAgICBtaXg6IENvbG9yLm1peCxcbiAgICAgIHRvVmFsdWU6ICgpID0+IENvbG9yLnRvUmdiU3RyaW5nKG5ld0NvbG9yKVxuICAgIH07XG4gICAgcmV0dXJuIG5ld0NvbG9yO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn1cbihmdW5jdGlvbihDb2xvcjIpIHtcbiAgZnVuY3Rpb24gaW5zcGVjdDIoY29sb3IyLCBpbml0aWFsVmFsdWUpIHtcbiAgICBpZiAoY29sb3IyLmZvcm1hdCA9PT0gQ29sb3JGb3JtYXQuSFNMKSB7XG4gICAgICByZXR1cm4gYDwke2NvbG9yMi5jb25zdHJ1Y3Rvci5uYW1lfSBoOiR7Y29sb3IyLmh9IHM6JHtjb2xvcjIuc30gbDoke2NvbG9yMi5sfSBhOiR7Y29sb3IyLmF9PmA7XG4gICAgfSBlbHNlIGlmIChjb2xvcjIuZm9ybWF0ID09PSBDb2xvckZvcm1hdC5IRVggfHwgY29sb3IyLmZvcm1hdCA9PT0gQ29sb3JGb3JtYXQuTkFNRSkge1xuICAgICAgcmV0dXJuIGA8JHtjb2xvcjIuY29uc3RydWN0b3IubmFtZX0gXCIke2luaXRpYWxWYWx1ZX1cIj5gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYDwke2NvbG9yMi5jb25zdHJ1Y3Rvci5uYW1lfSByOiR7Y29sb3IyLnJ9IGc6JHtjb2xvcjIuZ30gYjoke2NvbG9yMi5ifSBhOiR7Y29sb3IyLmF9PmA7XG4gICAgfVxuICB9XG4gIENvbG9yMi5pbnNwZWN0ID0gaW5zcGVjdDI7XG4gIGZ1bmN0aW9uIGlzQ29sb3IoY29sb3IyKSB7XG4gICAgaWYgKHR5cGVvZiBjb2xvcjIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBDb2xvcjIuaXNDb2xvclN0cmluZyhjb2xvcjIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gQ29sb3IyLmlzQ29sb3JPYmplY3QoY29sb3IyKTtcbiAgICB9XG4gIH1cbiAgQ29sb3IyLmlzQ29sb3IgPSBpc0NvbG9yO1xuICBmdW5jdGlvbiBpc0NvbG9yU3RyaW5nMihjb2xvclN0cmluZykge1xuICAgIGlmICh0eXBlb2YgY29sb3JTdHJpbmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBzdHJpbmdUb09iamVjdChjb2xvclN0cmluZykgIT09IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgQ29sb3IyLmlzQ29sb3JTdHJpbmcgPSBpc0NvbG9yU3RyaW5nMjtcbiAgZnVuY3Rpb24gaXNDb2xvck9iamVjdChjb2xvcjIpIHtcbiAgICByZXR1cm4gY29sb3IyICYmIHR5cGVvZiBjb2xvcjIgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGNvbG9yMi5yID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBjb2xvcjIuZyA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgY29sb3IyLmIgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGNvbG9yMi5oID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBjb2xvcjIucyA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgY29sb3IyLmwgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGNvbG9yMi5hID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBjb2xvcjIucm91bmRBID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBjb2xvcjIuZm9ybWF0ID09PSBcInN0cmluZ1wiO1xuICB9XG4gIENvbG9yMi5pc0NvbG9yT2JqZWN0ID0gaXNDb2xvck9iamVjdDtcbiAgZnVuY3Rpb24gdG9TdHJpbmcoY29sb3IyKSB7XG4gICAgcmV0dXJuIENvbG9yMi50b1JnYlN0cmluZyhjb2xvcjIpO1xuICB9XG4gIENvbG9yMi50b1N0cmluZyA9IHRvU3RyaW5nO1xuICBmdW5jdGlvbiB0b0hleChjb2xvcjIsIGFsbG93M0NoYXIgPSBmYWxzZSkge1xuICAgIHJldHVybiByZ2JUb0hleChjb2xvcjIuciwgY29sb3IyLmcsIGNvbG9yMi5iLCBhbGxvdzNDaGFyKTtcbiAgfVxuICBDb2xvcjIudG9IZXggPSB0b0hleDtcbiAgZnVuY3Rpb24gdG9IZXhTdHJpbmcoY29sb3IyLCBhbGxvdzNDaGFyID0gZmFsc2UpIHtcbiAgICByZXR1cm4gYCMke0NvbG9yMi50b0hleChjb2xvcjIsIGFsbG93M0NoYXIpfWA7XG4gIH1cbiAgQ29sb3IyLnRvSGV4U3RyaW5nID0gdG9IZXhTdHJpbmc7XG4gIGZ1bmN0aW9uIHRvUmdiU3RyaW5nKGNvbG9yMikge1xuICAgIHJldHVybiBjb2xvcjIuYSA9PT0gMSA/IFwicmdiKFwiICsgTWF0aC5yb3VuZChjb2xvcjIucikgKyBcIiwgXCIgKyBNYXRoLnJvdW5kKGNvbG9yMi5nKSArIFwiLCBcIiArIE1hdGgucm91bmQoY29sb3IyLmIpICsgXCIpXCIgOiBcInJnYmEoXCIgKyBNYXRoLnJvdW5kKGNvbG9yMi5yKSArIFwiLCBcIiArIE1hdGgucm91bmQoY29sb3IyLmcpICsgXCIsIFwiICsgTWF0aC5yb3VuZChjb2xvcjIuYikgKyBcIiwgXCIgKyBjb2xvcjIucm91bmRBICsgXCIpXCI7XG4gIH1cbiAgQ29sb3IyLnRvUmdiU3RyaW5nID0gdG9SZ2JTdHJpbmc7XG4gIGZ1bmN0aW9uIHRvSHVzbChjb2xvcjIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmdiVG9Ic2x1dihjb2xvcjIuciwgY29sb3IyLmcsIGNvbG9yMi5iKSxcbiAgICAgIGE6IGNvbG9yMi5yb3VuZEFcbiAgICB9O1xuICB9XG4gIENvbG9yMi50b0h1c2wgPSB0b0h1c2w7XG4gIGZ1bmN0aW9uIHRvSHNsU3RyaW5nKGNvbG9yMikge1xuICAgIGNvbnN0IGhzbCA9IENvbG9yMi50b0hzbChjb2xvcjIpO1xuICAgIGNvbnN0IGggPSBNYXRoLnJvdW5kKGhzbC5oKTtcbiAgICBjb25zdCBzID0gTWF0aC5yb3VuZChoc2wucyAqIDEwMCk7XG4gICAgY29uc3QgbCA9IE1hdGgucm91bmQoaHNsLmwgKiAxMDApO1xuICAgIHJldHVybiBjb2xvcjIuYSA9PT0gMSA/IFwiaHNsKFwiICsgaCArIFwiLCBcIiArIHMgKyBcIiUsIFwiICsgbCArIFwiJSlcIiA6IFwiaHNsYShcIiArIGggKyBcIiwgXCIgKyBzICsgXCIlLCBcIiArIGwgKyBcIiUsIFwiICsgY29sb3IyLnJvdW5kQSArIFwiKVwiO1xuICB9XG4gIENvbG9yMi50b0hzbFN0cmluZyA9IHRvSHNsU3RyaW5nO1xuICBmdW5jdGlvbiB0b0hzdihjb2xvcjIpIHtcbiAgICBjb25zdCBoc3YgPSByZ2JUb0hzdihjb2xvcjIuciwgY29sb3IyLmcsIGNvbG9yMi5iKTtcbiAgICByZXR1cm4geyBoOiBoc3YuaCAqIDM2MCwgczogaHN2LnMsIHY6IGhzdi52LCBhOiBjb2xvcjIuYSB9O1xuICB9XG4gIENvbG9yMi50b0hzdiA9IHRvSHN2O1xuICBmdW5jdGlvbiB0b0hzdlN0cmluZyhjb2xvcjIpIHtcbiAgICBjb25zdCBoc3YgPSByZ2JUb0hzdihjb2xvcjIuciwgY29sb3IyLmcsIGNvbG9yMi5iKTtcbiAgICBjb25zdCBoID0gTWF0aC5yb3VuZChoc3YuaCAqIDM2MCk7XG4gICAgY29uc3QgcyA9IE1hdGgucm91bmQoaHN2LnMgKiAxMDApO1xuICAgIGNvbnN0IHYgPSBNYXRoLnJvdW5kKGhzdi52ICogMTAwKTtcbiAgICByZXR1cm4gY29sb3IyLmEgPT09IDEgPyBcImhzdihcIiArIGggKyBcIiwgXCIgKyBzICsgXCIlLCBcIiArIHYgKyBcIiUpXCIgOiBcImhzdmEoXCIgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyB2ICsgXCIlLCBcIiArIGNvbG9yMi5yb3VuZEEgKyBcIilcIjtcbiAgfVxuICBDb2xvcjIudG9Ic3ZTdHJpbmcgPSB0b0hzdlN0cmluZztcbiAgZnVuY3Rpb24gdG9OYW1lKGNvbG9yMikge1xuICAgIGlmIChjb2xvcjIuYSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwidHJhbnNwYXJlbnRcIjtcbiAgICB9XG4gICAgaWYgKGNvbG9yMi5hIDwgMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBoZXgyID0gcmdiVG9IZXgoY29sb3IyLnIsIGNvbG9yMi5nLCBjb2xvcjIuYiwgdHJ1ZSk7XG4gICAgZm9yIChjb25zdCBrZXk2IG9mIE9iamVjdC5rZXlzKGNzc05hbWVzKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBjc3NOYW1lc1trZXk2XTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gaGV4Mikge1xuICAgICAgICByZXR1cm4ga2V5NjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIENvbG9yMi50b05hbWUgPSB0b05hbWU7XG4gIGZ1bmN0aW9uIHRvSHNsKGNvbG9yMikge1xuICAgIHJldHVybiB7XG4gICAgICBoOiBNYXRoLnJvdW5kKGNvbG9yMi5oKSxcbiAgICAgIHM6IGNvbG9yMi5zLFxuICAgICAgbDogY29sb3IyLmwsXG4gICAgICBhOiBjb2xvcjIuYVxuICAgIH07XG4gIH1cbiAgQ29sb3IyLnRvSHNsID0gdG9Ic2w7XG4gIGZ1bmN0aW9uIHRvUmdiKGNvbG9yMikge1xuICAgIHJldHVybiB7XG4gICAgICByOiBNYXRoLnJvdW5kKGNvbG9yMi5yKSxcbiAgICAgIGc6IE1hdGgucm91bmQoY29sb3IyLmcpLFxuICAgICAgYjogTWF0aC5yb3VuZChjb2xvcjIuYiksXG4gICAgICBhOiBjb2xvcjIuYVxuICAgIH07XG4gIH1cbiAgQ29sb3IyLnRvUmdiID0gdG9SZ2I7XG4gIGZ1bmN0aW9uIGJyaWdodGVuKGNvbG9yMiwgYW1vdW50ID0gMTApIHtcbiAgICBjb25zdCByZ2IgPSBDb2xvcjIudG9SZ2IoY29sb3IyKTtcbiAgICByZ2IuciA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcmdiLnIgLSBNYXRoLnJvdW5kKDI1NSAqIC0oYW1vdW50IC8gMTAwKSkpKTtcbiAgICByZ2IuZyA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcmdiLmcgLSBNYXRoLnJvdW5kKDI1NSAqIC0oYW1vdW50IC8gMTAwKSkpKTtcbiAgICByZ2IuYiA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcmdiLmIgLSBNYXRoLnJvdW5kKDI1NSAqIC0oYW1vdW50IC8gMTAwKSkpKTtcbiAgICByZXR1cm4gQ29sb3IyKHJnYik7XG4gIH1cbiAgQ29sb3IyLmJyaWdodGVuID0gYnJpZ2h0ZW47XG4gIGZ1bmN0aW9uIGxpZ2h0ZW4oY29sb3IyLCBhbW91bnQgPSAxMCkge1xuICAgIGNvbnN0IGhzbCA9IENvbG9yMi50b0hzbChjb2xvcjIpO1xuICAgIGhzbC5sICs9IGFtb3VudCAvIDEwMDtcbiAgICBoc2wubCA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGhzbC5sKSk7XG4gICAgcmV0dXJuIENvbG9yMihoc2wpO1xuICB9XG4gIENvbG9yMi5saWdodGVuID0gbGlnaHRlbjtcbiAgZnVuY3Rpb24gZGFya2VuKGNvbG9yMiwgYW1vdW50ID0gMTApIHtcbiAgICBjb25zdCBoc2wgPSBDb2xvcjIudG9Ic2woY29sb3IyKTtcbiAgICBoc2wubCAtPSBhbW91bnQgLyAxMDA7XG4gICAgaHNsLmwgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBoc2wubCkpO1xuICAgIHJldHVybiBDb2xvcjIoaHNsKTtcbiAgfVxuICBDb2xvcjIuZGFya2VuID0gZGFya2VuO1xuICBmdW5jdGlvbiBzYXR1cmF0ZShjb2xvcjIsIGFtb3VudCA9IDEwKSB7XG4gICAgY29uc3QgaHNsID0gQ29sb3IyLnRvSHNsKGNvbG9yMik7XG4gICAgaHNsLnMgKz0gYW1vdW50IC8gMTAwO1xuICAgIGhzbC5zID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgaHNsLnMpKTtcbiAgICByZXR1cm4gQ29sb3IyKGhzbCk7XG4gIH1cbiAgQ29sb3IyLnNhdHVyYXRlID0gc2F0dXJhdGU7XG4gIGZ1bmN0aW9uIGRlc2F0dXJhdGUoY29sb3IyLCBhbW91bnQgPSAxMCkge1xuICAgIGNvbnN0IGhzbCA9IENvbG9yMi50b0hzbChjb2xvcjIpO1xuICAgIGhzbC5zIC09IGFtb3VudCAvIDEwMDtcbiAgICBoc2wucyA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGhzbC5zKSk7XG4gICAgcmV0dXJuIENvbG9yMihoc2wpO1xuICB9XG4gIENvbG9yMi5kZXNhdHVyYXRlID0gZGVzYXR1cmF0ZTtcbiAgZnVuY3Rpb24gZ3JheXNjYWxlKGNvbG9yMikge1xuICAgIHJldHVybiBDb2xvcjIuZGVzYXR1cmF0ZShjb2xvcjIsIDEwMCk7XG4gIH1cbiAgQ29sb3IyLmdyYXlzY2FsZSA9IGdyYXlzY2FsZTtcbiAgZnVuY3Rpb24gaHVlUm90YXRlKGNvbG9yMiwgYW5nbGUpIHtcbiAgICBjb25zdCBoc2wgPSBDb2xvcjIudG9Ic2woY29sb3IyKTtcbiAgICBoc2wuaCArPSBhbmdsZTtcbiAgICBoc2wuaCA9IGhzbC5oID4gMzYwID8gaHNsLmggLSAzNjAgOiBoc2wuaDtcbiAgICByZXR1cm4gQ29sb3IyKGhzbCk7XG4gIH1cbiAgQ29sb3IyLmh1ZVJvdGF0ZSA9IGh1ZVJvdGF0ZTtcbiAgZnVuY3Rpb24gYWxwaGEyKGNvbG9yMiwgYTIgPSAxKSB7XG4gICAgcmV0dXJuIENvbG9yMih7XG4gICAgICByOiBjb2xvcjIucixcbiAgICAgIGc6IGNvbG9yMi5nLFxuICAgICAgYjogY29sb3IyLmIsXG4gICAgICBhOiBhMlxuICAgIH0pO1xuICB9XG4gIENvbG9yMi5hbHBoYSA9IGFscGhhMjtcbiAgZnVuY3Rpb24gdHJhbnNwYXJlbnQoY29sb3IyKSB7XG4gICAgcmV0dXJuIENvbG9yMi5hbHBoYShjb2xvcjIsIDApO1xuICB9XG4gIENvbG9yMi50cmFuc3BhcmVudCA9IHRyYW5zcGFyZW50O1xuICBmdW5jdGlvbiBtdWx0aXBseUFscGhhKGNvbG9yMiwgYWxwaGFWYWx1ZSA9IDEpIHtcbiAgICByZXR1cm4gQ29sb3IyKHtcbiAgICAgIHI6IGNvbG9yMi5yLFxuICAgICAgZzogY29sb3IyLmcsXG4gICAgICBiOiBjb2xvcjIuYixcbiAgICAgIGE6IGNvbG9yMi5hICogYWxwaGFWYWx1ZVxuICAgIH0pO1xuICB9XG4gIENvbG9yMi5tdWx0aXBseUFscGhhID0gbXVsdGlwbHlBbHBoYTtcbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGUyKGNvbG9yQSwgY29sb3JCLCBtb2RlbCA9IENvbG9yTWl4TW9kZWxUeXBlLlJHQikge1xuICAgIGlmICghQ29sb3IyLmlzQ29sb3JPYmplY3QoY29sb3JBKSB8fCAhQ29sb3IyLmlzQ29sb3JPYmplY3QoY29sb3JCKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkJvdGggYXJndW1lbnRzIGZvciBDb2xvci5pbnRlcnBvbGF0ZSBtdXN0IGJlIENvbG9yIG9iamVjdHNcIik7XG4gICAgfVxuICAgIHJldHVybiAocHJvZ3Jlc3MyKSA9PiB7XG4gICAgICBjb25zdCBjb2xvcjIgPSBDb2xvcjIubWl4QXNDb2xvcihjb2xvckEsIGNvbG9yQiwgcHJvZ3Jlc3MyLCBmYWxzZSwgbW9kZWwpO1xuICAgICAgcmV0dXJuIGNvbG9yMjtcbiAgICB9O1xuICB9XG4gIENvbG9yMi5pbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlMjtcbiAgZnVuY3Rpb24gbWl4Mihmcm9tLCB0b0NvbG9yLCB7IG1vZGVsID0gQ29sb3JNaXhNb2RlbFR5cGUuUkdCIH0gPSB7fSkge1xuICAgIGNvbnN0IGZyb21Db2xvciA9IHR5cGVvZiBmcm9tID09PSBcInN0cmluZ1wiID8gQ29sb3IyKGZyb20pIDogZnJvbTtcbiAgICBjb25zdCBtaXhlciA9IENvbG9yMi5pbnRlcnBvbGF0ZShmcm9tQ29sb3IsIHRvQ29sb3IsIG1vZGVsKTtcbiAgICByZXR1cm4gKHApID0+IENvbG9yMi50b1JnYlN0cmluZyhtaXhlcihwKSk7XG4gIH1cbiAgQ29sb3IyLm1peCA9IG1peDI7XG4gIGZ1bmN0aW9uIG1peEFzQ29sb3IoY29sb3JBLCBjb2xvckIsIGZyYWN0aW9uMiA9IDAuNSwgbGltaXQgPSBmYWxzZSwgbW9kZWwgPSBDb2xvck1peE1vZGVsVHlwZS5SR0IpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAoQ29sb3JNaXhNb2RlbC5pc1JHQihtb2RlbCkpIHtcbiAgICAgIHJlc3VsdCA9IENvbG9yMih7XG4gICAgICAgIHI6IG1vZHVsYXRlKGZyYWN0aW9uMiwgWzAsIDFdLCBbY29sb3JBLnIsIGNvbG9yQi5yXSwgbGltaXQpLFxuICAgICAgICBnOiBtb2R1bGF0ZShmcmFjdGlvbjIsIFswLCAxXSwgW2NvbG9yQS5nLCBjb2xvckIuZ10sIGxpbWl0KSxcbiAgICAgICAgYjogbW9kdWxhdGUoZnJhY3Rpb24yLCBbMCwgMV0sIFtjb2xvckEuYiwgY29sb3JCLmJdLCBsaW1pdCksXG4gICAgICAgIGE6IG1vZHVsYXRlKGZyYWN0aW9uMiwgWzAsIDFdLCBbY29sb3JBLmEsIGNvbG9yQi5hXSwgbGltaXQpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGhzbEEsIGhzbEI7XG4gICAgICBpZiAoQ29sb3JNaXhNb2RlbC5pc0hTTChtb2RlbCkpIHtcbiAgICAgICAgaHNsQSA9IENvbG9yMi50b0hzbChjb2xvckEpO1xuICAgICAgICBoc2xCID0gQ29sb3IyLnRvSHNsKGNvbG9yQik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoc2xBID0gQ29sb3IyLnRvSHVzbChjb2xvckEpO1xuICAgICAgICBoc2xCID0gQ29sb3IyLnRvSHVzbChjb2xvckIpO1xuICAgICAgfVxuICAgICAgaWYgKGhzbEEucyA9PT0gMCkge1xuICAgICAgICBoc2xBLmggPSBoc2xCLmg7XG4gICAgICB9IGVsc2UgaWYgKGhzbEIucyA9PT0gMCkge1xuICAgICAgICBoc2xCLmggPSBoc2xBLmg7XG4gICAgICB9XG4gICAgICBjb25zdCBmcm9tSCA9IGhzbEEuaDtcbiAgICAgIGNvbnN0IHRvSCA9IGhzbEIuaDtcbiAgICAgIGxldCBkZWx0YUggPSB0b0ggLSBmcm9tSDtcbiAgICAgIGlmIChkZWx0YUggPiAxODApIHtcbiAgICAgICAgZGVsdGFIID0gdG9IIC0gMzYwIC0gZnJvbUg7XG4gICAgICB9IGVsc2UgaWYgKGRlbHRhSCA8IC0xODApIHtcbiAgICAgICAgZGVsdGFIID0gdG9IICsgMzYwIC0gZnJvbUg7XG4gICAgICB9XG4gICAgICBjb25zdCB0d2VlbiA9IHtcbiAgICAgICAgaDogbW9kdWxhdGUoZnJhY3Rpb24yLCBbMCwgMV0sIFtmcm9tSCwgZnJvbUggKyBkZWx0YUhdLCBsaW1pdCksXG4gICAgICAgIHM6IG1vZHVsYXRlKGZyYWN0aW9uMiwgWzAsIDFdLCBbaHNsQS5zLCBoc2xCLnNdLCBsaW1pdCksXG4gICAgICAgIGw6IG1vZHVsYXRlKGZyYWN0aW9uMiwgWzAsIDFdLCBbaHNsQS5sLCBoc2xCLmxdLCBsaW1pdCksXG4gICAgICAgIGE6IG1vZHVsYXRlKGZyYWN0aW9uMiwgWzAsIDFdLCBbY29sb3JBLmEsIGNvbG9yQi5hXSwgbGltaXQpXG4gICAgICB9O1xuICAgICAgaWYgKENvbG9yTWl4TW9kZWwuaXNIU0wobW9kZWwpKSB7XG4gICAgICAgIHJlc3VsdCA9IENvbG9yMih0d2Vlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBDb2xvcjIocmdiYUZyb21IdXNsKHR3ZWVuLmgsIHR3ZWVuLnMsIHR3ZWVuLmwsIHR3ZWVuLmEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBDb2xvcjIubWl4QXNDb2xvciA9IG1peEFzQ29sb3I7XG4gIGZ1bmN0aW9uIHJhbmRvbShhbHBoYVZhbHVlID0gMSkge1xuICAgIGZ1bmN0aW9uIGdlbigpIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTUpO1xuICAgIH1cbiAgICByZXR1cm4gQ29sb3IyKFwicmdiYShcIiArIGdlbigpICsgXCIsIFwiICsgZ2VuKCkgKyBcIiwgXCIgKyBnZW4oKSArIFwiLCBcIiArIGFscGhhVmFsdWUgKyBcIilcIik7XG4gIH1cbiAgQ29sb3IyLnJhbmRvbSA9IHJhbmRvbTtcbiAgZnVuY3Rpb24gZ3JleShhbW91bnQgPSAwLjUsIGFscGhhVmFsdWUgPSAxKSB7XG4gICAgYW1vdW50ID0gTWF0aC5mbG9vcihhbW91bnQgKiAyNTUpO1xuICAgIHJldHVybiBDb2xvcjIoXCJyZ2JhKFwiICsgYW1vdW50ICsgXCIsIFwiICsgYW1vdW50ICsgXCIsIFwiICsgYW1vdW50ICsgXCIsIFwiICsgYWxwaGFWYWx1ZSArIFwiKVwiKTtcbiAgfVxuICBDb2xvcjIuZ3JleSA9IGdyZXk7XG4gIENvbG9yMi5ncmF5ID0gQ29sb3IyLmdyZXk7XG4gIGZ1bmN0aW9uIHJnYlRvSHNsMihyLCBnLCBiMikge1xuICAgIHJldHVybiByZ2JUb0hzbChyLCBnLCBiMik7XG4gIH1cbiAgQ29sb3IyLnJnYlRvSHNsID0gcmdiVG9Ic2wyO1xuICBDb2xvcjIuaXNWYWxpZENvbG9yUHJvcGVydHkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IGlzQ29sb3JLZXkgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoLTUpID09PSBcImNvbG9yXCIgfHwgbmFtZSA9PT0gXCJmaWxsXCIgfHwgbmFtZSA9PT0gXCJzdHJva2VcIjtcbiAgICBpZiAoaXNDb2xvcktleSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgQ29sb3IyLmlzQ29sb3JTdHJpbmcodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBmdW5jdGlvbiBkaWZmZXJlbmNlKGNvbG9yQSwgY29sb3JCKSB7XG4gICAgY29uc3QgX3IgPSAoY29sb3JBLnIgKyBjb2xvckIucikgLyAyO1xuICAgIGNvbnN0IGRlbHRhUiA9IGNvbG9yQS5yIC0gY29sb3JCLnI7XG4gICAgY29uc3QgZGVsdGFHID0gY29sb3JBLmcgLSBjb2xvckIuZztcbiAgICBjb25zdCBkZWx0YUIgPSBjb2xvckEuYiAtIGNvbG9yQi5iO1xuICAgIGNvbnN0IGRlbHRhUjIgPSBNYXRoLnBvdyhkZWx0YVIsIDIpO1xuICAgIGNvbnN0IGRlbHRhRzIgPSBNYXRoLnBvdyhkZWx0YUcsIDIpO1xuICAgIGNvbnN0IGRlbHRhQjIgPSBNYXRoLnBvdyhkZWx0YUIsIDIpO1xuICAgIHJldHVybiBNYXRoLnNxcnQoMiAqIGRlbHRhUjIgKyA0ICogZGVsdGFHMiArIDMgKiBkZWx0YUIyICsgX3IgKiAoZGVsdGFSMiAtIGRlbHRhQjIpIC8gMjU2KTtcbiAgfVxuICBDb2xvcjIuZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XG4gIGZ1bmN0aW9uIGVxdWFsMihjb2xvckEsIGNvbG9yQiwgdG9sZXJhbmNlID0gMC4xKSB7XG4gICAgaWYgKE1hdGguYWJzKGNvbG9yQS5yIC0gY29sb3JCLnIpID49IHRvbGVyYW5jZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoTWF0aC5hYnMoY29sb3JBLmcgLSBjb2xvckIuZykgPj0gdG9sZXJhbmNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyhjb2xvckEuYiAtIGNvbG9yQi5iKSA+PSB0b2xlcmFuY2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKGNvbG9yQS5hIC0gY29sb3JCLmEpICogMjU2ID49IHRvbGVyYW5jZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBDb2xvcjIuZXF1YWwgPSBlcXVhbDI7XG59KShDb2xvciB8fCAoQ29sb3IgPSB7fSkpO1xudmFyIENvbG9yTWl4TW9kZWwgPSB7XG4gIGlzUkdCKGNvbG9yTW9kZWwpIHtcbiAgICByZXR1cm4gY29sb3JNb2RlbCA9PT0gQ29sb3JNaXhNb2RlbFR5cGUuUkdCIHx8IGNvbG9yTW9kZWwgPT09IENvbG9yTWl4TW9kZWxUeXBlLlJHQkE7XG4gIH0sXG4gIGlzSFNMKGNvbG9yTW9kZWwpIHtcbiAgICByZXR1cm4gY29sb3JNb2RlbCA9PT0gQ29sb3JNaXhNb2RlbFR5cGUuSFNMIHx8IGNvbG9yTW9kZWwgPT09IENvbG9yTWl4TW9kZWxUeXBlLkhTTEE7XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRDb21wbGV0ZUNvbG9yU3RyYXRlZ3koY29sb3JPclIsIGcsIGIyLCBhMiA9IDEpIHtcbiAgbGV0IGNvbXBsZXRlQ29sb3I7XG4gIGlmICh0eXBlb2YgY29sb3JPclIgPT09IFwibnVtYmVyXCIgJiYgIU51bWJlci5pc05hTihjb2xvck9yUikgJiYgdHlwZW9mIGcgPT09IFwibnVtYmVyXCIgJiYgIU51bWJlci5pc05hTihnKSAmJiB0eXBlb2YgYjIgPT09IFwibnVtYmVyXCIgJiYgIU51bWJlci5pc05hTihiMikpIHtcbiAgICBjb25zdCBfciA9IGNvbG9yT3JSO1xuICAgIGNvbnN0IF9nID0gZztcbiAgICBjb25zdCBfYiA9IGIyO1xuICAgIGNvbnN0IF9hID0gYTI7XG4gICAgY29tcGxldGVDb2xvciA9IGdldENvbXBsZXRlQ29sb3JGcm9tUkdCKHsgcjogX3IsIGc6IF9nLCBiOiBfYiwgYTogX2EgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvbG9yT3JSID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29tcGxldGVDb2xvciA9IGdldENvbXBsZXRlQ29sb3JGcm9tU3RyaW5nKGNvbG9yT3JSKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29sb3JPclIgPT09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoY29sb3JPclIuaGFzT3duUHJvcGVydHkoXCJyXCIpICYmIGNvbG9yT3JSLmhhc093blByb3BlcnR5KFwiZ1wiKSAmJiBjb2xvck9yUi5oYXNPd25Qcm9wZXJ0eShcImJcIikpIHtcbiAgICAgIGNvbXBsZXRlQ29sb3IgPSBnZXRDb21wbGV0ZUNvbG9yRnJvbVJHQihjb2xvck9yUik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBsZXRlQ29sb3IgPSBnZXRDb21wbGV0ZUNvbG9yRnJvbUhTTChjb2xvck9yUik7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb21wbGV0ZUNvbG9yO1xufVxuZnVuY3Rpb24gZ2V0Q29tcGxldGVDb2xvckZyb21TdHJpbmcoY29sb3IyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHN0cmluZ1RvT2JqZWN0KGNvbG9yMik7XG4gIGlmIChyZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0LmZvcm1hdCA9PT0gQ29sb3JGb3JtYXQuSFNMKSB7XG4gICAgICByZXR1cm4gZ2V0Q29tcGxldGVDb2xvckZyb21IU0wocmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC5mb3JtYXQgPT09IENvbG9yRm9ybWF0LkhTVikge1xuICAgICAgcmV0dXJuIGdldENvbXBsZXRlQ29sb3JGcm9tSFNWKHJlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXRDb21wbGV0ZUNvbG9yRnJvbVJHQihyZXN1bHQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q29tcGxldGVDb2xvckZyb21IU1YoY29sb3IyKSB7XG4gIGNvbnN0IHJnYiA9IGhzdlRvUmdiKGNvbG9yMi5oLCBjb2xvcjIucywgY29sb3IyLnYpO1xuICBjb25zdCBoc2wgPSByZ2JUb0hzbChyZ2IuciwgcmdiLmcsIHJnYi5iKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5oc2wsXG4gICAgLi4ucmdiLFxuICAgIGZvcm1hdDogQ29sb3JGb3JtYXQuUkdCLFxuICAgIGE6IGNvbG9yMi5hICE9PSB2b2lkIDAgPyBjb3JyZWN0QWxwaGEoY29sb3IyLmEpIDogMVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q29tcGxldGVDb2xvckZyb21SR0IoY29sb3IyKSB7XG4gIGNvbnN0IHJnYiA9IHJnYlRvUmdiKGNvbG9yMi5yLCBjb2xvcjIuZywgY29sb3IyLmIpO1xuICBjb25zdCBoc2wgPSByZ2JUb0hzbChyZ2IuciwgcmdiLmcsIHJnYi5iKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5oc2wsXG4gICAgLi4ucmdiLFxuICAgIGZvcm1hdDogQ29sb3JGb3JtYXQuUkdCLFxuICAgIGE6IGNvbG9yMi5hICE9PSB2b2lkIDAgPyBjb3JyZWN0QWxwaGEoY29sb3IyLmEpIDogMVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q29tcGxldGVDb2xvckZyb21IU0woY29sb3IyKSB7XG4gIGxldCBoO1xuICBsZXQgcztcbiAgbGV0IGw7XG4gIGxldCByZ2IgPSB7IHI6IDAsIGc6IDAsIGI6IDAgfTtcbiAgbGV0IGhzbCA9IHsgaDogMCwgczogMCwgbDogMCB9O1xuICBoID0gaXNOdW1lcmljKGNvbG9yMi5oKSA/IGNvbG9yMi5oIDogMDtcbiAgaCA9IChoICsgMzYwKSAlIDM2MDtcbiAgcyA9IGlzTnVtZXJpYyhjb2xvcjIucykgPyBjb2xvcjIucyA6IDE7XG4gIGlmICh0eXBlb2YgY29sb3IyLnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICBzID0gbnVtYmVyRnJvbVN0cmluZyhjb2xvcjIucyk7XG4gIH1cbiAgbCA9IGlzTnVtZXJpYyhjb2xvcjIubCkgPyBjb2xvcjIubCA6IDAuNTtcbiAgaWYgKHR5cGVvZiBjb2xvcjIubCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGwgPSBudW1iZXJGcm9tU3RyaW5nKGNvbG9yMi5sKTtcbiAgfVxuICByZ2IgPSBoc2xUb1JnYihoLCBzLCBsKTtcbiAgaHNsID0ge1xuICAgIGgsXG4gICAgcyxcbiAgICBsXG4gIH07XG4gIHJldHVybiB7XG4gICAgLi4ucmdiLFxuICAgIC4uLmhzbCxcbiAgICBhOiBjb2xvcjIuYSA9PT0gdm9pZCAwID8gMSA6IGNvbG9yMi5hLFxuICAgIGZvcm1hdDogQ29sb3JGb3JtYXQuSFNMXG4gIH07XG59XG5mdW5jdGlvbiBjb3JyZWN0QWxwaGEoYWxwaGFWYWx1ZSkge1xuICBhbHBoYVZhbHVlID0gcGFyc2VGbG9hdChhbHBoYVZhbHVlKTtcbiAgaWYgKGFscGhhVmFsdWUgPCAwKSB7XG4gICAgYWxwaGFWYWx1ZSA9IDA7XG4gIH1cbiAgaWYgKGlzTmFOKGFscGhhVmFsdWUpIHx8IGFscGhhVmFsdWUgPiAxKSB7XG4gICAgYWxwaGFWYWx1ZSA9IDE7XG4gIH1cbiAgcmV0dXJuIGFscGhhVmFsdWU7XG59XG5cbi8vIHNyYy9yZW5kZXIvdHlwZXMvQ29sb3IvQ29udmVydENvbG9yLnRzXG52YXIgQ29udmVydENvbG9yO1xuKGZ1bmN0aW9uKENvbnZlcnRDb2xvcjIpIHtcbiAgZnVuY3Rpb24gaHVlUm90YXRlKGNvbG9yMiwgYW5nbGUpIHtcbiAgICByZXR1cm4gQ29sb3IudG9Ic2xTdHJpbmcoQ29sb3IuaHVlUm90YXRlKENvbG9yKGNvbG9yMiksIGFuZ2xlKSk7XG4gIH1cbiAgQ29udmVydENvbG9yMi5odWVSb3RhdGUgPSBodWVSb3RhdGU7XG4gIGZ1bmN0aW9uIHNldEFscGhhKGNvbG9yMiwgYWxwaGEyKSB7XG4gICAgcmV0dXJuIENvbG9yLnRvUmdiU3RyaW5nKENvbG9yLmFscGhhKENvbG9yKGNvbG9yMiksIGFscGhhMikpO1xuICB9XG4gIENvbnZlcnRDb2xvcjIuc2V0QWxwaGEgPSBzZXRBbHBoYTtcbiAgZnVuY3Rpb24gZ2V0QWxwaGEoY29sb3IyKSB7XG4gICAgY29uc3Qgb2JqID0gc3RyaW5nVG9PYmplY3QoY29sb3IyKTtcbiAgICByZXR1cm4gb2JqID8gb2JqLmEgOiAxO1xuICB9XG4gIENvbnZlcnRDb2xvcjIuZ2V0QWxwaGEgPSBnZXRBbHBoYTtcbiAgZnVuY3Rpb24gbXVsdGlwbHlBbHBoYShjb2xvcjIsIGFscGhhMikge1xuICAgIHJldHVybiBDb2xvci50b1JnYlN0cmluZyhDb2xvci5tdWx0aXBseUFscGhhKENvbG9yKGNvbG9yMiksIGFscGhhMikpO1xuICB9XG4gIENvbnZlcnRDb2xvcjIubXVsdGlwbHlBbHBoYSA9IG11bHRpcGx5QWxwaGE7XG4gIGZ1bmN0aW9uIHRvSGV4KGNvbG9yMikge1xuICAgIHJldHVybiBDb2xvci50b0hleFN0cmluZyhDb2xvcihjb2xvcjIpKS50b1VwcGVyQ2FzZSgpO1xuICB9XG4gIENvbnZlcnRDb2xvcjIudG9IZXggPSB0b0hleDtcbiAgZnVuY3Rpb24gdG9SZ2IoY29sb3IyKSB7XG4gICAgcmV0dXJuIENvbG9yLnRvUmdiKENvbG9yKGNvbG9yMikpO1xuICB9XG4gIENvbnZlcnRDb2xvcjIudG9SZ2IgPSB0b1JnYjtcbiAgZnVuY3Rpb24gdG9SZ2JTdHJpbmcoY29sb3IyKSB7XG4gICAgcmV0dXJuIENvbG9yLnRvUmdiU3RyaW5nKENvbG9yKGNvbG9yMikpO1xuICB9XG4gIENvbnZlcnRDb2xvcjIudG9SZ2JTdHJpbmcgPSB0b1JnYlN0cmluZztcbiAgZnVuY3Rpb24gdG9IU1YoY29sb3IyKSB7XG4gICAgcmV0dXJuIENvbG9yLnRvSHN2KENvbG9yKGNvbG9yMikpO1xuICB9XG4gIENvbnZlcnRDb2xvcjIudG9IU1YgPSB0b0hTVjtcbiAgZnVuY3Rpb24gdG9IU0woY29sb3IyKSB7XG4gICAgcmV0dXJuIENvbG9yLnRvSHNsKENvbG9yKGNvbG9yMikpO1xuICB9XG4gIENvbnZlcnRDb2xvcjIudG9IU0wgPSB0b0hTTDtcbiAgZnVuY3Rpb24gdG9Ic2xTdHJpbmcoY29sb3IyKSB7XG4gICAgcmV0dXJuIENvbG9yLnRvSHNsU3RyaW5nKENvbG9yKGNvbG9yMikpO1xuICB9XG4gIENvbnZlcnRDb2xvcjIudG9Ic2xTdHJpbmcgPSB0b0hzbFN0cmluZztcbiAgZnVuY3Rpb24gdG9Ic3ZTdHJpbmcoY29sb3IyKSB7XG4gICAgcmV0dXJuIENvbG9yLnRvSHN2U3RyaW5nKENvbG9yKGNvbG9yMikpO1xuICB9XG4gIENvbnZlcnRDb2xvcjIudG9Ic3ZTdHJpbmcgPSB0b0hzdlN0cmluZztcbiAgZnVuY3Rpb24gaHN2VG9IU0xTdHJpbmcoaHN2KSB7XG4gICAgcmV0dXJuIENvbG9yLnRvSHNsU3RyaW5nKENvbG9yKGhzdlRvU3RyKGhzdi5oLCBoc3YucywgaHN2LnYsIGhzdi5hKSkpO1xuICB9XG4gIENvbnZlcnRDb2xvcjIuaHN2VG9IU0xTdHJpbmcgPSBoc3ZUb0hTTFN0cmluZztcbiAgZnVuY3Rpb24gaHN2VG9TdHJpbmcoaHN2KSB7XG4gICAgcmV0dXJuIGhzdlRvU3RyKGhzdi5oLCBoc3YucywgaHN2LnYpO1xuICB9XG4gIENvbnZlcnRDb2xvcjIuaHN2VG9TdHJpbmcgPSBoc3ZUb1N0cmluZztcbiAgZnVuY3Rpb24gcmdiYVRvU3RyaW5nKGNvbG9yMikge1xuICAgIHJldHVybiBDb2xvci50b1JnYlN0cmluZyhDb2xvcihjb2xvcjIpKTtcbiAgfVxuICBDb252ZXJ0Q29sb3IyLnJnYmFUb1N0cmluZyA9IHJnYmFUb1N0cmluZztcbiAgZnVuY3Rpb24gaHNsVG9TdHJpbmcoaHNsKSB7XG4gICAgcmV0dXJuIENvbG9yLnRvUmdiU3RyaW5nKENvbG9yKGhzbCkpO1xuICB9XG4gIENvbnZlcnRDb2xvcjIuaHNsVG9TdHJpbmcgPSBoc2xUb1N0cmluZztcbiAgZnVuY3Rpb24gdG9Db2xvclBpY2tlclNxdWFyZShoKSB7XG4gICAgcmV0dXJuIENvbG9yLnRvUmdiU3RyaW5nKENvbG9yKHsgaCwgczogMSwgbDogMC41LCBhOiAxIH0pKTtcbiAgfVxuICBDb252ZXJ0Q29sb3IyLnRvQ29sb3JQaWNrZXJTcXVhcmUgPSB0b0NvbG9yUGlja2VyU3F1YXJlO1xuICBmdW5jdGlvbiBpc1ZhbGlkKGNvbG9yMikge1xuICAgIHJldHVybiBDb2xvcihjb2xvcjIpLmlzVmFsaWQgIT09IGZhbHNlO1xuICB9XG4gIENvbnZlcnRDb2xvcjIuaXNWYWxpZCA9IGlzVmFsaWQ7XG4gIGZ1bmN0aW9uIGVxdWFscyhhMiwgYjIpIHtcbiAgICBpZiAodHlwZW9mIGEyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBhMiA9IENvbG9yKGEyKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBiMiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgYjIgPSBDb2xvcihiMik7XG4gICAgfVxuICAgIHJldHVybiBDb2xvci5lcXVhbChhMiwgYjIpO1xuICB9XG4gIENvbnZlcnRDb2xvcjIuZXF1YWxzID0gZXF1YWxzO1xuICBmdW5jdGlvbiB0b0hleE9yUmdiYVN0cmluZyhpbnB1dCkge1xuICAgIGNvbnN0IGNvbG9yMiA9IENvbG9yKGlucHV0KTtcbiAgICByZXR1cm4gY29sb3IyLmEgIT09IDEgPyBDb2xvci50b1JnYlN0cmluZyhjb2xvcjIpIDogQ29sb3IudG9IZXhTdHJpbmcoY29sb3IyKTtcbiAgfVxuICBDb252ZXJ0Q29sb3IyLnRvSGV4T3JSZ2JhU3RyaW5nID0gdG9IZXhPclJnYmFTdHJpbmc7XG59KShDb252ZXJ0Q29sb3IgfHwgKENvbnZlcnRDb2xvciA9IHt9KSk7XG5cbi8vIHNyYy9yZW5kZXIvdXRpbHMvdHJhbnNmb3JtQ3VzdG9tVmFsdWVzLnRzXG52YXIgaXNDdXN0b21WYWx1ZTIgPSAodikgPT4ge1xuICByZXR1cm4gQm9vbGVhbih2ICYmIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYubWl4ICYmIHYudG9WYWx1ZSk7XG59O1xudmFyIGlzQ29sb3JQcm9wID0gKGtleTYpID0+IGtleTYgPT09IFwiYmFja2dyb3VuZFwiIHx8IGtleTYuZW5kc1dpdGgoXCJjb2xvclwiKSB8fCBrZXk2LmVuZHNXaXRoKFwiQ29sb3JcIik7XG52YXIgcmVzb2x2ZVNpbmdsZUN1c3RvbVZhbHVlID0gKGtleTYsIHYpID0+IHtcbiAgaWYgKHYgJiYgdHlwZW9mIHYgPT09IFwib2JqZWN0XCIpIHtcbiAgICBpbnZhcmlhbnQoaXNDdXN0b21WYWx1ZTIodiksIFwiTW90aW9uIHN0eWxlcyBtdXN0IGJlIG51bWJlcnMsIHN0cmluZ3MsIG9yIGFuIGluc3RhbmNlIHdpdGggYSBgdG9WYWx1ZWAgYW5kIGBtaXhgIG1ldGhvZHMuXCIpO1xuICAgIHJldHVybiB2LnRvVmFsdWUoKTtcbiAgfSBlbHNlIGlmIChpc0NvbG9yUHJvcChrZXk2KSAmJiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiAmJiBDb2xvci5pc0NvbG9yKHYpKSB7XG4gICAgcmV0dXJuIENvbG9yKHYpLnRvVmFsdWUoKTtcbiAgfVxuICByZXR1cm4gdjtcbn07XG52YXIgcmVzb2x2ZUN1c3RvbVZhbHVlcyA9IChrZXk2LCB2KSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgY29uc3QgbnVtVmFsdWVzID0gdi5sZW5ndGg7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZhbHVlczsgaSsrKSB7XG4gICAgICByZXNvbHZlZC5wdXNoKHJlc29sdmVTaW5nbGVDdXN0b21WYWx1ZShrZXk2LCB2W2ldKSk7XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzb2x2ZVNpbmdsZUN1c3RvbVZhbHVlKGtleTYsIHYpO1xuICB9XG59O1xudmFyIGN1c3RvbVZhbHVlSGFuZGxlcnMgPSB7XG4gIHNpemU6IHtcbiAgICBzZXQ6IChpbnB1dFZhbHVlcywgb3V0cHV0VmFsdWVzLCB2YWx1ZSkgPT4ge1xuICAgICAgaWYgKGlucHV0VmFsdWVzLmhlaWdodCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG91dHB1dFZhbHVlcy5oZWlnaHQgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnB1dFZhbHVlcy53aWR0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG91dHB1dFZhbHVlcy53aWR0aCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgdHlwZTogcHhcbiAgfSxcbiAgcmFkaXVzOiB7XG4gICAgc2V0OiAoaW5wdXRWYWx1ZXMsIG91dHB1dFZhbHVlcywgdmFsdWUpID0+IHtcbiAgICAgIG91dHB1dFZhbHVlcy5ib3JkZXJSYWRpdXMgPSB2YWx1ZTtcbiAgICB9LFxuICAgIHR5cGU6IHB4XG4gIH0sXG4gIHNoYWRvdzoge1xuICAgIHNldDogKGlucHV0VmFsdWVzLCBvdXRwdXRWYWx1ZXMsIHZhbHVlKSA9PiB7XG4gICAgICBvdXRwdXRWYWx1ZXMuYm94U2hhZG93ID0gdmFsdWU7XG4gICAgfSxcbiAgICB0eXBlOiBjb21wbGV4XG4gIH1cbn07XG52YXIgdHJhbnNmb3JtVmFsdWVzID0gKHZhbHVlcykgPT4ge1xuICBjb25zdCB0cmFuc2Zvcm1lZFZhbHVlcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleTYgaW4gdmFsdWVzKSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlQ3VzdG9tVmFsdWVzKGtleTYsIHZhbHVlc1trZXk2XSk7XG4gICAgY29uc3QgdmFsdWVIYW5kbGVyID0gY3VzdG9tVmFsdWVIYW5kbGVyc1trZXk2XTtcbiAgICBpZiAodmFsdWVIYW5kbGVyKSB7XG4gICAgICBjb25zdCBpc0RlZmF1bHRUeXBlID0gdmFsdWVIYW5kbGVyLnR5cGUgJiYgdHlwZW9mIHZhbHVlc1trZXk2XSA9PT0gXCJudW1iZXJcIjtcbiAgICAgIGNvbnN0IHZhbHVlID0gaXNEZWZhdWx0VHlwZSA/IHZhbHVlSGFuZGxlci50eXBlLnRyYW5zZm9ybSh2YWx1ZXNba2V5Nl0pIDogdmFsdWVzW2tleTZdO1xuICAgICAgdmFsdWVIYW5kbGVyLnNldCh2YWx1ZXMsIHRyYW5zZm9ybWVkVmFsdWVzLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zZm9ybWVkVmFsdWVzW2tleTZdID0gcmVzb2x2ZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFuc2Zvcm1lZFZhbHVlcztcbn07XG5cbi8vIHNyYy9yZW5kZXIvcHJlc2VudGF0aW9uL0xheWVyLnRzeFxuaW1wb3J0IHtcbiAgQ29tcG9uZW50IGFzIENvbXBvbmVudDNcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9yZW5kZXIvdXRpbHMvaXNFcXVhbC50c1xudmFyIGlzQXJyYXkyID0gQXJyYXkuaXNBcnJheTtcbnZhciBrZXlMaXN0ID0gT2JqZWN0LmtleXM7XG52YXIgaGFzUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBlcXVhbChhMiwgYjIsIGRlZXApIHtcbiAgaWYgKGEyID09PSBiMilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKGEyICYmIGIyICYmIHR5cGVvZiBhMiA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgYjIgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCBhcnJBID0gaXNBcnJheTIoYTIpO1xuICAgIGNvbnN0IGFyckIgPSBpc0FycmF5MihiMik7XG4gICAgbGV0IGksIGxlbmd0aCwga2V5NjtcbiAgICBpZiAoYXJyQSAmJiBhcnJCKSB7XG4gICAgICBsZW5ndGggPSBhMi5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiMi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOyApIHtcbiAgICAgICAgaWYgKCFkZWVwICYmIGEyW2ldICE9PSBiMltpXSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkZWVwICYmICFlcXVhbChhMltpXSwgYjJbaV0sIHRydWUpKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoYXJyQSAhPT0gYXJyQilcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBkYXRlQSA9IGEyIGluc3RhbmNlb2YgRGF0ZTtcbiAgICBjb25zdCBkYXRlQiA9IGIyIGluc3RhbmNlb2YgRGF0ZTtcbiAgICBpZiAoZGF0ZUEgIT09IGRhdGVCKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkYXRlQSAmJiBkYXRlQilcbiAgICAgIHJldHVybiBhMi5nZXRUaW1lKCkgPT09IGIyLmdldFRpbWUoKTtcbiAgICBjb25zdCByZWdleHBBID0gYTIgaW5zdGFuY2VvZiBSZWdFeHA7XG4gICAgY29uc3QgcmVnZXhwQiA9IGIyIGluc3RhbmNlb2YgUmVnRXhwO1xuICAgIGlmIChyZWdleHBBICE9PSByZWdleHBCKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChyZWdleHBBICYmIHJlZ2V4cEIpXG4gICAgICByZXR1cm4gYTIudG9TdHJpbmcoKSA9PT0gYjIudG9TdHJpbmcoKTtcbiAgICBpZiAodHlwZW9mIGEyLmVxdWFscyA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBiMi5lcXVhbHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGEyLmVxdWFscyhiMik7XG4gICAgfVxuICAgIGNvbnN0IGtleXMyID0ga2V5TGlzdChhMik7XG4gICAgbGVuZ3RoID0ga2V5czIubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IGtleUxpc3QoYjIpLmxlbmd0aClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDsgKSB7XG4gICAgICBpZiAoIWhhc1Byb3AuY2FsbChiMiwga2V5czJbaV0pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOyApIHtcbiAgICAgIGtleTYgPSBrZXlzMltpXTtcbiAgICAgIGlmIChrZXk2ID09PSBcIl9vd25lclwiICYmIGEyLiQkdHlwZW9mKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFkZWVwICYmIGEyW2tleTZdICE9PSBiMltrZXk2XSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGRlZXAgJiYgIWVxdWFsKGEyW2tleTZdLCBiMltrZXk2XSwgdHJ1ZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGEyICE9PSBhMiAmJiBiMiAhPT0gYjI7XG59XG5mdW5jdGlvbiBpc0VxdWFsKGEyLCBiMiwgZGVlcCA9IHRydWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZXF1YWwoYTIsIGIyLCBkZWVwKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IubWVzc2FnZSAmJiBlcnJvci5tZXNzYWdlLm1hdGNoKC9zdGFja3xyZWN1cnNpb24vaSkgfHwgZXJyb3IubnVtYmVyID09PSAtMjE0NjgyODI2MCkge1xuICAgICAgY29uc29sZS53YXJuKFwiV2FybmluZzogaXNFcXVhbCBkb2VzIG5vdCBoYW5kbGUgY2lyY3VsYXIgcmVmZXJlbmNlcy5cIiwgZXJyb3IubmFtZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8vIHNyYy9yZW5kZXIvdXRpbHMvdXNlV2Via2l0Rml4ZXMudHNcbmltcG9ydCB7IHVzZVJlZiBhcyB1c2VSZWYxMCwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDE2IH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiByZXNldFNldFN0eWxlKGVsZW1lbnQsIGtleTYsIHRvVmFsdWUsIG1pY3JvdGFzayA9IHRydWUpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHZhbHVlID0gdG9WYWx1ZSA/IHRvVmFsdWUgOiBlbGVtZW50LnN0eWxlW2tleTZdO1xuICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICBlbGVtZW50LnN0eWxlW2tleTZdID0gdmFsdWU7XG4gIH07XG4gIGVsZW1lbnQuc3R5bGVba2V5Nl0gPSBudWxsO1xuICBpZiAobWljcm90YXNrKSB7XG4gICAgdm9pZCBQcm9taXNlLnJlc29sdmUoKS50aGVuKHJlc2V0KTtcbiAgfSBlbHNlIHtcbiAgICBzZXRUaW1lb3V0KHJlc2V0LCAwKTtcbiAgfVxufVxuXG4vLyBzcmMvcmVuZGVyL3V0aWxzL29wdGlvbmFsUmVhY3RET00udHNcbmZ1bmN0aW9uIG9wdGlvbmFsUmVhY3RET00oKSB7XG4gIGlmICh0eXBlb2Ygc2FmZVdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzYWZlV2luZG93W1wiUmVhY3RET01cIl0pIHtcbiAgICByZXR1cm4gc2FmZVdpbmRvd1tcIlJlYWN0RE9NXCJdO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIHNyYy9yZW5kZXIvdXRpbHMvZWxlbWVudEZvckNvbXBvbmVudC50c1xuZnVuY3Rpb24gZWxlbWVudEZvckNvbXBvbmVudChjb21wb25lbnQpIHtcbiAgY29uc3QgUmVhY3RET00gPSBvcHRpb25hbFJlYWN0RE9NKCk7XG4gIGlmICghUmVhY3RET00pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBlbGVtZW50ID0gUmVhY3RET00uZmluZERPTU5vZGUoY29tcG9uZW50KTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8vIHNyYy91dGlscy9lbnZpcm9ubWVudC50c1xudmFyIGVudmlyb25tZW50X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGVudmlyb25tZW50X2V4cG9ydHMsIHtcbiAgZGV2aWNlRm9udDogKCkgPT4gZGV2aWNlRm9udCxcbiAgZGV2aWNlT1M6ICgpID0+IGRldmljZU9TLFxuICBkZXZpY2VQaXhlbFJhdGlvOiAoKSA9PiBkZXZpY2VQaXhlbFJhdGlvMixcbiAgZGV2aWNlVHlwZTogKCkgPT4gZGV2aWNlVHlwZSxcbiAgZW52aXJvbm1lbnQ6ICgpID0+IGVudmlyb25tZW50LFxuICBpc0FuZHJvaWQ6ICgpID0+IGlzQW5kcm9pZCxcbiAgaXNCcm93c2VyOiAoKSA9PiBpc0Jyb3dzZXIyLFxuICBpc0Nocm9tZTogKCkgPT4gaXNDaHJvbWUsXG4gIGlzRGF0YVVybDogKCkgPT4gaXNEYXRhVXJsLFxuICBpc0Rlc2t0b3A6ICgpID0+IGlzRGVza3RvcCxcbiAgaXNFZGdlOiAoKSA9PiBpc0VkZ2UsXG4gIGlzRmlsZVVybDogKCkgPT4gaXNGaWxlVXJsLFxuICBpc0ZpcmVmb3g6ICgpID0+IGlzRmlyZWZveCxcbiAgaXNGcmFtZXJYOiAoKSA9PiBpc0ZyYW1lclgsXG4gIGlzSU9TOiAoKSA9PiBpc0lPUyxcbiAgaXNKUDJTdXBwb3J0ZWQ6ICgpID0+IGlzSlAyU3VwcG9ydGVkLFxuICBpc0xvY2FsQXNzZXRVcmw6ICgpID0+IGlzTG9jYWxBc3NldFVybCxcbiAgaXNMb2NhbFNlcnZlclVybDogKCkgPT4gaXNMb2NhbFNlcnZlclVybCxcbiAgaXNMb2NhbFVybDogKCkgPT4gaXNMb2NhbFVybCxcbiAgaXNNYWNPUzogKCkgPT4gaXNNYWNPUyxcbiAgaXNNb2JpbGU6ICgpID0+IGlzTW9iaWxlLFxuICBpc1Bob25lOiAoKSA9PiBpc1Bob25lLFxuICBpc1JlbGF0aXZlVXJsOiAoKSA9PiBpc1JlbGF0aXZlVXJsLFxuICBpc1NhZmFyaTogKCkgPT4gaXNTYWZhcmksXG4gIGlzVGFibGV0OiAoKSA9PiBpc1RhYmxldCxcbiAgaXNUZXN0OiAoKSA9PiBpc1Rlc3QsXG4gIGlzVG91Y2g6ICgpID0+IGlzVG91Y2gsXG4gIGlzV2ViS2l0OiAoKSA9PiBpc1dlYktpdCxcbiAgaXNXZWJQU3VwcG9ydGVkOiAoKSA9PiBpc1dlYlBTdXBwb3J0ZWQsXG4gIGlzV2luZG93czogKCkgPT4gaXNXaW5kb3dzLFxuICB3ZWJraXRWZXJzaW9uOiAoKSA9PiB3ZWJraXRWZXJzaW9uXG59KTtcbnZhciBpc0Jyb3dzZXIyID0gKCkgPT4gdHlwZW9mIGRvY3VtZW50ID09PSBcIm9iamVjdFwiO1xudmFyIGlzV2ViS2l0ID0gKCkgPT4gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcIkFwcGxlV2ViS2l0L1wiKSAmJiAhaXNDaHJvbWUoKSAmJiAhaXNFZGdlKCk7XG52YXIgd2Via2l0VmVyc2lvbiA9ICgpID0+IHtcbiAgbGV0IHZlcnNpb24yID0gLTE7XG4gIGNvbnN0IHJlZ2V4cCA9IC9BcHBsZVdlYktpdFxcLyhbXFxkLl0rKS87XG4gIGNvbnN0IHJlc3VsdCA9IHJlZ2V4cC5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICBpZiAocmVzdWx0KSB7XG4gICAgdmVyc2lvbjIgPSBwYXJzZUZsb2F0KHJlc3VsdFsxXSk7XG4gIH1cbiAgcmV0dXJuIHZlcnNpb24yO1xufTtcbnZhciBpc0Nocm9tZSA9ICgpID0+IC9DaHJvbWUvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgL0dvb2dsZSBJbmMvLnRlc3QobmF2aWdhdG9yLnZlbmRvcikgJiYgIWlzRWRnZSgpO1xudmFyIGlzU2FmYXJpID0gKCkgPT4gL1NhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAvQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2aWdhdG9yLnZlbmRvcik7XG52YXIgaXNGaXJlZm94ID0gKCkgPT4gL0ZpcmVmb3hcXC9cXGQrXFwuXFxkKyQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgaXNGcmFtZXJYID0gKCkgPT4gL0ZyYW1lclgvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgaXNFZGdlID0gKCkgPT4gL0VkZ1xcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBpc0FuZHJvaWQgPSAoKSA9PiAvKGFuZHJvaWQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBpc0lPUyA9ICgpID0+IC8oaVBob25lfGlQb2R8aVBhZCkvaS50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG52YXIgaXNNYWNPUyA9ICgpID0+IC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbnZhciBpc1dpbmRvd3MgPSAoKSA9PiAvV2luLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG52YXIgaXNUb3VjaCA9ICgpID0+IHNhZmVXaW5kb3cub250b3VjaHN0YXJ0ID09PSBudWxsICYmIHNhZmVXaW5kb3cub250b3VjaG1vdmUgPT09IG51bGwgJiYgc2FmZVdpbmRvdy5vbnRvdWNoZW5kID09PSBudWxsO1xudmFyIGlzRGVza3RvcCA9ICgpID0+IGRldmljZVR5cGUoKSA9PT0gXCJkZXNrdG9wXCI7XG52YXIgaXNQaG9uZSA9ICgpID0+IGRldmljZVR5cGUoKSA9PT0gXCJwaG9uZVwiO1xudmFyIGlzVGFibGV0ID0gKCkgPT4gZGV2aWNlVHlwZSgpID09PSBcInRhYmxldFwiO1xudmFyIGlzTW9iaWxlID0gKCkgPT4gaXNQaG9uZSgpIHx8IGlzVGFibGV0KCk7XG52YXIgaXNGaWxlVXJsID0gKHVybCkgPT4gdXJsLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpO1xudmFyIGlzRGF0YVVybCA9ICh1cmwpID0+IHVybC5zdGFydHNXaXRoKFwiZGF0YTpcIik7XG52YXIgaXNUZXN0ID0gKCkgPT4gZmFsc2U7XG52YXIgaXNSZWxhdGl2ZVVybCA9ICh1cmwpID0+ICEvXihbYS16QS1aXXsxLDh9OlxcL1xcLykuKiQvLnRlc3QodXJsKTtcbnZhciBpc0xvY2FsU2VydmVyVXJsID0gKHVybCkgPT4gL1thLXpBLVpdezEsOH06XFwvXFwvMTI3XFwuMFxcLjBcXC4xLy50ZXN0KHVybCkgfHwgL1thLXpBLVpdezEsOH06XFwvXFwvbG9jYWxob3N0Ly50ZXN0KHVybCk7XG52YXIgaXNMb2NhbFVybCA9ICh1cmwpID0+IHtcbiAgaWYgKGlzRmlsZVVybCh1cmwpKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAoaXNMb2NhbFNlcnZlclVybCh1cmwpKVxuICAgIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIGlzTG9jYWxBc3NldFVybCA9ICh1cmwsIGJhc2VVcmwpID0+IHtcbiAgaWYgKGJhc2VVcmwgPT09IG51bGwpXG4gICAgYmFzZVVybCA9IHNhZmVXaW5kb3cubG9jYXRpb24uaHJlZjtcbiAgaWYgKGlzRGF0YVVybCh1cmwpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGlzTG9jYWxVcmwodXJsKSlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKGlzUmVsYXRpdmVVcmwodXJsKSAmJiBpc0xvY2FsVXJsKGJhc2VVcmwpKVxuICAgIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIGRldmljZVBpeGVsUmF0aW8yID0gKCkgPT4gc2FmZVdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xudmFyIGlzSlAyU3VwcG9ydGVkID0gZnVuY3Rpb24oKSB7XG4gIGlmIChpc0ZpcmVmb3goKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBpc1dlYktpdCgpO1xufTtcbnZhciBpc1dlYlBTdXBwb3J0ZWQgPSAoKSA9PiBpc0Nocm9tZSgpO1xudmFyIGRldmljZVR5cGUgPSAoKSA9PiB7XG4gIGlmICgvKHRhYmxldCl8KGlQYWQpfChOZXh1cyA5KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpXG4gICAgcmV0dXJuIFwidGFibGV0XCI7XG4gIGlmICgvKG1vYmkpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSlcbiAgICByZXR1cm4gXCJwaG9uZVwiO1xuICByZXR1cm4gXCJkZXNrdG9wXCI7XG59O1xudmFyIGRldmljZU9TID0gKCkgPT4ge1xuICBpZiAoaXNNYWNPUygpKVxuICAgIHJldHVybiBcIm1hY29zXCI7XG4gIGlmIChpc0lPUygpKVxuICAgIHJldHVybiBcImlvc1wiO1xuICBpZiAoaXNBbmRyb2lkKCkpXG4gICAgcmV0dXJuIFwiYW5kcm9pZFwiO1xuICBpZiAoaXNXaW5kb3dzKCkpXG4gICAgcmV0dXJuIFwid2luZG93c1wiO1xufTtcbnZhciBkZXZpY2VGb250ID0gKG9zKSA9PiB7XG4gIGlmICghb3MpIHtcbiAgICBvcyA9IGRldmljZU9TKCk7XG4gIH1cbiAgY29uc3QgZm9udHMgPSB7XG4gICAgYXBwbGU6IFwiLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBTRiBQcm8gVGV4dCwgU0YgVUkgVGV4dCwgSGVsdmV0aWNhIE5ldWVcIixcbiAgICBnb29nbGU6IFwiUm9ib3RvLCBIZWx2ZXRpY2EgTmV1ZVwiLFxuICAgIG1pY3Jvc29mdDogXCJTZWdvZSBVSSwgSGVsdmV0aWNhIE5ldWVcIlxuICB9O1xuICBpZiAob3MgPT09IFwibWFjb3NcIilcbiAgICByZXR1cm4gZm9udHMuYXBwbGU7XG4gIGlmIChvcyA9PT0gXCJpb3NcIilcbiAgICByZXR1cm4gZm9udHMuYXBwbGU7XG4gIGlmIChvcyA9PT0gXCJhbmRyb2lkXCIpXG4gICAgcmV0dXJuIGZvbnRzLmdvb2dsZTtcbiAgaWYgKG9zID09PSBcIndpbmRvd3NcIilcbiAgICByZXR1cm4gZm9udHMubWljcm9zb2Z0O1xuICByZXR1cm4gZm9udHMuYXBwbGU7XG59O1xudmFyIGVudmlyb25tZW50ID0ge1xuICBpc1dlYktpdCxcbiAgd2Via2l0VmVyc2lvbixcbiAgaXNDaHJvbWUsXG4gIGlzU2FmYXJpLFxuICBpc0ZpcmVmb3gsXG4gIGlzRnJhbWVyWCxcbiAgaXNFZGdlLFxuICBpc0FuZHJvaWQsXG4gIGlzSU9TLFxuICBpc01hY09TLFxuICBpc1dpbmRvd3MsXG4gIGlzVG91Y2gsXG4gIGlzRGVza3RvcCxcbiAgaXNQaG9uZSxcbiAgaXNUYWJsZXQsXG4gIGlzTW9iaWxlLFxuICBpc0ZpbGVVcmwsXG4gIGlzRGF0YVVybCxcbiAgaXNSZWxhdGl2ZVVybCxcbiAgaXNMb2NhbFNlcnZlclVybCxcbiAgaXNMb2NhbFVybCxcbiAgaXNMb2NhbEFzc2V0VXJsLFxuICBkZXZpY2VQaXhlbFJhdGlvOiBkZXZpY2VQaXhlbFJhdGlvMixcbiAgaXNKUDJTdXBwb3J0ZWQsXG4gIGlzV2ViUFN1cHBvcnRlZCxcbiAgZGV2aWNlVHlwZSxcbiAgZGV2aWNlT1MsXG4gIGRldmljZUZvbnRcbn07XG5cbi8vIHNyYy9yZW5kZXIvdXRpbHMvc2V0TGF5ZXJCYWNrZWQudHNcbnZhciBzbWFsbFZhbHVlID0gXCIwLjAwMDAwMXB4XCI7XG52YXIgdHJhbnNsYXRlWiA9IGAgdHJhbnNsYXRlWigke3NtYWxsVmFsdWV9KWA7XG52YXIgdXNlVHJhbnNsYXRlWkhhY2sgPSBpc0ZyYW1lclgoKSB8fCBpc1NhZmFyaSgpIHx8IGlzVGVzdCgpO1xuZnVuY3Rpb24gZm9yY2VMYXllckJhY2tpbmdXaXRoTW90aW9uU3R5bGUobW90aW9uU3R5bGUpIHtcbiAgbW90aW9uU3R5bGUud2lsbENoYW5nZSA9IFwidHJhbnNmb3JtXCI7XG4gIGNvbnN0IG9uQ2FudmFzID0gUmVuZGVyVGFyZ2V0LmN1cnJlbnQoKSA9PT0gUmVuZGVyVGFyZ2V0LmNhbnZhcztcbiAgaWYgKHVzZVRyYW5zbGF0ZVpIYWNrICYmIG9uQ2FudmFzKSB7XG4gICAgbW90aW9uU3R5bGUudHJhbnNsYXRlWiA9IHNtYWxsVmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGZvcmNlTGF5ZXJCYWNraW5nV2l0aENTU1Byb3BlcnRpZXMoY3NzUHJvcGVydGllcykge1xuICBjc3NQcm9wZXJ0aWVzLndpbGxDaGFuZ2UgPSBcInRyYW5zZm9ybVwiO1xuICBzZXRUcmFuc2xhdGVaSGFjayhjc3NQcm9wZXJ0aWVzLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIHNldFRyYW5zbGF0ZVpIYWNrKHN0eWxlLCBlbmFibGVkKSB7XG4gIGNvbnN0IG9uQ2FudmFzID0gUmVuZGVyVGFyZ2V0LmN1cnJlbnQoKSA9PT0gUmVuZGVyVGFyZ2V0LmNhbnZhcztcbiAgaWYgKCF1c2VUcmFuc2xhdGVaSGFjayB8fCAhb25DYW52YXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdHJhbnNmb3JtMiA9IHN0eWxlLnRyYW5zZm9ybSB8fCBcIlwiO1xuICBpZiAoZW5hYmxlZCkge1xuICAgIGNvbnN0IGhhc1RyYW5zbGF0ZVogPSB0cmFuc2Zvcm0yLmluY2x1ZGVzKHRyYW5zbGF0ZVopO1xuICAgIGlmICghaGFzVHJhbnNsYXRlWikge1xuICAgICAgc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtMiArIHRyYW5zbGF0ZVo7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTIucmVwbGFjZSh0cmFuc2xhdGVaLCBcIlwiKTtcbiAgfVxufVxuXG4vLyBzcmMvcmVuZGVyL3ByZXNlbnRhdGlvbi9MYXllci50c3hcbnZhciBMYXllciA9IGNsYXNzIGV4dGVuZHMgQ29tcG9uZW50MyB7XG4gIHN0YXRpYyBhcHBseVdpbGxDaGFuZ2UocHJvcHMsIHN0eWxlLCB1c2luZ01vdGlvblN0eWxlKSB7XG4gICAgaWYgKHByb3BzLndpbGxDaGFuZ2VUcmFuc2Zvcm0pIHtcbiAgICAgIGlmICh1c2luZ01vdGlvblN0eWxlKSB7XG4gICAgICAgIGZvcmNlTGF5ZXJCYWNraW5nV2l0aE1vdGlvblN0eWxlKHN0eWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcmNlTGF5ZXJCYWNraW5nV2l0aENTU1Byb3BlcnRpZXMoc3R5bGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICByZXR1cm4gbmV4dFByb3BzLl9uZWVkc01lYXN1cmUgfHwgdGhpcy5zdGF0ZSAhPT0gbmV4dFN0YXRlIHx8ICFpc0VxdWFsKHRoaXMucHJvcHMsIG5leHRQcm9wcyk7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50Rm9yQ29tcG9uZW50KHRoaXMpO1xuICAgIGlmICh0aGlzLnByb3BzW1wiY2xpcFwiXSAmJiB0aGlzLnByb3BzW1wicmFkaXVzXCJdID09PSAwICYmIHByZXZQcm9wc1tcInJhZGl1c1wiXSAhPT0gMCkge1xuICAgICAgcmVzZXRTZXRTdHlsZShlbGVtZW50LCBcIm92ZXJmbG93XCIsIFwiaGlkZGVuXCIsIGZhbHNlKTtcbiAgICB9XG4gIH1cbn07XG5MYXllci5kZWZhdWx0UHJvcHMgPSB7fTtcblxuLy8gc3JjL3JlbmRlci91dGlscy9leHRyYWN0U3R5bGVGcm9tUHJvcHMudHNcbmZ1bmN0aW9uIGV4dHJhY3RTdHlsZUZyb21Qcm9wcyhwcm9wcywgbmFtZSwgc3R5bGVSZWYsIGludG8pIHtcbiAgaWYgKGludG8gPT09IHZvaWQgMCkge1xuICAgIGludG8gPSBuYW1lO1xuICB9XG4gIGlmIChwcm9wc1tuYW1lXSAhPT0gdm9pZCAwKSB7XG4gICAgc3R5bGVSZWZbaW50b10gPSBwcm9wc1tuYW1lXTtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL3N0cmluZy50c1xudmFyIGhhc2ggPSAodmFsdWUpID0+IHtcbiAgbGV0IGhhc2hlciA9IDAsIGksIGNocjtcbiAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gaGFzaGVyO1xuICBmb3IgKGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICBjaHIgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2hlciA9IChoYXNoZXIgPDwgNSkgLSBoYXNoZXIgKyBjaHI7XG4gICAgaGFzaGVyIHw9IDA7XG4gIH1cbiAgcmV0dXJuIGhhc2hlcjtcbn07XG5cbi8vIHNyYy91dGlscy9tZW1vaXplLnRzXG5mdW5jdGlvbiBtYW5hZ2VDYWNoZShjYWNoZTQsIG1heEVudHJpZXMpIHtcbiAgY29uc3Qgc2l6ZTIgPSBjYWNoZTQuc2l6ZTtcbiAgaWYgKHNpemUyIDwgbWF4RW50cmllcylcbiAgICByZXR1cm47XG4gIGxldCBpID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpKTtcbiAgZm9yIChjb25zdCBrZXk2IG9mIGNhY2hlNC5rZXlzKCkpIHtcbiAgICBpZiAoKCsraSAmIDEpID09PSAxKVxuICAgICAgY29udGludWU7XG4gICAgY2FjaGU0LmRlbGV0ZShrZXk2KTtcbiAgfVxufVxuZnVuY3Rpb24gbWVtb2l6ZShtYXhFbnRyaWVzLCBjYWNoZTQsIGtleTYsIGNyZWF0ZSkge1xuICBjb25zdCByID0gY2FjaGU0LmdldChrZXk2KTtcbiAgaWYgKHIpXG4gICAgcmV0dXJuIHI7XG4gIG1hbmFnZUNhY2hlKGNhY2hlNCwgbWF4RW50cmllcyk7XG4gIGNvbnN0IGcgPSBjcmVhdGUoa2V5Nik7XG4gIGNhY2hlNC5zZXQoa2V5NiwgZyk7XG4gIHJldHVybiBnO1xufVxuXG4vLyBzcmMvcmVuZGVyL3V0aWxzL2dyYWRpZW50Q29sb3JTdG9wcy50c1xudmFyIENTU1ZhcmlhYmxlUmVnRXhwID0gL3ZhclxcKC4rXFwpLztcbnZhciBjb2xvckNhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gY2FjaGVkTXVsdGlwbHlBbHBoYShzLCBhMikge1xuICBjb25zdCBrZXk2ID0gW3MsIGEyXTtcbiAgaWYgKENTU1ZhcmlhYmxlUmVnRXhwLnRlc3QocykpIHtcbiAgICByZXR1cm4gcztcbiAgfVxuICByZXR1cm4gbWVtb2l6ZSgxZTMsIGNvbG9yQ2FjaGUsIGtleTYsICgpID0+IENvbnZlcnRDb2xvci5tdWx0aXBseUFscGhhKHMsIGEyKSk7XG59XG5mdW5jdGlvbiBncmFkaWVudENvbG9yU3RvcHMoZ3JhZGllbnQsIGFscGhhMiA9IDEpIHtcbiAgbGV0IHN0b3BzO1xuICBpZiAoXCJzdG9wc1wiIGluIGdyYWRpZW50KSB7XG4gICAgc3RvcHMgPSBncmFkaWVudC5zdG9wcztcbiAgfSBlbHNlIHtcbiAgICBzdG9wcyA9IFtcbiAgICAgIHsgdmFsdWU6IGdyYWRpZW50LnN0YXJ0LCBwb3NpdGlvbjogMCB9LFxuICAgICAgeyB2YWx1ZTogZ3JhZGllbnQuZW5kLCBwb3NpdGlvbjogMSB9XG4gICAgXTtcbiAgfVxuICBpZiAoYWxwaGEyID09PSAxKSB7XG4gICAgcmV0dXJuIHN0b3BzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdG9wcy5tYXAoKHN0b3ApID0+ICh7IC4uLnN0b3AsIHZhbHVlOiBjYWNoZWRNdWx0aXBseUFscGhhKHN0b3AudmFsdWUsIGFscGhhMikgfSkpO1xuICB9XG59XG5mdW5jdGlvbiBncmFkaWVudENvbG9yU3RvcHNIYXNoKGdyYWRpZW50LCBhbHBoYTIpIHtcbiAgbGV0IHJlc3VsdCA9IDA7XG4gIGdyYWRpZW50Q29sb3JTdG9wcyhncmFkaWVudCwgYWxwaGEyKS5mb3JFYWNoKChzdG9wKSA9PiB7XG4gICAgcmVzdWx0IF49IGhhc2goc3RvcC52YWx1ZSkgXiBzdG9wLnBvc2l0aW9uO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL3JlbmRlci90eXBlcy9TaW1wbGVHcmFkaWVudC50c1xudmFyIHNpbXBsZUdyYWRpZW50S2V5cyA9IFtcInN0YXJ0XCIsIFwiZW5kXCJdO1xuZnVuY3Rpb24gaXNTaW1wbGVHcmFkaWVudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgc2ltcGxlR3JhZGllbnRLZXlzLmV2ZXJ5KChrZXk2KSA9PiBrZXk2IGluIHZhbHVlKTtcbn1cblxuLy8gc3JjL3JlbmRlci90eXBlcy9NdWx0aVN0b3BHcmFkaWVudC50c1xudmFyIG11bHRpU3RvcEdyYWRpZW50S2V5cyA9IFtcInN0b3BzXCJdO1xuZnVuY3Rpb24gaXNNdWx0aVN0b3BHcmFkaWVudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgbXVsdGlTdG9wR3JhZGllbnRLZXlzLmV2ZXJ5KChrZXk2KSA9PiBrZXk2IGluIHZhbHVlKTtcbn1cblxuLy8gc3JjL3JlbmRlci90eXBlcy9MaW5lYXJHcmFkaWVudC50c1xudmFyIGxpbmVhckdyYWRpZW50S2V5cyA9IFtcImFuZ2xlXCIsIFwiYWxwaGFcIl07XG52YXIgTGluZWFyR3JhZGllbnQ7XG4oZnVuY3Rpb24oTGluZWFyR3JhZGllbnQyKSB7XG4gIGZ1bmN0aW9uIGlzTGluZWFyR3JhZGllbnQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgbGluZWFyR3JhZGllbnRLZXlzLmV2ZXJ5KChrZXk2KSA9PiBrZXk2IGluIHZhbHVlKSAmJiAoaXNTaW1wbGVHcmFkaWVudCh2YWx1ZSkgfHwgaXNNdWx0aVN0b3BHcmFkaWVudCh2YWx1ZSkpO1xuICB9XG4gIExpbmVhckdyYWRpZW50Mi5pc0xpbmVhckdyYWRpZW50ID0gaXNMaW5lYXJHcmFkaWVudDtcbiAgZnVuY3Rpb24gaGFzaDIobGluZWFyR3JhZGllbnQpIHtcbiAgICByZXR1cm4gbGluZWFyR3JhZGllbnQuYW5nbGUgXiBncmFkaWVudENvbG9yU3RvcHNIYXNoKGxpbmVhckdyYWRpZW50LCBsaW5lYXJHcmFkaWVudC5hbHBoYSk7XG4gIH1cbiAgTGluZWFyR3JhZGllbnQyLmhhc2ggPSBoYXNoMjtcbiAgZnVuY3Rpb24gdG9DU1MobGluZWFyR3JhZGllbnQsIG92ZXJyaWRlQW5nbGUpIHtcbiAgICBjb25zdCBzdG9wcyA9IGdyYWRpZW50Q29sb3JTdG9wcyhsaW5lYXJHcmFkaWVudCwgbGluZWFyR3JhZGllbnQuYWxwaGEpO1xuICAgIGNvbnN0IGFuZ2xlID0gb3ZlcnJpZGVBbmdsZSAhPT0gdm9pZCAwID8gb3ZlcnJpZGVBbmdsZSA6IGxpbmVhckdyYWRpZW50LmFuZ2xlO1xuICAgIGNvbnN0IGNzc1N0b3BzID0gc3RvcHMubWFwKChzdG9wKSA9PiBgJHtzdG9wLnZhbHVlfSAke3N0b3AucG9zaXRpb24gKiAxMDB9JWApO1xuICAgIHJldHVybiBgbGluZWFyLWdyYWRpZW50KCR7YW5nbGV9ZGVnLCAke2Nzc1N0b3BzLmpvaW4oXCIsIFwiKX0pYDtcbiAgfVxuICBMaW5lYXJHcmFkaWVudDIudG9DU1MgPSB0b0NTUztcbn0pKExpbmVhckdyYWRpZW50IHx8IChMaW5lYXJHcmFkaWVudCA9IHt9KSk7XG5cbi8vIHNyYy9yZW5kZXIvdHlwZXMvUmFkaWFsR3JhZGllbnQudHNcbnZhciByYWRpYWxHcmFkaWVudEtleXMgPSBbXG4gIFwid2lkdGhGYWN0b3JcIixcbiAgXCJoZWlnaHRGYWN0b3JcIixcbiAgXCJjZW50ZXJBbmNob3JYXCIsXG4gIFwiY2VudGVyQW5jaG9yWVwiLFxuICBcImFscGhhXCJcbl07XG52YXIgUmFkaWFsR3JhZGllbnQ7XG4oZnVuY3Rpb24oUmFkaWFsR3JhZGllbnQyKSB7XG4gIGZ1bmN0aW9uIGlzUmFkaWFsR3JhZGllbnQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgcmFkaWFsR3JhZGllbnRLZXlzLmV2ZXJ5KChrZXk2KSA9PiBrZXk2IGluIHZhbHVlKSAmJiAoaXNTaW1wbGVHcmFkaWVudCh2YWx1ZSkgfHwgaXNNdWx0aVN0b3BHcmFkaWVudCh2YWx1ZSkpO1xuICB9XG4gIFJhZGlhbEdyYWRpZW50Mi5pc1JhZGlhbEdyYWRpZW50ID0gaXNSYWRpYWxHcmFkaWVudDtcbiAgZnVuY3Rpb24gaGFzaDIocmFkaWFsR3JhZGllbnQpIHtcbiAgICByZXR1cm4gcmFkaWFsR3JhZGllbnQuY2VudGVyQW5jaG9yWCBeIHJhZGlhbEdyYWRpZW50LmNlbnRlckFuY2hvclkgXiByYWRpYWxHcmFkaWVudC53aWR0aEZhY3RvciBeIHJhZGlhbEdyYWRpZW50LmhlaWdodEZhY3RvciBeIGdyYWRpZW50Q29sb3JTdG9wc0hhc2gocmFkaWFsR3JhZGllbnQsIHJhZGlhbEdyYWRpZW50LmFscGhhKTtcbiAgfVxuICBSYWRpYWxHcmFkaWVudDIuaGFzaCA9IGhhc2gyO1xuICBmdW5jdGlvbiB0b0NTUyhyYWRpYWxHcmFkaWVudCkge1xuICAgIGNvbnN0IHsgYWxwaGE6IGFscGhhMiwgd2lkdGhGYWN0b3IsIGhlaWdodEZhY3RvciwgY2VudGVyQW5jaG9yWCwgY2VudGVyQW5jaG9yWSB9ID0gcmFkaWFsR3JhZGllbnQ7XG4gICAgY29uc3Qgc3RvcHMgPSBncmFkaWVudENvbG9yU3RvcHMocmFkaWFsR3JhZGllbnQsIGFscGhhMik7XG4gICAgY29uc3QgY3NzU3RvcHMgPSBzdG9wcy5tYXAoKHN0b3ApID0+IGAke3N0b3AudmFsdWV9ICR7c3RvcC5wb3NpdGlvbiAqIDEwMH0lYCk7XG4gICAgcmV0dXJuIGByYWRpYWwtZ3JhZGllbnQoJHt3aWR0aEZhY3RvciAqIDEwMH0lICR7aGVpZ2h0RmFjdG9yICogMTAwfSUgYXQgJHtjZW50ZXJBbmNob3JYICogMTAwfSUgJHtjZW50ZXJBbmNob3JZICogMTAwfSUsICR7Y3NzU3RvcHMuam9pbihcIiwgXCIpfSlgO1xuICB9XG4gIFJhZGlhbEdyYWRpZW50Mi50b0NTUyA9IHRvQ1NTO1xufSkoUmFkaWFsR3JhZGllbnQgfHwgKFJhZGlhbEdyYWRpZW50ID0ge30pKTtcblxuLy8gc3JjL3JlbmRlci91dGlscy9pc01vdGlvblZhbHVlLnRzXG52YXIgaXNNb3Rpb25WYWx1ZTIgPSAodikgPT4gdiBpbnN0YW5jZW9mIE1vdGlvblZhbHVlO1xuXG4vLyBzcmMvcmVuZGVyL3RyYWl0cy9CYWNrZ3JvdW5kLnRzXG5mdW5jdGlvbiBjb2xsZWN0QmFja2dyb3VuZEZyb21Qcm9wcyh7IGJhY2tncm91bmQsIGJhY2tncm91bmRDb2xvciB9LCBzdHlsZSkge1xuICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgaWYgKHR5cGVvZiBiYWNrZ3JvdW5kQ29sb3IgPT09IFwic3RyaW5nXCIgfHwgaXNNb3Rpb25WYWx1ZTIoYmFja2dyb3VuZENvbG9yKSkge1xuICAgICAgc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYmFja2dyb3VuZENvbG9yO1xuICAgIH0gZWxzZSBpZiAoQ29sb3IuaXNDb2xvck9iamVjdChiYWNrZ3JvdW5kKSkge1xuICAgICAgc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYmFja2dyb3VuZC5pbml0aWFsVmFsdWUgfHwgQ29sb3IudG9SZ2JTdHJpbmcoYmFja2dyb3VuZCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGJhY2tncm91bmQpIHtcbiAgICBiYWNrZ3JvdW5kID0gQW5pbWF0YWJsZS5nZXQoYmFja2dyb3VuZCwgbnVsbCk7XG4gICAgaWYgKHR5cGVvZiBiYWNrZ3JvdW5kID09PSBcInN0cmluZ1wiIHx8IGlzTW90aW9uVmFsdWUyKGJhY2tncm91bmQpKSB7XG4gICAgICBzdHlsZS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcbiAgICB9IGVsc2UgaWYgKExpbmVhckdyYWRpZW50LmlzTGluZWFyR3JhZGllbnQoYmFja2dyb3VuZCkpIHtcbiAgICAgIHN0eWxlLmJhY2tncm91bmQgPSBMaW5lYXJHcmFkaWVudC50b0NTUyhiYWNrZ3JvdW5kKTtcbiAgICB9IGVsc2UgaWYgKFJhZGlhbEdyYWRpZW50LmlzUmFkaWFsR3JhZGllbnQoYmFja2dyb3VuZCkpIHtcbiAgICAgIHN0eWxlLmJhY2tncm91bmQgPSBSYWRpYWxHcmFkaWVudC50b0NTUyhiYWNrZ3JvdW5kKTtcbiAgICB9IGVsc2UgaWYgKENvbG9yLmlzQ29sb3JPYmplY3QoYmFja2dyb3VuZCkpIHtcbiAgICAgIHN0eWxlLmJhY2tncm91bmRDb2xvciA9IGJhY2tncm91bmQuaW5pdGlhbFZhbHVlIHx8IENvbG9yLnRvUmdiU3RyaW5nKGJhY2tncm91bmQpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvcmVuZGVyL3ByZXNlbnRhdGlvbi9GcmFtZS9nZXRTdHlsZUZvckZyYW1lUHJvcHMudHNcbmZ1bmN0aW9uIGhhc0xlZnRBbmRSaWdodChzdHlsZSkge1xuICBpZiAoIXN0eWxlKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHN0eWxlLmxlZnQgIT09IHZvaWQgMCAmJiBzdHlsZS5yaWdodCAhPT0gdm9pZCAwO1xufVxuZnVuY3Rpb24gaGFzVG9wQW5kQm90dG9tKHN0eWxlKSB7XG4gIGlmICghc3R5bGUpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gc3R5bGUudG9wICE9PSB2b2lkIDAgJiYgc3R5bGUuYm90dG9tICE9PSB2b2lkIDA7XG59XG5mdW5jdGlvbiBnZXRTdHlsZUZvckZyYW1lUHJvcHMocHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCBzdHlsZSA9IHt9O1xuICBpZiAocHJvcHMucHJlc2VydmUzZCA9PT0gdHJ1ZSkge1xuICAgIHN0eWxlLnRyYW5zZm9ybVN0eWxlID0gXCJwcmVzZXJ2ZS0zZFwiO1xuICB9IGVsc2UgaWYgKHByb3BzLnByZXNlcnZlM2QgPT09IGZhbHNlKSB7XG4gICAgc3R5bGUudHJhbnNmb3JtU3R5bGUgPSBcImZsYXRcIjtcbiAgfVxuICBpZiAocHJvcHMuYmFja2ZhY2VWaXNpYmxlID09PSB0cnVlKSB7XG4gICAgc3R5bGUuYmFja2ZhY2VWaXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG4gIH0gZWxzZSBpZiAocHJvcHMuYmFja2ZhY2VWaXNpYmxlID09PSBmYWxzZSkge1xuICAgIHN0eWxlLmJhY2tmYWNlVmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gIH1cbiAgaWYgKHN0eWxlLmJhY2tmYWNlVmlzaWJpbGl0eSkge1xuICAgIHN0eWxlLldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSA9IHN0eWxlLmJhY2tmYWNlVmlzaWJpbGl0eTtcbiAgfVxuICBpZiAocHJvcHMucGVyc3BlY3RpdmUgIT09IHZvaWQgMCkge1xuICAgIHN0eWxlLnBlcnNwZWN0aXZlID0gc3R5bGUuV2Via2l0UGVyc3BlY3RpdmUgPSBwcm9wcy5wZXJzcGVjdGl2ZTtcbiAgfVxuICBpZiAoIXByb3BzLl9fZnJvbUNhbnZhc0NvbXBvbmVudCkge1xuICAgIGlmIChwcm9wcy5jZW50ZXIgPT09IHRydWUpIHtcbiAgICAgIHN0eWxlLmxlZnQgPSBcIjUwJVwiO1xuICAgICAgc3R5bGUudG9wID0gXCI1MCVcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BzLmNlbnRlciA9PT0gXCJ4XCIpIHtcbiAgICAgICAgc3R5bGUubGVmdCA9IFwiNTAlXCI7XG4gICAgICB9IGVsc2UgaWYgKHByb3BzLmNlbnRlciA9PT0gXCJ5XCIpIHtcbiAgICAgICAgc3R5bGUudG9wID0gXCI1MCVcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZXh0cmFjdFN0eWxlRnJvbVByb3BzKHByb3BzLCBcInNpemVcIiwgc3R5bGUpO1xuICBleHRyYWN0U3R5bGVGcm9tUHJvcHMocHJvcHMsIFwid2lkdGhcIiwgc3R5bGUpO1xuICBleHRyYWN0U3R5bGVGcm9tUHJvcHMocHJvcHMsIFwiaGVpZ2h0XCIsIHN0eWxlKTtcbiAgZXh0cmFjdFN0eWxlRnJvbVByb3BzKHByb3BzLCBcIm1pbldpZHRoXCIsIHN0eWxlKTtcbiAgZXh0cmFjdFN0eWxlRnJvbVByb3BzKHByb3BzLCBcIm1pbkhlaWdodFwiLCBzdHlsZSk7XG4gIGV4dHJhY3RTdHlsZUZyb21Qcm9wcyhwcm9wcywgXCJ0b3BcIiwgc3R5bGUpO1xuICBleHRyYWN0U3R5bGVGcm9tUHJvcHMocHJvcHMsIFwicmlnaHRcIiwgc3R5bGUpO1xuICBleHRyYWN0U3R5bGVGcm9tUHJvcHMocHJvcHMsIFwiYm90dG9tXCIsIHN0eWxlKTtcbiAgZXh0cmFjdFN0eWxlRnJvbVByb3BzKHByb3BzLCBcImxlZnRcIiwgc3R5bGUpO1xuICBleHRyYWN0U3R5bGVGcm9tUHJvcHMocHJvcHMsIFwicG9zaXRpb25cIiwgc3R5bGUpO1xuICBleHRyYWN0U3R5bGVGcm9tUHJvcHMocHJvcHMsIFwib3ZlcmZsb3dcIiwgc3R5bGUpO1xuICBleHRyYWN0U3R5bGVGcm9tUHJvcHMocHJvcHMsIFwib3BhY2l0eVwiLCBzdHlsZSk7XG4gIGlmICghcHJvcHMuX2JvcmRlciB8fCAhcHJvcHMuX2JvcmRlci5ib3JkZXJXaWR0aClcbiAgICBleHRyYWN0U3R5bGVGcm9tUHJvcHMocHJvcHMsIFwiYm9yZGVyXCIsIHN0eWxlKTtcbiAgZXh0cmFjdFN0eWxlRnJvbVByb3BzKHByb3BzLCBcImJvcmRlclJhZGl1c1wiLCBzdHlsZSk7XG4gIGV4dHJhY3RTdHlsZUZyb21Qcm9wcyhwcm9wcywgXCJyYWRpdXNcIiwgc3R5bGUsIFwiYm9yZGVyUmFkaXVzXCIpO1xuICBleHRyYWN0U3R5bGVGcm9tUHJvcHMocHJvcHMsIFwiY29sb3JcIiwgc3R5bGUpO1xuICBleHRyYWN0U3R5bGVGcm9tUHJvcHMocHJvcHMsIFwic2hhZG93XCIsIHN0eWxlLCBcImJveFNoYWRvd1wiKTtcbiAgZXh0cmFjdFN0eWxlRnJvbVByb3BzKHByb3BzLCBcInhcIiwgc3R5bGUpO1xuICBleHRyYWN0U3R5bGVGcm9tUHJvcHMocHJvcHMsIFwieVwiLCBzdHlsZSk7XG4gIGV4dHJhY3RTdHlsZUZyb21Qcm9wcyhwcm9wcywgXCJ6XCIsIHN0eWxlKTtcbiAgZXh0cmFjdFN0eWxlRnJvbVByb3BzKHByb3BzLCBcInJvdGF0ZVwiLCBzdHlsZSk7XG4gIGV4dHJhY3RTdHlsZUZyb21Qcm9wcyhwcm9wcywgXCJyb3RhdGVYXCIsIHN0eWxlKTtcbiAgZXh0cmFjdFN0eWxlRnJvbVByb3BzKHByb3BzLCBcInJvdGF0ZVlcIiwgc3R5bGUpO1xuICBleHRyYWN0U3R5bGVGcm9tUHJvcHMocHJvcHMsIFwicm90YXRlWlwiLCBzdHlsZSk7XG4gIGV4dHJhY3RTdHlsZUZyb21Qcm9wcyhwcm9wcywgXCJzY2FsZVwiLCBzdHlsZSk7XG4gIGV4dHJhY3RTdHlsZUZyb21Qcm9wcyhwcm9wcywgXCJzY2FsZVhcIiwgc3R5bGUpO1xuICBleHRyYWN0U3R5bGVGcm9tUHJvcHMocHJvcHMsIFwic2NhbGVZXCIsIHN0eWxlKTtcbiAgZXh0cmFjdFN0eWxlRnJvbVByb3BzKHByb3BzLCBcInNrZXdcIiwgc3R5bGUpO1xuICBleHRyYWN0U3R5bGVGcm9tUHJvcHMocHJvcHMsIFwic2tld1hcIiwgc3R5bGUpO1xuICBleHRyYWN0U3R5bGVGcm9tUHJvcHMocHJvcHMsIFwic2tld1lcIiwgc3R5bGUpO1xuICBleHRyYWN0U3R5bGVGcm9tUHJvcHMocHJvcHMsIFwib3JpZ2luWFwiLCBzdHlsZSk7XG4gIGV4dHJhY3RTdHlsZUZyb21Qcm9wcyhwcm9wcywgXCJvcmlnaW5ZXCIsIHN0eWxlKTtcbiAgZXh0cmFjdFN0eWxlRnJvbVByb3BzKHByb3BzLCBcIm9yaWdpblpcIiwgc3R5bGUpO1xuICBjb2xsZWN0QmFja2dyb3VuZEZyb21Qcm9wcyhwcm9wcywgc3R5bGUpO1xuICByZXR1cm4gc3R5bGU7XG59XG5cbi8vIHNyYy9yZW5kZXIvdXRpbHMvdXNlTGF5b3V0SWQudHNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDE4LCB1c2VNZW1vIGFzIHVzZU1lbW85IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9jb21wb25lbnRzL0FuaW1hdGVMYXlvdXQvTGF5b3V0SWRDb250ZXh0LnRzeFxuaW1wb3J0IHtcbiAgRnJhZ21lbnQgYXMgRnJhZ21lbnQ0LFxuICBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQ4LFxuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQxMlxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVJlZiBhcyB1c2VSZWYxMSwgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2szLCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxNywgdXNlTWVtbyBhcyB1c2VNZW1vOCB9IGZyb20gXCJyZWFjdFwiO1xudmFyIExheW91dElkQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ4KHtcbiAgZ2V0TGF5b3V0SWQ6IChhcmdzKSA9PiBudWxsLFxuICBwZXJzaXN0TGF5b3V0SWRDYWNoZTogKCkgPT4ge1xuICB9LFxuICB0b3A6IGZhbHNlLFxuICBlbmFibGVkOiB0cnVlXG59KTtcbmZ1bmN0aW9uIExheW91dElkUHJvdmlkZXIoeyBjaGlsZHJlbiB9KSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0MTcoTGF5b3V0SWRDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQudG9wKVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDEyKEZyYWdtZW50NCwgbnVsbCwgY2hpbGRyZW4pO1xuICBjb25zdCBjYWNoZTQgPSB1c2VSZWYxMSh7XG4gICAgYnlJZDoge30sXG4gICAgYnlOYW1lOiB7fSxcbiAgICBieUxhc3RJZDoge30sXG4gICAgYnlQb3NzaWJsZUlkOiB7fSxcbiAgICBieUxhc3ROYW1lOiB7fSxcbiAgICBieUxheW91dElkOiB7fSxcbiAgICBjb3VudDoge1xuICAgICAgYnlJZDoge30sXG4gICAgICBieU5hbWU6IHt9XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgc2NyZWVuID0gdXNlUmVmMTEoe1xuICAgIGJ5SWQ6IHt9LFxuICAgIGJ5TmFtZToge30sXG4gICAgYnlMYXN0SWQ6IHt9LFxuICAgIGJ5UG9zc2libGVJZDoge30sXG4gICAgYnlMYXN0TmFtZToge30sXG4gICAgYnlMYXlvdXRJZDoge31cbiAgfSk7XG4gIGNvbnN0IHVzZWRJZHMgPSB1c2VSZWYxMShuZXcgU2V0KCkpLmN1cnJlbnQ7XG4gIGNvbnN0IGdldExheW91dElkID0gdXNlQ2FsbGJhY2szKCh7IGlkLCBuYW1lLCBkdXBsaWNhdGVkRnJvbSB9KSA9PiB7XG4gICAgaWYgKCFpZClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gbmFtZSA/IFwiYnlOYW1lXCIgOiBcImJ5SWRcIjtcbiAgICBjb25zdCBwcmV2aW91c0lkID0gY2FjaGU0LmN1cnJlbnRbY2FjaGVLZXldW2lkXTtcbiAgICBpZiAocHJldmlvdXNJZClcbiAgICAgIHJldHVybiBwcmV2aW91c0lkO1xuICAgIGNvbnN0IG5vZGVJZGVudGlmaWVyID0gbmFtZSB8fCBpZDtcbiAgICBpZiAoIWR1cGxpY2F0ZWRGcm9tICYmICF1c2VkSWRzLmhhcyhub2RlSWRlbnRpZmllcikgJiYgKCFjYWNoZTQuY3VycmVudC5ieUxheW91dElkW25vZGVJZGVudGlmaWVyXSB8fCBjYWNoZTQuY3VycmVudC5ieUxheW91dElkW25vZGVJZGVudGlmaWVyXSA9PT0gbm9kZUlkZW50aWZpZXIpKSB7XG4gICAgICBpZiAoY2FjaGU0LmN1cnJlbnQuY291bnRbY2FjaGVLZXldW25vZGVJZGVudGlmaWVyXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNhY2hlNC5jdXJyZW50LmNvdW50W2NhY2hlS2V5XVtub2RlSWRlbnRpZmllcl0gPSAwO1xuICAgICAgICBjYWNoZTQuY3VycmVudC5ieUxheW91dElkW25vZGVJZGVudGlmaWVyXSA9IG5vZGVJZGVudGlmaWVyO1xuICAgICAgICBzY3JlZW4uY3VycmVudFtjYWNoZUtleV1baWRdID0gbm9kZUlkZW50aWZpZXI7XG4gICAgICB9XG4gICAgICB1c2VkSWRzLmFkZChub2RlSWRlbnRpZmllcik7XG4gICAgICByZXR1cm4gbm9kZUlkZW50aWZpZXI7XG4gICAgfVxuICAgIGxldCBwb3NzaWJsZU1hdGNoID0gdm9pZCAwO1xuICAgIGlmIChkdXBsaWNhdGVkRnJvbSA9PSBudWxsID8gdm9pZCAwIDogZHVwbGljYXRlZEZyb20ubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpbmRleCA9IGR1cGxpY2F0ZWRGcm9tLmxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgICAgY29uc3QgZHVwbGljYXRlZElkID0gZHVwbGljYXRlZEZyb21baW5kZXhdO1xuICAgICAgICBjb25zdCBtYXRjaCA9IGNhY2hlNC5jdXJyZW50W2NhY2hlS2V5XVtkdXBsaWNhdGVkSWRdO1xuICAgICAgICBjb25zdCBieUxhc3RJZE1hdGNoID0gY2FjaGU0LmN1cnJlbnQuYnlMYXN0SWRbZHVwbGljYXRlZElkXTtcbiAgICAgICAgaWYgKGJ5TGFzdElkTWF0Y2ggJiYgIXBvc3NpYmxlTWF0Y2gpIHtcbiAgICAgICAgICBjb25zdCBtYXRjaGVkTGF5b3V0SWQgPSBjYWNoZTQuY3VycmVudC5ieUxheW91dElkW2J5TGFzdElkTWF0Y2hdO1xuICAgICAgICAgIGNvbnN0IHNob3VsZFVzZU5hbWVkTGFzdElkTWF0Y2ggPSAhbWF0Y2hlZExheW91dElkIHx8IG1hdGNoZWRMYXlvdXRJZCA9PT0gbmFtZTtcbiAgICAgICAgICBpZiAoYnlMYXN0SWRNYXRjaCAmJiAhdXNlZElkcy5oYXMoYnlMYXN0SWRNYXRjaCkgJiYgKG5hbWUgPyBzaG91bGRVc2VOYW1lZExhc3RJZE1hdGNoIDogdHJ1ZSkpIHtcbiAgICAgICAgICAgIHBvc3NpYmxlTWF0Y2ggPSBbYnlMYXN0SWRNYXRjaCwgZHVwbGljYXRlZElkXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldmlvdXNMYXlvdXRJZCA9IGNhY2hlNC5jdXJyZW50LmJ5TGF5b3V0SWRbbWF0Y2hdO1xuICAgICAgICBjb25zdCBzaG91bGRVc2VOYW1lZE1hdGNoID0gIXByZXZpb3VzTGF5b3V0SWQgfHwgcHJldmlvdXNMYXlvdXRJZCA9PT0gbmFtZTtcbiAgICAgICAgaWYgKG1hdGNoICYmICF1c2VkSWRzLmhhcyhtYXRjaCkgJiYgKG5hbWUgPyBzaG91bGRVc2VOYW1lZE1hdGNoIDogdHJ1ZSkpIHtcbiAgICAgICAgICBzY3JlZW4uY3VycmVudFtjYWNoZUtleV1baWRdID0gbWF0Y2g7XG4gICAgICAgICAgc2NyZWVuLmN1cnJlbnQuYnlMYXN0SWRbZHVwbGljYXRlZElkXSA9IG1hdGNoO1xuICAgICAgICAgIHVzZWRJZHMuYWRkKG1hdGNoKTtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGFzdCA9IGNhY2hlNC5jdXJyZW50LmJ5TGFzdElkW2lkXTtcbiAgICBpZiAobGFzdCAmJiAhdXNlZElkcy5oYXMobGFzdCkpIHtcbiAgICAgIHVzZWRJZHMuYWRkKGxhc3QpO1xuICAgICAgc2NyZWVuLmN1cnJlbnQuYnlJZFtpZF0gPSBsYXN0O1xuICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgfVxuICAgIGlmIChwb3NzaWJsZU1hdGNoKSB7XG4gICAgICBjb25zdCBbbWF0Y2gsIGR1cGxpY2F0ZWRJZF0gPSBwb3NzaWJsZU1hdGNoO1xuICAgICAgc2NyZWVuLmN1cnJlbnRbY2FjaGVLZXldW2lkXSA9IG1hdGNoO1xuICAgICAgc2NyZWVuLmN1cnJlbnQuYnlMYXN0SWRbZHVwbGljYXRlZElkXSA9IG1hdGNoO1xuICAgICAgdXNlZElkcy5hZGQobWF0Y2gpO1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICBjb25zdCBwb3NzaWJsZSA9IGNhY2hlNC5jdXJyZW50LmJ5UG9zc2libGVJZFtpZF07XG4gICAgaWYgKHBvc3NpYmxlICYmICF1c2VkSWRzLmhhcyhwb3NzaWJsZSkpIHtcbiAgICAgIHVzZWRJZHMuYWRkKHBvc3NpYmxlKTtcbiAgICAgIHNjcmVlbi5jdXJyZW50LmJ5SWRbaWRdID0gcG9zc2libGU7XG4gICAgICByZXR1cm4gcG9zc2libGU7XG4gICAgfVxuICAgIGNvbnN0IHJvb3REdXBsaWNhdGVkSWQgPSBkdXBsaWNhdGVkRnJvbSA9PSBudWxsID8gdm9pZCAwIDogZHVwbGljYXRlZEZyb21bMF07XG4gICAgY29uc3QgaWRlbnRpZmllciA9IG5hbWUgfHwgcm9vdER1cGxpY2F0ZWRJZCB8fCBpZDtcbiAgICBjb25zdCB2YWx1ZSA9IGNhY2hlNC5jdXJyZW50LmNvdW50W2NhY2hlS2V5XVtpZGVudGlmaWVyXSArIDEgfHwgMDtcbiAgICBjb25zdCB7IGxheW91dElkLCB2YWx1ZTogbmV4dFZhbHVlIH0gPSBuZXh0TGF5b3V0SWQoaWRlbnRpZmllciwgdmFsdWUsIHVzZWRJZHMpO1xuICAgIGNhY2hlNC5jdXJyZW50LmNvdW50W2NhY2hlS2V5XVtpZGVudGlmaWVyXSA9IG5leHRWYWx1ZTtcbiAgICBzY3JlZW4uY3VycmVudFtjYWNoZUtleV1baWRdID0gbGF5b3V0SWQ7XG4gICAgaWYgKGR1cGxpY2F0ZWRGcm9tID09IG51bGwgPyB2b2lkIDAgOiBkdXBsaWNhdGVkRnJvbS5sZW5ndGgpIHtcbiAgICAgIGlmICghbmFtZSkge1xuICAgICAgICBzY3JlZW4uY3VycmVudC5ieUxhc3RJZFtkdXBsaWNhdGVkRnJvbVtkdXBsaWNhdGVkRnJvbS5sZW5ndGggLSAxXV0gPSBsYXlvdXRJZDtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZWRGcm9tLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgZHVwbGljYXRlZEZyb20ubGVuZ3RoIC0gMTsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgcG9zc2libGVJZCA9IGR1cGxpY2F0ZWRGcm9tW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghc2NyZWVuLmN1cnJlbnQuYnlQb3NzaWJsZUlkW3Bvc3NpYmxlSWRdKSB7XG4gICAgICAgICAgICAgIHNjcmVlbi5jdXJyZW50LmJ5UG9zc2libGVJZFtwb3NzaWJsZUlkXSA9IGxheW91dElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzY3JlZW4uY3VycmVudC5ieUxheW91dElkW2xheW91dElkXSA9IG5vZGVJZGVudGlmaWVyO1xuICAgIHVzZWRJZHMuYWRkKGxheW91dElkKTtcbiAgICByZXR1cm4gbGF5b3V0SWQ7XG4gIH0sIFtdKTtcbiAgY29uc3QgcGVyc2lzdExheW91dElkQ2FjaGUgPSB1c2VDYWxsYmFjazMoKCkgPT4ge1xuICAgIGNhY2hlNC5jdXJyZW50ID0ge1xuICAgICAgYnlJZDoge1xuICAgICAgICAuLi5jYWNoZTQuY3VycmVudC5ieUlkLFxuICAgICAgICAuLi5zY3JlZW4uY3VycmVudC5ieUlkXG4gICAgICB9LFxuICAgICAgYnlMYXN0SWQ6IHtcbiAgICAgICAgLi4uY2FjaGU0LmN1cnJlbnQuYnlMYXN0SWQsXG4gICAgICAgIC4uLnNjcmVlbi5jdXJyZW50LmJ5TGFzdElkXG4gICAgICB9LFxuICAgICAgYnlQb3NzaWJsZUlkOiB7XG4gICAgICAgIC4uLmNhY2hlNC5jdXJyZW50LmJ5UG9zc2libGVJZCxcbiAgICAgICAgLi4uc2NyZWVuLmN1cnJlbnQuYnlQb3NzaWJsZUlkXG4gICAgICB9LFxuICAgICAgYnlOYW1lOiB7XG4gICAgICAgIC4uLmNhY2hlNC5jdXJyZW50LmJ5TmFtZSxcbiAgICAgICAgLi4uc2NyZWVuLmN1cnJlbnQuYnlOYW1lXG4gICAgICB9LFxuICAgICAgYnlMYXN0TmFtZTogeyAuLi5jYWNoZTQuY3VycmVudC5ieUxhc3ROYW1lLCAuLi5zY3JlZW4uY3VycmVudC5ieUxhc3ROYW1lIH0sXG4gICAgICBieUxheW91dElkOiB7IC4uLmNhY2hlNC5jdXJyZW50LmJ5TGF5b3V0SWQsIC4uLnNjcmVlbi5jdXJyZW50LmJ5TGF5b3V0SWQgfSxcbiAgICAgIGNvdW50OiB7XG4gICAgICAgIC4uLmNhY2hlNC5jdXJyZW50LmNvdW50LFxuICAgICAgICBieU5hbWU6IHt9XG4gICAgICB9XG4gICAgfTtcbiAgICBzY3JlZW4uY3VycmVudCA9IHtcbiAgICAgIGJ5SWQ6IHt9LFxuICAgICAgYnlOYW1lOiB7fSxcbiAgICAgIGJ5TGFzdElkOiB7fSxcbiAgICAgIGJ5UG9zc2libGVJZDoge30sXG4gICAgICBieUxhc3ROYW1lOiB7fSxcbiAgICAgIGJ5TGF5b3V0SWQ6IHt9XG4gICAgfTtcbiAgICB1c2VkSWRzLmNsZWFyKCk7XG4gIH0sIFtdKTtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlUmVmMTEoe1xuICAgIGdldExheW91dElkLFxuICAgIHBlcnNpc3RMYXlvdXRJZENhY2hlLFxuICAgIHRvcDogdHJ1ZSxcbiAgICBlbmFibGVkOiB0cnVlXG4gIH0pLmN1cnJlbnQ7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDEyKExheW91dElkQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0VmFsdWVcbiAgfSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gbmV4dExheW91dElkKGlkZW50aWZpZXIsIGluaXRpYWxWYWx1ZSwgdXNlZElkcykge1xuICBsZXQgdmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGxldCBsYXlvdXRJZCA9IHZhbHVlID8gYCR7aWRlbnRpZmllcn0tJHt2YWx1ZX1gIDogaWRlbnRpZmllcjtcbiAgd2hpbGUgKHVzZWRJZHMuaGFzKGxheW91dElkKSkge1xuICAgIHZhbHVlKys7XG4gICAgbGF5b3V0SWQgPSBgJHtpZGVudGlmaWVyfS0ke3ZhbHVlfWA7XG4gIH1cbiAgcmV0dXJuIHsgbGF5b3V0SWQsIHZhbHVlIH07XG59XG5mdW5jdGlvbiBBdXRvbWF0aWNMYXlvdXRJZHMoeyBlbmFibGVkID0gdHJ1ZSwgLi4ucHJvcHMgfSkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dDE3KExheW91dElkQ29udGV4dCk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW84KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIGVuYWJsZWRcbiAgICB9O1xuICB9LCBbZW5hYmxlZF0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQxMihMYXlvdXRJZENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAuLi5wcm9wcyxcbiAgICB2YWx1ZTogY29udGV4dFZhbHVlXG4gIH0pO1xufVxuXG4vLyBzcmMvcmVuZGVyL3V0aWxzL3VzZUxheW91dElkLnRzXG5mdW5jdGlvbiB1c2VMYXlvdXRJZDIocHJvcHMsIHsgc3BlY2lmaWNMYXlvdXRJZCwgcG9zdGZpeCB9ID0ge30pIHtcbiAgY29uc3QgeyBuYW1lLCBsYXlvdXRJZEtleSwgZHVwbGljYXRlZEZyb20sIF9fZnJvbUNvZGVDb21wb25lbnROb2RlID0gZmFsc2UgfSA9IHByb3BzO1xuICBjb25zdCB7IGdldExheW91dElkLCBlbmFibGVkIH0gPSB1c2VDb250ZXh0MTgoTGF5b3V0SWRDb250ZXh0KTtcbiAgcmV0dXJuIHVzZU1lbW85KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpXG4gICAgICByZXR1cm4gcHJvcHMubGF5b3V0SWQ7XG4gICAgY29uc3QgZXhpc3RpbmdMYXlvdXRJZCA9IHNwZWNpZmljTGF5b3V0SWQgfHwgcHJvcHMubGF5b3V0SWQ7XG4gICAgaWYgKCFleGlzdGluZ0xheW91dElkKSB7XG4gICAgICBpZiAoIWxheW91dElkS2V5IHx8IF9fZnJvbUNvZGVDb21wb25lbnROb2RlKVxuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCBsYXlvdXRJZENhbmRpZGF0ZSA9IGV4aXN0aW5nTGF5b3V0SWQgfHwgZ2V0TGF5b3V0SWQoeyBpZDogbGF5b3V0SWRLZXksIG5hbWUsIGR1cGxpY2F0ZWRGcm9tIH0pO1xuICAgIGlmICghbGF5b3V0SWRDYW5kaWRhdGUpXG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiBwb3N0Zml4ID8gYCR7bGF5b3V0SWRDYW5kaWRhdGV9LSR7cG9zdGZpeH1gIDogbGF5b3V0SWRDYW5kaWRhdGU7XG4gIH0sIFtlbmFibGVkXSk7XG59XG5cbi8vIHNyYy9yZW5kZXIvdXRpbHMvdHJhbnNmb3JtVGVtcGxhdGUudHNcbmZ1bmN0aW9uIHRyYW5zZm9ybVRlbXBsYXRlKGNlbnRlcikge1xuICByZXR1cm4gKF8sIGdlbmVyYXRlZCkgPT4ge1xuICAgIGlmIChjZW50ZXIgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBgdHJhbnNsYXRlKC01MCUsIC01MCUpICR7Z2VuZXJhdGVkfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjZW50ZXIgPT09IFwieFwiKSB7XG4gICAgICAgIHJldHVybiBgdHJhbnNsYXRlWCgtNTAlKSAke2dlbmVyYXRlZH1gO1xuICAgICAgfSBlbHNlIGlmIChjZW50ZXIgPT09IFwieVwiKSB7XG4gICAgICAgIHJldHVybiBgdHJhbnNsYXRlWSgtNTAlKSAke2dlbmVyYXRlZH1gO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2VuZXJhdGVkIHx8IFwibm9uZVwiO1xuICB9O1xufVxuXG4vLyBzcmMvcmVuZGVyL3V0aWxzL3VzZU1lYXN1cmVMYXlvdXQudHNcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3QzLCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxOSB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdXRpbHMvcnVudGltZUluamVjdGlvbi50c1xudmFyIG1vY2tXaXRoV2FybmluZyA9IChtZXNzYWdlKSA9PiB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgd2Fybk9uY2UobWVzc2FnZSk7XG4gIH07XG59O1xudmFyIGltcGxlbWVudGF0aW9uID0ge1xuICB1c2VJbWFnZVNvdXJjZShpbWFnZSkge1xuICAgIHJldHVybiBpbWFnZS5zcmM7XG4gIH0sXG4gIHVzZUltYWdlRWxlbWVudChpbWFnZSwgcmVjdCwgbm9kZUlkKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IG5ldyBJbWFnZSgpO1xuICAgIGVsZW1lbnQuc3JjID0gcnVudGltZS51c2VJbWFnZVNvdXJjZShpbWFnZSwgcmVjdCwgbm9kZUlkKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufTtcbnZhciBpc1J1bnRpbWVJbmplY3RlZCA9IGZhbHNlO1xudmFyIHJ1bnRpbWVQcm94eSA9IHtcbiAgZ2V0KHRhcmdldCwga2V5NiwgcmVjaWV2ZXIpIHtcbiAgICBpZiAoUmVmbGVjdC5oYXModGFyZ2V0LCBrZXk2KSkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5NiwgcmVjaWV2ZXIpO1xuICAgIH1cbiAgICBpZiAoaXNSdW50aW1lSW5qZWN0ZWQpIHtcbiAgICAgIHJldHVybiBtb2NrV2l0aFdhcm5pbmcoYCR7U3RyaW5nKGtleTYpfSBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgdmVyc2lvbiBvZiBGcmFtZXIuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtb2NrV2l0aFdhcm5pbmcoYCR7U3RyaW5nKGtleTYpfSBpcyBvbmx5IGF2YWlsYWJsZSBpbnNpZGUgb2YgRnJhbWVyLiBodHRwczovL3d3dy5mcmFtZXIuY29tL2ApO1xuICAgIH1cbiAgfVxufTtcbnZhciBydW50aW1lID0gbmV3IFByb3h5KGltcGxlbWVudGF0aW9uLCBydW50aW1lUHJveHkpO1xuZnVuY3Rpb24gX2luamVjdFJ1bnRpbWUoaW5qZWN0ZWRSdW50aW1lKSB7XG4gIE9iamVjdC5hc3NpZ24oaW1wbGVtZW50YXRpb24sIGluamVjdGVkUnVudGltZSk7XG4gIGlzUnVudGltZUluamVjdGVkID0gdHJ1ZTtcbn1cblxuLy8gc3JjL3JlbmRlci91dGlscy9ub2RlSWRGcm9tU3RyaW5nLnRzXG5mdW5jdGlvbiBub2RlSWRGcm9tU3RyaW5nKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15pZF8vLCBcIlwiKS5yZXBsYWNlKC9cXFxcL2csIFwiXCIpO1xufVxuXG4vLyBzcmMvcmVuZGVyL3ByZXNlbnRhdGlvbi9Db21wb25lbnRDb250YWluZXJDb250ZXh0LnRzeFxuaW1wb3J0IHtcbiAgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0OVxufSBmcm9tIFwicmVhY3RcIjtcbnZhciBDb21wb25lbnRDb250YWluZXJDb250ZXh0ID0gY3JlYXRlQ29udGV4dDkoZmFsc2UpO1xuXG4vLyBzcmMvY29tcG9uZW50cy9ob2Mvd2l0aE1lYXN1cmVkU2l6ZS50c3hcbmltcG9ydCB7XG4gIGNyZWF0ZUVsZW1lbnQgYXMgY3JlYXRlRWxlbWVudDEzLFxuICB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0MixcbiAgdXNlUmVmIGFzIHVzZVJlZjEyXG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvbW9kdWxlcy91c2VGb3JjZVVwZGF0ZS50c1xuaW1wb3J0IHtcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s0LFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTdcbn0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VGb3JjZVVwZGF0ZTIoKSB7XG4gIGNvbnN0IFtfLCBzZXRGb3JjZWRSZW5kZXJDb3VudF0gPSB1c2VTdGF0ZTcoMCk7XG4gIHJldHVybiB1c2VDYWxsYmFjazQoKCkgPT4gc2V0Rm9yY2VkUmVuZGVyQ291bnQoKHYpID0+IHYgKyAxKSwgW10pO1xufVxuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL3Jlc2l6ZU9ic2VydmVycy5qc1xudmFyIHJlc2l6ZU9ic2VydmVycyA9IFtdO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvaGFzQWN0aXZlT2JzZXJ2YXRpb25zLmpzXG52YXIgaGFzQWN0aXZlT2JzZXJ2YXRpb25zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByZXNpemVPYnNlcnZlcnMuc29tZShmdW5jdGlvbihybykge1xuICAgIHJldHVybiByby5hY3RpdmVUYXJnZXRzLmxlbmd0aCA+IDA7XG4gIH0pO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9hbGdvcml0aG1zL2hhc1NraXBwZWRPYnNlcnZhdGlvbnMuanNcbnZhciBoYXNTa2lwcGVkT2JzZXJ2YXRpb25zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByZXNpemVPYnNlcnZlcnMuc29tZShmdW5jdGlvbihybykge1xuICAgIHJldHVybiByby5za2lwcGVkVGFyZ2V0cy5sZW5ndGggPiAwO1xuICB9KTtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvYWxnb3JpdGhtcy9kZWxpdmVyUmVzaXplTG9vcEVycm9yLmpzXG52YXIgbXNnID0gXCJSZXNpemVPYnNlcnZlciBsb29wIGNvbXBsZXRlZCB3aXRoIHVuZGVsaXZlcmVkIG5vdGlmaWNhdGlvbnMuXCI7XG52YXIgZGVsaXZlclJlc2l6ZUxvb3BFcnJvciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZXZlbnQ7XG4gIGlmICh0eXBlb2YgRXJyb3JFdmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZXZlbnQgPSBuZXcgRXJyb3JFdmVudChcImVycm9yXCIsIHtcbiAgICAgIG1lc3NhZ2U6IG1zZ1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICBldmVudC5pbml0RXZlbnQoXCJlcnJvclwiLCBmYWxzZSwgZmFsc2UpO1xuICAgIGV2ZW50Lm1lc3NhZ2UgPSBtc2c7XG4gIH1cbiAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9SZXNpemVPYnNlcnZlckJveE9wdGlvbnMuanNcbnZhciBSZXNpemVPYnNlcnZlckJveE9wdGlvbnM7XG4oZnVuY3Rpb24oUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zMikge1xuICBSZXNpemVPYnNlcnZlckJveE9wdGlvbnMyW1wiQk9SREVSX0JPWFwiXSA9IFwiYm9yZGVyLWJveFwiO1xuICBSZXNpemVPYnNlcnZlckJveE9wdGlvbnMyW1wiQ09OVEVOVF9CT1hcIl0gPSBcImNvbnRlbnQtYm94XCI7XG4gIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9uczJbXCJERVZJQ0VfUElYRUxfQ09OVEVOVF9CT1hcIl0gPSBcImRldmljZS1waXhlbC1jb250ZW50LWJveFwiO1xufSkoUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zIHx8IChSZXNpemVPYnNlcnZlckJveE9wdGlvbnMgPSB7fSkpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2ZyZWV6ZS5qc1xudmFyIGZyZWV6ZSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShvYmopO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9SZXNpemVPYnNlcnZlclNpemUuanNcbnZhciBSZXNpemVPYnNlcnZlclNpemUgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJTaXplMihpbmxpbmVTaXplLCBibG9ja1NpemUpIHtcbiAgICB0aGlzLmlubGluZVNpemUgPSBpbmxpbmVTaXplO1xuICAgIHRoaXMuYmxvY2tTaXplID0gYmxvY2tTaXplO1xuICAgIGZyZWV6ZSh0aGlzKTtcbiAgfVxuICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJTaXplMjtcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9ET01SZWN0UmVhZE9ubHkuanNcbnZhciBET01SZWN0UmVhZE9ubHkgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gRE9NUmVjdFJlYWRPbmx5Mih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnRvcCA9IHRoaXMueTtcbiAgICB0aGlzLmxlZnQgPSB0aGlzLng7XG4gICAgdGhpcy5ib3R0b20gPSB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0O1xuICAgIHRoaXMucmlnaHQgPSB0aGlzLmxlZnQgKyB0aGlzLndpZHRoO1xuICAgIHJldHVybiBmcmVlemUodGhpcyk7XG4gIH1cbiAgRE9NUmVjdFJlYWRPbmx5Mi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF9hID0gdGhpcywgeCA9IF9hLngsIHkgPSBfYS55LCB0b3AgPSBfYS50b3AsIHJpZ2h0ID0gX2EucmlnaHQsIGJvdHRvbSA9IF9hLmJvdHRvbSwgbGVmdCA9IF9hLmxlZnQsIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICByZXR1cm4geyB4LCB5LCB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHQgfTtcbiAgfTtcbiAgRE9NUmVjdFJlYWRPbmx5Mi5mcm9tUmVjdCA9IGZ1bmN0aW9uKHJlY3RhbmdsZSkge1xuICAgIHJldHVybiBuZXcgRE9NUmVjdFJlYWRPbmx5MihyZWN0YW5nbGUueCwgcmVjdGFuZ2xlLnksIHJlY3RhbmdsZS53aWR0aCwgcmVjdGFuZ2xlLmhlaWdodCk7XG4gIH07XG4gIHJldHVybiBET01SZWN0UmVhZE9ubHkyO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2VsZW1lbnQuanNcbnZhciBpc1NWRyA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiBcImdldEJCb3hcIiBpbiB0YXJnZXQ7XG59O1xudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gIGlmIChpc1NWRyh0YXJnZXQpKSB7XG4gICAgdmFyIF9hID0gdGFyZ2V0LmdldEJCb3goKSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgIHJldHVybiAhd2lkdGggJiYgIWhlaWdodDtcbiAgfVxuICB2YXIgX2IgPSB0YXJnZXQsIG9mZnNldFdpZHRoID0gX2Iub2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCA9IF9iLm9mZnNldEhlaWdodDtcbiAgcmV0dXJuICEob2Zmc2V0V2lkdGggfHwgb2Zmc2V0SGVpZ2h0IHx8IHRhcmdldC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCk7XG59O1xudmFyIGlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgX2EsIF9iO1xuICBpZiAob2JqIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBzY29wZSA9IChfYiA9IChfYSA9IG9iaikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm93bmVyRG9jdW1lbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZWZhdWx0VmlldztcbiAgcmV0dXJuICEhKHNjb3BlICYmIG9iaiBpbnN0YW5jZW9mIHNjb3BlLkVsZW1lbnQpO1xufTtcbnZhciBpc1JlcGxhY2VkRWxlbWVudCA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICBzd2l0Y2ggKHRhcmdldC50YWdOYW1lKSB7XG4gICAgY2FzZSBcIklOUFVUXCI6XG4gICAgICBpZiAodGFyZ2V0LnR5cGUgIT09IFwiaW1hZ2VcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIFwiVklERU9cIjpcbiAgICBjYXNlIFwiQVVESU9cIjpcbiAgICBjYXNlIFwiRU1CRURcIjpcbiAgICBjYXNlIFwiT0JKRUNUXCI6XG4gICAgY2FzZSBcIkNBTlZBU1wiOlxuICAgIGNhc2UgXCJJRlJBTUVcIjpcbiAgICBjYXNlIFwiSU1HXCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL3V0aWxzL2dsb2JhbC5qc1xudmFyIGdsb2JhbDIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge307XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvYWxnb3JpdGhtcy9jYWxjdWxhdGVCb3hTaXplLmpzXG52YXIgY2FjaGUzID0gbmV3IFdlYWtNYXAoKTtcbnZhciBzY3JvbGxSZWdleHAgPSAvYXV0b3xzY3JvbGwvO1xudmFyIHZlcnRpY2FsUmVnZXhwID0gL150Ynx2ZXJ0aWNhbC87XG52YXIgSUUgPSAvbXNpZXx0cmlkZW50L2kudGVzdChnbG9iYWwyLm5hdmlnYXRvciAmJiBnbG9iYWwyLm5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIHBhcnNlRGltZW5zaW9uID0gZnVuY3Rpb24ocGl4ZWwpIHtcbiAgcmV0dXJuIHBhcnNlRmxvYXQocGl4ZWwgfHwgXCIwXCIpO1xufTtcbnZhciBzaXplID0gZnVuY3Rpb24oaW5saW5lU2l6ZSwgYmxvY2tTaXplLCBzd2l0Y2hTaXplcykge1xuICBpZiAoaW5saW5lU2l6ZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5saW5lU2l6ZSA9IDA7XG4gIH1cbiAgaWYgKGJsb2NrU2l6ZSA9PT0gdm9pZCAwKSB7XG4gICAgYmxvY2tTaXplID0gMDtcbiAgfVxuICBpZiAoc3dpdGNoU2l6ZXMgPT09IHZvaWQgMCkge1xuICAgIHN3aXRjaFNpemVzID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlclNpemUoKHN3aXRjaFNpemVzID8gYmxvY2tTaXplIDogaW5saW5lU2l6ZSkgfHwgMCwgKHN3aXRjaFNpemVzID8gaW5saW5lU2l6ZSA6IGJsb2NrU2l6ZSkgfHwgMCk7XG59O1xudmFyIHplcm9Cb3hlcyA9IGZyZWV6ZSh7XG4gIGRldmljZVBpeGVsQ29udGVudEJveFNpemU6IHNpemUoKSxcbiAgYm9yZGVyQm94U2l6ZTogc2l6ZSgpLFxuICBjb250ZW50Qm94U2l6ZTogc2l6ZSgpLFxuICBjb250ZW50UmVjdDogbmV3IERPTVJlY3RSZWFkT25seSgwLCAwLCAwLCAwKVxufSk7XG52YXIgY2FsY3VsYXRlQm94U2l6ZXMgPSBmdW5jdGlvbih0YXJnZXQsIGZvcmNlUmVjYWxjdWxhdGlvbikge1xuICBpZiAoZm9yY2VSZWNhbGN1bGF0aW9uID09PSB2b2lkIDApIHtcbiAgICBmb3JjZVJlY2FsY3VsYXRpb24gPSBmYWxzZTtcbiAgfVxuICBpZiAoY2FjaGUzLmhhcyh0YXJnZXQpICYmICFmb3JjZVJlY2FsY3VsYXRpb24pIHtcbiAgICByZXR1cm4gY2FjaGUzLmdldCh0YXJnZXQpO1xuICB9XG4gIGlmIChpc0hpZGRlbih0YXJnZXQpKSB7XG4gICAgY2FjaGUzLnNldCh0YXJnZXQsIHplcm9Cb3hlcyk7XG4gICAgcmV0dXJuIHplcm9Cb3hlcztcbiAgfVxuICB2YXIgY3MgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XG4gIHZhciBzdmcgPSBpc1NWRyh0YXJnZXQpICYmIHRhcmdldC5vd25lclNWR0VsZW1lbnQgJiYgdGFyZ2V0LmdldEJCb3goKTtcbiAgdmFyIHJlbW92ZVBhZGRpbmcgPSAhSUUgJiYgY3MuYm94U2l6aW5nID09PSBcImJvcmRlci1ib3hcIjtcbiAgdmFyIHN3aXRjaFNpemVzID0gdmVydGljYWxSZWdleHAudGVzdChjcy53cml0aW5nTW9kZSB8fCBcIlwiKTtcbiAgdmFyIGNhblNjcm9sbFZlcnRpY2FsbHkgPSAhc3ZnICYmIHNjcm9sbFJlZ2V4cC50ZXN0KGNzLm92ZXJmbG93WSB8fCBcIlwiKTtcbiAgdmFyIGNhblNjcm9sbEhvcml6b250YWxseSA9ICFzdmcgJiYgc2Nyb2xsUmVnZXhwLnRlc3QoY3Mub3ZlcmZsb3dYIHx8IFwiXCIpO1xuICB2YXIgcGFkZGluZ1RvcCA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5wYWRkaW5nVG9wKTtcbiAgdmFyIHBhZGRpbmdSaWdodCA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5wYWRkaW5nUmlnaHQpO1xuICB2YXIgcGFkZGluZ0JvdHRvbSA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5wYWRkaW5nQm90dG9tKTtcbiAgdmFyIHBhZGRpbmdMZWZ0ID0gc3ZnID8gMCA6IHBhcnNlRGltZW5zaW9uKGNzLnBhZGRpbmdMZWZ0KTtcbiAgdmFyIGJvcmRlclRvcCA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5ib3JkZXJUb3BXaWR0aCk7XG4gIHZhciBib3JkZXJSaWdodCA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5ib3JkZXJSaWdodFdpZHRoKTtcbiAgdmFyIGJvcmRlckJvdHRvbSA9IHN2ZyA/IDAgOiBwYXJzZURpbWVuc2lvbihjcy5ib3JkZXJCb3R0b21XaWR0aCk7XG4gIHZhciBib3JkZXJMZWZ0ID0gc3ZnID8gMCA6IHBhcnNlRGltZW5zaW9uKGNzLmJvcmRlckxlZnRXaWR0aCk7XG4gIHZhciBob3Jpem9udGFsUGFkZGluZyA9IHBhZGRpbmdMZWZ0ICsgcGFkZGluZ1JpZ2h0O1xuICB2YXIgdmVydGljYWxQYWRkaW5nID0gcGFkZGluZ1RvcCArIHBhZGRpbmdCb3R0b207XG4gIHZhciBob3Jpem9udGFsQm9yZGVyQXJlYSA9IGJvcmRlckxlZnQgKyBib3JkZXJSaWdodDtcbiAgdmFyIHZlcnRpY2FsQm9yZGVyQXJlYSA9IGJvcmRlclRvcCArIGJvcmRlckJvdHRvbTtcbiAgdmFyIGhvcml6b250YWxTY3JvbGxiYXJUaGlja25lc3MgPSAhY2FuU2Nyb2xsSG9yaXpvbnRhbGx5ID8gMCA6IHRhcmdldC5vZmZzZXRIZWlnaHQgLSB2ZXJ0aWNhbEJvcmRlckFyZWEgLSB0YXJnZXQuY2xpZW50SGVpZ2h0O1xuICB2YXIgdmVydGljYWxTY3JvbGxiYXJUaGlja25lc3MgPSAhY2FuU2Nyb2xsVmVydGljYWxseSA/IDAgOiB0YXJnZXQub2Zmc2V0V2lkdGggLSBob3Jpem9udGFsQm9yZGVyQXJlYSAtIHRhcmdldC5jbGllbnRXaWR0aDtcbiAgdmFyIHdpZHRoUmVkdWN0aW9uID0gcmVtb3ZlUGFkZGluZyA/IGhvcml6b250YWxQYWRkaW5nICsgaG9yaXpvbnRhbEJvcmRlckFyZWEgOiAwO1xuICB2YXIgaGVpZ2h0UmVkdWN0aW9uID0gcmVtb3ZlUGFkZGluZyA/IHZlcnRpY2FsUGFkZGluZyArIHZlcnRpY2FsQm9yZGVyQXJlYSA6IDA7XG4gIHZhciBjb250ZW50V2lkdGggPSBzdmcgPyBzdmcud2lkdGggOiBwYXJzZURpbWVuc2lvbihjcy53aWR0aCkgLSB3aWR0aFJlZHVjdGlvbiAtIHZlcnRpY2FsU2Nyb2xsYmFyVGhpY2tuZXNzO1xuICB2YXIgY29udGVudEhlaWdodCA9IHN2ZyA/IHN2Zy5oZWlnaHQgOiBwYXJzZURpbWVuc2lvbihjcy5oZWlnaHQpIC0gaGVpZ2h0UmVkdWN0aW9uIC0gaG9yaXpvbnRhbFNjcm9sbGJhclRoaWNrbmVzcztcbiAgdmFyIGJvcmRlckJveFdpZHRoID0gY29udGVudFdpZHRoICsgaG9yaXpvbnRhbFBhZGRpbmcgKyB2ZXJ0aWNhbFNjcm9sbGJhclRoaWNrbmVzcyArIGhvcml6b250YWxCb3JkZXJBcmVhO1xuICB2YXIgYm9yZGVyQm94SGVpZ2h0ID0gY29udGVudEhlaWdodCArIHZlcnRpY2FsUGFkZGluZyArIGhvcml6b250YWxTY3JvbGxiYXJUaGlja25lc3MgKyB2ZXJ0aWNhbEJvcmRlckFyZWE7XG4gIHZhciBib3hlcyA9IGZyZWV6ZSh7XG4gICAgZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZTogc2l6ZShNYXRoLnJvdW5kKGNvbnRlbnRXaWR0aCAqIGRldmljZVBpeGVsUmF0aW8pLCBNYXRoLnJvdW5kKGNvbnRlbnRIZWlnaHQgKiBkZXZpY2VQaXhlbFJhdGlvKSwgc3dpdGNoU2l6ZXMpLFxuICAgIGJvcmRlckJveFNpemU6IHNpemUoYm9yZGVyQm94V2lkdGgsIGJvcmRlckJveEhlaWdodCwgc3dpdGNoU2l6ZXMpLFxuICAgIGNvbnRlbnRCb3hTaXplOiBzaXplKGNvbnRlbnRXaWR0aCwgY29udGVudEhlaWdodCwgc3dpdGNoU2l6ZXMpLFxuICAgIGNvbnRlbnRSZWN0OiBuZXcgRE9NUmVjdFJlYWRPbmx5KHBhZGRpbmdMZWZ0LCBwYWRkaW5nVG9wLCBjb250ZW50V2lkdGgsIGNvbnRlbnRIZWlnaHQpXG4gIH0pO1xuICBjYWNoZTMuc2V0KHRhcmdldCwgYm94ZXMpO1xuICByZXR1cm4gYm94ZXM7XG59O1xudmFyIGNhbGN1bGF0ZUJveFNpemUgPSBmdW5jdGlvbih0YXJnZXQsIG9ic2VydmVkQm94LCBmb3JjZVJlY2FsY3VsYXRpb24pIHtcbiAgdmFyIF9hID0gY2FsY3VsYXRlQm94U2l6ZXModGFyZ2V0LCBmb3JjZVJlY2FsY3VsYXRpb24pLCBib3JkZXJCb3hTaXplID0gX2EuYm9yZGVyQm94U2l6ZSwgY29udGVudEJveFNpemUgPSBfYS5jb250ZW50Qm94U2l6ZSwgZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZSA9IF9hLmRldmljZVBpeGVsQ29udGVudEJveFNpemU7XG4gIHN3aXRjaCAob2JzZXJ2ZWRCb3gpIHtcbiAgICBjYXNlIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucy5ERVZJQ0VfUElYRUxfQ09OVEVOVF9CT1g6XG4gICAgICByZXR1cm4gZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZTtcbiAgICBjYXNlIFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucy5CT1JERVJfQk9YOlxuICAgICAgcmV0dXJuIGJvcmRlckJveFNpemU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjb250ZW50Qm94U2l6ZTtcbiAgfVxufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9SZXNpemVPYnNlcnZlckVudHJ5LmpzXG52YXIgUmVzaXplT2JzZXJ2ZXJFbnRyeSA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckVudHJ5Mih0YXJnZXQpIHtcbiAgICB2YXIgYm94ZXMgPSBjYWxjdWxhdGVCb3hTaXplcyh0YXJnZXQpO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuY29udGVudFJlY3QgPSBib3hlcy5jb250ZW50UmVjdDtcbiAgICB0aGlzLmJvcmRlckJveFNpemUgPSBmcmVlemUoW2JveGVzLmJvcmRlckJveFNpemVdKTtcbiAgICB0aGlzLmNvbnRlbnRCb3hTaXplID0gZnJlZXplKFtib3hlcy5jb250ZW50Qm94U2l6ZV0pO1xuICAgIHRoaXMuZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZSA9IGZyZWV6ZShbYm94ZXMuZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZV0pO1xuICB9XG4gIHJldHVybiBSZXNpemVPYnNlcnZlckVudHJ5Mjtcbn0oKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9hbGdvcml0aG1zL2NhbGN1bGF0ZURlcHRoRm9yTm9kZS5qc1xudmFyIGNhbGN1bGF0ZURlcHRoRm9yTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYgKGlzSGlkZGVuKG5vZGUpKSB7XG4gICAgcmV0dXJuIEluZmluaXR5O1xuICB9XG4gIHZhciBkZXB0aCA9IDA7XG4gIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBkZXB0aCArPSAxO1xuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBkZXB0aDtcbn07XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvYWxnb3JpdGhtcy9icm9hZGNhc3RBY3RpdmVPYnNlcnZhdGlvbnMuanNcbnZhciBicm9hZGNhc3RBY3RpdmVPYnNlcnZhdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNoYWxsb3dlc3REZXB0aCA9IEluZmluaXR5O1xuICB2YXIgY2FsbGJhY2tzMiA9IFtdO1xuICByZXNpemVPYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiBwcm9jZXNzT2JzZXJ2ZXIocm8pIHtcbiAgICBpZiAocm8uYWN0aXZlVGFyZ2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICByby5hY3RpdmVUYXJnZXRzLmZvckVhY2goZnVuY3Rpb24gcHJvY2Vzc1RhcmdldChvdCkge1xuICAgICAgdmFyIGVudHJ5ID0gbmV3IFJlc2l6ZU9ic2VydmVyRW50cnkob3QudGFyZ2V0KTtcbiAgICAgIHZhciB0YXJnZXREZXB0aCA9IGNhbGN1bGF0ZURlcHRoRm9yTm9kZShvdC50YXJnZXQpO1xuICAgICAgZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgIG90Lmxhc3RSZXBvcnRlZFNpemUgPSBjYWxjdWxhdGVCb3hTaXplKG90LnRhcmdldCwgb3Qub2JzZXJ2ZWRCb3gpO1xuICAgICAgaWYgKHRhcmdldERlcHRoIDwgc2hhbGxvd2VzdERlcHRoKSB7XG4gICAgICAgIHNoYWxsb3dlc3REZXB0aCA9IHRhcmdldERlcHRoO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNhbGxiYWNrczIucHVzaChmdW5jdGlvbiByZXNpemVPYnNlcnZlckNhbGxiYWNrKCkge1xuICAgICAgcm8uY2FsbGJhY2suY2FsbChyby5vYnNlcnZlciwgZW50cmllcywgcm8ub2JzZXJ2ZXIpO1xuICAgIH0pO1xuICAgIHJvLmFjdGl2ZVRhcmdldHMuc3BsaWNlKDAsIHJvLmFjdGl2ZVRhcmdldHMubGVuZ3RoKTtcbiAgfSk7XG4gIGZvciAodmFyIF9pID0gMCwgY2FsbGJhY2tzXzEgPSBjYWxsYmFja3MyOyBfaSA8IGNhbGxiYWNrc18xLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrc18xW19pXTtcbiAgICBjYWxsYmFjaygpO1xuICB9XG4gIHJldHVybiBzaGFsbG93ZXN0RGVwdGg7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL2FsZ29yaXRobXMvZ2F0aGVyQWN0aXZlT2JzZXJ2YXRpb25zQXREZXB0aC5qc1xudmFyIGdhdGhlckFjdGl2ZU9ic2VydmF0aW9uc0F0RGVwdGggPSBmdW5jdGlvbihkZXB0aCkge1xuICByZXNpemVPYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiBwcm9jZXNzT2JzZXJ2ZXIocm8pIHtcbiAgICByby5hY3RpdmVUYXJnZXRzLnNwbGljZSgwLCByby5hY3RpdmVUYXJnZXRzLmxlbmd0aCk7XG4gICAgcm8uc2tpcHBlZFRhcmdldHMuc3BsaWNlKDAsIHJvLnNraXBwZWRUYXJnZXRzLmxlbmd0aCk7XG4gICAgcm8ub2JzZXJ2YXRpb25UYXJnZXRzLmZvckVhY2goZnVuY3Rpb24gcHJvY2Vzc1RhcmdldChvdCkge1xuICAgICAgaWYgKG90LmlzQWN0aXZlKCkpIHtcbiAgICAgICAgaWYgKGNhbGN1bGF0ZURlcHRoRm9yTm9kZShvdC50YXJnZXQpID4gZGVwdGgpIHtcbiAgICAgICAgICByby5hY3RpdmVUYXJnZXRzLnB1c2gob3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvLnNraXBwZWRUYXJnZXRzLnB1c2gob3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9wcm9jZXNzLmpzXG52YXIgcHJvY2VzczIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRlcHRoID0gMDtcbiAgZ2F0aGVyQWN0aXZlT2JzZXJ2YXRpb25zQXREZXB0aChkZXB0aCk7XG4gIHdoaWxlIChoYXNBY3RpdmVPYnNlcnZhdGlvbnMoKSkge1xuICAgIGRlcHRoID0gYnJvYWRjYXN0QWN0aXZlT2JzZXJ2YXRpb25zKCk7XG4gICAgZ2F0aGVyQWN0aXZlT2JzZXJ2YXRpb25zQXREZXB0aChkZXB0aCk7XG4gIH1cbiAgaWYgKGhhc1NraXBwZWRPYnNlcnZhdGlvbnMoKSkge1xuICAgIGRlbGl2ZXJSZXNpemVMb29wRXJyb3IoKTtcbiAgfVxuICByZXR1cm4gZGVwdGggPiAwO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9xdWV1ZU1pY3JvVGFzay5qc1xudmFyIHRyaWdnZXI7XG52YXIgY2FsbGJhY2tzID0gW107XG52YXIgbm90aWZ5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBjYWxsYmFja3Muc3BsaWNlKDApLmZvckVhY2goZnVuY3Rpb24oY2IyKSB7XG4gICAgcmV0dXJuIGNiMigpO1xuICB9KTtcbn07XG52YXIgcXVldWVNaWNyb1Rhc2sgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICBpZiAoIXRyaWdnZXIpIHtcbiAgICB2YXIgdG9nZ2xlXzEgPSAwO1xuICAgIHZhciBlbF8xID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7XG4gICAgdmFyIGNvbmZpZyA9IHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9O1xuICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5vdGlmeSgpO1xuICAgIH0pLm9ic2VydmUoZWxfMSwgY29uZmlnKTtcbiAgICB0cmlnZ2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICBlbF8xLnRleHRDb250ZW50ID0gXCJcIiArICh0b2dnbGVfMSA/IHRvZ2dsZV8xLS0gOiB0b2dnbGVfMSsrKTtcbiAgICB9O1xuICB9XG4gIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgdHJpZ2dlcigpO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9xdWV1ZVJlc2l6ZU9ic2VydmVyLmpzXG52YXIgcXVldWVSZXNpemVPYnNlcnZlciA9IGZ1bmN0aW9uKGNiMikge1xuICBxdWV1ZU1pY3JvVGFzayhmdW5jdGlvbiBSZXNpemVPYnNlcnZlcjIoKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiMik7XG4gIH0pO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi91dGlscy9zY2hlZHVsZXIuanNcbnZhciB3YXRjaGluZyA9IDA7XG52YXIgaXNXYXRjaGluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISF3YXRjaGluZztcbn07XG52YXIgQ0FUQ0hfUEVSSU9EID0gMjUwO1xudmFyIG9ic2VydmVyQ29uZmlnID0geyBhdHRyaWJ1dGVzOiB0cnVlLCBjaGFyYWN0ZXJEYXRhOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfTtcbnZhciBldmVudHMgPSBbXG4gIFwicmVzaXplXCIsXG4gIFwibG9hZFwiLFxuICBcInRyYW5zaXRpb25lbmRcIixcbiAgXCJhbmltYXRpb25lbmRcIixcbiAgXCJhbmltYXRpb25zdGFydFwiLFxuICBcImFuaW1hdGlvbml0ZXJhdGlvblwiLFxuICBcImtleXVwXCIsXG4gIFwia2V5ZG93blwiLFxuICBcIm1vdXNldXBcIixcbiAgXCJtb3VzZWRvd25cIixcbiAgXCJtb3VzZW92ZXJcIixcbiAgXCJtb3VzZW91dFwiLFxuICBcImJsdXJcIixcbiAgXCJmb2N1c1wiXG5dO1xudmFyIHRpbWUgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0ID09PSB2b2lkIDApIHtcbiAgICB0aW1lb3V0ID0gMDtcbiAgfVxuICByZXR1cm4gRGF0ZS5ub3coKSArIHRpbWVvdXQ7XG59O1xudmFyIHNjaGVkdWxlZCA9IGZhbHNlO1xudmFyIFNjaGVkdWxlciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBTY2hlZHVsZXIyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX3RoaXMuc2NoZWR1bGUoKTtcbiAgICB9O1xuICB9XG4gIFNjaGVkdWxlcjIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICh0aW1lb3V0ID09PSB2b2lkIDApIHtcbiAgICAgIHRpbWVvdXQgPSBDQVRDSF9QRVJJT0Q7XG4gICAgfVxuICAgIGlmIChzY2hlZHVsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICB2YXIgdW50aWwgPSB0aW1lKHRpbWVvdXQpO1xuICAgIHF1ZXVlUmVzaXplT2JzZXJ2ZXIoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZWxlbWVudHNIYXZlUmVzaXplZCA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZWxlbWVudHNIYXZlUmVzaXplZCA9IHByb2Nlc3MyKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgdGltZW91dCA9IHVudGlsIC0gdGltZSgpO1xuICAgICAgICBpZiAoIWlzV2F0Y2hpbmcoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudHNIYXZlUmVzaXplZCkge1xuICAgICAgICAgIF90aGlzLnJ1bigxZTMpO1xuICAgICAgICB9IGVsc2UgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgX3RoaXMucnVuKHRpbWVvdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgU2NoZWR1bGVyMi5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICB0aGlzLnJ1bigpO1xuICB9O1xuICBTY2hlZHVsZXIyLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgY2IyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX3RoaXMub2JzZXJ2ZXIgJiYgX3RoaXMub2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5ib2R5LCBvYnNlcnZlckNvbmZpZyk7XG4gICAgfTtcbiAgICBkb2N1bWVudC5ib2R5ID8gY2IyKCkgOiBnbG9iYWwyLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGNiMik7XG4gIH07XG4gIFNjaGVkdWxlcjIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAodGhpcy5zdG9wcGVkKSB7XG4gICAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLmxpc3RlbmVyKTtcbiAgICAgIHRoaXMub2JzZXJ2ZSgpO1xuICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsMi5hZGRFdmVudExpc3RlbmVyKG5hbWUsIF90aGlzLmxpc3RlbmVyLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgU2NoZWR1bGVyMi5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKCF0aGlzLnN0b3BwZWQpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXIgJiYgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWwyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgX3RoaXMubGlzdGVuZXIsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFNjaGVkdWxlcjI7XG59KCk7XG52YXIgc2NoZWR1bGVyID0gbmV3IFNjaGVkdWxlcigpO1xudmFyIHVwZGF0ZUNvdW50ID0gZnVuY3Rpb24obikge1xuICAhd2F0Y2hpbmcgJiYgbiA+IDAgJiYgc2NoZWR1bGVyLnN0YXJ0KCk7XG4gIHdhdGNoaW5nICs9IG47XG4gICF3YXRjaGluZyAmJiBzY2hlZHVsZXIuc3RvcCgpO1xufTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL0BqdWdnbGUvcmVzaXplLW9ic2VydmVyL2xpYi9SZXNpemVPYnNlcnZhdGlvbi5qc1xudmFyIHNraXBOb3RpZnlPbkVsZW1lbnQgPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgcmV0dXJuICFpc1NWRyh0YXJnZXQpICYmICFpc1JlcGxhY2VkRWxlbWVudCh0YXJnZXQpICYmIGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KS5kaXNwbGF5ID09PSBcImlubGluZVwiO1xufTtcbnZhciBSZXNpemVPYnNlcnZhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBSZXNpemVPYnNlcnZhdGlvbjIodGFyZ2V0LCBvYnNlcnZlZEJveCkge1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMub2JzZXJ2ZWRCb3ggPSBvYnNlcnZlZEJveCB8fCBSZXNpemVPYnNlcnZlckJveE9wdGlvbnMuQ09OVEVOVF9CT1g7XG4gICAgdGhpcy5sYXN0UmVwb3J0ZWRTaXplID0ge1xuICAgICAgaW5saW5lU2l6ZTogMCxcbiAgICAgIGJsb2NrU2l6ZTogMFxuICAgIH07XG4gIH1cbiAgUmVzaXplT2JzZXJ2YXRpb24yLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzaXplMiA9IGNhbGN1bGF0ZUJveFNpemUodGhpcy50YXJnZXQsIHRoaXMub2JzZXJ2ZWRCb3gsIHRydWUpO1xuICAgIGlmIChza2lwTm90aWZ5T25FbGVtZW50KHRoaXMudGFyZ2V0KSkge1xuICAgICAgdGhpcy5sYXN0UmVwb3J0ZWRTaXplID0gc2l6ZTI7XG4gICAgfVxuICAgIGlmICh0aGlzLmxhc3RSZXBvcnRlZFNpemUuaW5saW5lU2l6ZSAhPT0gc2l6ZTIuaW5saW5lU2l6ZSB8fCB0aGlzLmxhc3RSZXBvcnRlZFNpemUuYmxvY2tTaXplICE9PSBzaXplMi5ibG9ja1NpemUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIHJldHVybiBSZXNpemVPYnNlcnZhdGlvbjI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvUmVzaXplT2JzZXJ2ZXJEZXRhaWwuanNcbnZhciBSZXNpemVPYnNlcnZlckRldGFpbCA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckRldGFpbDIocmVzaXplT2JzZXJ2ZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5hY3RpdmVUYXJnZXRzID0gW107XG4gICAgdGhpcy5za2lwcGVkVGFyZ2V0cyA9IFtdO1xuICAgIHRoaXMub2JzZXJ2YXRpb25UYXJnZXRzID0gW107XG4gICAgdGhpcy5vYnNlcnZlciA9IHJlc2l6ZU9ic2VydmVyO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJEZXRhaWwyO1xufSgpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvQGp1Z2dsZS9yZXNpemUtb2JzZXJ2ZXIvbGliL1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5qc1xudmFyIG9ic2VydmVyTWFwID0gbmV3IFdlYWtNYXAoKTtcbnZhciBnZXRPYnNlcnZhdGlvbkluZGV4ID0gZnVuY3Rpb24ob2JzZXJ2YXRpb25UYXJnZXRzLCB0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYnNlcnZhdGlvblRhcmdldHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAob2JzZXJ2YXRpb25UYXJnZXRzW2ldLnRhcmdldCA9PT0gdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcbnZhciBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyMigpIHtcbiAgfVxuICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIyLmNvbm5lY3QgPSBmdW5jdGlvbihyZXNpemVPYnNlcnZlciwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGV0YWlsID0gbmV3IFJlc2l6ZU9ic2VydmVyRGV0YWlsKHJlc2l6ZU9ic2VydmVyLCBjYWxsYmFjayk7XG4gICAgb2JzZXJ2ZXJNYXAuc2V0KHJlc2l6ZU9ic2VydmVyLCBkZXRhaWwpO1xuICB9O1xuICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIyLm9ic2VydmUgPSBmdW5jdGlvbihyZXNpemVPYnNlcnZlciwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgdmFyIGRldGFpbCA9IG9ic2VydmVyTWFwLmdldChyZXNpemVPYnNlcnZlcik7XG4gICAgdmFyIGZpcnN0T2JzZXJ2YXRpb24gPSBkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLmxlbmd0aCA9PT0gMDtcbiAgICBpZiAoZ2V0T2JzZXJ2YXRpb25JbmRleChkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLCB0YXJnZXQpIDwgMCkge1xuICAgICAgZmlyc3RPYnNlcnZhdGlvbiAmJiByZXNpemVPYnNlcnZlcnMucHVzaChkZXRhaWwpO1xuICAgICAgZGV0YWlsLm9ic2VydmF0aW9uVGFyZ2V0cy5wdXNoKG5ldyBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQsIG9wdGlvbnMgJiYgb3B0aW9ucy5ib3gpKTtcbiAgICAgIHVwZGF0ZUNvdW50KDEpO1xuICAgICAgc2NoZWR1bGVyLnNjaGVkdWxlKCk7XG4gICAgfVxuICB9O1xuICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIyLnVub2JzZXJ2ZSA9IGZ1bmN0aW9uKHJlc2l6ZU9ic2VydmVyLCB0YXJnZXQpIHtcbiAgICB2YXIgZGV0YWlsID0gb2JzZXJ2ZXJNYXAuZ2V0KHJlc2l6ZU9ic2VydmVyKTtcbiAgICB2YXIgaW5kZXggPSBnZXRPYnNlcnZhdGlvbkluZGV4KGRldGFpbC5vYnNlcnZhdGlvblRhcmdldHMsIHRhcmdldCk7XG4gICAgdmFyIGxhc3RPYnNlcnZhdGlvbiA9IGRldGFpbC5vYnNlcnZhdGlvblRhcmdldHMubGVuZ3RoID09PSAxO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBsYXN0T2JzZXJ2YXRpb24gJiYgcmVzaXplT2JzZXJ2ZXJzLnNwbGljZShyZXNpemVPYnNlcnZlcnMuaW5kZXhPZihkZXRhaWwpLCAxKTtcbiAgICAgIGRldGFpbC5vYnNlcnZhdGlvblRhcmdldHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHVwZGF0ZUNvdW50KC0xKTtcbiAgICB9XG4gIH07XG4gIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcjIuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKHJlc2l6ZU9ic2VydmVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgZGV0YWlsID0gb2JzZXJ2ZXJNYXAuZ2V0KHJlc2l6ZU9ic2VydmVyKTtcbiAgICBkZXRhaWwub2JzZXJ2YXRpb25UYXJnZXRzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbihvdCkge1xuICAgICAgcmV0dXJuIF90aGlzLnVub2JzZXJ2ZShyZXNpemVPYnNlcnZlciwgb3QudGFyZ2V0KTtcbiAgICB9KTtcbiAgICBkZXRhaWwuYWN0aXZlVGFyZ2V0cy5zcGxpY2UoMCwgZGV0YWlsLmFjdGl2ZVRhcmdldHMubGVuZ3RoKTtcbiAgfTtcbiAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcjI7XG59KCk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9AanVnZ2xlL3Jlc2l6ZS1vYnNlcnZlci9saWIvUmVzaXplT2JzZXJ2ZXIuanNcbnZhciBSZXNpemVPYnNlcnZlciA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlcjIoY2FsbGJhY2spIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Jlc2l6ZU9ic2VydmVyJzogMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LlwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVzaXplT2JzZXJ2ZXInOiBUaGUgY2FsbGJhY2sgcHJvdmlkZWQgYXMgcGFyYW1ldGVyIDEgaXMgbm90IGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuY29ubmVjdCh0aGlzLCBjYWxsYmFjayk7XG4gIH1cbiAgUmVzaXplT2JzZXJ2ZXIyLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24odGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAnb2JzZXJ2ZScgb24gJ1Jlc2l6ZU9ic2VydmVyJzogMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LlwiKTtcbiAgICB9XG4gICAgaWYgKCFpc0VsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICdvYnNlcnZlJyBvbiAnUmVzaXplT2JzZXJ2ZXInOiBwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSAnRWxlbWVudFwiKTtcbiAgICB9XG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLm9ic2VydmUodGhpcywgdGFyZ2V0LCBvcHRpb25zKTtcbiAgfTtcbiAgUmVzaXplT2JzZXJ2ZXIyLnByb3RvdHlwZS51bm9ic2VydmUgPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICd1bm9ic2VydmUnIG9uICdSZXNpemVPYnNlcnZlcic6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC5cIik7XG4gICAgfVxuICAgIGlmICghaXNFbGVtZW50KHRhcmdldCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAndW5vYnNlcnZlJyBvbiAnUmVzaXplT2JzZXJ2ZXInOiBwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSAnRWxlbWVudFwiKTtcbiAgICB9XG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnVub2JzZXJ2ZSh0aGlzLCB0YXJnZXQpO1xuICB9O1xuICBSZXNpemVPYnNlcnZlcjIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZGlzY29ubmVjdCh0aGlzKTtcbiAgfTtcbiAgUmVzaXplT2JzZXJ2ZXIyLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXIgKCkgeyBbcG9seWZpbGwgY29kZV0gfVwiO1xuICB9O1xuICByZXR1cm4gUmVzaXplT2JzZXJ2ZXIyO1xufSgpO1xuXG4vLyBzcmMvY29tcG9uZW50cy9ob2Mvd2l0aE1lYXN1cmVkU2l6ZS50c3hcbnZhciBERUZBVUxUX1NJWkUgPSAyMDA7XG52YXIgX3NoYXJlZFJlc2l6ZU9ic2VydmVyLCBfY2FsbGJhY2tzO1xudmFyIFNoYXJlZE9ic2VydmVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3NoYXJlZFJlc2l6ZU9ic2VydmVyLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfY2FsbGJhY2tzLCBuZXcgV2Vha01hcCgpKTtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgUmVzaXplT2JzZXJ2ZXIyID0gKF9hID0gd2luZG93LlJlc2l6ZU9ic2VydmVyKSAhPSBudWxsID8gX2EgOiBSZXNpemVPYnNlcnZlcjtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3NoYXJlZFJlc2l6ZU9ic2VydmVyLCBuZXcgUmVzaXplT2JzZXJ2ZXIyKHRoaXMudXBkYXRlUmVzaXplZEVsZW1lbnRzLmJpbmQodGhpcykpKTtcbiAgfVxuICB1cGRhdGVSZXNpemVkRWxlbWVudHMoZW50cmllcykge1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgY29uc3QgY2FsbGJhY2tGb3JFbGVtZW50ID0gX19wcml2YXRlR2V0KHRoaXMsIF9jYWxsYmFja3MpLmdldChlbnRyeS50YXJnZXQpO1xuICAgICAgaWYgKGNhbGxiYWNrRm9yRWxlbWVudClcbiAgICAgICAgY2FsbGJhY2tGb3JFbGVtZW50KGVudHJ5LmNvbnRlbnRSZWN0KTtcbiAgICB9XG4gIH1cbiAgb2JzZXJ2ZUVsZW1lbnRXaXRoQ2FsbGJhY2soZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX3NoYXJlZFJlc2l6ZU9ic2VydmVyKS5vYnNlcnZlKGVsZW1lbnQpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfY2FsbGJhY2tzKS5zZXQoZWxlbWVudCwgY2FsbGJhY2spO1xuICB9XG4gIHVub2JzZXJ2ZShlbGVtZW50KSB7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9zaGFyZWRSZXNpemVPYnNlcnZlcikudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfY2FsbGJhY2tzKS5kZWxldGUoZWxlbWVudCk7XG4gIH1cbn07XG5fc2hhcmVkUmVzaXplT2JzZXJ2ZXIgPSBuZXcgV2Vha01hcCgpO1xuX2NhbGxiYWNrcyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgc2hhcmVkUmVzaXplT2JzZXJ2ZXIgPSBuZXcgU2hhcmVkT2JzZXJ2ZXIoKTtcbmZ1bmN0aW9uIHVzZU1lYXN1cmVkU2l6ZShyZWYpIHtcbiAgY29uc3QgZm9yY2VVcGRhdGUgPSB1c2VGb3JjZVVwZGF0ZTIoKTtcbiAgY29uc3Qgc2l6ZTIgPSB1c2VSZWYxMihudWxsKTtcbiAgZnVuY3Rpb24gdXBkYXRlU2l6ZShuZXdTaXplKSB7XG4gICAgaWYgKG5ld1NpemUud2lkdGggPT09IDAgJiYgbmV3U2l6ZS5oZWlnaHQgPT09IDApXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFzaXplMi5jdXJyZW50IHx8IG5ld1NpemUuaGVpZ2h0ICE9PSBzaXplMi5jdXJyZW50LmhlaWdodCB8fCBuZXdTaXplLndpZHRoICE9PSBzaXplMi5jdXJyZW50LndpZHRoKSB7XG4gICAgICBzaXplMi5jdXJyZW50ID0geyB3aWR0aDogbmV3U2l6ZS53aWR0aCwgaGVpZ2h0OiBuZXdTaXplLmhlaWdodCB9O1xuICAgICAgZm9yY2VVcGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgdXNlTGF5b3V0RWZmZWN0MigoKSA9PiB7XG4gICAgaWYgKCFyZWYuY3VycmVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IG9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQgfSA9IHJlZi5jdXJyZW50O1xuICAgIHVwZGF0ZVNpemUoe1xuICAgICAgd2lkdGg6IG9mZnNldFdpZHRoLFxuICAgICAgaGVpZ2h0OiBvZmZzZXRIZWlnaHRcbiAgICB9KTtcbiAgICBzaGFyZWRSZXNpemVPYnNlcnZlci5vYnNlcnZlRWxlbWVudFdpdGhDYWxsYmFjayhyZWYuY3VycmVudCwgdXBkYXRlU2l6ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICghcmVmLmN1cnJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHNoYXJlZFJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShyZWYuY3VycmVudCk7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gc2l6ZTIuY3VycmVudDtcbn1cbnZhciBTSVpFX0NPTVBBVElCSUxJVFlfV1JBUFBFUl9BVFRSSUJVVEUgPSBcImRhdGEtZnJhbWVyLXNpemUtY29tcGF0aWJpbGl0eS13cmFwcGVyXCI7XG52YXIgd2l0aE1lYXN1cmVkU2l6ZSA9IChDb21wb25lbnQxOSkgPT4gKHByb3BzKSA9PiB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgY29uc3QgcmVmID0gdXNlUmVmMTIobnVsbCk7XG4gIGNvbnN0IHNpemUyID0gdXNlTWVhc3VyZWRTaXplKHJlZik7XG4gIGNvbnN0IGRhdGFQcm9wcyA9IHsgW1NJWkVfQ09NUEFUSUJJTElUWV9XUkFQUEVSX0FUVFJJQlVURV06IHRydWUgfTtcbiAgY29uc3Qgc2hvdWxkUmVuZGVyID0gQm9vbGVhbihzaXplMik7XG4gIGNvbnN0IGZhbGxiYWNrV2lkdGggPSAoX2EgPSBwcm9wcy53aWR0aCkgIT0gbnVsbCA/IF9hIDogREVGQVVMVF9TSVpFO1xuICBjb25zdCBmYWxsYmFja0hlaWdodCA9IChfYiA9IHByb3BzLmhlaWdodCkgIT0gbnVsbCA/IF9iIDogREVGQVVMVF9TSVpFO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQxMyhcImRpdlwiLCB7XG4gICAgc3R5bGU6IHsgd2lkdGg6IFwiMTAwJVwiLCBoZWlnaHQ6IFwiMTAwJVwiLCBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIiB9LFxuICAgIHJlZixcbiAgICAuLi5kYXRhUHJvcHNcbiAgfSwgc2hvdWxkUmVuZGVyICYmIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MTMoQ29tcG9uZW50MTksIHtcbiAgICAuLi5wcm9wcyxcbiAgICB3aWR0aDogKF9jID0gc2l6ZTIgPT0gbnVsbCA/IHZvaWQgMCA6IHNpemUyLndpZHRoKSAhPSBudWxsID8gX2MgOiBmYWxsYmFja1dpZHRoLFxuICAgIGhlaWdodDogKF9kID0gc2l6ZTIgPT0gbnVsbCA/IHZvaWQgMCA6IHNpemUyLmhlaWdodCkgIT0gbnVsbCA/IF9kIDogZmFsbGJhY2tIZWlnaHRcbiAgfSkpO1xufTtcblxuLy8gc3JjL3JlbmRlci91dGlscy9nZXRNZWFzdXJhYmxlQ29kZUNvbXBvbmVudENoaWxkcmVuLnRzXG5mdW5jdGlvbiBnZXRNZWFzdXJhYmxlQ29kZUNvbXBvbmVudENoaWxkcmVuKGVsZW1lbnQpIHtcbiAgY29uc3QgY2hpbGRyZW5Db2xsZWN0aW9uID0gZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCAmJiBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkLmhhc0F0dHJpYnV0ZShTSVpFX0NPTVBBVElCSUxJVFlfV1JBUFBFUl9BVFRSSUJVVEUpID8gZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZC5jaGlsZHJlbiA6IGVsZW1lbnQuY2hpbGRyZW47XG4gIHJldHVybiBbLi4uY2hpbGRyZW5Db2xsZWN0aW9uXS5maWx0ZXIoaXNNZWFzdXJhYmxlKS5tYXAodW53cmFwSW5saW5lZERpc3BsYXlDb250ZW50cyk7XG59XG5mdW5jdGlvbiBpc01lYXN1cmFibGUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxCYXNlRWxlbWVudCB8fCBlbGVtZW50IGluc3RhbmNlb2YgSFRNTEhlYWRFbGVtZW50IHx8IGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MTGlua0VsZW1lbnQgfHwgZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxNZXRhRWxlbWVudCB8fCBlbGVtZW50IGluc3RhbmNlb2YgSFRNTFNjcmlwdEVsZW1lbnQgfHwgZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxTdHlsZUVsZW1lbnQgfHwgZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxUaXRsZUVsZW1lbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBlbGVtZW50IGluc3RhbmNlb2YgU1ZHRWxlbWVudDtcbn1cbmZ1bmN0aW9uIHVud3JhcElubGluZWREaXNwbGF5Q29udGVudHMoZWxlbWVudCkge1xuICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKVxuICAgIHJldHVybiBlbGVtZW50O1xuICBpZiAoZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIGlmIChlbGVtZW50LnN0eWxlLmRpc3BsYXkgIT09IFwiY29udGVudHNcIilcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgY29uc3QgZmlyc3RNZWFzdXJhYmxlQ2hpbGQgPSBbLi4uZWxlbWVudC5jaGlsZHJlbl0uZmluZChpc01lYXN1cmFibGUpO1xuICBpZiAoZmlyc3RNZWFzdXJhYmxlQ2hpbGQpIHtcbiAgICByZXR1cm4gdW53cmFwSW5saW5lZERpc3BsYXlDb250ZW50cyhmaXJzdE1lYXN1cmFibGVDaGlsZCk7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8vIHNyYy9yZW5kZXIvdXRpbHMvdXNlTWVhc3VyZUxheW91dC50c1xuZnVuY3Rpb24gdXNlTWVhc3VyZUxheW91dChwcm9wcywgcmVmLCBnZXRDaGlsZHJlbiA9ICgpID0+IFtdLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyBpZCwgdmlzaWJsZSwgX25lZWRzTWVhc3VyZSB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgc2tpcEhvb2sgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgY29uc3QgaW5Db2RlQ29tcG9uZW50ID0gQm9vbGVhbih1c2VDb250ZXh0MTkoQ29tcG9uZW50Q29udGFpbmVyQ29udGV4dCkpO1xuICBjb25zdCBvbkNhbnZhcyA9IFJlbmRlclRhcmdldC5jdXJyZW50KCkgPT09IFJlbmRlclRhcmdldC5jYW52YXM7XG4gIHVzZUxheW91dEVmZmVjdDMoKCkgPT4ge1xuICAgIGlmICghb25DYW52YXMgfHwgaW5Db2RlQ29tcG9uZW50IHx8IHNraXBIb29rKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghKHJlZi5jdXJyZW50ICYmIGlkICYmIHZpc2libGUgJiYgX25lZWRzTWVhc3VyZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcnVudGltZS5xdWV1ZU1lYXN1cmVSZXF1ZXN0KG5vZGVJZEZyb21TdHJpbmcoaWQpLCByZWYuY3VycmVudCwgZ2V0Q2hpbGRyZW4ocmVmLmN1cnJlbnQpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBtZWFzdXJlQ2xvc2VzdENvbXBvbmVudENvbnRhaW5lcihlbGVtZW50KSB7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGVsZW1lbnQuY2xvc2VzdChcIltkYXRhLWZyYW1lci1jb21wb25lbnQtY29udGFpbmVyXVwiKTtcbiAgaWYgKCFjb250YWluZXIpXG4gICAgcmV0dXJuO1xuICBydW50aW1lLnF1ZXVlTWVhc3VyZVJlcXVlc3Qobm9kZUlkRnJvbVN0cmluZyhjb250YWluZXIuaWQpLCBjb250YWluZXIsIGdldE1lYXN1cmFibGVDb2RlQ29tcG9uZW50Q2hpbGRyZW4oY29udGFpbmVyKSk7XG59XG5cbi8vIHNyYy9yZW5kZXIvdXRpbHMvbGF5b3V0SGludERhdGFQcm9wc0ZvckNlbnRlci50c1xudmFyIGlzQ2hyb21lMiA9IGlzQ2hyb21lKCk7XG5mdW5jdGlvbiBsYXlvdXRIaW50RGF0YVByb3BzRm9yQ2VudGVyKGNlbnRlcikge1xuICBjb25zdCBwcm9wcyA9IHt9O1xuICBpZiAoIWlzQ2hyb21lMiB8fCBSZW5kZXJUYXJnZXQuY3VycmVudCgpICE9PSBSZW5kZXJUYXJnZXQuY2FudmFzKSB7XG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG4gIGlmIChjZW50ZXIgPT09IHRydWUgfHwgY2VudGVyID09PSBcInhcIikge1xuICAgIHByb3BzW1wiZGF0YS1mcmFtZXItbGF5b3V0LWhpbnQtY2VudGVyLXhcIl0gPSB0cnVlO1xuICB9XG4gIGlmIChjZW50ZXIgPT09IHRydWUgfHwgY2VudGVyID09PSBcInlcIikge1xuICAgIHByb3BzW1wiZGF0YS1mcmFtZXItbGF5b3V0LWhpbnQtY2VudGVyLXlcIl0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBwcm9wcztcbn1cblxuLy8gc3JjL3JlbmRlci9zdHlsZS9CYWNrZ3JvdW5kSW1hZ2VDb21wb25lbnQudHN4XG5pbXBvcnQge1xuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQxNCxcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDQsXG4gIHVzZVJlZiBhcyB1c2VSZWYxM1xufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3JlbmRlci91dGlscy9pbWFnZVJlbmRlcmluZy50c1xuZnVuY3Rpb24gbWluWm9vbUZvclBpeGVsYXRlZEltYWdlUmVuZGVyaW5nKGltYWdlLCBjb250YWluZXJTaXplLCBkZXZpY2VQaXhlbFJhdGlvMyA9IDEpIHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICBsZXQgeyB3aWR0aDogZnJhbWVXaWR0aCwgaGVpZ2h0OiBmcmFtZUhlaWdodCB9ID0gY29udGFpbmVyU2l6ZTtcbiAgY29uc3QgaW1hZ2VXaWR0aCA9IChfYiA9IChfYSA9IGltYWdlLnBpeGVsV2lkdGgpICE9IG51bGwgPyBfYSA6IGltYWdlLmludHJpbnNpY1dpZHRoKSAhPSBudWxsID8gX2IgOiAwO1xuICBjb25zdCBpbWFnZUhlaWdodCA9IChfZCA9IChfYyA9IGltYWdlLnBpeGVsSGVpZ2h0KSAhPSBudWxsID8gX2MgOiBpbWFnZS5pbnRyaW5zaWNIZWlnaHQpICE9IG51bGwgPyBfZCA6IDA7XG4gIGlmIChmcmFtZVdpZHRoIDwgMSB8fCBmcmFtZUhlaWdodCA8IDEgfHwgaW1hZ2VXaWR0aCA8IDEgfHwgaW1hZ2VIZWlnaHQgPCAxKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBmcmFtZVdpZHRoICo9IGRldmljZVBpeGVsUmF0aW8zO1xuICBmcmFtZUhlaWdodCAqPSBkZXZpY2VQaXhlbFJhdGlvMztcbiAgY29uc3QgZnJhbWVBc3BlY3RSYXRpbyA9IGZyYW1lV2lkdGggLyBmcmFtZUhlaWdodDtcbiAgY29uc3QgaW1hZ2VBc3BlY3RSYXRpbyA9IGltYWdlV2lkdGggLyBpbWFnZUhlaWdodDtcbiAgc3dpdGNoIChpbWFnZS5maXQpIHtcbiAgICBjYXNlIFwiZmlsbFwiOlxuICAgICAgaWYgKGltYWdlQXNwZWN0UmF0aW8gPiBmcmFtZUFzcGVjdFJhdGlvKSB7XG4gICAgICAgIHJldHVybiBpbWFnZUhlaWdodCAvIGZyYW1lSGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGltYWdlV2lkdGggLyBmcmFtZVdpZHRoO1xuICAgICAgfVxuICAgIGNhc2UgXCJmaXRcIjpcbiAgICBjYXNlIFwic3RyZXRjaFwiOlxuICAgICAgcmV0dXJuIE1hdGgubWF4KGltYWdlV2lkdGggLyBmcmFtZVdpZHRoLCBpbWFnZUhlaWdodCAvIGZyYW1lSGVpZ2h0KTtcbiAgfVxufVxuZnVuY3Rpb24gaW1hZ2VSZW5kZXJpbmdGb3Jab29tKHpvb20sIG1pblBpeGVsYXRlZFpvb20pIHtcbiAgaWYgKG1pblBpeGVsYXRlZFpvb20gJiYgTWF0aC5tYXgoMSwgem9vbSkgPiBtaW5QaXhlbGF0ZWRab29tKSB7XG4gICAgcmV0dXJuIFwicGl4ZWxhdGVkXCI7XG4gIH1cbiAgcmV0dXJuIFwiYXV0b1wiO1xufVxuXG4vLyBzcmMvcmVuZGVyL3N0eWxlL0JhY2tncm91bmRJbWFnZUNvbXBvbmVudC50c3hcbnZhciB3cmFwcGVyU3R5bGUgPSB7XG4gIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICB1c2VyU2VsZWN0OiBcIm5vbmVcIixcbiAgYm9yZGVyUmFkaXVzOiBcImluaGVyaXRcIixcbiAgdG9wOiAwLFxuICByaWdodDogMCxcbiAgYm90dG9tOiAwLFxuICBsZWZ0OiAwXG59O1xuZnVuY3Rpb24gY3NzT2JqZWN0Rml0KGltYWdlRml0KSB7XG4gIHN3aXRjaCAoaW1hZ2VGaXQpIHtcbiAgICBjYXNlIFwiZml0XCI6XG4gICAgICByZXR1cm4gXCJjb250YWluXCI7XG4gICAgY2FzZSBcInN0cmV0Y2hcIjpcbiAgICAgIHJldHVybiBcImZpbGxcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiY292ZXJcIjtcbiAgfVxufVxuZnVuY3Rpb24gY3NzSW1hZ2VSZW5kZXJpbmcoaW1hZ2UsIGNvbnRhaW5lclNpemUpIHtcbiAgaWYgKCFjb250YWluZXJTaXplKVxuICAgIHJldHVybiBcImF1dG9cIjtcbiAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbzMgPSBSZW5kZXJUYXJnZXQuY3VycmVudCgpID09PSBSZW5kZXJUYXJnZXQuY2FudmFzID8gc2FmZVdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcbiAgY29uc3QgbWluUGl4ZWxhdGVkWm9vbSA9IG1pblpvb21Gb3JQaXhlbGF0ZWRJbWFnZVJlbmRlcmluZyhpbWFnZSwgY29udGFpbmVyU2l6ZSwgZGV2aWNlUGl4ZWxSYXRpbzMpO1xuICBpZiAoUmVuZGVyVGFyZ2V0LmN1cnJlbnQoKSA9PT0gUmVuZGVyVGFyZ2V0LmNhbnZhcykge1xuICAgIHJldHVybiBpbWFnZVJlbmRlcmluZ0Zvclpvb20oMSwgbWluUGl4ZWxhdGVkWm9vbSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGltYWdlUmVuZGVyaW5nRm9yWm9vbShSZW5kZXJFbnZpcm9ubWVudC56b29tLCBtaW5QaXhlbGF0ZWRab29tKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SW1hZ2VTdHlsZShpbWFnZSwgY29udGFpbmVyU2l6ZSkge1xuICByZXR1cm4ge1xuICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiLFxuICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICBib3JkZXJSYWRpdXM6IFwiaW5oZXJpdFwiLFxuICAgIG9iamVjdFBvc2l0aW9uOiBcImNlbnRlclwiLFxuICAgIG9iamVjdEZpdDogY3NzT2JqZWN0Rml0KGltYWdlLmZpdCksXG4gICAgaW1hZ2VSZW5kZXJpbmc6IGNzc0ltYWdlUmVuZGVyaW5nKGltYWdlLCBjb250YWluZXJTaXplKVxuICB9O1xufVxuZnVuY3Rpb24gQmFja2dyb3VuZEltYWdlQ29tcG9uZW50KHsgaW1hZ2UsIGNvbnRhaW5lclNpemUsIG5vZGVJZCwgbGF5b3V0SWQgfSkge1xuICBjb25zdCB3cmFwcGVyUmVmID0gdXNlUmVmMTMobnVsbCk7XG4gIGNvbnN0IGlzU3RhdGljUmVuZGVyaW5nID0gIWlzQnJvd3NlcjIoKSB8fCBSZW5kZXJUYXJnZXQuY3VycmVudCgpID09PSBSZW5kZXJUYXJnZXQuZXhwb3J0O1xuICBpZiAobGF5b3V0SWQpIHtcbiAgICBsYXlvdXRJZCA9IGxheW91dElkICsgXCItYmFja2dyb3VuZFwiO1xuICB9XG4gIGNvbnN0IHNvdXJjZSA9IHJ1bnRpbWUudXNlSW1hZ2VTb3VyY2UoaW1hZ2UsIGNvbnRhaW5lclNpemUsIG5vZGVJZCk7XG4gIGNvbnN0IGltYWdlU3R5bGUgPSBnZXRJbWFnZVN0eWxlKGltYWdlLCBjb250YWluZXJTaXplKTtcbiAgaWYgKCFpc1N0YXRpY1JlbmRlcmluZykge1xuICAgIGNvbnN0IGltYWdlRWxlbWVudCA9IHJ1bnRpbWUudXNlSW1hZ2VFbGVtZW50KGltYWdlLCBjb250YWluZXJTaXplLCBub2RlSWQpO1xuICAgIHVzZUxheW91dEVmZmVjdDQoKCkgPT4ge1xuICAgICAgY29uc3Qgd3JhcHBlciA9IHdyYXBwZXJSZWYuY3VycmVudDtcbiAgICAgIGlmICh3cmFwcGVyID09PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGltYWdlRWxlbWVudCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB3cmFwcGVyLnJlbW92ZUNoaWxkKGltYWdlRWxlbWVudCk7XG4gICAgICB9O1xuICAgIH0sIFtpbWFnZUVsZW1lbnRdKTtcbiAgICBPYmplY3QuYXNzaWduKGltYWdlRWxlbWVudC5zdHlsZSwgaW1hZ2VTdHlsZSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MTQobW90aW9uLmRpdiwge1xuICAgIHJlZjogd3JhcHBlclJlZixcbiAgICBzdHlsZTogd3JhcHBlclN0eWxlLFxuICAgIGxheW91dElkXG4gIH0sIGlzU3RhdGljUmVuZGVyaW5nID8gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQxNChcImltZ1wiLCB7XG4gICAgc3JjOiBzb3VyY2UsXG4gICAgc3R5bGU6IGltYWdlU3R5bGVcbiAgfSkgOiBudWxsKTtcbn1cblxuLy8gc3JjL3JlbmRlci9wcmVzZW50YXRpb24vRnJhbWUvRnJhbWVXaXRoTW90aW9uLnRzeFxuZnVuY3Rpb24gaGFzRXZlbnRzKHByb3BzKSB7XG4gIGZvciAoY29uc3Qga2V5NiBpbiBwcm9wcykge1xuICAgIGlmIChrZXk2ID09PSBcImRyYWdcIiB8fCBrZXk2LnN0YXJ0c1dpdGgoXCJ3aGlsZVwiKSB8fCB0eXBlb2YgcHJvcHNba2V5Nl0gPT09IFwiZnVuY3Rpb25cIiAmJiBrZXk2LnN0YXJ0c1dpdGgoXCJvblwiKSAmJiAha2V5Ni5pbmNsdWRlcyhcIkFuaW1hdGlvblwiKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbnZhciBwb2ludGVyRXZlbnRzID0gW1xuICBcIm9uQXV4Q2xpY2tcIixcbiAgXCJvbkNsaWNrXCIsXG4gIFwib25Eb3VibGVDbGlja1wiLFxuICBcIm9uTW91c2VcIixcbiAgXCJvbk1vdXNlRG93blwiLFxuICBcIm9uTW91c2VVcFwiLFxuICBcIm9uVGFwRG93blwiLFxuICBcIm9uVGFwXCIsXG4gIFwib25UYXBVcFwiLFxuICBcIm9uUG9pbnRlclwiLFxuICBcIm9uUG9pbnRlckRvd25cIixcbiAgXCJvblBvaW50ZXJVcFwiLFxuICBcIm9uVG91Y2hcIixcbiAgXCJvblRvdWNoRG93blwiLFxuICBcIm9uVG91Y2hVcFwiXG5dO1xudmFyIHBvaW50ZXJFdmVudHNTZXQgPSBuZXcgU2V0KFtcbiAgLi4ucG9pbnRlckV2ZW50cyxcbiAgLi4ucG9pbnRlckV2ZW50cy5tYXAoKGV2ZW50KSA9PiBgJHtldmVudH1DYXB0dXJlYClcbl0pO1xuZnVuY3Rpb24gZ2V0Q3Vyc29yRnJvbUV2ZW50cyhwcm9wcykge1xuICBpZiAocHJvcHMuZHJhZykge1xuICAgIHJldHVybiBcImdyYWJcIjtcbiAgfVxuICBmb3IgKGNvbnN0IGtleTYgaW4gcHJvcHMpIHtcbiAgICBpZiAocG9pbnRlckV2ZW50c1NldC5oYXMoa2V5NikpIHtcbiAgICAgIHJldHVybiBcInBvaW50ZXJcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHVud3JhcEZyYW1lUHJvcHMoZnJhbWVQcm9wcykge1xuICBjb25zdCB7XG4gICAgbGVmdCxcbiAgICB0b3AsXG4gICAgYm90dG9tLFxuICAgIHJpZ2h0LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBtaW5XaWR0aCxcbiAgICBtaW5IZWlnaHQsXG4gICAgY2VudGVyLFxuICAgIF9jb25zdHJhaW50cyxcbiAgICBzaXplOiBzaXplMixcbiAgICB3aWR0aFR5cGUsXG4gICAgaGVpZ2h0VHlwZVxuICB9ID0gZnJhbWVQcm9wcztcbiAgY29uc3QgY29uc3RyYWludFByb3BzID0ge1xuICAgIHRvcDogcmVzb2x2ZU1vdGlvblZhbHVlKHRvcCksXG4gICAgbGVmdDogcmVzb2x2ZU1vdGlvblZhbHVlKGxlZnQpLFxuICAgIGJvdHRvbTogcmVzb2x2ZU1vdGlvblZhbHVlKGJvdHRvbSksXG4gICAgcmlnaHQ6IHJlc29sdmVNb3Rpb25WYWx1ZShyaWdodCksXG4gICAgd2lkdGg6IHJlc29sdmVNb3Rpb25WYWx1ZSh3aWR0aCksXG4gICAgaGVpZ2h0OiByZXNvbHZlTW90aW9uVmFsdWUoaGVpZ2h0KSxcbiAgICBtaW5XaWR0aDogcmVzb2x2ZU1vdGlvblZhbHVlKG1pbldpZHRoKSxcbiAgICBtaW5IZWlnaHQ6IHJlc29sdmVNb3Rpb25WYWx1ZShtaW5IZWlnaHQpLFxuICAgIHNpemU6IHJlc29sdmVNb3Rpb25WYWx1ZShzaXplMiksXG4gICAgY2VudGVyLFxuICAgIF9jb25zdHJhaW50cyxcbiAgICB3aWR0aFR5cGUsXG4gICAgaGVpZ2h0VHlwZVxuICB9O1xuICByZXR1cm4gY29uc3RyYWludFByb3BzO1xufVxudmFyIGRlZmF1bHRGcmFtZVJlY3QgPSB7IHg6IDAsIHk6IDAsIHdpZHRoOiAyMDAsIGhlaWdodDogMjAwIH07XG5mdW5jdGlvbiB1c2VTdHlsZUFuZFJlY3QocHJvcHMpIHtcbiAgaW5qZWN0Q29tcG9uZW50Q1NTUnVsZXMoKTtcbiAgY29uc3QgaW5Db2RlQ29tcG9uZW50ID0gQm9vbGVhbih1c2VDb250ZXh0MjAoQ29tcG9uZW50Q29udGFpbmVyQ29udGV4dCkpO1xuICBjb25zdCB7IHN0eWxlLCBfaW5pdGlhbFN0eWxlLCBfX2Zyb21DYW52YXNDb21wb25lbnQsIHNpemU6IHNpemUyIH0gPSBwcm9wcztcbiAgY29uc3QgdW53cmFwcGVkUHJvcHMgPSB1bndyYXBGcmFtZVByb3BzKHByb3BzKTtcbiAgY29uc3QgY29uc3RyYWludHNSZWN0ID0gdXNlQ29uc3RyYWludHModW53cmFwcGVkUHJvcHMpO1xuICBjb25zdCBkZWZhdWx0U3R5bGUgPSB7XG4gICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgIGZsZXhTaHJpbms6IDAsXG4gICAgdXNlclNlbGVjdDogXCJub25lXCJcbiAgfTtcbiAgaWYgKCFwcm9wcy5fX2Zyb21DYW52YXNDb21wb25lbnQpIHtcbiAgICBkZWZhdWx0U3R5bGUuYmFja2dyb3VuZENvbG9yID0gcHJvcHMuYmFja2dyb3VuZCA9PT0gdm9pZCAwID8gXCJyZ2JhKDAsIDE3MCwgMjU1LCAwLjMpXCIgOiB2b2lkIDA7XG4gIH1cbiAgaWYgKCFoYXNFdmVudHMocHJvcHMpKSB7XG4gICAgZGVmYXVsdFN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgfVxuICBjb25zdCBhZGRUZXh0Q2VudGVyaW5nID0gQ2hpbGRyZW4zLmNvdW50KHByb3BzLmNoaWxkcmVuKSA+IDAgJiYgQ2hpbGRyZW4zLnRvQXJyYXkocHJvcHMuY2hpbGRyZW4pLmV2ZXJ5KChjaGlsZCkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgY2hpbGQgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGNoaWxkID09PSBcIm51bWJlclwiO1xuICB9KTtcbiAgY29uc3QgY2VudGVyVGV4dFN0eWxlID0gYWRkVGV4dENlbnRlcmluZyAmJiB7XG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCJcbiAgfTtcbiAgY29uc3QgcHJvcHNTdHlsZSA9IGdldFN0eWxlRm9yRnJhbWVQcm9wcyhwcm9wcyk7XG4gIGlmIChzaXplMiA9PT0gdm9pZCAwICYmICFfX2Zyb21DYW52YXNDb21wb25lbnQpIHtcbiAgICBpZiAoIWhhc0xlZnRBbmRSaWdodChwcm9wc1N0eWxlKSkge1xuICAgICAgZGVmYXVsdFN0eWxlLndpZHRoID0gZGVmYXVsdEZyYW1lUmVjdC53aWR0aDtcbiAgICB9XG4gICAgaWYgKCFoYXNUb3BBbmRCb3R0b20ocHJvcHNTdHlsZSkpIHtcbiAgICAgIGRlZmF1bHRTdHlsZS5oZWlnaHQgPSBkZWZhdWx0RnJhbWVSZWN0LmhlaWdodDtcbiAgICB9XG4gIH1cbiAgaWYgKHVud3JhcHBlZFByb3BzLm1pbldpZHRoICE9PSB2b2lkIDApIHtcbiAgICBkZWZhdWx0U3R5bGUubWluV2lkdGggPSB1bndyYXBwZWRQcm9wcy5taW5XaWR0aDtcbiAgfVxuICBpZiAodW53cmFwcGVkUHJvcHMubWluSGVpZ2h0ICE9PSB2b2lkIDApIHtcbiAgICBkZWZhdWx0U3R5bGUubWluSGVpZ2h0ID0gdW53cmFwcGVkUHJvcHMubWluSGVpZ2h0O1xuICB9XG4gIGxldCBjb25zdHJhaW50c1N0eWxlID0ge307XG4gIGlmIChjb25zdHJhaW50c0VuYWJsZWQodW53cmFwcGVkUHJvcHMpKSB7XG4gICAgaWYgKGNvbnN0cmFpbnRzUmVjdCAmJiAhaXNBdXRvU2l6ZWQocHJvcHMpKSB7XG4gICAgICBjb25zdHJhaW50c1N0eWxlID0ge1xuICAgICAgICBsZWZ0OiBjb25zdHJhaW50c1JlY3QueCxcbiAgICAgICAgdG9wOiBjb25zdHJhaW50c1JlY3QueSxcbiAgICAgICAgd2lkdGg6IGNvbnN0cmFpbnRzUmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjb25zdHJhaW50c1JlY3QuaGVpZ2h0LFxuICAgICAgICByaWdodDogdm9pZCAwLFxuICAgICAgICBib3R0b206IHZvaWQgMFxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgT2JqZWN0LmFzc2lnbihkZWZhdWx0U3R5bGUsIGNlbnRlclRleHRTdHlsZSwgX2luaXRpYWxTdHlsZSwgcHJvcHNTdHlsZSwgY29uc3RyYWludHNTdHlsZSwgc3R5bGUpO1xuICBMYXllci5hcHBseVdpbGxDaGFuZ2UocHJvcHMsIGRlZmF1bHRTdHlsZSwgdHJ1ZSk7XG4gIGxldCByZXN1bHRTdHlsZSA9IGRlZmF1bHRTdHlsZTtcbiAgaWYgKCFkZWZhdWx0U3R5bGUudHJhbnNmb3JtKSB7XG4gICAgcmVzdWx0U3R5bGUgPSB7IHg6IDAsIHk6IDAsIC4uLmRlZmF1bHRTdHlsZSB9O1xuICB9XG4gIGlmIChwcm9wcy5wb3NpdGlvblN0aWNreSkge1xuICAgIGNvbnN0IG9uQ2FudmFzID0gUmVuZGVyVGFyZ2V0LmN1cnJlbnQoKSA9PT0gUmVuZGVyVGFyZ2V0LmNhbnZhcztcbiAgICBpZiAoIW9uQ2FudmFzIHx8IGluQ29kZUNvbXBvbmVudCkge1xuICAgICAgcmVzdWx0U3R5bGUucG9zaXRpb24gPSBcInN0aWNreVwiO1xuICAgICAgcmVzdWx0U3R5bGUud2lsbENoYW5nZSA9IFwidHJhbnNmb3JtXCI7XG4gICAgICByZXN1bHRTdHlsZS56SW5kZXggPSAxO1xuICAgICAgcmVzdWx0U3R5bGUudG9wID0gcHJvcHMucG9zaXRpb25TdGlja3lUb3A7XG4gICAgICByZXN1bHRTdHlsZS5yaWdodCA9IHByb3BzLnBvc2l0aW9uU3RpY2t5UmlnaHQ7XG4gICAgICByZXN1bHRTdHlsZS5ib3R0b20gPSBwcm9wcy5wb3NpdGlvblN0aWNreUJvdHRvbTtcbiAgICAgIHJlc3VsdFN0eWxlLmxlZnQgPSBwcm9wcy5wb3NpdGlvblN0aWNreUxlZnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBbcmVzdWx0U3R5bGUsIGNvbnN0cmFpbnRzUmVjdF07XG59XG52YXIgZmlsdGVyZWRQcm9wcyA9IG5ldyBTZXQoW1xuICBcIndpZHRoXCIsXG4gIFwiaGVpZ2h0XCIsXG4gIFwib3BhY2l0eVwiLFxuICBcIm92ZXJmbG93XCIsXG4gIFwicmFkaXVzXCIsXG4gIFwiYmFja2dyb3VuZFwiLFxuICBcImNvbG9yXCIsXG4gIFwieFwiLFxuICBcInlcIixcbiAgXCJ6XCIsXG4gIFwicm90YXRlXCIsXG4gIFwicm90YXRlWFwiLFxuICBcInJvdGF0ZVlcIixcbiAgXCJyb3RhdGVaXCIsXG4gIFwic2NhbGVcIixcbiAgXCJzY2FsZVhcIixcbiAgXCJzY2FsZVlcIixcbiAgXCJza2V3XCIsXG4gIFwic2tld1hcIixcbiAgXCJza2V3WVwiLFxuICBcIm9yaWdpblhcIixcbiAgXCJvcmlnaW5ZXCIsXG4gIFwib3JpZ2luWlwiXG5dKTtcbmZ1bmN0aW9uIGdldE1vdGlvblByb3BzKHByb3BzKSB7XG4gIGNvbnN0IG1vdGlvblByb3BzID0ge307XG4gIGZvciAoY29uc3Qga2V5NiBpbiBwcm9wcykge1xuICAgIGNvbnN0IGlzVmFsaWQgPSBpc1ZhbGlkTW90aW9uUHJvcChrZXk2KSB8fCAoMCwgaW1wb3J0X2lzX3Byb3BfdmFsaWQuZGVmYXVsdCkoa2V5Nik7XG4gICAgaWYgKGlzVmFsaWQgJiYgIWZpbHRlcmVkUHJvcHMuaGFzKGtleTYpKSB7XG4gICAgICBtb3Rpb25Qcm9wc1trZXk2XSA9IHByb3BzW2tleTZdO1xuICAgIH0gZWxzZSBpZiAoa2V5NiA9PT0gXCJwb3NpdGlvblRyYW5zaXRpb25cIiB8fCBrZXk2ID09PSBcImxheW91dFRyYW5zaXRpb25cIikge1xuICAgICAgbW90aW9uUHJvcHNbXCJsYXlvdXRcIl0gPSB0cnVlO1xuICAgICAgaWYgKHR5cGVvZiBwcm9wc1trZXk2XSAhPT0gXCJib29sZWFuXCIgJiYgIXByb3BzLnRyYW5zaXRpb24pIHtcbiAgICAgICAgbW90aW9uUHJvcHNbXCJ0cmFuc2l0aW9uXCJdID0gcHJvcHNba2V5Nl07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb3Rpb25Qcm9wcztcbn1cbmZ1bmN0aW9uIGhhc0RhdGFGcmFtZXJOYW1lKHByb3BzKSB7XG4gIHJldHVybiBcImRhdGEtZnJhbWVyLW5hbWVcIiBpbiBwcm9wcztcbn1cbnZhciBGcmFtZVdpdGhNb3Rpb24gPSBmb3J3YXJkUmVmMihmdW5jdGlvbiBGcmFtZVdpdGhNb3Rpb24yKHByb3BzLCByZWYpIHtcbiAgaWYgKHNhZmVXaW5kb3dbXCJwZXJmXCJdKVxuICAgIHNhZmVXaW5kb3dbXCJwZXJmXCJdLm5vZGVSZW5kZXIoKTtcbiAgY29uc3QgeyB2aXNpYmxlID0gdHJ1ZSB9ID0gcHJvcHM7XG4gIGlmICghdmlzaWJsZSlcbiAgICByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MTUoVmlzaWJsZUZyYW1lLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgcmVmXG4gIH0pO1xufSk7XG52YXIgVmlzaWJsZUZyYW1lID0gZm9yd2FyZFJlZjIoZnVuY3Rpb24gVmlzaWJsZUZyYW1lMihwcm9wcywgZm9yd2FyZGVkUmVmKSB7XG4gIGNvbnN0IHsgX2JvcmRlciwgbmFtZSwgY2VudGVyLCBib3JkZXIgfSA9IHByb3BzO1xuICBjb25zdCB7IHByb3BzOiBwcm9wc1dpdGhPdmVycmlkZXMsIGNoaWxkcmVuIH0gPSBwcm9jZXNzT3ZlcnJpZGVGb3J3YXJkaW5nKHByb3BzKTtcbiAgY29uc3QgbW90aW9uUHJvcHMgPSBnZXRNb3Rpb25Qcm9wcyhwcm9wc1dpdGhPdmVycmlkZXMpO1xuICBjb25zdCBsYXlvdXRJZCA9IHVzZUxheW91dElkMihwcm9wcyk7XG4gIGNvbnN0IGN1cnNvciA9IGdldEN1cnNvckZyb21FdmVudHMocHJvcHMpO1xuICBjb25zdCBmYWxsYmFja1JlZiA9IHVzZVJlZjE0KG51bGwpO1xuICBjb25zdCByZWYgPSBmb3J3YXJkZWRSZWYgIT0gbnVsbCA/IGZvcndhcmRlZFJlZiA6IGZhbGxiYWNrUmVmO1xuICBjb25zdCBkYXRhUHJvcHMgPSB7XG4gICAgXCJkYXRhLWZyYW1lci1jb21wb25lbnQtdHlwZVwiOiBcIkZyYW1lXCIsXG4gICAgXCJkYXRhLWZyYW1lci1jdXJzb3JcIjogY3Vyc29yLFxuICAgIFwiZGF0YS1mcmFtZXItaGlnaGxpZ2h0XCI6IGN1cnNvciA9PT0gXCJwb2ludGVyXCIgPyB0cnVlIDogdm9pZCAwLFxuICAgIFwiZGF0YS1sYXlvdXRpZFwiOiBsYXlvdXRJZFxuICB9O1xuICBpZiAoIWhhc0RhdGFGcmFtZXJOYW1lKHByb3BzKSAmJiBuYW1lKSB7XG4gICAgZGF0YVByb3BzW1wiZGF0YS1mcmFtZXItbmFtZVwiXSA9IG5hbWU7XG4gIH1cbiAgY29uc3QgW2N1cnJlbnRTdHlsZSwgcmVjdF0gPSB1c2VTdHlsZUFuZFJlY3QocHJvcHNXaXRoT3ZlcnJpZGVzKTtcbiAgY29uc3QgdW53cmFwcGVkUHJvcHMgPSB1bndyYXBGcmFtZVByb3BzKHByb3BzV2l0aE92ZXJyaWRlcyk7XG4gIGNvbnN0IGF1dG9TaXplZCA9IGlzQXV0b1NpemVkKHVud3JhcHBlZFByb3BzKTtcbiAgaWYgKGNlbnRlciAmJiAhKHJlY3QgJiYgIWF1dG9TaXplZCAmJiBjb25zdHJhaW50c0VuYWJsZWQodW53cmFwcGVkUHJvcHMpKSkge1xuICAgIG1vdGlvblByb3BzLnRyYW5zZm9ybVRlbXBsYXRlID0gdHJhbnNmb3JtVGVtcGxhdGUoY2VudGVyKTtcbiAgICBPYmplY3QuYXNzaWduKGRhdGFQcm9wcywgbGF5b3V0SGludERhdGFQcm9wc0ZvckNlbnRlcihjZW50ZXIpKTtcbiAgfSBlbHNlIHtcbiAgICBtb3Rpb25Qcm9wcy50cmFuc2Zvcm1UZW1wbGF0ZSA9IHRyYW5zZm9ybVRlbXBsYXRlKGZhbHNlKTtcbiAgfVxuICB1c2VNZWFzdXJlTGF5b3V0KHByb3BzLCByZWYpO1xuICBjb25zdCBiYWNrZ3JvdW5kSW1hZ2UgPSBiYWNrZ3JvdW5kSW1hZ2VGcm9tUHJvcHMocHJvcHMpO1xuICBjb25zdCBpbkNvZGVDb21wb25lbnQgPSBCb29sZWFuKHVzZUNvbnRleHQyMChDb21wb25lbnRDb250YWluZXJDb250ZXh0KSk7XG4gIGNvbnN0IHBhcmVudFNpemUgPSByZXNvbHZlUGFyZW50U2l6ZShwcm9wc1dpdGhPdmVycmlkZXMsIHVud3JhcHBlZFByb3BzLCByZWN0LCBpbkNvZGVDb21wb25lbnQpO1xuICBjb25zdCB3cmFwcGVkQ29udGVudCA9IHVzZVByb3ZpZGVQYXJlbnRTaXplKC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MTUoRnJhZ21lbnQ1LCBudWxsLCBiYWNrZ3JvdW5kSW1hZ2UgPyAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDE1KEJhY2tncm91bmRJbWFnZUNvbXBvbmVudCwge1xuICAgIGltYWdlOiBiYWNrZ3JvdW5kSW1hZ2UsXG4gICAgY29udGFpbmVyU2l6ZTogcmVjdCAhPSBudWxsID8gcmVjdCA6IHZvaWQgMCxcbiAgICBub2RlSWQ6IHByb3BzLmlkICYmIG5vZGVJZEZyb21TdHJpbmcocHJvcHMuaWQpLFxuICAgIGxheW91dElkXG4gIH0pIDogbnVsbCwgY2hpbGRyZW4sIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MTUoQm9yZGVyLCB7XG4gICAgLi4uX2JvcmRlcixcbiAgICBib3JkZXIsXG4gICAgbGF5b3V0SWRcbiAgfSkpLCBwYXJlbnRTaXplKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MTUobW90aW9uLmRpdiwge1xuICAgIC4uLmRhdGFQcm9wcyxcbiAgICAuLi5tb3Rpb25Qcm9wcyxcbiAgICBsYXlvdXRJZCxcbiAgICBzdHlsZTogY3VycmVudFN0eWxlLFxuICAgIHJlZixcbiAgICB0cmFuc2Zvcm1WYWx1ZXNcbiAgfSwgd3JhcHBlZENvbnRlbnQpO1xufSk7XG5mdW5jdGlvbiByZXNvbHZlUGFyZW50U2l6ZShwcm9wcywgdW53cmFwcGVkUHJvcHMsIHJlY3QsIGluQ29kZUNvbXBvbmVudCkge1xuICBpZiAoaW5Db2RlQ29tcG9uZW50KSB7XG4gICAgcmV0dXJuIHJlY3QgPyB7IHdpZHRoOiByZWN0LndpZHRoLCBoZWlnaHQ6IHJlY3QuaGVpZ2h0IH0gOiBQYXJlbnRTaXplU3RhdGUuRGlzYWJsZWQ7XG4gIH1cbiAgY29uc3QgeyBfdXNlc0RPTVJlY3QgfSA9IHByb3BzO1xuICBjb25zdCB7XG4gICAgd2lkdGhUeXBlID0gRGltZW5zaW9uVHlwZS5GaXhlZE51bWJlcixcbiAgICBoZWlnaHRUeXBlID0gRGltZW5zaW9uVHlwZS5GaXhlZE51bWJlcixcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IHVud3JhcHBlZFByb3BzO1xuICBpZiAocmVjdCAmJiAhX3VzZXNET01SZWN0KSB7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cbiAgaWYgKHdpZHRoVHlwZSA9PT0gRGltZW5zaW9uVHlwZS5GaXhlZE51bWJlciAmJiBoZWlnaHRUeXBlID09PSBEaW1lbnNpb25UeXBlLkZpeGVkTnVtYmVyICYmIHR5cGVvZiB3aWR0aCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgaGVpZ2h0ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCB9O1xuICB9XG4gIGlmIChfdXNlc0RPTVJlY3QpIHtcbiAgICByZXR1cm4gUGFyZW50U2l6ZVN0YXRlLkRpc2FibGVkRm9yQ3VycmVudExldmVsO1xuICB9XG4gIHJldHVybiBQYXJlbnRTaXplU3RhdGUuVW5rbm93bjtcbn1cbmZ1bmN0aW9uIGlzQXV0b1NpemVkKHtcbiAgd2lkdGgsXG4gIGhlaWdodFxufSkge1xuICByZXR1cm4gd2lkdGggPT09IFwiYXV0b1wiIHx8IHdpZHRoID09PSBcIm1pbi1jb250ZW50XCIgfHwgaGVpZ2h0ID09PSBcImF1dG9cIiB8fCBoZWlnaHQgPT09IFwibWluLWNvbnRlbnRcIjtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvRW1wdHlTdGF0ZS50c3hcbmltcG9ydCB7XG4gIENoaWxkcmVuIGFzIENoaWxkcmVuNSxcbiAgY3JlYXRlRWxlbWVudCBhcyBjcmVhdGVFbGVtZW50MjJcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9yZW5kZXIvcHJlc2VudGF0aW9uL0ZyYW1lL2luZGV4LnRzeFxuaW1wb3J0IHtcbiAgY3JlYXRlRWxlbWVudCBhcyBjcmVhdGVFbGVtZW50MjFcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWYzIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9jb21wb25lbnRzL2hvYy9XaXRoRXZlbnRzLnRzeFxuaW1wb3J0IHtcbiAgQ29tcG9uZW50IGFzIENvbXBvbmVudDUsXG4gIGNyZWF0ZUVsZW1lbnQgYXMgY3JlYXRlRWxlbWVudDE3LFxuICBjcmVhdGVSZWZcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy91dGlscy9ldmVudHMudHNcbmZ1bmN0aW9uIHBvaW50Rm9yRXZlbnQoZXZlbnQsIGN1c3RvbVRhcmdldCA9IG51bGwpIHtcbiAgbGV0IHRhcmdldDtcbiAgaWYgKGN1c3RvbVRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgdGFyZ2V0ID0gY3VzdG9tVGFyZ2V0O1xuICB9XG4gIGlmICghdGFyZ2V0ICYmIGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICB9XG4gIGlmICghdGFyZ2V0KSB7XG4gICAgcmV0dXJuIHsgeDogZXZlbnQucGFnZVgsIHk6IGV2ZW50LnBhZ2VZIH07XG4gIH1cbiAgaWYgKHNhZmVXaW5kb3cud2Via2l0Q29udmVydFBvaW50RnJvbVBhZ2VUb05vZGUpIHtcbiAgICBsZXQgd2Via2l0UG9pbnQgPSBuZXcgV2ViS2l0UG9pbnQoZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKTtcbiAgICB3ZWJraXRQb2ludCA9IHNhZmVXaW5kb3cud2Via2l0Q29udmVydFBvaW50RnJvbVBhZ2VUb05vZGUodGFyZ2V0LCB3ZWJraXRQb2ludCk7XG4gICAgcmV0dXJuIHsgeDogd2Via2l0UG9pbnQueCwgeTogd2Via2l0UG9pbnQueSB9O1xuICB9XG4gIGNvbnN0IHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHdpZHRoID0gcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUud2lkdGgpO1xuICBjb25zdCBoZWlnaHQgPSBwYXJzZUZsb2F0KHRhcmdldC5zdHlsZS5oZWlnaHQpO1xuICBjb25zdCBzY2FsZTIgPSB7XG4gICAgeDogd2lkdGggPyB3aWR0aCAvIHJlY3Qud2lkdGggOiAxLFxuICAgIHk6IGhlaWdodCA/IGhlaWdodCAvIHJlY3QuaGVpZ2h0IDogMVxuICB9O1xuICBjb25zdCBwb2ludCA9IHtcbiAgICB4OiBzY2FsZTIueCAqIChldmVudC5wYWdlWCAtIHJlY3QubGVmdCAtIHRhcmdldC5jbGllbnRMZWZ0ICsgdGFyZ2V0LnNjcm9sbExlZnQpLFxuICAgIHk6IHNjYWxlMi55ICogKGV2ZW50LnBhZ2VZIC0gcmVjdC50b3AgLSB0YXJnZXQuY2xpZW50VG9wICsgdGFyZ2V0LnNjcm9sbFRvcClcbiAgfTtcbiAgcmV0dXJuIHBvaW50O1xufVxuXG4vLyBzcmMvY29yZS9UaW1lLnRzXG52YXIgX3JhZiA9IChmKSA9PiB7XG4gIHNldFRpbWVvdXQoZiwgMSAvIDYwKTtcbn07XG52YXIgX19yYWYgPSBzYWZlV2luZG93W1wicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdIHx8IF9yYWY7XG52YXIgcmFmID0gKGYpID0+IF9fcmFmKGYpO1xuXG4vLyBzcmMvY29yZS9FdmVudEVtaXR0ZXIudHNcbnZhciBpbXBvcnRfZXZlbnRlbWl0dGVyMyA9IF9fdG9Nb2R1bGUocmVxdWlyZV9ldmVudGVtaXR0ZXIzKCkpO1xudmFyIEV2ZW50RW1pdHRlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZW1pdHRlciA9IG5ldyBpbXBvcnRfZXZlbnRlbWl0dGVyMy5FdmVudEVtaXR0ZXIoKTtcbiAgfVxuICBldmVudE5hbWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLmV2ZW50TmFtZXMoKTtcbiAgfVxuICBldmVudExpc3RlbmVycygpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGV2ZW50TmFtZSBvZiB0aGlzLl9lbWl0dGVyLmV2ZW50TmFtZXMoKSkge1xuICAgICAgbGlzdGVuZXJzW2V2ZW50TmFtZV0gPSB0aGlzLl9lbWl0dGVyLmxpc3RlbmVycyhldmVudE5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdGVuZXJzO1xuICB9XG4gIG9uKGV2ZW50TmFtZSwgZm4pIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmbiwgZmFsc2UsIGZhbHNlLCB0aGlzKTtcbiAgfVxuICBvZmYoZXZlbnROYW1lLCBmbikge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcnMoZXZlbnROYW1lLCBmbik7XG4gIH1cbiAgb25jZShldmVudE5hbWUsIGZuKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZm4sIHRydWUsIGZhbHNlLCB0aGlzKTtcbiAgfVxuICB1bmlxdWUoZXZlbnROYW1lLCBmbikge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuLCBmYWxzZSwgdHJ1ZSwgdGhpcyk7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuLCBvbmNlLCB1bmlxdWUsIGNvbnRleHQpIHtcbiAgICBpZiAodW5pcXVlKSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5fZW1pdHRlci5ldmVudE5hbWVzKCkpIHtcbiAgICAgICAgaWYgKGZuID09PSB0aGlzLl9lbWl0dGVyLmxpc3RlbmVycyhuYW1lKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob25jZSA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fZW1pdHRlci5vbmNlKGV2ZW50TmFtZSwgZm4sIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbWl0dGVyLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgZm4sIGNvbnRleHQpO1xuICAgIH1cbiAgfVxuICByZW1vdmVFdmVudExpc3RlbmVycyhldmVudE5hbWUsIGZuKSB7XG4gICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgdGhpcy5fZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGZuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVBbGxFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgfVxuICByZW1vdmVBbGxFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9lbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG4gIGNvdW50RXZlbnRMaXN0ZW5lcnMoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIubGlzdGVuZXJzKGV2ZW50TmFtZSkubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMuX2VtaXR0ZXIuZXZlbnROYW1lcygpKSB7XG4gICAgICAgIGNvdW50ICs9IHRoaXMuX2VtaXR0ZXIubGlzdGVuZXJzKG5hbWUpLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gIH1cbiAgZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lbWl0dGVyLmVtaXQoZXZlbnROYW1lLCAuLi5hcmdzKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvTG9vcC50c1xudmFyIExvb3BUaW1lU3RlcCA9IDEgLyA2MDtcbnZhciBMb29wID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihzdGFydCA9IGZhbHNlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZnJhbWUgPSAwO1xuICAgIHRoaXMuX2ZyYW1lVGFza3MgPSBbXTtcbiAgICB0aGlzLnRpY2sgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHJhZih0aGlzLnRpY2spO1xuICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHRoaXMuX2ZyYW1lLCBMb29wVGltZVN0ZXApO1xuICAgICAgdGhpcy5lbWl0KFwicmVuZGVyXCIsIHRoaXMuX2ZyYW1lLCBMb29wVGltZVN0ZXApO1xuICAgICAgdGhpcy5fcHJvY2Vzc0ZyYW1lVGFza3MoKTtcbiAgICAgIHRoaXMuX2ZyYW1lKys7XG4gICAgfTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG4gIH1cbiAgYWRkRnJhbWVUYXNrKHRhc2spIHtcbiAgICB0aGlzLl9mcmFtZVRhc2tzLnB1c2godGFzayk7XG4gIH1cbiAgX3Byb2Nlc3NGcmFtZVRhc2tzKCkge1xuICAgIGNvbnN0IHBvc3RFdmVudFRhc2tzID0gdGhpcy5fZnJhbWVUYXNrcztcbiAgICBjb25zdCBsZW5ndGggPSBwb3N0RXZlbnRUYXNrcy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBwb3N0RXZlbnRUYXNrc1tpXSgpO1xuICAgIH1cbiAgICBwb3N0RXZlbnRUYXNrcy5sZW5ndGggPSAwO1xuICB9XG4gIHN0YXRpYyBzZXQgVGltZVN0ZXAodmFsdWUpIHtcbiAgICBMb29wVGltZVN0ZXAgPSB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgZ2V0IFRpbWVTdGVwKCkge1xuICAgIHJldHVybiBMb29wVGltZVN0ZXA7XG4gIH1cbiAgc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMuX3N0YXJ0ZWQpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB0aGlzLl9mcmFtZSA9IDA7XG4gICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgcmFmKHRoaXMudGljayk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0IGZyYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9mcmFtZTtcbiAgfVxuICBnZXQgdGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnJhbWUgKiBMb29wVGltZVN0ZXA7XG4gIH1cbn07XG52YXIgTWFpbkxvb3AgPSBuZXcgTG9vcCgpO1xuXG4vLyBzcmMvdXRpbHMvbWF0aC50c1xudmFyIGNsYW1wMyA9ICh2YWx1ZSwgYTIsIGIyKSA9PiB7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKGEyLCBiMik7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KGEyLCBiMik7XG4gIGlmICh2YWx1ZSA8IG1pbikge1xuICAgIHZhbHVlID0gbWluO1xuICB9XG4gIGlmICh2YWx1ZSA+IG1heCkge1xuICAgIHZhbHVlID0gbWF4O1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIHNyYy9ldmVudHMvRnJhbWVyRXZlbnQudHNcbnZhciBGcmFtZXJFdmVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3JpZ2luYWxFdmVudCwgc2Vzc2lvbikge1xuICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICB0aGlzLnRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMubG9vcFRpbWUgPSBNYWluTG9vcC50aW1lO1xuICAgIGNvbnN0IGN1c3RvbVRhcmdldCA9IHNlc3Npb24gJiYgc2Vzc2lvbi5zdGFydEV2ZW50ICYmIHNlc3Npb24uc3RhcnRFdmVudC50YXJnZXQgfHwgb3JpZ2luYWxFdmVudC50YXJnZXQ7XG4gICAgY29uc3QgZXZlbnRMaWtlID0gRnJhbWVyRXZlbnQuZXZlbnRMaWtlRnJvbU9yaWdpbmFsRXZlbnQob3JpZ2luYWxFdmVudCk7XG4gICAgdGhpcy5wb2ludCA9IHBvaW50Rm9yRXZlbnQoZXZlbnRMaWtlLCBjdXN0b21UYXJnZXQpO1xuICAgIGNvbnN0IGRldmljZVRhcmdldCA9IHNlc3Npb24gJiYgc2Vzc2lvbi5vcmlnaW5FbGVtZW50ID8gc2Vzc2lvbi5vcmlnaW5FbGVtZW50IDogZG9jdW1lbnQuYm9keTtcbiAgICB0aGlzLmRldmljZVBvaW50ID0gcG9pbnRGb3JFdmVudChldmVudExpa2UsIGRldmljZVRhcmdldCk7XG4gICAgdGhpcy50YXJnZXQgPSBvcmlnaW5hbEV2ZW50LnRhcmdldCB8fCBudWxsO1xuICAgIGNvbnN0IGxhc3RFdmVudCA9IHNlc3Npb24gJiYgc2Vzc2lvbi5sYXN0RXZlbnQ7XG4gICAgaWYgKG9yaWdpbmFsRXZlbnQgaW5zdGFuY2VvZiBXaGVlbEV2ZW50KSB7XG4gICAgICB0aGlzLmRlbHRhID0geyB4OiBvcmlnaW5hbEV2ZW50LmRlbHRhWCwgeTogb3JpZ2luYWxFdmVudC5kZWx0YVkgfTtcbiAgICB9IGVsc2UgaWYgKGxhc3RFdmVudCAmJiB0aGlzLmRldmljZVBvaW50ICYmIGxhc3RFdmVudC5kZXZpY2VQb2ludCkge1xuICAgICAgdGhpcy5kZWx0YSA9IFBvaW50LnN1YnRyYWN0KHRoaXMuZGV2aWNlUG9pbnQsIGxhc3RFdmVudC5kZXZpY2VQb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVsdGEgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGV2ZW50TGlrZUZyb21PcmlnaW5hbEV2ZW50KG9yaWdpbmFsRXZlbnQpIHtcbiAgICBpZiAoXCJ0b3VjaGVzXCIgaW4gb3JpZ2luYWxFdmVudCkge1xuICAgICAgbGV0IHRvdWNoZXMgPSBvcmlnaW5hbEV2ZW50LnRvdWNoZXM7XG4gICAgICBpZiAoIXRvdWNoZXMgfHwgIXRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIG9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdG91Y2hlcyA9IG9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdG91Y2hlcyB8fCAhdG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHsgcGFnZVg6IDAsIHBhZ2VZOiAwLCB0YXJnZXQ6IG51bGwgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpcnN0VG91Y2ggPSB0b3VjaGVzWzBdO1xuICAgICAgY29uc3QgcGFnZVggPSBmaXJzdFRvdWNoLmNsaWVudFggfHwgZmlyc3RUb3VjaC5zY3JlZW5YIHx8IGZpcnN0VG91Y2gucGFnZVg7XG4gICAgICBjb25zdCBwYWdlWSA9IGZpcnN0VG91Y2guY2xpZW50WSB8fCBmaXJzdFRvdWNoLnNjcmVlblkgfHwgZmlyc3RUb3VjaC5wYWdlWTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VYLFxuICAgICAgICBwYWdlWSxcbiAgICAgICAgdGFyZ2V0OiBvcmlnaW5hbEV2ZW50LnRhcmdldFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdpbmFsRXZlbnQ7XG4gIH1cbiAgdmVsb2NpdHkodCkge1xuICAgIHJldHVybiB0aGlzLnNlc3Npb24gPyB0aGlzLnNlc3Npb24udmVsb2NpdHkodCkgOiB7IHg6IDAsIHk6IDAgfTtcbiAgfVxuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLnNlc3Npb24gPyB0aGlzLnNlc3Npb24ub2Zmc2V0KHRoaXMpIDogeyB4OiAwLCB5OiAwIH07XG4gIH1cbiAgZ2V0IGlzTGVmdE1vdXNlQ2xpY2soKSB7XG4gICAgaWYgKGVudmlyb25tZW50X2V4cG9ydHMuaXNUb3VjaCgpKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoXCJidXR0b25cIiBpbiB0aGlzLm9yaWdpbmFsRXZlbnQgJiYgXCJidXR0b25zXCIgaW4gdGhpcy5vcmlnaW5hbEV2ZW50ICYmIFwiY3RybEtleVwiIGluIHRoaXMub3JpZ2luYWxFdmVudCkge1xuICAgICAgcmV0dXJuICh0aGlzLm9yaWdpbmFsRXZlbnQuYnV0dG9uID09PSAwIHx8IHRoaXMub3JpZ2luYWxFdmVudC5idXR0b25zID09PSAxKSAmJiAhdGhpcy5vcmlnaW5hbEV2ZW50LmN0cmxLZXk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gc3JjL2NvbXBvbmVudHMvaG9jL1dpdGhEcmFnZ2luZy50c3hcbmltcG9ydCB7XG4gIENvbXBvbmVudCBhcyBDb21wb25lbnQ0LFxuICBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxMCxcbiAgY3JlYXRlRWxlbWVudCBhcyBjcmVhdGVFbGVtZW50MTZcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9hbmltYXRpb24vQW5pbWF0b3JzL0ludGVncmF0b3IudHNcbnZhciBJbnRlZ3JhdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihhY2NlbGVyYXRpb25GdW5jdGlvbikge1xuICAgIHRoaXMuYWNjZWxlcmF0aW9uRm9yU3RhdGUgPSBhY2NlbGVyYXRpb25GdW5jdGlvbjtcbiAgfVxuICBpbnRlZ3JhdGVTdGF0ZShzdGF0ZSwgZHQpIHtcbiAgICBjb25zdCBhMiA9IHRoaXMuZXZhbHVhdGVTdGF0ZShzdGF0ZSk7XG4gICAgY29uc3QgYjIgPSB0aGlzLmV2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShzdGF0ZSwgZHQgKiAwLjUsIGEyKTtcbiAgICBjb25zdCBjMiA9IHRoaXMuZXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKHN0YXRlLCBkdCAqIDAuNSwgYjIpO1xuICAgIGNvbnN0IGQgPSB0aGlzLmV2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShzdGF0ZSwgZHQsIGMyKTtcbiAgICBjb25zdCBkeGR0ID0gMSAvIDYgKiAoYTIuZHggKyAyICogKGIyLmR4ICsgYzIuZHgpICsgZC5keCk7XG4gICAgY29uc3QgZHZkdCA9IDEgLyA2ICogKGEyLmR2ICsgMiAqIChiMi5kdiArIGMyLmR2KSArIGQuZHYpO1xuICAgIHN0YXRlLnggPSBzdGF0ZS54ICsgZHhkdCAqIGR0O1xuICAgIHN0YXRlLnYgPSBzdGF0ZS52ICsgZHZkdCAqIGR0O1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBldmFsdWF0ZVN0YXRlKGluaXRpYWxTdGF0ZTIpIHtcbiAgICBjb25zdCBkdiA9IHRoaXMuYWNjZWxlcmF0aW9uRm9yU3RhdGUoaW5pdGlhbFN0YXRlMik7XG4gICAgcmV0dXJuIHsgZHg6IGluaXRpYWxTdGF0ZTIudiwgZHYgfTtcbiAgfVxuICBldmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoaW5pdGlhbFN0YXRlMiwgZHQsIGRlcml2YXRpdmUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgIHg6IGluaXRpYWxTdGF0ZTIueCArIGRlcml2YXRpdmUuZHggKiBkdCxcbiAgICAgIHY6IGluaXRpYWxTdGF0ZTIudiArIGRlcml2YXRpdmUuZHYgKiBkdFxuICAgIH07XG4gICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgZHg6IHN0YXRlLnYsXG4gICAgICBkdjogdGhpcy5hY2NlbGVyYXRpb25Gb3JTdGF0ZShzdGF0ZSlcbiAgICB9O1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbn07XG5cbi8vIHNyYy9hbmltYXRpb24vQW5pbWF0b3JzL0ZyaWN0aW9uQW5pbWF0b3IudHNcbnZhciBGcmljdGlvbkFuaW1hdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgdmVsb2NpdHk6IDAsXG4gICAgICBmcmljdGlvbjogMixcbiAgICAgIHRvbGVyYW5jZTogMSAvIDEwXG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB2OiB0aGlzLm9wdGlvbnMudmVsb2NpdHlcbiAgICB9O1xuICAgIHRoaXMuaW50ZWdyYXRvciA9IG5ldyBJbnRlZ3JhdG9yKChzdGF0ZSkgPT4gLSh0aGlzLm9wdGlvbnMuZnJpY3Rpb24gKiBzdGF0ZS52KSk7XG4gIH1cbiAgc2V0RnJvbSh2YWx1ZSkge1xuICAgIHRoaXMuc3RhdGUueCA9IHZhbHVlO1xuICB9XG4gIHNldFRvKHZhbHVlKSB7XG4gIH1cbiAgc2V0VmVsb2NpdHkodmVsb2NpdHkpIHtcbiAgICB0aGlzLnN0YXRlLnYgPSB2ZWxvY2l0eTtcbiAgfVxuICBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgfVxuICBpc1JlYWR5KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIG5leHQoZGVsdGEyKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuaW50ZWdyYXRvci5pbnRlZ3JhdGVTdGF0ZSh0aGlzLnN0YXRlLCBkZWx0YTIpO1xuICAgIHJldHVybiB0aGlzLnN0YXRlLng7XG4gIH1cbiAgaXNGaW5pc2hlZCgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zdGF0ZS52KSA8IHRoaXMub3B0aW9ucy50b2xlcmFuY2U7XG4gIH1cbn07XG5cbi8vIHNyYy9hbmltYXRpb24vQW5pbWF0b3JzL1NwcmluZ0N1cnZlVmFsdWVDb252ZXJ0ZXIudHNcbnZhciBlcHNpbG9uID0gMWUtMztcbnZhciBtaW5EdXJhdGlvbjIgPSAwLjAxO1xudmFyIG1heER1cmF0aW9uMiA9IDEwO1xudmFyIG1pbkRhbXBpbmcyID0gTnVtYmVyLk1JTl9WQUxVRTtcbnZhciBtYXhEYW1waW5nMiA9IDE7XG5mdW5jdGlvbiBhcHByb3hpbWF0ZVJvb3QyKGZ1bmMsIGRlcml2YXRpdmUsIGluaXRpYWxHdWVzcywgdGltZXMgPSAxMikge1xuICBsZXQgcmVzdWx0ID0gaW5pdGlhbEd1ZXNzO1xuICBmb3IgKGxldCBpID0gMSwgZW5kID0gdGltZXMsIGFzYyA9IDEgPD0gZW5kOyBhc2MgPyBpIDwgZW5kIDogaSA+IGVuZDsgYXNjID8gaSsrIDogaS0tKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0IC0gZnVuYyhyZXN1bHQpIC8gZGVyaXZhdGl2ZShyZXN1bHQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBhbmd1bGFyRnJlcXVlbmN5KHVuZGFtcGVkRnJlcXVlbmN5LCBkYW1waW5nUmF0aW8pIHtcbiAgcmV0dXJuIHVuZGFtcGVkRnJlcXVlbmN5ICogTWF0aC5zcXJ0KDEgLSBNYXRoLnBvdyhkYW1waW5nUmF0aW8sIDIpKTtcbn1cbnZhciBTcHJpbmdDdXJ2ZVZhbHVlQ29udmVydGVyO1xuKGZ1bmN0aW9uKFNwcmluZ0N1cnZlVmFsdWVDb252ZXJ0ZXIyKSB7XG4gIGZ1bmN0aW9uIGNvbXB1dGVEYW1waW5nUmF0aW8odGVuc2lvbiwgZnJpY3Rpb24sIG1hc3MgPSAxKSB7XG4gICAgcmV0dXJuIGZyaWN0aW9uIC8gKDIgKiBNYXRoLnNxcnQobWFzcyAqIHRlbnNpb24pKTtcbiAgfVxuICBTcHJpbmdDdXJ2ZVZhbHVlQ29udmVydGVyMi5jb21wdXRlRGFtcGluZ1JhdGlvID0gY29tcHV0ZURhbXBpbmdSYXRpbztcbiAgZnVuY3Rpb24gY29tcHV0ZUR1cmF0aW9uKHRlbnNpb24sIGZyaWN0aW9uLCB2ZWxvY2l0eSA9IDAsIG1hc3MgPSAxKSB7XG4gICAgbGV0IGR1cmF0aW9uO1xuICAgIGNvbnN0IGRhbXBpbmdSYXRpbyA9IGNvbXB1dGVEYW1waW5nUmF0aW8odGVuc2lvbiwgZnJpY3Rpb24pO1xuICAgIGNvbnN0IHVuZGFtcGVkRnJlcXVlbmN5ID0gTWF0aC5zcXJ0KHRlbnNpb24gLyBtYXNzKTtcbiAgICBpZiAoZGFtcGluZ1JhdGlvIDwgMSkge1xuICAgICAgY29uc3QgYTIgPSBNYXRoLnNxcnQoMSAtIE1hdGgucG93KGRhbXBpbmdSYXRpbywgMikpO1xuICAgICAgY29uc3QgYjIgPSB2ZWxvY2l0eSAvIChhMiAqIHVuZGFtcGVkRnJlcXVlbmN5KTtcbiAgICAgIGNvbnN0IGMyID0gZGFtcGluZ1JhdGlvIC8gYTI7XG4gICAgICBjb25zdCBkID0gLSgoYjIgLSBjMikgLyBlcHNpbG9uKTtcbiAgICAgIGlmIChkIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBkdXJhdGlvbiA9IE1hdGgubG9nKGQpIC8gKGRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkRnJlcXVlbmN5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkdXJhdGlvbjtcbiAgfVxuICBTcHJpbmdDdXJ2ZVZhbHVlQ29udmVydGVyMi5jb21wdXRlRHVyYXRpb24gPSBjb21wdXRlRHVyYXRpb247XG4gIGZ1bmN0aW9uIGNvbXB1dGVEZXJpdmVkQ3VydmVPcHRpb25zKGRhbXBpbmdSYXRpbywgZHVyYXRpb24sIHZlbG9jaXR5ID0gMCwgbWFzcyA9IDEpIHtcbiAgICBsZXQgZGVyaXZhdGl2ZSwgZW52ZWxvcGU7XG4gICAgZGFtcGluZ1JhdGlvID0gTWF0aC5tYXgoTWF0aC5taW4oZGFtcGluZ1JhdGlvLCBtYXhEYW1waW5nMiksIG1pbkRhbXBpbmcyKTtcbiAgICBkdXJhdGlvbiA9IE1hdGgubWF4KE1hdGgubWluKGR1cmF0aW9uLCBtYXhEdXJhdGlvbjIpLCBtaW5EdXJhdGlvbjIpO1xuICAgIGlmIChkYW1waW5nUmF0aW8gPCAxKSB7XG4gICAgICBlbnZlbG9wZSA9IGZ1bmN0aW9uKGVudmVsb3BlVW5kYW1wZWRGcmVxdWVuY3kpIHtcbiAgICAgICAgY29uc3QgZXhwb25lbnRpYWxEZWNheSA9IGVudmVsb3BlVW5kYW1wZWRGcmVxdWVuY3kgKiBkYW1waW5nUmF0aW87XG4gICAgICAgIGNvbnN0IGN1cnJlbnREaXNwbGFjZW1lbnQgPSBleHBvbmVudGlhbERlY2F5ICogZHVyYXRpb247XG4gICAgICAgIGNvbnN0IGEyID0gZXhwb25lbnRpYWxEZWNheSAtIHZlbG9jaXR5O1xuICAgICAgICBjb25zdCBiMiA9IGFuZ3VsYXJGcmVxdWVuY3koZW52ZWxvcGVVbmRhbXBlZEZyZXF1ZW5jeSwgZGFtcGluZ1JhdGlvKTtcbiAgICAgICAgY29uc3QgYzIgPSBNYXRoLmV4cCgtY3VycmVudERpc3BsYWNlbWVudCk7XG4gICAgICAgIHJldHVybiBlcHNpbG9uIC0gYTIgLyBiMiAqIGMyO1xuICAgICAgfTtcbiAgICAgIGRlcml2YXRpdmUgPSBmdW5jdGlvbihkZXJpdmF0aXZlVW5kYW1wZWRGcmVxdWVuY3kpIHtcbiAgICAgICAgY29uc3QgZXhwb25lbnRpYWxEZWNheSA9IGRlcml2YXRpdmVVbmRhbXBlZEZyZXF1ZW5jeSAqIGRhbXBpbmdSYXRpbztcbiAgICAgICAgY29uc3QgY3VycmVudERpc3BsYWNlbWVudCA9IGV4cG9uZW50aWFsRGVjYXkgKiBkdXJhdGlvbjtcbiAgICAgICAgY29uc3QgZCA9IGN1cnJlbnREaXNwbGFjZW1lbnQgKiB2ZWxvY2l0eSArIHZlbG9jaXR5O1xuICAgICAgICBjb25zdCBlID0gTWF0aC5wb3coZGFtcGluZ1JhdGlvLCAyKSAqIE1hdGgucG93KGRlcml2YXRpdmVVbmRhbXBlZEZyZXF1ZW5jeSwgMikgKiBkdXJhdGlvbjtcbiAgICAgICAgY29uc3QgZiA9IE1hdGguZXhwKC1jdXJyZW50RGlzcGxhY2VtZW50KTtcbiAgICAgICAgY29uc3QgZyA9IGFuZ3VsYXJGcmVxdWVuY3koTWF0aC5wb3coZGVyaXZhdGl2ZVVuZGFtcGVkRnJlcXVlbmN5LCAyKSwgZGFtcGluZ1JhdGlvKTtcbiAgICAgICAgY29uc3QgZmFjdG9yID0gLWVudmVsb3BlKGRlcml2YXRpdmVVbmRhbXBlZEZyZXF1ZW5jeSkgKyBlcHNpbG9uID4gMCA/IC0xIDogMTtcbiAgICAgICAgcmV0dXJuIGZhY3RvciAqICgoZCAtIGUpICogZikgLyBnO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW52ZWxvcGUgPSBmdW5jdGlvbihlbnZlbG9wZVVuZGFtcGVkRnJlcXVlbmN5KSB7XG4gICAgICAgIGNvbnN0IGEyID0gTWF0aC5leHAoLWVudmVsb3BlVW5kYW1wZWRGcmVxdWVuY3kgKiBkdXJhdGlvbik7XG4gICAgICAgIGNvbnN0IGIyID0gKGVudmVsb3BlVW5kYW1wZWRGcmVxdWVuY3kgLSB2ZWxvY2l0eSkgKiBkdXJhdGlvbiArIDE7XG4gICAgICAgIHJldHVybiAtZXBzaWxvbiArIGEyICogYjI7XG4gICAgICB9O1xuICAgICAgZGVyaXZhdGl2ZSA9IGZ1bmN0aW9uKGRlcml2YXRpdmVVbmRhbXBlZEZyZXF1ZW5jeSkge1xuICAgICAgICBjb25zdCBhMiA9IE1hdGguZXhwKC1kZXJpdmF0aXZlVW5kYW1wZWRGcmVxdWVuY3kgKiBkdXJhdGlvbik7XG4gICAgICAgIGNvbnN0IGIyID0gKHZlbG9jaXR5IC0gZGVyaXZhdGl2ZVVuZGFtcGVkRnJlcXVlbmN5KSAqIE1hdGgucG93KGR1cmF0aW9uLCAyKTtcbiAgICAgICAgcmV0dXJuIGEyICogYjI7XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICB0ZW5zaW9uOiAxMDAsXG4gICAgICBmcmljdGlvbjogMTAsXG4gICAgICB2ZWxvY2l0eVxuICAgIH07XG4gICAgY29uc3QgaW5pdGlhbEd1ZXNzID0gNSAvIGR1cmF0aW9uO1xuICAgIGNvbnN0IHVuZGFtcGVkRnJlcXVlbmN5ID0gYXBwcm94aW1hdGVSb290MihlbnZlbG9wZSwgZGVyaXZhdGl2ZSwgaW5pdGlhbEd1ZXNzKTtcbiAgICBpZiAoIWlzTmFOKHVuZGFtcGVkRnJlcXVlbmN5KSkge1xuICAgICAgcmVzdWx0LnRlbnNpb24gPSBNYXRoLnBvdyh1bmRhbXBlZEZyZXF1ZW5jeSwgMikgKiBtYXNzO1xuICAgICAgcmVzdWx0LmZyaWN0aW9uID0gZGFtcGluZ1JhdGlvICogMiAqIE1hdGguc3FydChtYXNzICogcmVzdWx0LnRlbnNpb24pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIFNwcmluZ0N1cnZlVmFsdWVDb252ZXJ0ZXIyLmNvbXB1dGVEZXJpdmVkQ3VydmVPcHRpb25zID0gY29tcHV0ZURlcml2ZWRDdXJ2ZU9wdGlvbnM7XG59KShTcHJpbmdDdXJ2ZVZhbHVlQ29udmVydGVyIHx8IChTcHJpbmdDdXJ2ZVZhbHVlQ29udmVydGVyID0ge30pKTtcblxuLy8gc3JjL2FuaW1hdGlvbi9BbmltYXRvcnMvU3ByaW5nQW5pbWF0b3IudHNcbnZhciBTcHJpbmdUZW5zaW9uRnJpY3Rpb25EZWZhdWx0cyA9IHtcbiAgdGVuc2lvbjogNTAwLFxuICBmcmljdGlvbjogMTAsXG4gIHRvbGVyYW5jZTogMSAvIDFlNCxcbiAgdmVsb2NpdHk6IDBcbn07XG52YXIgU3ByaW5nRGFtcGluZ0R1cmF0aW9uRGVmYXVsdHMgPSB7XG4gIGRhbXBpbmdSYXRpbzogMSxcbiAgZHVyYXRpb246IDEsXG4gIHZlbG9jaXR5OiAwLFxuICBtYXNzOiAxXG59O1xuZnVuY3Rpb24gaXNEYW1waW5nRHVyYXRpb25TcHJpbmdPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlb2Ygb3B0aW9ucy5kYW1waW5nUmF0aW8gPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIG9wdGlvbnMuZHVyYXRpb24gPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIG9wdGlvbnMubWFzcyA9PT0gXCJudW1iZXJcIjtcbn1cbnZhciBTcHJpbmdBbmltYXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgaW50ZXJwb2xhdGlvbikge1xuICAgIHRoaXMuaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XG4gICAgbGV0IF9vcHQ7XG4gICAgaWYgKGlzRGFtcGluZ0R1cmF0aW9uU3ByaW5nT3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgY29uc3QgdG9QYXNzID0geyAuLi5TcHJpbmdEYW1waW5nRHVyYXRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xuICAgICAgX29wdCA9IFNwcmluZ0N1cnZlVmFsdWVDb252ZXJ0ZXIuY29tcHV0ZURlcml2ZWRDdXJ2ZU9wdGlvbnModG9QYXNzLmRhbXBpbmdSYXRpbywgdG9QYXNzLmR1cmF0aW9uLCB0b1Bhc3MudmVsb2NpdHksIHRvUGFzcy5tYXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX29wdCA9IG9wdGlvbnM7XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucyA9IHsgLi4uU3ByaW5nVGVuc2lvbkZyaWN0aW9uRGVmYXVsdHMsIC4uLl9vcHQgfTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgeDogMCxcbiAgICAgIHY6IHRoaXMub3B0aW9ucy52ZWxvY2l0eVxuICAgIH07XG4gICAgdGhpcy5pbnRlZ3JhdG9yID0gbmV3IEludGVncmF0b3IoKHN0YXRlKSA9PiAtdGhpcy5vcHRpb25zLnRlbnNpb24gKiBzdGF0ZS54IC0gdGhpcy5vcHRpb25zLmZyaWN0aW9uICogc3RhdGUudik7XG4gIH1cbiAgaXNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlcnBvbGF0b3IgIT09IHZvaWQgMCAmJiB0aGlzLmRpZmZlcmVuY2UgIT09IHZvaWQgMDtcbiAgfVxuICBuZXh0KGRlbHRhMikge1xuICAgIHRoaXMuc3RhdGUgPSB0aGlzLmludGVncmF0b3IuaW50ZWdyYXRlU3RhdGUodGhpcy5zdGF0ZSwgZGVsdGEyKTtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW50ZXJwb2xhdG9yKHRoaXMucHJvZ3Jlc3MoKSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlzRmluaXNoZWQoKSB7XG4gICAgY29uc3QgcG9zaXRpb25OZWFyWmVybyA9IE1hdGguYWJzKHRoaXMuc3RhdGUueCkgPCB0aGlzLm9wdGlvbnMudG9sZXJhbmNlO1xuICAgIGNvbnN0IHZlbG9jaXR5TmVhclplcm8gPSBNYXRoLmFicyh0aGlzLnN0YXRlLnYpIDwgdGhpcy5vcHRpb25zLnRvbGVyYW5jZTtcbiAgICByZXR1cm4gcG9zaXRpb25OZWFyWmVybyAmJiB2ZWxvY2l0eU5lYXJaZXJvO1xuICB9XG4gIHNldEZyb20odmFsdWUpIHtcbiAgICB0aGlzLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZUludGVycG9sYXRvcigpO1xuICB9XG4gIHNldFZlbG9jaXR5KHZlbG9jaXR5KSB7XG4gICAgdGhpcy5zdGF0ZS52ID0gdmVsb2NpdHk7XG4gIH1cbiAgcHJvZ3Jlc3MoKSB7XG4gICAgcmV0dXJuIDEgLSB0aGlzLnN0YXRlLnggLyB0aGlzLmRpZmZlcmVuY2U7XG4gIH1cbiAgc2V0VG8odmFsdWUpIHtcbiAgICB0aGlzLmRlc3RpbmF0aW9uID0gdmFsdWU7XG4gICAgdGhpcy5kaWZmZXJlbmNlID0gdGhpcy5pbnRlcnBvbGF0aW9uLmRpZmZlcmVuY2UodGhpcy5kZXN0aW5hdGlvbiwgdGhpcy5jdXJyZW50KTtcbiAgICB0aGlzLnN0YXRlLnggPSB0aGlzLmRpZmZlcmVuY2U7XG4gICAgdGhpcy51cGRhdGVJbnRlcnBvbGF0b3IoKTtcbiAgfVxuICBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgfVxuICB1cGRhdGVJbnRlcnBvbGF0b3IoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudCA9PT0gdm9pZCAwIHx8IHRoaXMuZGVzdGluYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmludGVycG9sYXRvciA9IHRoaXMuaW50ZXJwb2xhdGlvbi5pbnRlcnBvbGF0ZSh0aGlzLmN1cnJlbnQsIHRoaXMuZGVzdGluYXRpb24pO1xuICB9XG59O1xuXG4vLyBzcmMvaW50ZXJwb2xhdGlvbi9JbnRlcnBvbGF0aW9uLnRzXG5mdW5jdGlvbiBpc0ludGVycG9sYXRhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJiB2YWx1ZS5pbnRlcnBvbGF0aW9uRm9yICYmIHR5cGVvZiB2YWx1ZS5pbnRlcnBvbGF0aW9uRm9yID09PSBcImZ1bmN0aW9uXCI7XG59XG52YXIgSW50ZXJwb2xhdGlvbjtcbihmdW5jdGlvbihJbnRlcnBvbGF0aW9uMykge1xuICBmdW5jdGlvbiBoYW5kbGVVbmRlZmluZWQoZnJvbSwgdG8pIHtcbiAgICBpZiAoZnJvbSA9PT0gdm9pZCAwKSB7XG4gICAgICBmcm9tID0gdG87XG4gICAgfVxuICAgIGlmICh0byA9PT0gdm9pZCAwKSB7XG4gICAgICB0byA9IGZyb207XG4gICAgfVxuICAgIHJldHVybiBbZnJvbSwgdG9dO1xuICB9XG4gIEludGVycG9sYXRpb24zLmhhbmRsZVVuZGVmaW5lZCA9IGhhbmRsZVVuZGVmaW5lZDtcbn0pKEludGVycG9sYXRpb24gfHwgKEludGVycG9sYXRpb24gPSB7fSkpO1xuXG4vLyBzcmMvaW50ZXJwb2xhdGlvbi9OdW1iZXJJbnRlcnBvbGF0aW9uLnRzXG52YXIgTnVtYmVySW50ZXJwb2xhdGlvbiA9IHtcbiAgaW50ZXJwb2xhdGUoZnJvbSwgdG8pIHtcbiAgICA7XG4gICAgW2Zyb20sIHRvXSA9IEludGVycG9sYXRpb24uaGFuZGxlVW5kZWZpbmVkKGZyb20sIHRvKTtcbiAgICBjb25zdCBhMSA9ICtmcm9tO1xuICAgIGNvbnN0IGIxID0gdG8gLSBhMTtcbiAgICByZXR1cm4gKHByb2dyZXNzMikgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBhMSArIGIxICogcHJvZ3Jlc3MyO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH0sXG4gIGRpZmZlcmVuY2UoZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gdG8gLSBmcm9tO1xuICB9XG59O1xuXG4vLyBzcmMvaW50ZXJwb2xhdGlvbi9PYmplY3RJbnRlcnBvbGF0aW9uLnRzXG52YXIgT2JqZWN0SW50ZXJwb2xhdGlvbiA9ICh2YWx1ZUludGVycG9sYXRpb24pID0+IHtcbiAgcmV0dXJuIHtcbiAgICBpbnRlcnBvbGF0ZShmcm9tLCB0bykge1xuICAgICAgO1xuICAgICAgW2Zyb20sIHRvXSA9IEludGVycG9sYXRpb24uaGFuZGxlVW5kZWZpbmVkKGZyb20sIHRvKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIGZyb20pO1xuICAgICAgY29uc3QgaW50ZXJwb2xhdGlvbnMgPSB7fTtcbiAgICAgIGNvbnN0IGtleXMyID0gbmV3IFNldCgpO1xuICAgICAgZm9yIChjb25zdCBrZXk2IGluIGZyb20pIHtcbiAgICAgICAgaW50ZXJwb2xhdGlvbnNba2V5Nl0gPSB2YWx1ZUludGVycG9sYXRpb24uaW50ZXJwb2xhdGUoZnJvbVtrZXk2XSwgdG9ba2V5Nl0pO1xuICAgICAgICBrZXlzMi5hZGQoa2V5Nik7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleTYgaW4gdG8pIHtcbiAgICAgICAgaWYgKCFrZXlzMi5oYXMoa2V5NikpIHtcbiAgICAgICAgICBpbnRlcnBvbGF0aW9uc1trZXk2XSA9IHZhbHVlSW50ZXJwb2xhdGlvbi5pbnRlcnBvbGF0ZShmcm9tW2tleTZdLCB0b1trZXk2XSk7XG4gICAgICAgICAga2V5czIuYWRkKGtleTYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gKHByb2dyZXNzMikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGtleTYgaW4gaW50ZXJwb2xhdGlvbnMpIHtcbiAgICAgICAgICByZXN1bHRba2V5Nl0gPSBpbnRlcnBvbGF0aW9uc1trZXk2XShwcm9ncmVzczIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0sXG4gICAgZGlmZmVyZW5jZShmcm9tLCB0bykge1xuICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGtleTYgaW4gZnJvbSkge1xuICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gdmFsdWVJbnRlcnBvbGF0aW9uLmRpZmZlcmVuY2UoZnJvbVtrZXk2XSwgdG9ba2V5Nl0pO1xuICAgICAgICBzdW0gKz0gTWF0aC5wb3coZGlmZmVyZW5jZSwgMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KHN1bSk7XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL2ludGVycG9sYXRpb24vTm9JbnRlcnBvbGF0aW9uLnRzXG52YXIgTm9JbnRlcnBvbGF0aW9uID0ge1xuICBpbnRlcnBvbGF0ZShmcm9tLCB0bykge1xuICAgIDtcbiAgICBbZnJvbSwgdG9dID0gSW50ZXJwb2xhdGlvbi5oYW5kbGVVbmRlZmluZWQoZnJvbSwgdG8pO1xuICAgIHJldHVybiAocHJvZ3Jlc3MyKSA9PiB7XG4gICAgICByZXR1cm4gcHJvZ3Jlc3MyIDwgMC41ID8gZnJvbSA6IHRvO1xuICAgIH07XG4gIH0sXG4gIGRpZmZlcmVuY2UoZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gZnJvbSA9PT0gdG8gPyAwIDogMTtcbiAgfVxufTtcblxuLy8gc3JjL2ludGVycG9sYXRpb24vQ29sb3JJbnRlcnBvbGF0aW9uLnRzXG52YXIgQ29sb3JJbnRlcnBvbGF0aW9uID0gKHR5cGUgPSBDb2xvck1peE1vZGVsVHlwZS5IVVNMKSA9PiB7XG4gIHJldHVybiB7XG4gICAgaW50ZXJwb2xhdGUoZnJvbSwgdG8pIHtcbiAgICAgIDtcbiAgICAgIFtmcm9tLCB0b10gPSBJbnRlcnBvbGF0aW9uLmhhbmRsZVVuZGVmaW5lZChmcm9tLCB0byk7XG4gICAgICByZXR1cm4gQ29sb3IuaW50ZXJwb2xhdGUoQ29sb3IoZnJvbSksIENvbG9yKHRvKSwgdHlwZSk7XG4gICAgfSxcbiAgICBkaWZmZXJlbmNlKGZyb20sIHRvKSB7XG4gICAgICByZXR1cm4gQ29sb3IuZGlmZmVyZW5jZShDb2xvcihmcm9tKSwgQ29sb3IodG8pKTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvaW50ZXJwb2xhdGlvbi9WYWx1ZUludGVycG9sYXRpb24udHNcbnZhciBEZWZhdWx0SW50ZXJwb2xhdGlvbk9wdGlvbnMgPSB7XG4gIGNvbG9yTW9kZWw6IENvbG9yTWl4TW9kZWxUeXBlLkhVU0xcbn07XG52YXIgVmFsdWVJbnRlcnBvbGF0aW9uID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0gRGVmYXVsdEludGVycG9sYXRpb25PcHRpb25zKSB7XG4gICAgdGhpcy5pbnRlcnBvbGF0ZSA9IChmcm9tLCB0bykgPT4ge1xuICAgICAgO1xuICAgICAgW2Zyb20sIHRvXSA9IEludGVycG9sYXRpb24uaGFuZGxlVW5kZWZpbmVkKGZyb20sIHRvKTtcbiAgICAgIHJldHVybiB0aGlzLmludGVyUG9sYXRpb25Gb3JWYWx1ZShmcm9tKS5pbnRlcnBvbGF0ZShmcm9tLCB0byk7XG4gICAgfTtcbiAgICB0aGlzLmRpZmZlcmVuY2UgPSAoZnJvbSwgdG8pID0+IHtcbiAgICAgIGNvbnN0IGludGVycG9sYXRpb24gPSB0aGlzLmludGVyUG9sYXRpb25Gb3JWYWx1ZShmcm9tKTtcbiAgICAgIHJldHVybiBpbnRlcnBvbGF0aW9uLmRpZmZlcmVuY2UoZnJvbSwgdG8pO1xuICAgIH07XG4gICAgdGhpcy5vcHRpb25zID0geyAuLi5EZWZhdWx0SW50ZXJwb2xhdGlvbk9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgfVxuICBpbnRlclBvbGF0aW9uRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gTnVtYmVySW50ZXJwb2xhdGlvbjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIE5vSW50ZXJwb2xhdGlvbjtcbiAgICB9IGVsc2UgaWYgKENvbG9yLmlzQ29sb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gQ29sb3JJbnRlcnBvbGF0aW9uKHRoaXMub3B0aW9ucy5jb2xvck1vZGVsKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gTm9JbnRlcnBvbGF0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3QgY29uc3RydWN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChjb25zdHJ1Y3RvciAmJiBpc0ludGVycG9sYXRhYmxlKGNvbnN0cnVjdG9yKSkge1xuICAgICAgICBjb25zdCBpbnRlcnBvbGF0aW9uID0gY29uc3RydWN0b3IuaW50ZXJwb2xhdGlvbkZvcih2YWx1ZSwgdGhpcyk7XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uICYmIGludGVycG9sYXRpb24gIT09IHRoaXMgJiYgaW50ZXJwb2xhdGlvbi5jb25zdHJ1Y3RvciAhPT0gVmFsdWVJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVycG9sYXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3RJbnRlcnBvbGF0aW9uKHRoaXMpO1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4oYE5vIGludGVycG9sYXRpb24gZGVmaW5lZCBmb3IgJHt2YWx1ZX1gKTtcbiAgICByZXR1cm4gTm9JbnRlcnBvbGF0aW9uO1xuICB9XG59O1xudmFyIEFueUludGVycG9sYXRpb24gPSBuZXcgVmFsdWVJbnRlcnBvbGF0aW9uKCk7XG5cbi8vIHNyYy9hbmltYXRpb24vQW5pbWF0b3JzL0luZXJ0aWFsU2Nyb2xsQW5pbWF0b3IudHNcbnZhciBEZWZhdWx0cyA9IHtcbiAgdmVsb2NpdHk6IDAsXG4gIG1pbjogMCxcbiAgbWF4OiAwLFxuICBtb21lbnR1bToge1xuICAgIGZyaWN0aW9uOiAyLFxuICAgIHRvbGVyYW5jZTogMTBcbiAgfSxcbiAgYm91bmNlOiB7XG4gICAgdGVuc2lvbjogNTAwLFxuICAgIGZyaWN0aW9uOiAxMCxcbiAgICB0b2xlcmFuY2U6IDFcbiAgfVxufTtcbnZhciBJbmVydGlhbFNjcm9sbEFuaW1hdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IC4uLkRlZmF1bHRzIH0sIG9wdGlvbnMpO1xuICAgIHRoaXMuZnJpY3Rpb25BbmltYXRvciA9IG5ldyBGcmljdGlvbkFuaW1hdG9yKHtcbiAgICAgIGZyaWN0aW9uOiB0aGlzLm9wdGlvbnMubW9tZW50dW0uZnJpY3Rpb24sXG4gICAgICB0b2xlcmFuY2U6IHRoaXMub3B0aW9ucy5tb21lbnR1bS50b2xlcmFuY2UsXG4gICAgICB2ZWxvY2l0eTogdGhpcy5vcHRpb25zLnZlbG9jaXR5XG4gICAgfSk7XG4gICAgdGhpcy5zcHJpbmdBbmltYXRvciA9IG5ldyBTcHJpbmdBbmltYXRvcih7XG4gICAgICB0ZW5zaW9uOiB0aGlzLm9wdGlvbnMuYm91bmNlLnRlbnNpb24sXG4gICAgICBmcmljdGlvbjogdGhpcy5vcHRpb25zLmJvdW5jZS5mcmljdGlvbixcbiAgICAgIHRvbGVyYW5jZTogdGhpcy5vcHRpb25zLmJvdW5jZS50b2xlcmFuY2UsXG4gICAgICB2ZWxvY2l0eTogdGhpcy5vcHRpb25zLnZlbG9jaXR5XG4gICAgfSwgTnVtYmVySW50ZXJwb2xhdGlvbik7XG4gICAgdGhpcy51c2VTcHJpbmcgPSBmYWxzZTtcbiAgfVxuICBpc1JlYWR5KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIG5leHQoZGVsdGEyKSB7XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5jdXJyZW50QW5pbWF0b3IubmV4dChkZWx0YTIpO1xuICAgIGlmICghdGhpcy51c2VTcHJpbmcpIHtcbiAgICAgIHRoaXMudHJ5VHJhbnNpdGlvblRvU3ByaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG4gIH1cbiAgZ2V0IGN1cnJlbnRBbmltYXRvcigpIHtcbiAgICBpZiAodGhpcy51c2VTcHJpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLnNwcmluZ0FuaW1hdG9yO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mcmljdGlvbkFuaW1hdG9yO1xuICB9XG4gIGlzRmluaXNoZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEFuaW1hdG9yLmlzRmluaXNoZWQoKTtcbiAgfVxuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEFuaW1hdG9yLmdldFN0YXRlKCk7XG4gIH1cbiAgc2V0RnJvbSh2YWx1ZSkge1xuICAgIHRoaXMuc2V0U3RhdGUoeyB4OiB2YWx1ZSwgdjogdGhpcy5zdGF0ZS52IH0pO1xuICB9XG4gIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgdGhpcy5mcmljdGlvbkFuaW1hdG9yLnNldEZyb20oc3RhdGUueCk7XG4gICAgdGhpcy5mcmljdGlvbkFuaW1hdG9yLnNldFZlbG9jaXR5KHN0YXRlLnYpO1xuICAgIGlmICh0aGlzLmlzVmFsaWRTdGF0ZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50cnlUcmFuc2l0aW9uVG9TcHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGJvdW5kID0gMDtcbiAgICAgIGlmICh0aGlzLnN0YXRlLnggPD0gdGhpcy5vcHRpb25zLm1pbikge1xuICAgICAgICBib3VuZCA9IHRoaXMub3B0aW9ucy5taW47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGF0ZS54ID49IHRoaXMub3B0aW9ucy5tYXgpIHtcbiAgICAgICAgYm91bmQgPSB0aGlzLm9wdGlvbnMubWF4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvU3ByaW5nKGJvdW5kKTtcbiAgICB9XG4gIH1cbiAgc2V0VG8oZGVzdGluYXRpb24pIHtcbiAgICB0aGlzLmZyaWN0aW9uQW5pbWF0b3Iuc2V0VG8oZGVzdGluYXRpb24pO1xuICAgIHRoaXMuc3ByaW5nQW5pbWF0b3Iuc2V0VG8oZGVzdGluYXRpb24pO1xuICB9XG4gIHNldExpbWl0cyhtaW4sIG1heCkge1xuICAgIHRoaXMub3B0aW9ucy5taW4gPSBtaW47XG4gICAgdGhpcy5vcHRpb25zLm1heCA9IG1heDtcbiAgfVxuICB0cnlUcmFuc2l0aW9uVG9TcHJpbmcoKSB7XG4gICAgY29uc3QgYmVsb3dNaW5XaXRoVmVsb2NpdHkgPSB0aGlzLnN0YXRlLnggPCB0aGlzLm9wdGlvbnMubWluICYmIHRoaXMuc3RhdGUudiA8PSAwO1xuICAgIGNvbnN0IGFib3ZlTWF4V2l0aFZlbG9jaXR5ID0gdGhpcy5zdGF0ZS54ID4gdGhpcy5vcHRpb25zLm1heCAmJiB0aGlzLnN0YXRlLnYgPj0gMDtcbiAgICBpZiAoYmVsb3dNaW5XaXRoVmVsb2NpdHkgfHwgYWJvdmVNYXhXaXRoVmVsb2NpdHkpIHtcbiAgICAgIGxldCBib3VuZDtcbiAgICAgIGlmIChiZWxvd01pbldpdGhWZWxvY2l0eSkge1xuICAgICAgICBib3VuZCA9IHRoaXMub3B0aW9ucy5taW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib3VuZCA9IHRoaXMub3B0aW9ucy5tYXg7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYW5zaXRpb25Ub1NwcmluZyhib3VuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXNlU3ByaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHRyYW5zaXRpb25Ub1NwcmluZyhib3VuZCkge1xuICAgIHRoaXMuc3ByaW5nQW5pbWF0b3Iuc2V0RnJvbSh0aGlzLnN0YXRlLngpO1xuICAgIHRoaXMuc3ByaW5nQW5pbWF0b3Iuc2V0VmVsb2NpdHkodGhpcy5zdGF0ZS52KTtcbiAgICB0aGlzLnNwcmluZ0FuaW1hdG9yLnNldFRvKGJvdW5kKTtcbiAgICB0aGlzLnVzZVNwcmluZyA9IHRydWU7XG4gIH1cbiAgaXNWYWxpZFN0YXRlKCkge1xuICAgIGNvbnN0IGJlbG93TWluVHJhdmVsaW5nQmFjayA9IHRoaXMuc3RhdGUueCA8IHRoaXMub3B0aW9ucy5taW4gJiYgdGhpcy5zdGF0ZS52ID4gMDtcbiAgICBjb25zdCBhYm92ZU1heFRyYXZlbGluZ0JhY2sgPSB0aGlzLnN0YXRlLnggPiB0aGlzLm9wdGlvbnMubWF4ICYmIHRoaXMuc3RhdGUudiA8IDA7XG4gICAgaWYgKGJlbG93TWluVHJhdmVsaW5nQmFjayB8fCBhYm92ZU1heFRyYXZlbGluZ0JhY2spIHtcbiAgICAgIGxldCBib3VuZDtcbiAgICAgIGlmIChiZWxvd01pblRyYXZlbGluZ0JhY2spIHtcbiAgICAgICAgYm91bmQgPSB0aGlzLm9wdGlvbnMubWluO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYm91bmQgPSB0aGlzLm9wdGlvbnMubWF4O1xuICAgICAgfVxuICAgICAgY29uc3QgZnJpY3Rpb24gPSB0aGlzLmZyaWN0aW9uQW5pbWF0b3Iub3B0aW9ucy5mcmljdGlvbjtcbiAgICAgIGNvbnN0IHNvbHV0aW9uID0gMSAtIGZyaWN0aW9uICogKGJvdW5kIC0gdGhpcy5zdGF0ZS54KSAvIHRoaXMuc3RhdGUudjtcbiAgICAgIHJldHVybiBzb2x1dGlvbiA+IDA7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vLyBzcmMvYW5pbWF0aW9uL0RyaXZlcnMvQW5pbWF0aW9uRHJpdmVyLnRzXG52YXIgQW5pbWF0aW9uRHJpdmVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihhbmltYXRvciwgdXBkYXRlQ2FsbGJhY2ssIGZpbmlzaGVkQ2FsbGJhY2spIHtcbiAgICB0aGlzLmFuaW1hdG9yID0gYW5pbWF0b3I7XG4gICAgdGhpcy51cGRhdGVDYWxsYmFjayA9IHVwZGF0ZUNhbGxiYWNrO1xuICAgIHRoaXMuZmluaXNoZWRDYWxsYmFjayA9IGZpbmlzaGVkQ2FsbGJhY2s7XG4gICAgdGhpcy51cGRhdGUgPSAoZnJhbWUyLCBlbGFwc2VkKSA9PiB7XG4gICAgICBpZiAodGhpcy5hbmltYXRvci5pc0ZpbmlzaGVkKCkpIHtcbiAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5hbmltYXRvci5uZXh0KGVsYXBzZWQpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICghdGhpcy5hbmltYXRvci5pc1JlYWR5KCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkFuaW1hdGlvbkRyaXZlciBpbml0aWFsaXplZCB3aXRoIGFuaW1hdG9yIHRoYXQgaXNuJ3QgcmVhZHlcIik7XG4gICAgfVxuICB9XG4gIGZpbmlzaCgpIHtcbiAgICBpZiAodGhpcy5maW5pc2hlZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLmZpbmlzaGVkQ2FsbGJhY2sodGhpcy5hbmltYXRvci5pc0ZpbmlzaGVkKCkpO1xuICAgIH1cbiAgfVxuICBpc0ZpbmlzaGVkKCkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdG9yLmlzRmluaXNoZWQoKTtcbiAgfVxufTtcblxuLy8gc3JjL2FuaW1hdGlvbi9Ecml2ZXJzL01haW5Mb29wRHJpdmVyLnRzXG52YXIgTWFpbkxvb3BBbmltYXRpb25Ecml2ZXIgPSBjbGFzcyBleHRlbmRzIEFuaW1hdGlvbkRyaXZlciB7XG4gIHBsYXkoKSB7XG4gICAgaWYgKFJlbmRlckVudmlyb25tZW50LnRhcmdldCAhPT0gUmVuZGVyVGFyZ2V0LnByZXZpZXcpIHtcbiAgICAgIHRoaXMuZmluaXNoZWRDYWxsYmFjayAmJiB0aGlzLmZpbmlzaGVkQ2FsbGJhY2soZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBNYWluTG9vcC5vbihcInVwZGF0ZVwiLCB0aGlzLnVwZGF0ZSk7XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIE1haW5Mb29wLm9mZihcInVwZGF0ZVwiLCB0aGlzLnVwZGF0ZSk7XG4gIH1cbiAgZmluaXNoKCkge1xuICAgIE1haW5Mb29wLm9mZihcInVwZGF0ZVwiLCB0aGlzLnVwZGF0ZSk7XG4gICAgc3VwZXIuZmluaXNoKCk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb21wb25lbnRzL2hvYy9XaXRoRHJhZ2dpbmcudHN4XG52YXIgRHJhZ2dpbmdDb250ZXh0ID0gY3JlYXRlQ29udGV4dDEwKHsgZHJhZ2dpbmc6IGZhbHNlIH0pO1xudmFyIGhvaXN0Tm9uUmVhY3RTdGF0aWMgPSByZXF1aXJlX2hvaXN0X25vbl9yZWFjdF9zdGF0aWNzX2NqcygpO1xuZnVuY3Rpb24gV2l0aERyYWdnaW5nKENvbXBvbmVudDE5KSB7XG4gIGNvbnN0IF9XaXRoRHJhZ2dpbmdIT0MgPSBjbGFzcyBleHRlbmRzIENvbXBvbmVudDQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzLCBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIHN1cGVyKHByb3BzLCBkZWZhdWx0UHJvcHMpO1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgaXNEcmFnZ2luZzogZmFsc2VcbiAgICAgIH07XG4gICAgICB0aGlzLnggPSBBbmltYXRhYmxlKDApO1xuICAgICAgdGhpcy55ID0gQW5pbWF0YWJsZSgwKTtcbiAgICAgIHRoaXMub25DaGFuZ2VQb3NpdGlvbiA9IChjaGFuZ2UsIHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAgIGlmIChjaGFuZ2UudmFsdWUgPT09IGNoYW5nZS5vbGRWYWx1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbk1vdmUpIHtcbiAgICAgICAgICB0aGlzLnByb3BzLm9uTW92ZSh0aGlzLnBvaW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMuaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGlyZWN0aW9uTG9ja0F4aXMgPSBudWxsO1xuICAgICAgdGhpcy5fY29uc3RyYWludHMgPSBudWxsO1xuICAgICAgdGhpcy5wYW5TdGFydCA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMuZW5hYmxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzTW92aW5nID0gdGhpcy5pc0FuaW1hdGluZztcbiAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgIHRoaXMucmVzZXRkaXJlY3Rpb25Mb2NrKCk7XG4gICAgICAgIHRoaXMubGF5ZXJTdGFydFBvaW50ID0gdGhpcy5wb2ludDtcbiAgICAgICAgdGhpcy5jb3JyZWN0ZWRMYXllclN0YXJ0UG9pbnQgPSB0aGlzLnBvaW50O1xuICAgICAgICBpZiAodGhpcy5fY29uc3RyYWludHMgJiYgdGhpcy5wcm9wcy5ib3VuY2UpIHtcbiAgICAgICAgICB0aGlzLmNvcnJlY3RlZExheWVyU3RhcnRQb2ludCA9IHRoaXMuY29uc3RyYWluUG9zaXRpb24odGhpcy5jb3JyZWN0ZWRMYXllclN0YXJ0UG9pbnQsIHRoaXMuX2NvbnN0cmFpbnRzLCAxIC8gdGhpcy5wcm9wcy5vdmVyZHJhZ1NjYWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXZpb3VzUG9pbnQgPSB0aGlzLmNvcnJlY3RlZExheWVyU3RhcnRQb2ludDtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgaXNEcmFnZ2luZzogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkRyYWdTZXNzaW9uU3RhcnQpIHtcbiAgICAgICAgICB0aGlzLnByb3BzLm9uRHJhZ1Nlc3Npb25TdGFydChldmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLnBhbiA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZW5hYmxlZCxcbiAgICAgICAgICBzcGVlZFgsXG4gICAgICAgICAgc3BlZWRZLFxuICAgICAgICAgIGRpcmVjdGlvbkxvY2ssXG4gICAgICAgICAgb3ZlcmRyYWdTY2FsZSxcbiAgICAgICAgICB2ZXJ0aWNhbCxcbiAgICAgICAgICBob3Jpem9udGFsLFxuICAgICAgICAgIHBpeGVsQWxpZ24sXG4gICAgICAgICAgb25EcmFnU3RhcnQsXG4gICAgICAgICAgb25EcmFnV2lsbE1vdmUsXG4gICAgICAgICAgb25EcmFnRGlkTW92ZSxcbiAgICAgICAgICBvbkRyYWdTZXNzaW9uTW92ZVxuICAgICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwb2ludCA9IHsgLi4udGhpcy5wcmV2aW91c1BvaW50IH07XG4gICAgICAgIHBvaW50LnggKz0gZXZlbnQuZGVsdGEueCAqIHNwZWVkWDtcbiAgICAgICAgcG9pbnQueSArPSBldmVudC5kZWx0YS55ICogc3BlZWRZO1xuICAgICAgICB0aGlzLnByZXZpb3VzUG9pbnQgPSB7IC4uLnBvaW50IH07XG4gICAgICAgIGlmICh0aGlzLl9jb25zdHJhaW50cykge1xuICAgICAgICAgIHBvaW50ID0gdGhpcy5jb25zdHJhaW5Qb3NpdGlvbihwb2ludCwgdGhpcy5fY29uc3RyYWludHMsIG92ZXJkcmFnU2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJlY3Rpb25Mb2NrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uTG9ja0F4aXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGV2ZW50Lm9mZnNldDtcbiAgICAgICAgICAgIG9mZnNldC54ID0gb2Zmc2V0LnggKiBzcGVlZFg7XG4gICAgICAgICAgICBvZmZzZXQueSA9IG9mZnNldC55ICogc3BlZWRZO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVkaXJlY3Rpb25Mb2NrKG9mZnNldCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbkxvY2tBeGlzID09PSBcInlcIikge1xuICAgICAgICAgICAgICBwb2ludC54ID0gdGhpcy5sYXllclN0YXJ0UG9pbnQueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbkxvY2tBeGlzID09PSBcInhcIikge1xuICAgICAgICAgICAgICBwb2ludC55ID0gdGhpcy5sYXllclN0YXJ0UG9pbnQueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgaXNEcmFnZ2luZzogdHJ1ZSB9KTtcbiAgICAgICAgICB0aGlzLmlzTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgICBpZiAob25EcmFnU3RhcnQpIHtcbiAgICAgICAgICAgIG9uRHJhZ1N0YXJ0KGV2ZW50LCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRHJhZ1dpbGxNb3ZlKSB7XG4gICAgICAgICAgb25EcmFnV2lsbE1vdmUoZXZlbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwaXhlbEFsaWduKSB7XG4gICAgICAgICAgcG9pbnQueCA9IE1hdGgucm91bmQocG9pbnQueCk7XG4gICAgICAgICAgcG9pbnQueSA9IE1hdGgucm91bmQocG9pbnQueSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFob3Jpem9udGFsICYmICF2ZXJ0aWNhbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXhpcyA9IG51bGw7XG4gICAgICAgIGlmIChob3Jpem9udGFsICYmICF2ZXJ0aWNhbCkge1xuICAgICAgICAgIGF4aXMgPSBcInhcIjtcbiAgICAgICAgfSBlbHNlIGlmICh2ZXJ0aWNhbCAmJiAhaG9yaXpvbnRhbCkge1xuICAgICAgICAgIGF4aXMgPSBcInlcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFBvaW50KHBvaW50LCBheGlzKTtcbiAgICAgICAgaWYgKG9uRHJhZ0RpZE1vdmUpIHtcbiAgICAgICAgICBvbkRyYWdEaWRNb3ZlKGV2ZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25EcmFnU2Vzc2lvbk1vdmUpIHtcbiAgICAgICAgICBvbkRyYWdTZXNzaW9uTW92ZShldmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLnBhbkVuZCA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMucHJvcHMuZW5hYmxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0QW5pbWF0aW9uKGV2ZW50KTtcbiAgICAgICAgY29uc3QgeyBvbkRyYWdTZXNzaW9uRW5kLCBvbkRyYWdFbmQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICBpZiAob25EcmFnRW5kKSB7XG4gICAgICAgICAgICBvbkRyYWdFbmQoZXZlbnQsIHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob25EcmFnU2Vzc2lvbkVuZCkge1xuICAgICAgICAgIG9uRHJhZ1Nlc3Npb25FbmQoZXZlbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgaXNEcmFnZ2luZzogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc01vdmluZyA9IHRoaXMuaXNBbmltYXRpbmc7XG4gICAgICB9O1xuICAgICAgdGhpcy5tb3VzZVdoZWVsU3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5jb3JyZWN0ZWRMYXllclN0YXJ0UG9pbnQgPSB0aGlzLnBvaW50O1xuICAgICAgICB0aGlzLnByZXZpb3VzUG9pbnQgPSB0aGlzLmNvcnJlY3RlZExheWVyU3RhcnRQb2ludDtcbiAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5tb3VzZVdoZWVsID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBlbmFibGVkLFxuICAgICAgICAgIHNwZWVkWCxcbiAgICAgICAgICBzcGVlZFksXG4gICAgICAgICAgdmVydGljYWwsXG4gICAgICAgICAgaG9yaXpvbnRhbCxcbiAgICAgICAgICBwaXhlbEFsaWduLFxuICAgICAgICAgIG9uRHJhZ1dpbGxNb3ZlLFxuICAgICAgICAgIG9uRHJhZ0RpZE1vdmUsXG4gICAgICAgICAgbW91c2VXaGVlbFxuICAgICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKCFtb3VzZVdoZWVsIHx8ICFlbmFibGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwb2ludCA9IHsgLi4udGhpcy5wb2ludCB9O1xuICAgICAgICBwb2ludC54IC09IGV2ZW50LmRlbHRhLnggKiBzcGVlZFg7XG4gICAgICAgIHBvaW50LnkgLT0gZXZlbnQuZGVsdGEueSAqIHNwZWVkWTtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgcG9pbnQgPSB0aGlzLmNvbnN0cmFpblBvc2l0aW9uKHBvaW50LCB0aGlzLl9jb25zdHJhaW50cywgMCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkRyYWdXaWxsTW92ZSkge1xuICAgICAgICAgIG9uRHJhZ1dpbGxNb3ZlKGV2ZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGl4ZWxBbGlnbikge1xuICAgICAgICAgIHBvaW50LnggPSBNYXRoLnJvdW5kKHBvaW50LngpO1xuICAgICAgICAgIHBvaW50LnkgPSBNYXRoLnJvdW5kKHBvaW50LnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaG9yaXpvbnRhbCAmJiAhdmVydGljYWwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGF4aXMgPSBudWxsO1xuICAgICAgICBpZiAoaG9yaXpvbnRhbCAmJiAhdmVydGljYWwpIHtcbiAgICAgICAgICBheGlzID0gXCJ4XCI7XG4gICAgICAgIH0gZWxzZSBpZiAodmVydGljYWwgJiYgIWhvcml6b250YWwpIHtcbiAgICAgICAgICBheGlzID0gXCJ5XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRQb2ludChwb2ludCwgYXhpcyk7XG4gICAgICAgIGlmIChvbkRyYWdEaWRNb3ZlKSB7XG4gICAgICAgICAgb25EcmFnRGlkTW92ZShldmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLm1vdXNlV2hlZWxFbmQgPSAoZXZlbnQpID0+IHtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uQW5pbWF0aW9uU3RlcCA9IChheGlzLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoYXhpcyA9PT0gXCJ4XCIgJiYgdGhpcy5wcm9wcy5ob3Jpem9udGFsID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXhpcyA9PT0gXCJ5XCIgJiYgdGhpcy5wcm9wcy52ZXJ0aWNhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlbHRhMiA9IDA7XG4gICAgICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgaWYgKHRoaXMucHJvcHMuYm91bmNlKSB7XG4gICAgICAgICAgICBkZWx0YTIgPSB2YWx1ZSAtIHRoaXMuZ2V0VmFsdWUoYXhpcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbWluWCwgbWluWSwgbWF4WCwgbWF4WSB9ID0gdGhpcy5jYWxjdWxhdGVDb25zdHJhaW50cyh0aGlzLl9jb25zdHJhaW50cyk7XG4gICAgICAgICAgICBpZiAoYXhpcyA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgICAgZGVsdGEyID0gY2xhbXAzKHZhbHVlLCBtaW5YLCBtYXhYKSAtIHRoaXMuZ2V0VmFsdWUoYXhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXhpcyA9PT0gXCJ5XCIpIHtcbiAgICAgICAgICAgICAgZGVsdGEyID0gY2xhbXAzKHZhbHVlLCBtaW5ZLCBtYXhZKSAtIHRoaXMuZ2V0VmFsdWUoYXhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbHRhMiA9IHZhbHVlIC0gdGhpcy5nZXRWYWx1ZShheGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGRhdGVQb2ludCA9IHRoaXMucG9pbnQ7XG4gICAgICAgIGlmIChheGlzID09PSBcInhcIikge1xuICAgICAgICAgIHVwZGF0ZVBvaW50W2F4aXNdID0gdXBkYXRlUG9pbnRbYXhpc10gKyBkZWx0YTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF4aXMgPT09IFwieVwiKSB7XG4gICAgICAgICAgdXBkYXRlUG9pbnRbYXhpc10gPSB1cGRhdGVQb2ludFtheGlzXSArIGRlbHRhMjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFBvaW50KHVwZGF0ZVBvaW50LCBheGlzKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uQW5pbWF0aW9uU3RvcCA9IChheGlzKSA9PiB7XG4gICAgICAgIGlmIChheGlzID09PSBcInhcIiAmJiB0aGlzLnByb3BzLmhvcml6b250YWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChheGlzID09PSBcInlcIiAmJiB0aGlzLnByb3BzLnZlcnRpY2FsID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnBpeGVsQWxpZ24pIHtcbiAgICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMucG9pbnQ7XG4gICAgICAgICAgcG9pbnQueCA9IE1hdGgucm91bmQocG9pbnQueCk7XG4gICAgICAgICAgcG9pbnQueSA9IE1hdGgucm91bmQocG9pbnQueSk7XG4gICAgICAgICAgdGhpcy5zZXRQb2ludChwb2ludCwgYXhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uLnguaXNGaW5pc2hlZCgpICYmIHRoaXMuYW5pbWF0aW9uLnkuaXNGaW5pc2hlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLmFuaW1hdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFuaW1hdGlvbi54LmNhbmNlbCgpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbi55LmNhbmNlbCgpO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkRyYWdBbmltYXRpb25FbmQpIHtcbiAgICAgICAgICB0aGlzLnByb3BzLm9uRHJhZ0FuaW1hdGlvbkVuZCh0aGlzLmFuaW1hdGlvbiwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBudWxsO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHggPSB0aGlzLnByb3BzLmxlZnQ7XG4gICAgICBjb25zdCB5ID0gdGhpcy5wcm9wcy50b3A7XG4gICAgICBpZiAoIXgpIHtcbiAgICAgICAgdGhpcy54ID0gQW5pbWF0YWJsZSgwKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBbmltYXRhYmxlMih4KSkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy54ID0gQW5pbWF0YWJsZSh4KTtcbiAgICAgIH1cbiAgICAgIGlmICgheSkge1xuICAgICAgICB0aGlzLnkgPSBBbmltYXRhYmxlKDApO1xuICAgICAgfSBlbHNlIGlmIChpc0FuaW1hdGFibGUyKHkpKSB7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnkgPSBBbmltYXRhYmxlKHkpO1xuICAgICAgfVxuICAgICAgdGhpcy54Lm9uVXBkYXRlKHRoaXMub25DaGFuZ2VQb3NpdGlvbik7XG4gICAgICB0aGlzLnkub25VcGRhdGUodGhpcy5vbkNoYW5nZVBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gdGhpcy5wcm9wcy5jb25zdHJhaW50cztcbiAgICAgIGlmIChjb25zdHJhaW50cykge1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gY29uc3RyYWludHM7XG4gICAgICB9XG4gICAgfVxuICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHByb3BzKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5sZWZ0ICE9PSBwcm9wcy5sZWZ0ICYmIGlzRmluaXRlTnVtYmVyKHByb3BzLmxlZnQpKSB7XG4gICAgICAgIHRoaXMueC5zZXQocHJvcHMubGVmdCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcm9wcy50b3AgIT09IHByb3BzLnRvcCAmJiBpc0Zpbml0ZU51bWJlcihwcm9wcy50b3ApKSB7XG4gICAgICAgIHRoaXMueS5zZXQocHJvcHMudG9wKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gcHJvcHMuY29uc3RyYWludHM7XG4gICAgICBpZiAoY29uc3RyYWludHMpIHtcbiAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXQgcG9pbnQoKSB7XG4gICAgICByZXR1cm4geyB4OiB0aGlzLnguZ2V0KCksIHk6IHRoaXMueS5nZXQoKSB9O1xuICAgIH1cbiAgICBzZXRQb2ludChwb2ludCwgYXhpcyA9IG51bGwpIHtcbiAgICAgIHN3aXRjaCAoYXhpcykge1xuICAgICAgICBjYXNlIFwieFwiOlxuICAgICAgICAgIHRoaXMueC5zZXQocG9pbnQueCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgdGhpcy55LnNldChwb2ludC55KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgIHRoaXMueC5zZXQocG9pbnQueCk7XG4gICAgICAgICAgdGhpcy55LnNldChwb2ludC55KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0VmFsdWUoYXhpcykge1xuICAgICAgc3dpdGNoIChheGlzKSB7XG4gICAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMueC5nZXQoKTtcbiAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy55LmdldCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IHRoaXMucHJvcHMud2lkdGg7XG4gICAgICBpZiAoIXdpZHRoKSB7XG4gICAgICAgIHJldHVybiAxMDA7XG4gICAgICB9XG4gICAgICBpZiAoaXNBbmltYXRhYmxlMih3aWR0aCkpIHtcbiAgICAgICAgcmV0dXJuIHdpZHRoLmdldCgpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB3aWR0aCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh3aWR0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2lkdGg7XG4gICAgfVxuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLnByb3BzLmhlaWdodDtcbiAgICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiAxMDA7XG4gICAgICB9XG4gICAgICBpZiAoaXNBbmltYXRhYmxlMihoZWlnaHQpKSB7XG4gICAgICAgIHJldHVybiBoZWlnaHQuZ2V0KCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGhlaWdodCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChoZWlnaHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9XG4gICAgZ2V0IGNvbnN0cmFpbnRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnN0cmFpbnRzO1xuICAgIH1cbiAgICBzZXQgY29uc3RyYWludHModmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhpcy5fY29uc3RyYWludHMgPSB7XG4gICAgICAgICAgeDogdmFsdWUueCB8fCAwLFxuICAgICAgICAgIHk6IHZhbHVlLnkgfHwgMCxcbiAgICAgICAgICB3aWR0aDogdmFsdWUud2lkdGggfHwgMCxcbiAgICAgICAgICBoZWlnaHQ6IHZhbHVlLmhlaWdodCB8fCAwXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50cyA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fY29uc3RyYWludHMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVBbmltYXRpb25Db25zdHJhaW50cyh0aGlzLl9jb25zdHJhaW50cyk7XG4gICAgICB9XG4gICAgfVxuICAgIGdldCBjb25zdHJhaW50c09mZnNldCgpIHtcbiAgICAgIGlmICghdGhpcy5jb25zdHJhaW50cykge1xuICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gICAgICB9XG4gICAgICBjb25zdCB7IG1pblgsIG1pblksIG1heFgsIG1heFkgfSA9IHRoaXMuY2FsY3VsYXRlQ29uc3RyYWludHModGhpcy5fY29uc3RyYWludHMpO1xuICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLnBvaW50O1xuICAgICAgY29uc3QgY29uc3RyYWluZWRQb2ludCA9IHsgeDogY2xhbXAzKHBvaW50LngsIG1pblgsIG1heFgpLCB5OiBjbGFtcDMocG9pbnQueSwgbWluWSwgbWF4WSkgfTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHsgeDogcG9pbnQueCAtIGNvbnN0cmFpbmVkUG9pbnQueCwgeTogcG9pbnQueSAtIGNvbnN0cmFpbmVkUG9pbnQueSB9O1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgZ2V0IGlzQmV5b25kQ29uc3RyYWludHMoKSB7XG4gICAgICBjb25zdCBjb25zdHJhaW50c09mZnNldCA9IHRoaXMuY29uc3RyYWludHNPZmZzZXQ7XG4gICAgICBpZiAoY29uc3RyYWludHNPZmZzZXQueCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjb25zdHJhaW50c09mZnNldC55ICE9PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjbGFtcEFuZFNjYWxlKHZhbHVlLCBtaW4sIG1heCwgc2NhbGUyLCBzY2FsZUFsbG93ZWQpIHtcbiAgICAgIGlmICghc2NhbGVBbGxvd2VkKSB7XG4gICAgICAgIHJldHVybiBjbGFtcDModmFsdWUsIG1pbiwgbWF4KTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICB2YWx1ZSA9IG1pbiArICh2YWx1ZSAtIG1pbikgKiBzY2FsZTI7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgdmFsdWUgPSBtYXggKyAodmFsdWUgLSBtYXgpICogc2NhbGUyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjYWxjdWxhdGVDb25zdHJhaW50cyhib3VuZHMpIHtcbiAgICAgIGlmICghYm91bmRzKSB7XG4gICAgICAgIHJldHVybiB7IG1pblg6IEluZmluaXR5LCBtYXhYOiBJbmZpbml0eSwgbWluWTogSW5maW5pdHksIG1heFk6IEluZmluaXR5IH07XG4gICAgICB9XG4gICAgICBpZiAoYm91bmRzLndpZHRoIDwgdGhpcy53aWR0aCkge1xuICAgICAgICBib3VuZHMud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGJvdW5kcy5oZWlnaHQgPCB0aGlzLmhlaWdodCkge1xuICAgICAgICBib3VuZHMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICB9XG4gICAgICBjb25zdCBjb25zdHJhaW50cyA9IHtcbiAgICAgICAgbWluWDogUmVjdC5taW5YKGJvdW5kcyksXG4gICAgICAgIG1heFg6IFJlY3QubWF4WChib3VuZHMpLFxuICAgICAgICBtaW5ZOiBSZWN0Lm1pblkoYm91bmRzKSxcbiAgICAgICAgbWF4WTogUmVjdC5tYXhZKGJvdW5kcylcbiAgICAgIH07XG4gICAgICBjb25zdHJhaW50cy5tYXhYIC09IHRoaXMud2lkdGg7XG4gICAgICBjb25zdHJhaW50cy5tYXhZIC09IHRoaXMuaGVpZ2h0O1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xuICAgIH1cbiAgICBjb25zdHJhaW5Qb3NpdGlvbihwcm9wb3NlZFBvaW50LCBib3VuZHMsIHNjYWxlMiwgb3ZlcmRyYWcgPSB0aGlzLnByb3BzLm92ZXJkcmFnKSB7XG4gICAgICBjb25zdCB7IG1heFgsIG1heFksIG1pblgsIG1pblkgfSA9IHRoaXMuY2FsY3VsYXRlQ29uc3RyYWludHModGhpcy5fY29uc3RyYWludHMpO1xuICAgICAgY29uc3QgcG9pbnQgPSB7XG4gICAgICAgIHg6IHRoaXMuY2xhbXBBbmRTY2FsZShwcm9wb3NlZFBvaW50LngsIG1pblgsIG1heFgsIHNjYWxlMiwgb3ZlcmRyYWcpLFxuICAgICAgICB5OiB0aGlzLmNsYW1wQW5kU2NhbGUocHJvcG9zZWRQb2ludC55LCBtaW5ZLCBtYXhZLCBzY2FsZTIsIG92ZXJkcmFnKVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLnByb3BzLnNwZWVkWCA9PT0gMCB8fCB0aGlzLnByb3BzLmhvcml6b250YWwgPT09IGZhbHNlKSB7XG4gICAgICAgIHBvaW50LnggPSBwcm9wb3NlZFBvaW50Lng7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcm9wcy5zcGVlZFkgPT09IDAgfHwgdGhpcy5wcm9wcy52ZXJ0aWNhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcG9pbnQueSA9IHByb3Bvc2VkUG9pbnQueTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gICAgdXBkYXRlZGlyZWN0aW9uTG9jayhjb3JyZWN0ZWREZWx0YSkge1xuICAgICAgaWYgKE1hdGguYWJzKGNvcnJlY3RlZERlbHRhLnkpID4gdGhpcy5wcm9wcy5kaXJlY3Rpb25Mb2NrVGhyZXNob2xkLnkpIHtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb25Mb2NrQXhpcyA9IFwieVwiO1xuICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhjb3JyZWN0ZWREZWx0YS54KSA+IHRoaXMucHJvcHMuZGlyZWN0aW9uTG9ja1RocmVzaG9sZC54KSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uTG9ja0F4aXMgPSBcInhcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRpcmVjdGlvbkxvY2tBeGlzICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uRHJhZ0RpcmVjdGlvbkxvY2tTdGFydCkge1xuICAgICAgICAgIHRoaXMucHJvcHMub25EcmFnRGlyZWN0aW9uTG9ja1N0YXJ0KHRoaXMuZGlyZWN0aW9uTG9ja0F4aXMsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlc2V0ZGlyZWN0aW9uTG9jaygpIHtcbiAgICAgIHRoaXMuZGlyZWN0aW9uTG9ja0F4aXMgPSBudWxsO1xuICAgIH1cbiAgICBzZXR1cEFuaW1hdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmFuaW1hdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmFuaW1hdGlvbiA9IHsgeDogdGhpcy5zZXR1cEFuaW1hdGlvbkZvckF4aXMoXCJ4XCIpLCB5OiB0aGlzLnNldHVwQW5pbWF0aW9uRm9yQXhpcyhcInlcIikgfTtcbiAgICAgIHRoaXMudXBkYXRlQW5pbWF0aW9uQ29uc3RyYWludHModGhpcy5fY29uc3RyYWludHMpO1xuICAgIH1cbiAgICBzZXR1cEFuaW1hdGlvbkZvckF4aXMoYXhpcykge1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHt9O1xuICAgICAgcHJvcGVydGllc1theGlzXSA9IHRydWU7XG4gICAgICBjb25zdCBhbmltYXRvciA9IG5ldyBJbmVydGlhbFNjcm9sbEFuaW1hdG9yKHtcbiAgICAgICAgbW9tZW50dW06IHRoaXMucHJvcHMubW9tZW50dW1PcHRpb25zLFxuICAgICAgICBib3VuY2U6IHRoaXMucHJvcHMuYm91bmNlT3B0aW9uc1xuICAgICAgfSk7XG4gICAgICBjb25zdCB1cGRhdGVDYWxsYmFjayA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLm9uQW5pbWF0aW9uU3RlcChheGlzLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgZG9uZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICB0aGlzLm9uQW5pbWF0aW9uU3RvcChheGlzKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gbmV3IE1haW5Mb29wQW5pbWF0aW9uRHJpdmVyKGFuaW1hdG9yLCB1cGRhdGVDYWxsYmFjaywgZG9uZUNhbGxiYWNrKTtcbiAgICB9XG4gICAgdXBkYXRlQW5pbWF0aW9uQ29uc3RyYWludHMoY29uc3RyYWludHMpIHtcbiAgICAgIGlmICghdGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnN0cmFpbnRzKSB7XG4gICAgICAgIGNvbnN0IHsgbWluWCwgbWluWSwgbWF4WCwgbWF4WSB9ID0gdGhpcy5jYWxjdWxhdGVDb25zdHJhaW50cyhjb25zdHJhaW50cyk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uLnguYW5pbWF0b3Iuc2V0TGltaXRzKG1pblgsIG1heFgpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbi55LmFuaW1hdG9yLnNldExpbWl0cyhtaW5ZLCBtYXhZKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uLnguYW5pbWF0b3Iuc2V0TGltaXRzKC1JbmZpbml0eSwgSW5maW5pdHkpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbi55LmFuaW1hdG9yLnNldExpbWl0cygtSW5maW5pdHksIEluZmluaXR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRBbmltYXRpb24oZXZlbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbW9tZW50dW0sXG4gICAgICAgIGJvdW5jZSxcbiAgICAgICAgbW9tZW50dW1WZWxvY2l0eU11bHRpcGxpZXIsXG4gICAgICAgIHNwZWVkWCxcbiAgICAgICAgc3BlZWRZLFxuICAgICAgICBvdmVyZHJhZyxcbiAgICAgICAgb25EcmFnQW5pbWF0aW9uU3RhcnRcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgaWYgKCEobW9tZW50dW0gfHwgYm91bmNlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0JleW9uZENvbnN0cmFpbnRzID09PSBmYWxzZSAmJiBtb21lbnR1bSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNCZXlvbmRDb25zdHJhaW50cyA9PT0gZmFsc2UgJiYgdGhpcy5zdGF0ZS5pc0RyYWdnaW5nID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IG1pblgsIG1pblksIG1heFgsIG1heFkgfSA9IHRoaXMuY2FsY3VsYXRlQ29uc3RyYWludHModGhpcy5fY29uc3RyYWludHMpO1xuICAgICAgY29uc3Qgc3RhcnRBbmltYXRpb25YID0gb3ZlcmRyYWcgPT09IHRydWUgfHwgdGhpcy5wb2ludC54ID4gbWluWCAmJiB0aGlzLnBvaW50LnggPCBtYXhYO1xuICAgICAgY29uc3Qgc3RhcnRBbmltYXRpb25ZID0gb3ZlcmRyYWcgPT09IHRydWUgfHwgdGhpcy5wb2ludC55ID4gbWluWSAmJiB0aGlzLnBvaW50LnkgPCBtYXhZO1xuICAgICAgaWYgKHN0YXJ0QW5pbWF0aW9uWCA9PT0gc3RhcnRBbmltYXRpb25ZICYmIHN0YXJ0QW5pbWF0aW9uWSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdmVsb2NpdHkgPSBldmVudC52ZWxvY2l0eSgwLjEpO1xuICAgICAgbGV0IHZlbG9jaXR5WCA9IHZlbG9jaXR5LnggKiBtb21lbnR1bVZlbG9jaXR5TXVsdGlwbGllciAqIHNwZWVkWDtcbiAgICAgIGxldCB2ZWxvY2l0eVkgPSB2ZWxvY2l0eS55ICogbW9tZW50dW1WZWxvY2l0eU11bHRpcGxpZXIgKiBzcGVlZFk7XG4gICAgICBpZiAodGhpcy5kaXJlY3Rpb25Mb2NrQXhpcyA9PT0gXCJ4XCIpIHtcbiAgICAgICAgdmVsb2NpdHlZID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRpcmVjdGlvbkxvY2tBeGlzID09PSBcInlcIikge1xuICAgICAgICB2ZWxvY2l0eVggPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXR1cEFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IHRydWU7XG4gICAgICB0aGlzLmlzTW92aW5nID0gdHJ1ZTtcbiAgICAgIGlmICghdGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hbmltYXRpb24ueC5hbmltYXRvci5zZXRTdGF0ZSh7IHg6IHRoaXMucG9pbnQueCwgdjogdmVsb2NpdHlYIH0pO1xuICAgICAgaWYgKHN0YXJ0QW5pbWF0aW9uWCkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbi54LnBsYXkoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYW5pbWF0aW9uLnkuYW5pbWF0b3Iuc2V0U3RhdGUoeyB4OiB0aGlzLnBvaW50LnksIHY6IHZlbG9jaXR5WSB9KTtcbiAgICAgIGlmIChzdGFydEFuaW1hdGlvblkpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb24ueS5wbGF5KCk7XG4gICAgICB9XG4gICAgICBpZiAob25EcmFnQW5pbWF0aW9uU3RhcnQpIHtcbiAgICAgICAgb25EcmFnQW5pbWF0aW9uU3RhcnQodGhpcy5hbmltYXRpb24sIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICB3cmFwSGFuZGxlcihvd25IYW5kbGVyLCBvcmlnaW5hbEhhbmRsZXIpIHtcbiAgICAgIGlmICghb3JpZ2luYWxIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBvd25IYW5kbGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICBvd25IYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgb3JpZ2luYWxIYW5kbGVyKGV2ZW50KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb25QYW5TdGFydCxcbiAgICAgICAgb25QYW4sXG4gICAgICAgIG9uUGFuRW5kLFxuICAgICAgICBvbk1vdXNlV2hlZWxTdGFydCxcbiAgICAgICAgb25Nb3VzZVdoZWVsLFxuICAgICAgICBvbk1vdXNlV2hlZWxFbmQsXG4gICAgICAgIC4uLmF0dHJpYnV0ZXNcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3Qgb3JpZ2luYWxQcm9wcyA9IHsgLi4uYXR0cmlidXRlcyB9O1xuICAgICAgT2JqZWN0LmtleXMoX1dpdGhEcmFnZ2luZ0hPQy5kcmFnZ2luZ0RlZmF1bHRQcm9wcykuZm9yRWFjaCgoa2V5NikgPT4ge1xuICAgICAgICBkZWxldGUgb3JpZ2luYWxQcm9wc1trZXk2XTtcbiAgICAgIH0pO1xuICAgICAgb3JpZ2luYWxQcm9wcy5vblBhblN0YXJ0ID0gdGhpcy53cmFwSGFuZGxlcih0aGlzLnBhblN0YXJ0LCBvblBhblN0YXJ0KTtcbiAgICAgIG9yaWdpbmFsUHJvcHMub25QYW4gPSB0aGlzLndyYXBIYW5kbGVyKHRoaXMucGFuLCBvblBhbik7XG4gICAgICBvcmlnaW5hbFByb3BzLm9uUGFuRW5kID0gdGhpcy53cmFwSGFuZGxlcih0aGlzLnBhbkVuZCwgb25QYW5FbmQpO1xuICAgICAgb3JpZ2luYWxQcm9wcy5vbk1vdXNlV2hlZWxTdGFydCA9IHRoaXMud3JhcEhhbmRsZXIodGhpcy5tb3VzZVdoZWVsU3RhcnQsIG9uTW91c2VXaGVlbFN0YXJ0KTtcbiAgICAgIG9yaWdpbmFsUHJvcHMub25Nb3VzZVdoZWVsID0gdGhpcy53cmFwSGFuZGxlcih0aGlzLm1vdXNlV2hlZWwsIG9uTW91c2VXaGVlbCk7XG4gICAgICBvcmlnaW5hbFByb3BzLm9uTW91c2VXaGVlbEVuZCA9IHRoaXMud3JhcEhhbmRsZXIodGhpcy5tb3VzZVdoZWVsRW5kLCBvbk1vdXNlV2hlZWxFbmQpO1xuICAgICAgb3JpZ2luYWxQcm9wcy5sZWZ0ID0gdGhpcy54O1xuICAgICAgb3JpZ2luYWxQcm9wcy50b3AgPSB0aGlzLnk7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQxNihEcmFnZ2luZ0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHsgZHJhZ2dpbmc6IHRoaXMuc3RhdGUuaXNEcmFnZ2luZyB9XG4gICAgICB9LCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDE2KENvbXBvbmVudDE5LCB7XG4gICAgICAgIC4uLm9yaWdpbmFsUHJvcHNcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG4gIGxldCBXaXRoRHJhZ2dpbmdIT0MgPSBfV2l0aERyYWdnaW5nSE9DO1xuICBXaXRoRHJhZ2dpbmdIT0MuZHJhZ2dpbmdEZWZhdWx0UHJvcHMgPSB7XG4gICAgbW9tZW50dW06IHRydWUsXG4gICAgbW9tZW50dW1PcHRpb25zOiB7IGZyaWN0aW9uOiAyLjEsIHRvbGVyYW5jZTogMSB9LFxuICAgIG1vbWVudHVtVmVsb2NpdHlNdWx0aXBsaWVyOiA4MDAsXG4gICAgc3BlZWRYOiAxLFxuICAgIHNwZWVkWTogMSxcbiAgICBib3VuY2U6IHRydWUsXG4gICAgYm91bmNlT3B0aW9uczogeyBmcmljdGlvbjogNDAsIHRlbnNpb246IDIwMCwgdG9sZXJhbmNlOiAxIH0sXG4gICAgZGlyZWN0aW9uTG9jazogZmFsc2UsXG4gICAgZGlyZWN0aW9uTG9ja1RocmVzaG9sZDogeyB4OiAxMCwgeTogMTAgfSxcbiAgICBvdmVyZHJhZzogdHJ1ZSxcbiAgICBvdmVyZHJhZ1NjYWxlOiAwLjUsXG4gICAgcGl4ZWxBbGlnbjogdHJ1ZSxcbiAgICB2ZWxvY2l0eVRpbWVvdXQ6IDEwMCxcbiAgICB2ZWxvY2l0eVNjYWxlOiA4OTAsXG4gICAgaG9yaXpvbnRhbDogdHJ1ZSxcbiAgICB2ZXJ0aWNhbDogdHJ1ZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGNvbnN0cmFpbnRzOiB7fSxcbiAgICBtb3VzZVdoZWVsOiBmYWxzZVxuICB9O1xuICBXaXRoRHJhZ2dpbmdIT0MuZGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgQ29tcG9uZW50MTkuZGVmYXVsdFByb3BzLCBfV2l0aERyYWdnaW5nSE9DLmRyYWdnaW5nRGVmYXVsdFByb3BzKTtcbiAgY29uc3Qgd2l0aERyYWdnaW5nID0gV2l0aERyYWdnaW5nSE9DO1xuICBob2lzdE5vblJlYWN0U3RhdGljKHdpdGhEcmFnZ2luZywgQ29tcG9uZW50MTkpO1xuICByZXR1cm4gd2l0aERyYWdnaW5nO1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9ob2MvV2l0aEV2ZW50cy50c3hcbnZhciBob2lzdE5vblJlYWN0U3RhdGljMiA9IHJlcXVpcmVfaG9pc3Rfbm9uX3JlYWN0X3N0YXRpY3NfY2pzKCk7XG52YXIgaG92ZXJQcm9wcyA9IHtcbiAgb25Nb3VzZUVudGVyOiBcIm1vdXNlZW50ZXJcIixcbiAgb25Nb3VzZUxlYXZlOiBcIm1vdXNlbGVhdmVcIlxufTtcbnZhciBob3ZlckV2ZW50S2V5cyA9IE9iamVjdC5rZXlzKGhvdmVyUHJvcHMpO1xudmFyIGV2ZW50SGFuZGxlck1hcHBpbmcgPSB7XG4gIHBhbnN0YXJ0OiBbXCJvblBhblN0YXJ0XCJdLFxuICBwYW46IFtcIm9uUGFuXCJdLFxuICBwYW5lbmQ6IFtcIm9uUGFuRW5kXCJdLFxuICB0YXBzdGFydDogW1wib25UYXBTdGFydFwiLCBcIm9uTW91c2VEb3duXCJdLFxuICB0YXA6IFtcIm9uVGFwXCIsIFwib25DbGlja1wiXSxcbiAgdGFwZW5kOiBbXCJvblRhcEVuZFwiLCBcIm9uTW91c2VVcFwiXSxcbiAgbW91c2V3aGVlbHN0YXJ0OiBbXCJvbk1vdXNlV2hlZWxTdGFydFwiXSxcbiAgbW91c2V3aGVlbDogW1wib25Nb3VzZVdoZWVsXCJdLFxuICBtb3VzZXdoZWVsZW5kOiBbXCJvbk1vdXNlV2hlZWxFbmRcIl1cbn07XG52YXIgdGFwRXZlbnRLZXlzID0gbmV3IFNldChbXCJ0YXBzdGFydFwiLCBcInRhcFwiLCBcInRhcGVuZFwiXSk7XG5mdW5jdGlvbiBXaXRoRXZlbnRzKEJhc2VDb21wb25lbnQpIHtcbiAgdmFyIF9hO1xuICBjb25zdCB3aXRoRXZlbnRzID0gKF9hID0gY2xhc3MgZXh0ZW5kcyBDb21wb25lbnQ1IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICB0aGlzLnNob3VsZENhbmNlbFRhcCA9IGZhbHNlO1xuICAgICAgdGhpcy5hY3RpdmVFdmVudExpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuaGFzRnJhbWVyRXZlbnRMaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgdGhpcy5jb21wb25lbnQgPSBjcmVhdGVSZWYoKTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQuY3VycmVudCAmJiB0aGlzLmNvbXBvbmVudC5jdXJyZW50LmVsZW1lbnQ7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKHByZXZQcm9wcyk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICBhZGRFdmVudExpc3RlbmVycyhwcmV2UHJvcHMpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQgJiYgIXRoaXMuaGFzRnJhbWVyRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkZyYW1lckV2ZW50XCIsICh7IGRldGFpbCB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IGRldGFpbC50eXBlO1xuICAgICAgICAgIGNvbnN0IGZyYW1lckV2ZW50ID0gZGV0YWlsLmV2ZW50O1xuICAgICAgICAgIHRoaXMuaGFuZGxlRXZlbnQodHlwZSwgZnJhbWVyRXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaG92ZXJFdmVudEtleXMuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB0aGlzLmFkZEhvdmVyRXZlbnQoZXZlbnROYW1lKSk7XG4gICAgICAgIHRoaXMuaGFzRnJhbWVyRXZlbnRMaXN0ZW5lciA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZWxlbWVudCAmJiBwcmV2UHJvcHMpIHtcbiAgICAgICAgaG92ZXJFdmVudEtleXMuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB0aGlzLmNoZWNrSG92ZXJFdmVudChldmVudE5hbWUsIHByZXZQcm9wcykpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5lbGVtZW50KSB7XG4gICAgICAgIHRoaXMuaGFzRnJhbWVyRXZlbnRMaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICAgIGhvdmVyRXZlbnRLZXlzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4gdGhpcy5yZW1vdmVIb3ZlckV2ZW50KGV2ZW50TmFtZSkpO1xuICAgIH1cbiAgICBhZGRIb3ZlckV2ZW50KGV2ZW50TmFtZSkge1xuICAgICAgY29uc3Qgb3JpZ2luYWxFdmVudExpc3RlbmVyID0gdGhpcy5wcm9wc1tldmVudE5hbWVdO1xuICAgICAgaWYgKHRoaXMuZWxlbWVudCAmJiBvcmlnaW5hbEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IChlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZnJhbWVyRXZlbnQgPSBuZXcgRnJhbWVyRXZlbnQoZSk7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudExpc3RlbmVyKGZyYW1lckV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hY3RpdmVFdmVudExpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBldmVudExpc3RlbmVyKTtcbiAgICAgICAgY29uc3QgZG9tRXZlbnROYW1lID0gaG92ZXJQcm9wc1tldmVudE5hbWVdO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihkb21FdmVudE5hbWUsIGV2ZW50TGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVIb3ZlckV2ZW50KGV2ZW50TmFtZSkge1xuICAgICAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IHRoaXMuYWN0aXZlRXZlbnRMaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICBpZiAodGhpcy5lbGVtZW50ICYmIGV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgZG9tRXZlbnROYW1lID0gaG92ZXJQcm9wc1tldmVudE5hbWVdO1xuICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihkb21FdmVudE5hbWUsIGV2ZW50TGlzdGVuZXIpO1xuICAgICAgICB0aGlzLmFjdGl2ZUV2ZW50TGlzdGVuZXJzLmRlbGV0ZShldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjaGVja0hvdmVyRXZlbnQoZXZlbnROYW1lLCBwcmV2UHJvcHMpIHtcbiAgICAgIGlmIChwcmV2UHJvcHNbZXZlbnROYW1lXSAhPT0gdGhpcy5wcm9wc1tldmVudE5hbWVdKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlSG92ZXJFdmVudChldmVudE5hbWUpO1xuICAgICAgICB0aGlzLmFkZEhvdmVyRXZlbnQoZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRXZlbnQodHlwZSwgZnJhbWVyRXZlbnQpIHtcbiAgICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJLZXlzID0gZXZlbnRIYW5kbGVyTWFwcGluZ1t0eXBlXTtcbiAgICAgIGlmICghZXZlbnRMaXN0ZW5lcktleXMpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGV2ZW50TGlzdGVuZXJLZXlzLmZvckVhY2goKGV2ZW50S2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB0aGlzLnByb3BzW2V2ZW50S2V5XTtcbiAgICAgICAgY29uc3QgY2FuY2VsRXZlbnQgPSB0aGlzLnNob3VsZENhbmNlbFRhcCAmJiB0YXBFdmVudEtleXMuaGFzKGV2ZW50S2V5KTtcbiAgICAgICAgaWYgKGV2ZW50TGlzdGVuZXIgJiYgIWNhbmNlbEV2ZW50KSB7XG4gICAgICAgICAgZXZlbnRMaXN0ZW5lcihmcmFtZXJFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQxNyhEcmFnZ2luZ0NvbnRleHQuQ29uc3VtZXIsIG51bGwsICh2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLnNob3VsZENhbmNlbFRhcCA9IHZhbHVlLmRyYWdnaW5nO1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQxNyhCYXNlQ29tcG9uZW50LCB7XG4gICAgICAgICAgLi4udGhpcy5wcm9wcyxcbiAgICAgICAgICByZWY6IHRoaXMuY29tcG9uZW50XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBfYS5kZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBCYXNlQ29tcG9uZW50LmRlZmF1bHRQcm9wcyksIF9hKTtcbiAgaG9pc3ROb25SZWFjdFN0YXRpYzIod2l0aEV2ZW50cywgQmFzZUNvbXBvbmVudCk7XG4gIHJldHVybiB3aXRoRXZlbnRzO1xufVxuXG4vLyBzcmMvcmVuZGVyL3ByZXNlbnRhdGlvbi9GcmFtZS9EZXByZWNhdGVkRnJhbWUudHN4XG5pbXBvcnQge1xuICBDaGlsZHJlbiBhcyBDaGlsZHJlbjQsXG4gIGNsb25lRWxlbWVudCBhcyBjbG9uZUVsZW1lbnQzLFxuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQyMFxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2RhdGEvT2JzZXJ2YWJsZU9iamVjdC50c1xudmFyIGhhc093blByb3BlcnR5ID0gKG9iaiwgcHJvcCkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG5mdW5jdGlvbiBPYnNlcnZhYmxlT2JqZWN0KGluaXRpYWwgPSB7fSwgbWFrZUFuaW1hdGFibGVzID0gZmFsc2UsIG9ic2VydmVBbmltYXRhYmxlcyA9IHRydWUpIHtcbiAgY29uc3QgdW5wcm94aWVkU3RhdGUgPSB7fTtcbiAgdW5wcm94aWVkU3RhdGVbJHByaXZhdGVdID0ge1xuICAgIG1ha2VBbmltYXRhYmxlcyxcbiAgICBvYnNlcnZlQW5pbWF0YWJsZXMsXG4gICAgb2JzZXJ2ZXJzOiBuZXcgT2JzZXJ2ZXJzKCksXG4gICAgcmVzZXQoKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleTYgaW4gc3RhdGUpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KHN0YXRlLCBrZXk2KSkge1xuICAgICAgICAgIHN0YXRlW2tleTZdID0gaGFzT3duUHJvcGVydHkoaW5pdGlhbCwga2V5NikgPyBpbml0aWFsW2tleTZdIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB0cmFuc2FjdGlvbnM6IG5ldyBTZXQoKVxuICB9O1xuICBjb25zdCBzdGF0ZSA9IG5ldyBQcm94eSh1bnByb3hpZWRTdGF0ZSwgc2hhcmVkUHJveHlIYW5kbGVyKTtcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZSwgaW5pdGlhbCk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbihmdW5jdGlvbihPYnNlcnZhYmxlT2JqZWN0Mikge1xuICBmdW5jdGlvbiByZXNldE9iamVjdCh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0WyRwcml2YXRlXS5yZXNldCgpO1xuICB9XG4gIE9ic2VydmFibGVPYmplY3QyLnJlc2V0T2JqZWN0ID0gcmVzZXRPYmplY3Q7XG4gIGZ1bmN0aW9uIGFkZE9ic2VydmVyKHRhcmdldCwgb2JzZXJ2ZXIpIHtcbiAgICByZXR1cm4gdGFyZ2V0WyRwcml2YXRlXS5vYnNlcnZlcnMuYWRkKG9ic2VydmVyKTtcbiAgfVxuICBPYnNlcnZhYmxlT2JqZWN0Mi5hZGRPYnNlcnZlciA9IGFkZE9ic2VydmVyO1xufSkoT2JzZXJ2YWJsZU9iamVjdCB8fCAoT2JzZXJ2YWJsZU9iamVjdCA9IHt9KSk7XG52YXIgT2JzZXJ2YWJsZU9iamVjdFByb3h5SGFuZGxlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zZXQgPSAodGFyZ2V0LCBrZXk2LCB2YWx1ZSwgcmVjZWl2ZXIpID0+IHtcbiAgICAgIGlmIChrZXk2ID09PSAkcHJpdmF0ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBwcml2YXRlT2JqZWN0ID0gdGFyZ2V0WyRwcml2YXRlXTtcbiAgICAgIGxldCBhbmltYXRhYmxlO1xuICAgICAgbGV0IHJhd1ZhbHVlO1xuICAgICAgaWYgKGlzQW5pbWF0YWJsZTIodmFsdWUpKSB7XG4gICAgICAgIGFuaW1hdGFibGUgPSB2YWx1ZTtcbiAgICAgICAgcmF3VmFsdWUgPSBhbmltYXRhYmxlLmdldCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmF3VmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcml2YXRlT2JqZWN0Lm1ha2VBbmltYXRhYmxlcyAmJiB0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgIWFuaW1hdGFibGUpIHtcbiAgICAgICAgYW5pbWF0YWJsZSA9IEFuaW1hdGFibGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHByaXZhdGVPYmplY3Qub2JzZXJ2ZUFuaW1hdGFibGVzICYmIGFuaW1hdGFibGUpIHtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25zID0gcHJpdmF0ZU9iamVjdC50cmFuc2FjdGlvbnM7XG4gICAgICAgIGFuaW1hdGFibGUub25VcGRhdGUoe1xuICAgICAgICAgIHVwZGF0ZTogKGNoYW5nZSwgdHJhbnNhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICB0cmFuc2FjdGlvbnMuYWRkKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByaXZhdGVPYmplY3Qub2JzZXJ2ZXJzLm5vdGlmeSh7IHZhbHVlOiByZWNlaXZlciB9LCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmaW5pc2g6ICh0cmFuc2FjdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9ucy5kZWxldGUodHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgIHByaXZhdGVPYmplY3Qub2JzZXJ2ZXJzLmZpbmlzaFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICAgICAgbGV0IGNoYW5nZWQgPSB0cnVlO1xuICAgICAgaWYgKHRhcmdldFtrZXk2XSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChpc0FuaW1hdGFibGUyKHRhcmdldFtrZXk2XSkpIHtcbiAgICAgICAgICBjaGFuZ2VkID0gdGFyZ2V0W2tleTZdLmdldCgpICE9PSByYXdWYWx1ZTtcbiAgICAgICAgICB0YXJnZXRba2V5Nl0uc2V0KHJhd1ZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGFuZ2VkID0gdGFyZ2V0W2tleTZdICE9PSByYXdWYWx1ZTtcbiAgICAgICAgICB0YXJnZXRba2V5Nl0gPSByYXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXdWYWx1ZUlzT2JqZWN0ID0gcmF3VmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHJhd1ZhbHVlID09PSBcIm9iamVjdFwiO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyYXdWYWx1ZSkgfHwgcmF3VmFsdWVJc09iamVjdClcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhbmltYXRhYmxlKSB7XG4gICAgICAgICAgdmFsdWUgPSBhbmltYXRhYmxlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IFJlZmxlY3Quc2V0KHRhcmdldCwga2V5NiwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgcHJpdmF0ZU9iamVjdC5vYnNlcnZlcnMubm90aWZ5KHsgdmFsdWU6IHJlY2VpdmVyIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHRoaXMuZ2V0ID0gKHRhcmdldCwga2V5NiwgcmVjZWl2ZXIpID0+IHtcbiAgICAgIGlmIChrZXk2ID09PSAkcHJpdmF0ZSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0W2tleTZdO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSBSZWZsZWN0LmdldCh0YXJnZXQsIGtleTYsIHJlY2VpdmVyKTtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlLmJpbmQocmVjZWl2ZXIpIDogdmFsdWU7XG4gICAgfTtcbiAgfVxuICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleTYpIHtcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5Nik7XG4gICAgdGFyZ2V0WyRwcml2YXRlXS5vYnNlcnZlcnMubm90aWZ5KHsgdmFsdWU6IHRhcmdldCB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIG93bktleXModGFyZ2V0KSB7XG4gICAgY29uc3Qga2V5czIgPSBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbiAgICBjb25zdCBwcml2YXRlSW5kZXggPSBrZXlzMi5pbmRleE9mKCRwcml2YXRlKTtcbiAgICBpZiAocHJpdmF0ZUluZGV4ICE9PSAtMSkge1xuICAgICAga2V5czIuc3BsaWNlKHByaXZhdGVJbmRleCwgMSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzMjtcbiAgfVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXk2KSB7XG4gICAgaWYgKGtleTYgPT09ICRwcml2YXRlKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXk2KTtcbiAgfVxufTtcbnZhciBzaGFyZWRQcm94eUhhbmRsZXIgPSBuZXcgT2JzZXJ2YWJsZU9iamVjdFByb3h5SGFuZGxlcigpO1xudmFyICRwcml2YXRlID0gU3ltYm9sKFwicHJpdmF0ZVwiKTtcblxuLy8gc3JjL3JlbmRlci90cmFpdHMvUmFkaXVzLnRzXG52YXIga2V5MiA9IFwicmFkaXVzXCI7XG5mdW5jdGlvbiBoYXNSYWRpdXMocHJvcHMpIHtcbiAgcmV0dXJuIGtleTIgaW4gcHJvcHM7XG59XG5mdW5jdGlvbiBnZXRSYWRpdXNWYWx1ZSh2YWx1ZSkge1xuICBsZXQgbnVtID0gTnVtYmVyKHZhbHVlKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiBpc05hTihudW0pKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IGVsc2UgaWYgKGlzQW5pbWF0YWJsZTIodmFsdWUpKSB7XG4gICAgbnVtID0gQW5pbWF0YWJsZS5nZXROdW1iZXIodmFsdWUpO1xuICB9XG4gIHJldHVybiBudW0gPyBgJHtudW19cHhgIDogXCIwXCI7XG59XG5mdW5jdGlvbiBoYXNSYWRpdXNWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgdmFsdWUgIT09IFwiMFwiO1xufVxuZnVuY3Rpb24gY29sbGVjdFJhZGl1c0Zyb21Qcm9wcyhwcm9wcywgc3R5bGUpIHtcbiAgaWYgKCFoYXNSYWRpdXMocHJvcHMpKVxuICAgIHJldHVybjtcbiAgY29uc3QgeyByYWRpdXMgfSA9IHByb3BzO1xuICBpZiAodHlwZW9mIHJhZGl1cyA9PT0gXCJzdHJpbmdcIiB8fCBpc0FuaW1hdGFibGUyKHJhZGl1cykgfHwgaXNGaW5pdGVOdW1iZXIocmFkaXVzKSkge1xuICAgIGNvbnN0IHJhZGl1c1ZhbHVlID0gZ2V0UmFkaXVzVmFsdWUocmFkaXVzKTtcbiAgICBpZiAoaGFzUmFkaXVzVmFsdWUocmFkaXVzVmFsdWUpKSB7XG4gICAgICBzdHlsZS5ib3JkZXJUb3BMZWZ0UmFkaXVzID0gc3R5bGUuYm9yZGVyVG9wUmlnaHRSYWRpdXMgPSBzdHlsZS5ib3JkZXJCb3R0b21SaWdodFJhZGl1cyA9IHN0eWxlLmJvcmRlckJvdHRvbUxlZnRSYWRpdXMgPSByYWRpdXNWYWx1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmFkaXVzKSB7XG4gICAgY29uc3QgdG9wTGVmdCA9IGdldFJhZGl1c1ZhbHVlKHJhZGl1cy50b3BMZWZ0KTtcbiAgICBjb25zdCB0b3BSaWdodCA9IGdldFJhZGl1c1ZhbHVlKHJhZGl1cy50b3BSaWdodCk7XG4gICAgY29uc3QgYm90dG9tUmlnaHQgPSBnZXRSYWRpdXNWYWx1ZShyYWRpdXMuYm90dG9tUmlnaHQpO1xuICAgIGNvbnN0IGJvdHRvbUxlZnQgPSBnZXRSYWRpdXNWYWx1ZShyYWRpdXMuYm90dG9tTGVmdCk7XG4gICAgaWYgKGhhc1JhZGl1c1ZhbHVlKHRvcExlZnQpIHx8IGhhc1JhZGl1c1ZhbHVlKHRvcFJpZ2h0KSB8fCBoYXNSYWRpdXNWYWx1ZShib3R0b21SaWdodCkgfHwgaGFzUmFkaXVzVmFsdWUoYm90dG9tTGVmdCkpIHtcbiAgICAgIHN0eWxlLmJvcmRlclRvcExlZnRSYWRpdXMgPSB0b3BMZWZ0O1xuICAgICAgc3R5bGUuYm9yZGVyVG9wUmlnaHRSYWRpdXMgPSB0b3BSaWdodDtcbiAgICAgIHN0eWxlLmJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzID0gYm90dG9tUmlnaHQ7XG4gICAgICBzdHlsZS5ib3JkZXJCb3R0b21MZWZ0UmFkaXVzID0gYm90dG9tTGVmdDtcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL3JlbmRlci90cmFpdHMvQmxlbmRpbmcudHNcbmZ1bmN0aW9uIGNvbGxlY3RCbGVuZGluZ0Zyb21Qcm9wcyhub2RlLCBzdHlsZSkge1xuICBpZiAoIW5vZGUuYmxlbmRpbmdNb2RlIHx8IG5vZGUuYmxlbmRpbmdNb2RlID09PSBcIm5vcm1hbFwiKVxuICAgIHJldHVybjtcbiAgc3R5bGUubWl4QmxlbmRNb2RlID0gbm9kZS5ibGVuZGluZ01vZGU7XG59XG5cbi8vIHNyYy9yZW5kZXIvdHJhaXRzL092ZXJmbG93LnRzXG5mdW5jdGlvbiBjb2xsZWN0T3ZlcmZsb3dGcm9tUHJvcHMocHJvcHMsIHN0eWxlKSB7XG4gIGlmIChwcm9wcy5vdmVyZmxvdykge1xuICAgIHN0eWxlLm92ZXJmbG93ID0gcHJvcHMub3ZlcmZsb3c7XG4gIH1cbn1cblxuLy8gc3JjL3JlbmRlci90cmFpdHMvT3BhY2l0eS50c1xudmFyIGtleTMgPSBcIm9wYWNpdHlcIjtcbmZ1bmN0aW9uIHdpdGhPcGFjaXR5KHRhcmdldCkge1xuICByZXR1cm4ga2V5MyBpbiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBjb2xsZWN0T3BhY2l0eUZyb21Qcm9wcyhwcm9wcywgc3R5bGUpIHtcbiAgaWYgKCF3aXRoT3BhY2l0eShwcm9wcykpXG4gICAgcmV0dXJuO1xuICBjb25zdCBvcGFjaXR5ID0gQW5pbWF0YWJsZS5nZXROdW1iZXIocHJvcHMub3BhY2l0eSk7XG4gIGlmIChvcGFjaXR5ID09PSAxKVxuICAgIHJldHVybjtcbiAgc3R5bGUub3BhY2l0eSA9IG9wYWNpdHk7XG59XG5cbi8vIHNyYy9yZW5kZXIvc3R5bGUvc2hhZG93LnRzeFxuaW1wb3J0IHtcbiAgRnJhZ21lbnQgYXMgRnJhZ21lbnQ2LFxuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQxOSxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjFcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9yZW5kZXIvdHlwZXMvU2hhZG93LnRzXG52YXIgc2hhZG93S2V5cyA9IFtcImNvbG9yXCIsIFwieFwiLCBcInlcIiwgXCJibHVyXCJdO1xudmFyIFNoYWRvdztcbihmdW5jdGlvbihTaGFkb3czKSB7XG4gIGZ1bmN0aW9uIGlzKHNoYWRvdykge1xuICAgIHJldHVybiBzaGFkb3cgJiYgc2hhZG93S2V5cy5ldmVyeSgoa2V5NikgPT4ga2V5NiBpbiBzaGFkb3cpO1xuICB9XG4gIFNoYWRvdzMuaXMgPSBpcztcbn0pKFNoYWRvdyB8fCAoU2hhZG93ID0ge30pKTtcbnZhciBib3hTaGFkb3dLZXlzID0gW1wiaW5zZXRcIiwgXCJjb2xvclwiLCBcInhcIiwgXCJ5XCIsIFwiYmx1clwiLCBcInNwcmVhZFwiXTtcbnZhciBCb3hTaGFkb3c7XG4oZnVuY3Rpb24oQm94U2hhZG93Mikge1xuICBmdW5jdGlvbiBpcyhzaGFkb3cpIHtcbiAgICByZXR1cm4gc2hhZG93ICYmIGJveFNoYWRvd0tleXMuZXZlcnkoKGtleTYpID0+IGtleTYgaW4gc2hhZG93KTtcbiAgfVxuICBCb3hTaGFkb3cyLmlzID0gaXM7XG4gIGZ1bmN0aW9uIHRvQ1NTKHNoYWRvdykge1xuICAgIGNvbnN0IGluc2V0ID0gc2hhZG93Lmluc2V0ID8gXCJpbnNldCBcIiA6IFwiXCI7XG4gICAgcmV0dXJuIGAke2luc2V0fSR7c2hhZG93Lnh9cHggJHtzaGFkb3cueX1weCAke3NoYWRvdy5ibHVyfXB4ICR7c2hhZG93LnNwcmVhZH1weCAke3NoYWRvdy5jb2xvcn1gO1xuICB9XG4gIEJveFNoYWRvdzIudG9DU1MgPSB0b0NTUztcbn0pKEJveFNoYWRvdyB8fCAoQm94U2hhZG93ID0ge30pKTtcblxuLy8gc3JjL3JlbmRlci9wcmVzZW50YXRpb24vQ3VzdG9tUHJvcGVydGllcy50c3hcbmltcG9ydCB7XG4gIFB1cmVDb21wb25lbnQsXG4gIGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDExLFxuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQxOFxufSBmcm9tIFwicmVhY3RcIjtcbnZhciBWYXJpYWJsZVJlZ2V4ID0gL3ZhclxcKChbXiksXSspLztcbnZhciBDdXN0b21Qcm9wZXJ0aWVzQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQxMSgoKSA9PiBudWxsKTtcbnZhciBDdXN0b21Qcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmxvb2t1cCA9ICh2YXJpYWJsZSkgPT4ge1xuICAgICAgY29uc3QgbWF0Y2ggPSBWYXJpYWJsZVJlZ2V4LmV4ZWModmFyaWFibGUpO1xuICAgICAgY29uc3QgY3VzdG9tUHJvcGVydHkgPSBtYXRjaCA/IG1hdGNoWzFdLnRyaW0oKSA6IFwiXCI7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5jdXN0b21Qcm9wZXJ0aWVzW2N1c3RvbVByb3BlcnR5XSB8fCBudWxsO1xuICAgIH07XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIGN1c3RvbVByb3BlcnRpZXMgfSA9IHRoaXMucHJvcHM7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MTgoQ3VzdG9tUHJvcGVydGllc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiB0aGlzLmxvb2t1cFxuICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MTgoXCJkaXZcIiwge1xuICAgICAgc3R5bGU6IGN1c3RvbVByb3BlcnRpZXNcbiAgICB9LCBjaGlsZHJlbikpO1xuICB9XG59O1xuXG4vLyBzcmMvcmVuZGVyL3N0eWxlL3NoYWRvdy50c3hcbmZ1bmN0aW9uIHNoYWRvd3NBc0ZpbHRlcihzaGFkb3dzKSB7XG4gIGNvbnN0IGZpbHRlcnMgPSBbXTtcbiAgaWYgKHNoYWRvd3MgJiYgc2hhZG93cy5sZW5ndGgpIHtcbiAgICBjb25zdCBkcm9wU2hhZG93cyA9IHNoYWRvd3MubWFwKChzaGFkb3dJdGVtKSA9PiB7XG4gICAgICByZXR1cm4gYGRyb3Atc2hhZG93KCR7c2hhZG93SXRlbS54fXB4ICR7c2hhZG93SXRlbS55fXB4ICR7c2hhZG93SXRlbS5ibHVyfXB4ICR7c2hhZG93SXRlbS5jb2xvcn0pYDtcbiAgICB9KTtcbiAgICBmaWx0ZXJzLnB1c2goLi4uZHJvcFNoYWRvd3MpO1xuICB9XG4gIHJldHVybiBmaWx0ZXJzO1xufVxuZnVuY3Rpb24gY29sbGVjdFRleHRTaGFkb3dzRm9yUHJvcHMocHJvcHMsIHN0eWxlKSB7XG4gIGlmICghcHJvcHMuc2hhZG93cyB8fCBwcm9wcy5zaGFkb3dzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm47XG4gIGNvbnN0IHRleHRTaGFkb3cgPSBwcm9wcy5zaGFkb3dzLm1hcCgoc2hhZG93KSA9PiB7XG4gICAgcmV0dXJuIGAke3NoYWRvdy54fXB4ICR7c2hhZG93Lnl9cHggJHtzaGFkb3cuYmx1cn1weCAke3NoYWRvdy5jb2xvcn1gO1xuICB9KS5qb2luKFwiLCBcIik7XG4gIGlmICghdGV4dFNoYWRvdylcbiAgICByZXR1cm47XG4gIHN0eWxlLnRleHRTaGFkb3cgPSB0ZXh0U2hhZG93O1xufVxuZnVuY3Rpb24gY29sbGVjdEJveFNoYWRvd3NGb3JQcm9wcyhwcm9wcywgc3R5bGUpIHtcbiAgaWYgKCFwcm9wcy5zaGFkb3dzIHx8IHByb3BzLnNoYWRvd3MubGVuZ3RoID09PSAwKVxuICAgIHJldHVybjtcbiAgY29uc3QgYm94U2hhZG93ID0gcHJvcHMuc2hhZG93cy5tYXAoKHNoYWRvd0l0ZW0pID0+IEJveFNoYWRvdy50b0NTUyhzaGFkb3dJdGVtKSkuam9pbihcIiwgXCIpO1xuICBpZiAoIWJveFNoYWRvdylcbiAgICByZXR1cm47XG4gIHN0eWxlLmJveFNoYWRvdyA9IGJveFNoYWRvdztcbn1cbmZ1bmN0aW9uIHNoYWRvd0ZvclNoYXBlKGJveFNoYWRvd3MsIHJlY3QsIHNoYXBlSWQsIGZpbGxBbHBoYSwgc3Ryb2tlQWxwaGEsIHN0cm9rZVdpZHRoLCBzdHJva2VDbGlwSWQsIHN2Z1N0cm9rZUF0dHJpYnV0ZXMpIHtcbiAgY29uc3QgZGVmaW5pdGlvbiA9IFtdO1xuICBsZXQgb3V0c2V0RWxlbWVudCA9IG51bGw7XG4gIGxldCBpbnNldEVsZW1lbnQgPSBudWxsO1xuICBjb25zdCBuZWVkc1N0cm9rZUNsaXAgPSBmYWxzZTtcbiAgY29uc3Qgc2hhZG93cyA9IFtdO1xuICBjb25zdCBpbnNldFNoYWRvd3MgPSBbXTtcbiAgY29uc3QgYm94U2hhZG93c0NvdW50ID0gYm94U2hhZG93cy5sZW5ndGg7XG4gIGNvbnN0IHN2Z1NoYWRvd0NsYXNzID0gXCJzdmctc2hhZG93XCI7XG4gIGNvbnN0IHN2Z1NoYWRvd1Byb3BzID0gUmVuZGVyVGFyZ2V0LmN1cnJlbnQoKSA9PT0gUmVuZGVyVGFyZ2V0LmNhbnZhcyA/IHsgY2xhc3NOYW1lOiBzdmdTaGFkb3dDbGFzcyB9IDoge307XG4gIGZvciAobGV0IGkgPSAwLCBpbCA9IGJveFNoYWRvd3NDb3VudDsgaSA8IGlsOyBpKyspIHtcbiAgICBjb25zdCBzaGFkb3cgPSBib3hTaGFkb3dzW2ldO1xuICAgIHNoYWRvdy5pbnNldCA/IGluc2V0U2hhZG93cy5wdXNoKHNoYWRvdykgOiBzaGFkb3dzLnB1c2goc2hhZG93KTtcbiAgfVxuICBpZiAoc2hhZG93cy5sZW5ndGggPiAwKSB7XG4gICAgc2hhZG93cy5yZXZlcnNlKCk7XG4gICAgY29uc3Qgb3V0c2lkZVNoYWRvd0lkID0gc2hhcGVJZC5hZGQoXCJfc2hhZG93X291dFwiKTtcbiAgICBjb25zdCBub3JtYWxpemVkRnJhbWUgPSBSZWN0LmF0T3JpZ2luKHJlY3QpO1xuICAgIGNvbnN0IHNoYWRvd1JlY3RzID0gW25vcm1hbGl6ZWRGcmFtZV07XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gc2hhZG93cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBjb25zdCBzaGFkb3cgPSBzaGFkb3dzW2ldO1xuICAgICAgY29uc3Qgc2hhZG93RnJhbWUgPSBsb2NhbFNoYWRvd0ZyYW1lKHNoYWRvdywgbm9ybWFsaXplZEZyYW1lLCB0cnVlKTtcbiAgICAgIGlmIChzaGFkb3dGcmFtZSA9PT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNoYWRvd1JlY3RzLnB1c2goc2hhZG93RnJhbWUpO1xuICAgIH1cbiAgICBsZXQgbWF4Qmx1ciA9IDA7XG4gICAgY29uc3QgZmlsdGVyRWxlbWVudHMgPSBbXTtcbiAgICBjb25zdCBtZXJnZUVsZW1lbnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gc2hhZG93cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBjb25zdCBzaGFkb3cgPSBzaGFkb3dzW2ldO1xuICAgICAgY29uc3Qgc2hhZG93RWxlbWVudHMgPSBvdXRlclNoYWRvd0VsZW1lbnRzKHNoYXBlSWQsIHNoYWRvdywgaSk7XG4gICAgICBtYXhCbHVyID0gTWF0aC5tYXgobWF4Qmx1ciwgc2hhZG93LmJsdXIpO1xuICAgICAgZmlsdGVyRWxlbWVudHMucHVzaChzaGFkb3dFbGVtZW50cy5maWx0ZXJFbGVtZW50cyk7XG4gICAgICBtZXJnZUVsZW1lbnRzLnB1c2goc2hhZG93RWxlbWVudHMubWVyZ2VFbGVtZW50KTtcbiAgICB9XG4gICAgbGV0IGV4cGFuZFN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcihleHBhbmRTdHJva2VXaWR0aCkpXG4gICAgICBleHBhbmRTdHJva2VXaWR0aCA9IDA7XG4gICAgbGV0IG1pdGVyID0gc3ZnU3Ryb2tlQXR0cmlidXRlcy5zdHJva2VNaXRlcmxpbWl0O1xuICAgIGlmICghaXNGaW5pdGVOdW1iZXIobWl0ZXIpKVxuICAgICAgbWl0ZXIgPSA0O1xuICAgIGxldCBzaGFkb3dSZWN0ID0gUmVjdC5tZXJnZSguLi5zaGFkb3dSZWN0cyk7XG4gICAgc2hhZG93UmVjdCA9IFJlY3QuaW5mbGF0ZShzaGFkb3dSZWN0LCAoZXhwYW5kU3Ryb2tlV2lkdGggKiBtaXRlciAvIDIgKyBtYXhCbHVyKSAqIDEuMSk7XG4gICAgY29uc3Qgd2lkdGggPSByZWN0LndpZHRoICsgKHN0cm9rZVdpZHRoID8gc3Ryb2tlV2lkdGggLyAyIDogMC4xKTtcbiAgICBjb25zdCBoZWlnaHQgPSByZWN0LmhlaWdodCArIChzdHJva2VXaWR0aCA/IHN0cm9rZVdpZHRoIC8gMiA6IDAuMSk7XG4gICAgY29uc3QgZmlsdGVyWCA9IHNoYWRvd1JlY3QueCAvIHdpZHRoICogMTAwO1xuICAgIGNvbnN0IGZpbHRlclkgPSBzaGFkb3dSZWN0LnkgLyBoZWlnaHQgKiAxMDA7XG4gICAgY29uc3QgZmlsdGVyV2lkdGggPSBzaGFkb3dSZWN0LndpZHRoIC8gd2lkdGggKiAxMDA7XG4gICAgY29uc3QgZmlsdGVySGVpZ2h0ID0gc2hhZG93UmVjdC5oZWlnaHQgLyBoZWlnaHQgKiAxMDA7XG4gICAgZGVmaW5pdGlvbi5wdXNoKC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MTkoXCJmaWx0ZXJcIiwge1xuICAgICAga2V5OiBvdXRzaWRlU2hhZG93SWQuaWQsXG4gICAgICBpZDogb3V0c2lkZVNoYWRvd0lkLmlkLFxuICAgICAgeDogYCR7ZmlsdGVyWC50b0ZpeGVkKDEpfSVgLFxuICAgICAgeTogYCR7ZmlsdGVyWS50b0ZpeGVkKDEpfSVgLFxuICAgICAgd2lkdGg6IGAke2ZpbHRlcldpZHRoLnRvRml4ZWQoMSl9JWAsXG4gICAgICBoZWlnaHQ6IGAke2ZpbHRlckhlaWdodC50b0ZpeGVkKDEpfSVgLFxuICAgICAgZmlsdGVyVW5pdHM6IFwib2JqZWN0Qm91bmRpbmdCb3hcIixcbiAgICAgIC4uLnN2Z1NoYWRvd1Byb3BzXG4gICAgfSwgZmlsdGVyRWxlbWVudHMsIHNoYWRvd3MubGVuZ3RoID4gMSA/IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MTkoXCJmZU1lcmdlXCIsIG51bGwsIG1lcmdlRWxlbWVudHMpIDogbnVsbCkpO1xuICAgIG91dHNldEVsZW1lbnQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDE5KFwiZ1wiLCB7XG4gICAgICBmaWx0ZXI6IG91dHNpZGVTaGFkb3dJZC51cmxMaW5rLFxuICAgICAgLi4uc3ZnU2hhZG93UHJvcHNcbiAgICB9LCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDE5KFwidXNlXCIsIHtcbiAgICAgIC4uLnN2Z1N0cm9rZUF0dHJpYnV0ZXMsXG4gICAgICBmaWxsOiBcImJsYWNrXCIsXG4gICAgICBmaWxsT3BhY2l0eTogZmlsbEFscGhhIDw9IDAgPyAwIDogMSxcbiAgICAgIHN0cm9rZTogXCJibGFja1wiLFxuICAgICAgc3Ryb2tlT3BhY2l0eTogc3Ryb2tlQWxwaGEgPD0gMCA/IDAgOiAxLFxuICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZUFscGhhID4gMCA/IHN0cm9rZVdpZHRoIDogMCxcbiAgICAgIHhsaW5rSHJlZjogc2hhcGVJZC5saW5rLFxuICAgICAgY2xpcFBhdGg6IHN0cm9rZUNsaXBJZC51cmxMaW5rXG4gICAgfSkpO1xuICB9XG4gIGlmIChpbnNldFNoYWRvd3MubGVuZ3RoKSB7XG4gICAgaW5zZXRTaGFkb3dzLnJldmVyc2UoKTtcbiAgICBjb25zdCBpbnNpZGVTaGFkb3dJZCA9IHNoYXBlSWQuYWRkKFwiX3NoYWRvd19pbnNpZGVcIik7XG4gICAgY29uc3Qgbm9ybWFsaXplZEZyYW1lID0gUmVjdC5hdE9yaWdpbihyZWN0KTtcbiAgICBjb25zdCBzaGFkb3dGcmFtZXMgPSBbbm9ybWFsaXplZEZyYW1lXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBpbnNldFNoYWRvd3MubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY29uc3Qgc2hhZG93ID0gaW5zZXRTaGFkb3dzW2ldO1xuICAgICAgY29uc3Qgc2hhZG93RnJhbWUgPSBsb2NhbFNoYWRvd0ZyYW1lKHNoYWRvdywgbm9ybWFsaXplZEZyYW1lLCB0cnVlKTtcbiAgICAgIGlmIChzaGFkb3dGcmFtZSA9PT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNoYWRvd0ZyYW1lcy5wdXNoKHNoYWRvd0ZyYW1lKTtcbiAgICB9XG4gICAgY29uc3Qgc2hhZG93UmVjdCA9IFJlY3QubWVyZ2UoLi4uc2hhZG93RnJhbWVzKTtcbiAgICBjb25zdCB3aWR0aCA9IHJlY3Qud2lkdGggKyAoc3Ryb2tlV2lkdGggPyBzdHJva2VXaWR0aCAvIDIgOiAwLjEpO1xuICAgIGNvbnN0IGhlaWdodCA9IHJlY3QuaGVpZ2h0ICsgKHN0cm9rZVdpZHRoID8gc3Ryb2tlV2lkdGggLyAyIDogMC4xKTtcbiAgICBjb25zdCBmaWx0ZXJYID0gc2hhZG93UmVjdC54IC8gd2lkdGggKiAxMDA7XG4gICAgY29uc3QgZmlsdGVyWSA9IHNoYWRvd1JlY3QueSAvIGhlaWdodCAqIDEwMDtcbiAgICBjb25zdCBmaWx0ZXJXaWR0aCA9IHNoYWRvd1JlY3Qud2lkdGggLyB3aWR0aCAqIDEwMDtcbiAgICBjb25zdCBmaWx0ZXJIZWlnaHQgPSBzaGFkb3dSZWN0LmhlaWdodCAvIGhlaWdodCAqIDEwMDtcbiAgICBjb25zdCBmaWx0ZXJFbGVtZW50cyA9IFtdO1xuICAgIGNvbnN0IG1lcmdlRWxlbWVudHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBpbnNldFNoYWRvd3MubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY29uc3Qgc2hhZG93ID0gaW5zZXRTaGFkb3dzW2ldO1xuICAgICAgY29uc3Qgc2hhZG93RWxlbWVudHMgPSBpbm5lclNoYWRvd0VsZW1lbnRzKHNoYXBlSWQsIHNoYWRvdywgaSk7XG4gICAgICBmaWx0ZXJFbGVtZW50cy5wdXNoKHNoYWRvd0VsZW1lbnRzLmZpbHRlckVsZW1lbnRzKTtcbiAgICAgIG1lcmdlRWxlbWVudHMucHVzaChzaGFkb3dFbGVtZW50cy5tZXJnZUVsZW1lbnQpO1xuICAgIH1cbiAgICBkZWZpbml0aW9uLnB1c2goLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQxOShcImZpbHRlclwiLCB7XG4gICAgICBrZXk6IGluc2lkZVNoYWRvd0lkLmlkLFxuICAgICAgaWQ6IGluc2lkZVNoYWRvd0lkLmlkLFxuICAgICAgeDogYCR7ZmlsdGVyWC50b0ZpeGVkKDEpfSVgLFxuICAgICAgeTogYCR7ZmlsdGVyWS50b0ZpeGVkKDEpfSVgLFxuICAgICAgd2lkdGg6IGAke2ZpbHRlcldpZHRoLnRvRml4ZWQoMSl9JWAsXG4gICAgICBoZWlnaHQ6IGAke2ZpbHRlckhlaWdodC50b0ZpeGVkKDEpfSVgLFxuICAgICAgZmlsdGVyVW5pdHM6IFwib2JqZWN0Qm91bmRpbmdCb3hcIixcbiAgICAgIC4uLnN2Z1NoYWRvd1Byb3BzXG4gICAgfSwgZmlsdGVyRWxlbWVudHMsIGluc2V0U2hhZG93cy5sZW5ndGggPiAxID8gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQxOShcImZlTWVyZ2VcIiwgbnVsbCwgbWVyZ2VFbGVtZW50cykgOiBudWxsKSk7XG4gICAgbGV0IGNsaXBQYXRoO1xuICAgIGlmIChuZWVkc1N0cm9rZUNsaXApIHtcbiAgICAgIGNsaXBQYXRoID0gc3Ryb2tlQ2xpcElkLnVybExpbms7XG4gICAgfVxuICAgIGluc2V0RWxlbWVudCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MTkoXCJ1c2VcIiwge1xuICAgICAgZmlsbDogXCJibGFja1wiLFxuICAgICAgZmlsbE9wYWNpdHk6IFwiMVwiLFxuICAgICAgZmlsdGVyOiBpbnNpZGVTaGFkb3dJZC51cmxMaW5rLFxuICAgICAgeGxpbmtIcmVmOiBzaGFwZUlkLmxpbmssXG4gICAgICBjbGlwUGF0aCxcbiAgICAgIC4uLnN2Z1NoYWRvd1Byb3BzXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHsgZGVmaW5pdGlvbiwgb3V0c2V0RWxlbWVudCwgaW5zZXRFbGVtZW50LCBuZWVkc1N0cm9rZUNsaXAgfTtcbn1cbmZ1bmN0aW9uIG91dGVyU2hhZG93RWxlbWVudHMoc2hhcGVJRCwgc2hhZG93LCBpbmRleCkge1xuICBjb25zdCBzaGFkb3dLZXkgPSBzaGFwZUlELmFkZChcIl9vdXRlcl9zaGFkb3dcIiArIGluZGV4KTtcbiAgY29uc3Qgb2Zmc2V0UmVzdWx0SWQgPSBzaGFkb3dLZXkuYWRkKFwib2Zmc2V0XCIpLmlkO1xuICBjb25zdCBibHVyUmVzdWx0SWQgPSBzaGFkb3dLZXkuYWRkKFwiYmx1clwiKS5pZDtcbiAgY29uc3QgbWF0cml4UmVzdWx0SWQgPSBzaGFkb3dLZXkuYWRkKFwibWF0cml4XCIpLmlkO1xuICBjb25zdCBmaWx0ZXJFbGVtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MTkoT3V0ZXJTaGFkb3dGaWx0ZXJFbGVtZW50cywge1xuICAgIGtleTogc2hhZG93S2V5LmlkICsgXCItZmlsdGVyc1wiLFxuICAgIHNoYWRvdyxcbiAgICBibHVySWQ6IGJsdXJSZXN1bHRJZCxcbiAgICBvZmZzZXRJZDogb2Zmc2V0UmVzdWx0SWQsXG4gICAgbWF0cml4SWQ6IG1hdHJpeFJlc3VsdElkXG4gIH0pO1xuICBjb25zdCBtZXJnZUVsZW1lbnQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDE5KFwiZmVNZXJnZU5vZGVcIiwge1xuICAgIGtleTogc2hhZG93S2V5LmlkICsgXCItbWVyZ2VcIixcbiAgICBpbjogbWF0cml4UmVzdWx0SWRcbiAgfSk7XG4gIHJldHVybiB7IGZpbHRlckVsZW1lbnRzLCBtZXJnZUVsZW1lbnQgfTtcbn1cbnZhciBPdXRlclNoYWRvd0ZpbHRlckVsZW1lbnRzID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IGxvb2t1cCA9IHVzZUNvbnRleHQyMShDdXN0b21Qcm9wZXJ0aWVzQ29udGV4dCk7XG4gIGNvbnN0IHsgc2hhZG93LCBibHVySWQsIG9mZnNldElkLCBtYXRyaXhJZCB9ID0gcHJvcHM7XG4gIGxldCBjb2xvcjIgPSBzaGFkb3cuY29sb3I7XG4gIGNvbnN0IHJlc3VsdCA9IGxvb2t1cChjb2xvcjIpO1xuICBpZiAocmVzdWx0KSB7XG4gICAgY29sb3IyID0gcmVzdWx0O1xuICB9XG4gIGNvbnN0IHJnYiA9IENvbnZlcnRDb2xvci50b1JnYihjb2xvcjIpO1xuICBjb25zdCByID0gcm91bmRlZE51bWJlclN0cmluZyhyZ2IuciAvIDI1NSwgMyk7XG4gIGNvbnN0IGcgPSByb3VuZGVkTnVtYmVyU3RyaW5nKHJnYi5nIC8gMjU1LCAzKTtcbiAgY29uc3QgYjIgPSByb3VuZGVkTnVtYmVyU3RyaW5nKHJnYi5iIC8gMjU1LCAzKTtcbiAgY29uc3QgbWF0cml4VmFsdWVzID0gYDAgMCAwIDAgJHtyfSAgIDAgMCAwIDAgJHtnfSAgIDAgMCAwIDAgJHtiMn0gIDAgMCAwICR7cmdiLmF9IDBgO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQxOShGcmFnbWVudDYsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MTkoXCJmZU9mZnNldFwiLCB7XG4gICAgZHg6IHNoYWRvdy54LFxuICAgIGR5OiBzaGFkb3cueSxcbiAgICBpbjogXCJTb3VyY2VBbHBoYVwiLFxuICAgIHJlc3VsdDogb2Zmc2V0SWRcbiAgfSksIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MTkoXCJmZUdhdXNzaWFuQmx1clwiLCB7XG4gICAgc3RkRGV2aWF0aW9uOiBzaGFkb3cuYmx1ciAvIDIsXG4gICAgaW46IG9mZnNldElkLFxuICAgIHJlc3VsdDogYmx1cklkXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDE5KFwiZmVDb2xvck1hdHJpeFwiLCB7XG4gICAgY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyczogXCJzUkdCXCIsXG4gICAgdmFsdWVzOiBtYXRyaXhWYWx1ZXMsXG4gICAgdHlwZTogXCJtYXRyaXhcIixcbiAgICBpbjogYmx1cklkLFxuICAgIHJlc3VsdDogbWF0cml4SWRcbiAgfSkpO1xufTtcbmZ1bmN0aW9uIGlubmVyU2hhZG93RWxlbWVudHMoc2hhcGVJRCwgc2hhZG93LCBpbmRleCkge1xuICBjb25zdCBzaGFkb3dLZXkgPSBzaGFwZUlELmFkZChcIl9pbnNpZGVfc2hhZG93XCIgKyBpbmRleCk7XG4gIGNvbnN0IGJsdXJJZCA9IHNoYWRvd0tleS5hZGQoXCJibHVyXCIpLmlkO1xuICBjb25zdCBvZmZzZXRJZCA9IHNoYWRvd0tleS5hZGQoXCJvZmZzZXRcIikuaWQ7XG4gIGNvbnN0IGNvbXBvc2l0ZUlkID0gc2hhZG93S2V5LmFkZChcImNvbXBvc2l0ZVwiKS5pZDtcbiAgY29uc3QgbWF0cml4SWQgPSBzaGFkb3dLZXkuYWRkKFwibWF0cml4XCIpLmlkO1xuICBjb25zdCBmaWx0ZXJFbGVtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MTkoSW5uZXJTaGFkb3dGaWx0ZXJFbGVtZW50cywge1xuICAgIGtleTogc2hhZG93S2V5LmlkICsgXCItZmlsdGVyc1wiLFxuICAgIHNoYWRvdyxcbiAgICBibHVySWQsXG4gICAgb2Zmc2V0SWQsXG4gICAgY29tcG9zaXRlSWQsXG4gICAgbWF0cml4SWRcbiAgfSk7XG4gIGNvbnN0IG1lcmdlRWxlbWVudCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MTkoXCJmZU1lcmdlTm9kZVwiLCB7XG4gICAga2V5OiBzaGFkb3dLZXkuaWQgKyBcIi1tZXJnZVwiLFxuICAgIGluOiBtYXRyaXhJZFxuICB9KTtcbiAgcmV0dXJuIHsgZmlsdGVyRWxlbWVudHMsIG1lcmdlRWxlbWVudCB9O1xufVxudmFyIElubmVyU2hhZG93RmlsdGVyRWxlbWVudHMgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgbG9va3VwID0gdXNlQ29udGV4dDIxKEN1c3RvbVByb3BlcnRpZXNDb250ZXh0KTtcbiAgY29uc3QgeyBzaGFkb3csIGJsdXJJZCwgb2Zmc2V0SWQsIGNvbXBvc2l0ZUlkLCBtYXRyaXhJZCB9ID0gcHJvcHM7XG4gIGxldCBjb2xvcjIgPSBzaGFkb3cuY29sb3I7XG4gIGNvbnN0IHJlc3VsdCA9IGxvb2t1cChjb2xvcjIpO1xuICBpZiAocmVzdWx0KSB7XG4gICAgY29sb3IyID0gcmVzdWx0O1xuICB9XG4gIGNvbnN0IHJnYiA9IENvbnZlcnRDb2xvci50b1JnYihjb2xvcjIpO1xuICBjb25zdCByID0gcmdiLnIgLyAyNTU7XG4gIGNvbnN0IGcgPSByZ2IuZyAvIDI1NTtcbiAgY29uc3QgYjIgPSByZ2IuYiAvIDI1NTtcbiAgY29uc3QgbWF0cml4VmFsdWVzID0gYDAgMCAwIDAgJHtyfSAgIDAgMCAwIDAgJHtnfSAgIDAgMCAwIDAgJHtiMn0gIDAgMCAwICR7cmdiLmF9IDBgO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQxOShGcmFnbWVudDYsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MTkoXCJmZUdhdXNzaWFuQmx1clwiLCB7XG4gICAgc3RkRGV2aWF0aW9uOiBzaGFkb3cuYmx1ciAvIDIsXG4gICAgaW46IFwiU291cmNlQWxwaGFcIixcbiAgICByZXN1bHQ6IGJsdXJJZFxuICB9KSwgLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQxOShcImZlT2Zmc2V0XCIsIHtcbiAgICBkeDogc2hhZG93LngsXG4gICAgZHk6IHNoYWRvdy55LFxuICAgIGluOiBibHVySWQsXG4gICAgcmVzdWx0OiBvZmZzZXRJZFxuICB9KSwgLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQxOShcImZlQ29tcG9zaXRlXCIsIHtcbiAgICBpbjogb2Zmc2V0SWQsXG4gICAgaW4yOiBcIlNvdXJjZUFscGhhXCIsXG4gICAgb3BlcmF0b3I6IFwiYXJpdGhtZXRpY1wiLFxuICAgIGsyOiBcIi0xXCIsXG4gICAgazM6IFwiMVwiLFxuICAgIHJlc3VsdDogY29tcG9zaXRlSWRcbiAgfSksIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MTkoXCJmZUNvbG9yTWF0cml4XCIsIHtcbiAgICBjb2xvckludGVycG9sYXRpb25GaWx0ZXJzOiBcInNSR0JcIixcbiAgICB2YWx1ZXM6IG1hdHJpeFZhbHVlcyxcbiAgICB0eXBlOiBcIm1hdHJpeFwiLFxuICAgIGluOiBjb21wb3NpdGVJZCxcbiAgICByZXN1bHQ6IG1hdHJpeElkXG4gIH0pKTtcbn07XG5mdW5jdGlvbiBsb2NhbFNoYWRvd0ZyYW1lKHNoYWRvdywgZnJhbWUyLCBpc1NWRzIpIHtcbiAgbGV0IGdyb3d0aCA9IHNoYWRvdy5ibHVyO1xuICBpZiAoQm94U2hhZG93LmlzKHNoYWRvdykpIHtcbiAgICBpZiAoaXNTVkcyICE9PSB0cnVlKSB7XG4gICAgICBpZiAoc2hhZG93Lmluc2V0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGdyb3d0aCArPSBzaGFkb3cuc3ByZWFkO1xuICAgIH1cbiAgfVxuICBsZXQgbWluWDtcbiAgbGV0IG1heFg7XG4gIGxldCBtaW5ZO1xuICBsZXQgbWF4WTtcbiAgaWYgKGlzU1ZHMiA9PT0gdHJ1ZSkge1xuICAgIG1pblggPSAtTWF0aC5hYnMoc2hhZG93LngpIC0gZ3Jvd3RoO1xuICAgIG1heFggPSBNYXRoLmFicyhzaGFkb3cueCkgKyBmcmFtZTIud2lkdGggKyBncm93dGg7XG4gICAgbWluWSA9IC1NYXRoLmFicyhzaGFkb3cueSkgLSBncm93dGg7XG4gICAgbWF4WSA9IE1hdGguYWJzKHNoYWRvdy55KSArIGZyYW1lMi5oZWlnaHQgKyBncm93dGg7XG4gIH0gZWxzZSB7XG4gICAgbWluWCA9IHNoYWRvdy54IC0gZ3Jvd3RoO1xuICAgIG1heFggPSBzaGFkb3cueCArIGZyYW1lMi53aWR0aCArIGdyb3d0aDtcbiAgICBtaW5ZID0gc2hhZG93LnkgLSBncm93dGg7XG4gICAgbWF4WSA9IHNoYWRvdy55ICsgZnJhbWUyLmhlaWdodCArIGdyb3d0aDtcbiAgfVxuICBpZiAobWF4WCA8PSBtaW5YIHx8IG1heFkgPD0gbWluWSlcbiAgICByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHsgeDogbWluWCwgeTogbWluWSwgd2lkdGg6IG1heFggLSBtaW5YLCBoZWlnaHQ6IG1heFkgLSBtaW5ZIH07XG59XG5cbi8vIHNyYy9yZW5kZXIvdXRpbHMvZmlsdGVyc0Zvck5vZGUudHNcbmZ1bmN0aW9uIGNvbGxlY3RMYXllckZpbHRlcnMocHJvcHMsIHN0eWxlKSB7XG4gIGNvbnN0IGZpbHRlcnMgPSBbXTtcbiAgaWYgKGlzRmluaXRlTnVtYmVyKHByb3BzLmJyaWdodG5lc3MpKSB7XG4gICAgZmlsdGVycy5wdXNoKGBicmlnaHRuZXNzKCR7cHJvcHMuYnJpZ2h0bmVzcyAvIDEwMH0pYCk7XG4gIH1cbiAgaWYgKGlzRmluaXRlTnVtYmVyKHByb3BzLmNvbnRyYXN0KSkge1xuICAgIGZpbHRlcnMucHVzaChgY29udHJhc3QoJHtwcm9wcy5jb250cmFzdCAvIDEwMH0pYCk7XG4gIH1cbiAgaWYgKGlzRmluaXRlTnVtYmVyKHByb3BzLmdyYXlzY2FsZSkpIHtcbiAgICBmaWx0ZXJzLnB1c2goYGdyYXlzY2FsZSgke3Byb3BzLmdyYXlzY2FsZSAvIDEwMH0pYCk7XG4gIH1cbiAgaWYgKGlzRmluaXRlTnVtYmVyKHByb3BzLmh1ZVJvdGF0ZSkpIHtcbiAgICBmaWx0ZXJzLnB1c2goYGh1ZS1yb3RhdGUoJHtwcm9wcy5odWVSb3RhdGV9ZGVnKWApO1xuICB9XG4gIGlmIChpc0Zpbml0ZU51bWJlcihwcm9wcy5pbnZlcnQpKSB7XG4gICAgZmlsdGVycy5wdXNoKGBpbnZlcnQoJHtwcm9wcy5pbnZlcnQgLyAxMDB9KWApO1xuICB9XG4gIGlmIChpc0Zpbml0ZU51bWJlcihwcm9wcy5zYXR1cmF0ZSkpIHtcbiAgICBmaWx0ZXJzLnB1c2goYHNhdHVyYXRlKCR7cHJvcHMuc2F0dXJhdGUgLyAxMDB9KWApO1xuICB9XG4gIGlmIChpc0Zpbml0ZU51bWJlcihwcm9wcy5zZXBpYSkpIHtcbiAgICBmaWx0ZXJzLnB1c2goYHNlcGlhKCR7cHJvcHMuc2VwaWEgLyAxMDB9KWApO1xuICB9XG4gIGlmIChpc0Zpbml0ZU51bWJlcihwcm9wcy5ibHVyKSkge1xuICAgIGZpbHRlcnMucHVzaChgYmx1cigke3Byb3BzLmJsdXJ9cHgpYCk7XG4gIH1cbiAgaWYgKHByb3BzLmRyb3BTaGFkb3dzKSB7XG4gICAgZmlsdGVycy5wdXNoKC4uLnNoYWRvd3NBc0ZpbHRlcihwcm9wcy5kcm9wU2hhZG93cykpO1xuICB9XG4gIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm47XG4gIHN0eWxlLmZpbHRlciA9IHN0eWxlLldlYmtpdEZpbHRlciA9IGZpbHRlcnMuam9pbihcIiBcIik7XG59XG5mdW5jdGlvbiBjb2xsZWN0QmFja2dyb3VuZEZpbHRlcnMocHJvcHMsIHN0eWxlKSB7XG4gIGlmIChpc0Zpbml0ZU51bWJlcihwcm9wcy5iYWNrZ3JvdW5kQmx1cikpIHtcbiAgICBzdHlsZS5iYWNrZHJvcEZpbHRlciA9IHN0eWxlLldlYmtpdEJhY2tkcm9wRmlsdGVyID0gYGJsdXIoJHtwcm9wcy5iYWNrZ3JvdW5kQmx1cn1weClgO1xuICB9XG59XG5mdW5jdGlvbiBjb2xsZWN0RmlsdGVyc0Zyb21Qcm9wcyhwcm9wcywgc3R5bGUpIHtcbiAgY29sbGVjdEJhY2tncm91bmRGaWx0ZXJzKHByb3BzLCBzdHlsZSk7XG4gIGNvbGxlY3RMYXllckZpbHRlcnMocHJvcHMsIHN0eWxlKTtcbn1cblxuLy8gc3JjL3JlbmRlci90cmFpdHMvVGV4dENvbG9yLnRzXG5mdW5jdGlvbiBjb2xsZWN0VGV4dENvbG9yRnJvbVByb3BzKHByb3BzLCBzdHlsZSkge1xuICBjb25zdCB7IGNvbG9yOiBjb2xvcjIgfSA9IHByb3BzO1xuICBpZiAodHlwZW9mIGNvbG9yMiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHN0eWxlLmNvbG9yID0gY29sb3IyO1xuICB9IGVsc2UgaWYgKENvbG9yLmlzQ29sb3JPYmplY3QoY29sb3IyKSkge1xuICAgIHN0eWxlLmNvbG9yID0gY29sb3IyLmluaXRpYWxWYWx1ZSB8fCBDb2xvci50b1JnYlN0cmluZyhjb2xvcjIpO1xuICB9XG59XG5cbi8vIHNyYy9yZW5kZXIvc3R5bGUvY29sbGVjdFZpc3VhbFN0eWxlRnJvbVByb3BzLnRzXG5mdW5jdGlvbiBjb2xsZWN0VmlzdWFsU3R5bGVGcm9tUHJvcHMocHJvcHMsIHN0eWxlLCBpc1RleHROb2RlID0gZmFsc2UpIHtcbiAgY29sbGVjdEJhY2tncm91bmRGcm9tUHJvcHMocHJvcHMsIHN0eWxlKTtcbiAgY29sbGVjdFJhZGl1c0Zyb21Qcm9wcyhwcm9wcywgc3R5bGUpO1xuICBjb2xsZWN0RmlsdGVyc0Zyb21Qcm9wcyhwcm9wcywgc3R5bGUpO1xuICBjb2xsZWN0QmxlbmRpbmdGcm9tUHJvcHMocHJvcHMsIHN0eWxlKTtcbiAgY29sbGVjdE92ZXJmbG93RnJvbVByb3BzKHByb3BzLCBzdHlsZSk7XG4gIGNvbGxlY3RPcGFjaXR5RnJvbVByb3BzKHByb3BzLCBzdHlsZSk7XG4gIGNvbGxlY3RUZXh0Q29sb3JGcm9tUHJvcHMocHJvcHMsIHN0eWxlKTtcbiAgaWYgKGlzVGV4dE5vZGUpIHtcbiAgICBjb2xsZWN0VGV4dFNoYWRvd3NGb3JQcm9wcyhwcm9wcywgc3R5bGUpO1xuICB9IGVsc2Uge1xuICAgIGNvbGxlY3RCb3hTaGFkb3dzRm9yUHJvcHMocHJvcHMsIHN0eWxlKTtcbiAgfVxufVxuXG4vLyBzcmMvcmVuZGVyL3RyYWl0cy9UcmFuc2Zvcm0udHNcbnZhciB7IGdldE51bWJlciB9ID0gQW5pbWF0YWJsZTtcbnZhciB0cmFuc2Zvcm1EZWZhdWx0cyA9IHtcbiAgejogMCxcbiAgcm90YXRpb246IDAsXG4gIHJvdGF0aW9uWDogMCxcbiAgcm90YXRpb25ZOiAwLFxuICByb3RhdGlvblo6IDAsXG4gIHNjYWxlOiAxLFxuICBzY2FsZVg6IDEsXG4gIHNjYWxlWTogMSxcbiAgc2NhbGVaOiAxLFxuICBza2V3OiAwLFxuICBza2V3WDogMCxcbiAgc2tld1k6IDAsXG4gIG9yaWdpblg6IDAuNSxcbiAgb3JpZ2luWTogMC41LFxuICBvcmlnaW5aOiAwXG59O1xuZnVuY3Rpb24gZ2V0Um90YXRpb24ocm90YXRpb24sIHJvdGF0ZSkge1xuICBpZiAodHlwZW9mIHJvdGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJvdGF0ZSA9IHBhcnNlRmxvYXQocm90YXRlKTtcbiAgfVxuICByZXR1cm4gaXNGaW5pdGVOdW1iZXIocm90YXRlKSA/IHJvdGF0ZSA6IGdldE51bWJlcihyb3RhdGlvbik7XG59XG5mdW5jdGlvbiBjb2xsZWN0VHJhbnNmb3JtRnJvbVByb3BzKHByb3BzLCByZWN0LCBzdHlsZSkge1xuICBjb25zdCBtb3Rpb25TdHlsZSA9IHN0eWxlO1xuICBjb25zdCB4ID0gdHlwZW9mIHJlY3QueCA9PT0gXCJudW1iZXJcIiA/IGAke3JlY3QueH1weGAgOiByZWN0Lng7XG4gIGNvbnN0IHkgPSB0eXBlb2YgcmVjdC55ID09PSBcIm51bWJlclwiID8gYCR7cmVjdC55fXB4YCA6IHJlY3QueTtcbiAgY29uc3QgeiA9IGdldE51bWJlcihwcm9wcy56KTtcbiAgY29uc3Qgc2NhbGVaID0gZ2V0TnVtYmVyKHByb3BzLnNjYWxlWik7XG4gIGNvbnN0IG9yaWdpblogPSBnZXROdW1iZXIocHJvcHMub3JpZ2luWik7XG4gIGNvbnN0IHJvdGF0aW9uWiA9IGdldFJvdGF0aW9uKHByb3BzLnJvdGF0aW9uWiwgcmVzb2x2ZU1vdGlvblZhbHVlKG1vdGlvblN0eWxlLnJvdGF0ZVopKTtcbiAgY29uc3Qgcm90YXRpb25YID0gZ2V0Um90YXRpb24ocHJvcHMucm90YXRpb25YLCByZXNvbHZlTW90aW9uVmFsdWUobW90aW9uU3R5bGUucm90YXRlWCkpO1xuICBjb25zdCByb3RhdGlvblkgPSBnZXRSb3RhdGlvbihwcm9wcy5yb3RhdGlvblksIHJlc29sdmVNb3Rpb25WYWx1ZShtb3Rpb25TdHlsZS5yb3RhdGVZKSk7XG4gIGNvbnN0IHNjYWxlMiA9IGdldE51bWJlcihwcm9wcy5zY2FsZSk7XG4gIGNvbnN0IHNjYWxlWCA9IGdldE51bWJlcihwcm9wcy5zY2FsZVgpO1xuICBjb25zdCBzY2FsZVkgPSBnZXROdW1iZXIocHJvcHMuc2NhbGVZKTtcbiAgY29uc3Qgc2tldyA9IGdldE51bWJlcihwcm9wcy5za2V3KTtcbiAgY29uc3Qgc2tld1ggPSBnZXROdW1iZXIocHJvcHMuc2tld1gpO1xuICBjb25zdCBza2V3WSA9IGdldE51bWJlcihwcm9wcy5za2V3WSk7XG4gIGNvbnN0IHJvdGF0aW9uID0gZ2V0Um90YXRpb24ocHJvcHMucm90YXRpb24sIHJlc29sdmVNb3Rpb25WYWx1ZShtb3Rpb25TdHlsZS5yb3RhdGUpKTtcbiAgY29uc3QgZm9yY2UzZCA9IFJlbmRlckVudmlyb25tZW50LnRhcmdldCA9PT0gUmVuZGVyVGFyZ2V0LmV4cG9ydDtcbiAgaWYgKGZvcmNlM2QgfHwgeiAhPT0gMCB8fCBzY2FsZVogIT09IDEgfHwgb3JpZ2luWiAhPT0gMCB8fCByb3RhdGlvblogIT09IDAgfHwgcm90YXRpb25YICE9PSAwIHx8IHJvdGF0aW9uWSAhPT0gMCkge1xuICAgIHN0eWxlLnRyYW5zZm9ybSA9IGBcbiAgICAgICAgICAgICR7YHRyYW5zbGF0ZTNkKCR7eH0sICR7eX0sICR7en1weClgfVxuICAgICAgICAgICAgc2NhbGUzZCgke3NjYWxlWCAqIHNjYWxlMn0sICR7c2NhbGVZICogc2NhbGUyfSwgJHtzY2FsZVp9KVxuICAgICAgICAgICAgc2tldygke3NrZXd9ZGVnLCR7c2tld31kZWcpXG4gICAgICAgICAgICBza2V3WCgke3NrZXdYfWRlZylcbiAgICAgICAgICAgIHNrZXdZKCR7c2tld1l9ZGVnKVxuICAgICAgICAgICAgdHJhbnNsYXRlWigke29yaWdpblp9cHgpXG4gICAgICAgICAgICByb3RhdGVYKCR7cm90YXRpb25YfWRlZylcbiAgICAgICAgICAgIHJvdGF0ZVkoJHtyb3RhdGlvbll9ZGVnKVxuICAgICAgICAgICAgcm90YXRlWigkeyhyb3RhdGlvbiArIHJvdGF0aW9uWikudG9GaXhlZCg0KX1kZWcpXG4gICAgICAgICAgICB0cmFuc2xhdGVaKCR7LW9yaWdpblp9cHgpYDtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS50cmFuc2Zvcm0gPSBgXG4gICAgICAgICAgICAke2B0cmFuc2xhdGUoJHt4fSwgJHt5fSlgfVxuICAgICAgICAgICAgc2NhbGUoJHtzY2FsZVggKiBzY2FsZTJ9LCAke3NjYWxlWSAqIHNjYWxlMn0pXG4gICAgICAgICAgICBza2V3KCR7c2tld31kZWcsJHtza2V3fWRlZylcbiAgICAgICAgICAgIHNrZXdYKCR7c2tld1h9ZGVnKVxuICAgICAgICAgICAgc2tld1koJHtza2V3WX1kZWcpXG4gICAgICAgICAgICByb3RhdGUoJHtyb3RhdGlvbi50b0ZpeGVkKDQpfWRlZylgO1xuICB9XG4gIGNvbnN0IHRyYW5zZm9ybU9yaWdpbiA9IGAke2dldE51bWJlcihwcm9wcy5vcmlnaW5YKSAqIDEwMH0lICR7Z2V0TnVtYmVyKHByb3BzLm9yaWdpblkpICogMTAwfSVgO1xuICBzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSB0cmFuc2Zvcm1PcmlnaW47XG4gIHN0eWxlLldlYmtpdFRyYW5zZm9ybU9yaWdpbiA9IHRyYW5zZm9ybU9yaWdpbjtcbn1cblxuLy8gc3JjL3JlbmRlci9wcmVzZW50YXRpb24vRnJhbWUvRGVwcmVjYXRlZEZyYW1lLnRzeFxuZnVuY3Rpb24gY3NzQmFja2dyb3VuZFNpemUoc2l6ZTIpIHtcbiAgc3dpdGNoIChzaXplMikge1xuICAgIGNhc2UgXCJmaXRcIjpcbiAgICAgIHJldHVybiBcImNvbnRhaW5cIjtcbiAgICBjYXNlIFwic3RyZXRjaFwiOlxuICAgICAgcmV0dXJuIFwiMTAwJSAxMDAlXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcImNvdmVyXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbGxlY3RCYWNrZ3JvdW5kSW1hZ2VGcm9tUHJvcHMocHJvcHMsIHN0eWxlKSB7XG4gIGNvbnN0IGltYWdlID0gYmFja2dyb3VuZEltYWdlRnJvbVByb3BzKHByb3BzKTtcbiAgaWYgKGltYWdlKSB7XG4gICAgc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybChcIiR7aW1hZ2Uuc3JjfVwiKWA7XG4gICAgc3R5bGUuYmFja2dyb3VuZFNpemUgPSBjc3NCYWNrZ3JvdW5kU2l6ZShpbWFnZS5maXQpO1xuICAgIHN0eWxlLmJhY2tncm91bmRSZXBlYXQgPSBcIm5vLXJlcGVhdFwiO1xuICAgIHN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9IFwiY2VudGVyXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvUGl4ZWxTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIGlzRmluaXRlTnVtYmVyKHZhbHVlKSA/IGAke3ZhbHVlfXB4YCA6IHZhbHVlO1xufVxuZnVuY3Rpb24gYXBwbHlMYXlvdXRQcm9wKHN0eWxlLCBwcm9wcywga2V5Nikge1xuICBpZiAocHJvcHNba2V5Nl0gIT09IHZvaWQgMCkge1xuICAgIGNvbnN0IHZhbHVlID0gQW5pbWF0YWJsZS5nZXQocHJvcHNba2V5Nl0sIHZvaWQgMCk7XG4gICAgc3R5bGVba2V5Nl0gPSB0b1BpeGVsU3RyaW5nKHZhbHVlKTtcbiAgfVxufVxudmFyIF9EZXByZWNhdGVkRnJhbWUgPSBjbGFzcyBleHRlbmRzIExheWVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuaW1hZ2VEaWRDaGFuZ2UgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgc2l6ZTogbnVsbFxuICAgIH07XG4gICAgdGhpcy51cGRhdGVTdHlsZSA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5lbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5lbGVtZW50LnN0eWxlLCB0aGlzLmdldFN0eWxlKCkpO1xuICAgIH07XG4gICAgdGhpcy5zZXRFbGVtZW50ID0gKGVsZW1lbnQpID0+IHtcbiAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgfTtcbiAgICB0aGlzLm9uUHJvcHNDaGFuZ2UgPSAocHJvcHMpID0+IHtcbiAgICAgIGNvbnN0IHJlY3QgPSBfRGVwcmVjYXRlZEZyYW1lLnJlY3QoQW5pbWF0YWJsZS5vYmplY3RUb1ZhbHVlcyhwcm9wcy52YWx1ZSkpO1xuICAgICAgaWYgKHRoaXMuc3RhdGUuc2l6ZSAmJiBpc0FuaW1hdGFibGUyKHRoaXMuc3RhdGUuc2l6ZS53aWR0aCkgJiYgaXNBbmltYXRhYmxlMihwcm9wcy52YWx1ZS53aWR0aCkpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zaXplLndpZHRoLnNldChyZWN0LndpZHRoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXRlLnNpemUgJiYgaXNBbmltYXRhYmxlMih0aGlzLnN0YXRlLnNpemUuaGVpZ2h0KSAmJiBpc0FuaW1hdGFibGUyKHByb3BzLnZhbHVlLmhlaWdodCkpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zaXplLmhlaWdodC5zZXQocmVjdC5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVTdHlsZSgpO1xuICAgIH07XG4gICAgdGhpcy5vblNpemVDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZVN0eWxlKCk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgcmVjdChwcm9wcykge1xuICAgIGNvbnN0IGNvbnN0cmFpbnRWYWx1ZXMgPSBDb25zdHJhaW50VmFsdWVzLmZyb21Qcm9wZXJ0aWVzKHByb3BzKTtcbiAgICByZXR1cm4gQ29uc3RyYWludFZhbHVlcy50b1JlY3QoY29uc3RyYWludFZhbHVlcywgcHJvcHMucGFyZW50U2l6ZSB8fCBudWxsLCBudWxsLCB0cnVlKTtcbiAgfVxuICBnZXQgcmVjdCgpIHtcbiAgICByZXR1cm4gX0RlcHJlY2F0ZWRGcmFtZS5yZWN0KHRoaXMucHJvcHMpO1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICBjb25zdCBzaXplMiA9IF9EZXByZWNhdGVkRnJhbWUudXBkYXRlZFNpemUobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSBSZW5kZXJFbnZpcm9ubWVudDtcbiAgICBjb25zdCBuZXh0QmFja2dyb3VuZEltYWdlU3JjID0gbmV4dFByb3BzLmJhY2tncm91bmQgJiYgQmFja2dyb3VuZEltYWdlLmlzSW1hZ2VPYmplY3QobmV4dFByb3BzLmJhY2tncm91bmQpID8gbmV4dFByb3BzLmJhY2tncm91bmQuc3JjIDogbnVsbDtcbiAgICBpZiAobmV4dEJhY2tncm91bmRJbWFnZVNyYykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2l6ZTogc2l6ZTJcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChwcmV2U3RhdGUuc2l6ZSkge1xuICAgICAgaWYgKHRhcmdldCA9PT0gUmVuZGVyVGFyZ2V0LnByZXZpZXcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAocHJldlN0YXRlLnNpemUud2lkdGggPT09IHNpemUyLndpZHRoICYmIHByZXZTdGF0ZS5zaXplLmhlaWdodCA9PT0gc2l6ZTIuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2l6ZTogc2l6ZTJcbiAgICB9O1xuICB9XG4gIHN0YXRpYyB1cGRhdGVkU2l6ZShwcm9wcywgc3RhdGUpIHtcbiAgICBjb25zdCByZWN0ID0gX0RlcHJlY2F0ZWRGcmFtZS5yZWN0KHByb3BzKTtcbiAgICBsZXQgc2l6ZTIgPSBzdGF0ZS5zaXplO1xuICAgIGNvbnN0IG5ld1NpemUgPSB7IHdpZHRoOiByZWN0LndpZHRoLCBoZWlnaHQ6IHJlY3QuaGVpZ2h0IH07XG4gICAgY29uc3QgeyB0YXJnZXQgfSA9IFJlbmRlckVudmlyb25tZW50O1xuICAgIGlmICghc2l6ZTIpIHtcbiAgICAgIGlmICh0YXJnZXQgPT09IFJlbmRlclRhcmdldC5wcmV2aWV3KSB7XG4gICAgICAgIHNpemUyID0gT2JzZXJ2YWJsZU9iamVjdChuZXdTaXplLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemUyID0gbmV3U2l6ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzQW5pbWF0YWJsZTIoc2l6ZTIud2lkdGgpICYmIGlzQW5pbWF0YWJsZTIoc2l6ZTIuaGVpZ2h0KSkge1xuICAgICAgICBzaXplMi53aWR0aC5zZXQobmV3U2l6ZS53aWR0aCk7XG4gICAgICAgIHNpemUyLmhlaWdodC5zZXQobmV3U2l6ZS5oZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZTIgPSBuZXdTaXplO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2l6ZTI7XG4gIH1cbiAgZ2V0U3R5bGUoKSB7XG4gICAgY29uc3QgcmVjdCA9IHRoaXMucmVjdDtcbiAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICB3aWR0aDogYCR7cmVjdC53aWR0aH1weGAsXG4gICAgICBoZWlnaHQ6IGAke3JlY3QuaGVpZ2h0fXB4YCxcbiAgICAgIHBvaW50ZXJFdmVudHM6IHZvaWQgMCxcbiAgICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiXG4gICAgfTtcbiAgICBsZXQgbGVmdCA9IEFuaW1hdGFibGUuZ2V0KHRoaXMucHJvcHMubGVmdCwgdm9pZCAwKTtcbiAgICBsZXQgdG9wID0gQW5pbWF0YWJsZS5nZXQodGhpcy5wcm9wcy50b3AsIHZvaWQgMCk7XG4gICAgT2JqZWN0LmFzc2lnbihzdHlsZSwgdGhpcy5wcm9wcy5faW5pdGlhbFN0eWxlKTtcbiAgICBjb25zdCBoYXNQYXJlbnRTaXplID0gdGhpcy5jb250ZXh0LnNpemUgIT09IFBhcmVudFNpemVTdGF0ZS5EaXNhYmxlZDtcbiAgICBjb25zdCBwZXJzcGVjdGl2ZSA9IEFuaW1hdGFibGUuZ2V0KHRoaXMucHJvcHMucGVyc3BlY3RpdmUsIHZvaWQgMCk7XG4gICAgc3R5bGUucGVyc3BlY3RpdmUgPSBwZXJzcGVjdGl2ZTtcbiAgICBzdHlsZS5XZWJraXRQZXJzcGVjdGl2ZSA9IHBlcnNwZWN0aXZlO1xuICAgIGxldCBiYWNrZmFjZVZpc2liaWxpdHkgPSB2b2lkIDA7XG4gICAgY29uc3QgYmFja2ZhY2VWaXNpYmxlID0gQW5pbWF0YWJsZS5nZXQodGhpcy5wcm9wcy5iYWNrZmFjZVZpc2libGUsIHZvaWQgMCk7XG4gICAgaWYgKGJhY2tmYWNlVmlzaWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgYmFja2ZhY2VWaXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG4gICAgfSBlbHNlIGlmIChiYWNrZmFjZVZpc2libGUgPT09IGZhbHNlKSB7XG4gICAgICBiYWNrZmFjZVZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgIH1cbiAgICBzdHlsZS5iYWNrZmFjZVZpc2liaWxpdHkgPSBiYWNrZmFjZVZpc2liaWxpdHk7XG4gICAgc3R5bGUuV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5ID0gYmFja2ZhY2VWaXNpYmlsaXR5O1xuICAgIGNvbnN0IHByZXNlcnZlM2QgPSBBbmltYXRhYmxlLmdldCh0aGlzLnByb3BzLnByZXNlcnZlM2QsIHZvaWQgMCk7XG4gICAgaWYgKHByZXNlcnZlM2QgPT09IHRydWUpIHtcbiAgICAgIHN0eWxlLnRyYW5zZm9ybVN0eWxlID0gXCJwcmVzZXJ2ZS0zZFwiO1xuICAgIH0gZWxzZSBpZiAocHJlc2VydmUzZCA9PT0gZmFsc2UpIHtcbiAgICAgIHN0eWxlLnRyYW5zZm9ybVN0eWxlID0gXCJmbGF0XCI7XG4gICAgfVxuICAgIGlmICghaGFzUGFyZW50U2l6ZSkge1xuICAgICAgYXBwbHlMYXlvdXRQcm9wKHN0eWxlLCB0aGlzLnByb3BzLCBcInJpZ2h0XCIpO1xuICAgICAgYXBwbHlMYXlvdXRQcm9wKHN0eWxlLCB0aGlzLnByb3BzLCBcImJvdHRvbVwiKTtcbiAgICAgIGNvbnN0IHdpZHRoID0gQW5pbWF0YWJsZS5nZXQodGhpcy5wcm9wcy53aWR0aCwgdm9pZCAwKTtcbiAgICAgIGNvbnN0IHN0cmluZ1dpZHRoID0gdG9QaXhlbFN0cmluZyh3aWR0aCk7XG4gICAgICBjb25zdCBoZWlnaHQgPSBBbmltYXRhYmxlLmdldCh0aGlzLnByb3BzLmhlaWdodCwgdm9pZCAwKTtcbiAgICAgIGNvbnN0IHN0cmluZ0hlaWdodCA9IHRvUGl4ZWxTdHJpbmcoaGVpZ2h0KTtcbiAgICAgIGlmICh0eXBlb2YgbGVmdCA9PT0gXCJzdHJpbmdcIiAmJiBsZWZ0LmVuZHNXaXRoKFwiJVwiKSAmJiB0aGlzLnByb3BzLnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgIGxlZnQgPSBgY2FsYygke2xlZnR9IC0gY2FsYygke3N0cmluZ1dpZHRofX0gLyAyKSlgO1xuICAgICAgICBzdHlsZS53aWR0aCA9IHN0cmluZ1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0b3AgPT09IFwic3RyaW5nXCIgJiYgdG9wLmVuZHNXaXRoKFwiJVwiKSAmJiB0aGlzLnByb3BzLmJvdHRvbSA9PT0gbnVsbCkge1xuICAgICAgICB0b3AgPSBgY2FsYygke3RvcH0gLSBjYWxjKCR7c3RyaW5nSGVpZ2h0fSAvIDIpKWA7XG4gICAgICAgIHN0eWxlLmhlaWdodCA9IHN0cmluZ0hlaWdodDtcbiAgICAgIH1cbiAgICAgIGlmICh0b3AgIT09IHZvaWQgMCAmJiBzdHlsZS5ib3R0b20gIT09IHZvaWQgMCkge1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSB2b2lkIDA7XG4gICAgICAgIHRvcCA9IHRvUGl4ZWxTdHJpbmcoQW5pbWF0YWJsZS5nZXQodGhpcy5wcm9wcy50b3AsIHZvaWQgMCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gc3RyaW5nSGVpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKGxlZnQgIT09IHZvaWQgMCAmJiBzdHlsZS5yaWdodCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHN0eWxlLndpZHRoID0gdm9pZCAwO1xuICAgICAgICBsZWZ0ID0gdG9QaXhlbFN0cmluZyhBbmltYXRhYmxlLmdldCh0aGlzLnByb3BzLmxlZnQsIHZvaWQgMCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUud2lkdGggPSBzdHJpbmdXaWR0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdHJhbnNmb3JtUmVjdCA9IHsgLi4ucmVjdCB9O1xuICAgIGlmICh0eXBlb2YgbGVmdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdHJhbnNmb3JtUmVjdC54ID0gbGVmdDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0b3AgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRyYW5zZm9ybVJlY3QueSA9IHRvcDtcbiAgICB9XG4gICAgY29sbGVjdFRyYW5zZm9ybUZyb21Qcm9wcyh0aGlzLnByb3BzLCB0cmFuc2Zvcm1SZWN0LCBzdHlsZSk7XG4gICAgY29sbGVjdFZpc3VhbFN0eWxlRnJvbVByb3BzKHRoaXMucHJvcHMsIHN0eWxlKTtcbiAgICBjb2xsZWN0QmFja2dyb3VuZEltYWdlRnJvbVByb3BzKHRoaXMucHJvcHMsIHN0eWxlKTtcbiAgICBMYXllci5hcHBseVdpbGxDaGFuZ2UodGhpcy5wcm9wcywgc3R5bGUsIGZhbHNlKTtcbiAgICBpZiAodGhpcy5wcm9wcy5zdHlsZSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZSwgdGhpcy5wcm9wcy5zdHlsZSk7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCB7IHRhcmdldCB9ID0gUmVuZGVyRW52aXJvbm1lbnQ7XG4gICAgaWYgKHRhcmdldCA9PT0gUmVuZGVyVGFyZ2V0LnByZXZpZXcpIHtcbiAgICAgIHRoaXMucHJvcHNPYnNlcnZlciA9IE9ic2VydmFibGVPYmplY3QodGhpcy5wcm9wcywgdHJ1ZSk7XG4gICAgICB0aGlzLnByb3BzT2JzZXJ2ZXJDYW5jZWwgPSBPYnNlcnZhYmxlT2JqZWN0LmFkZE9ic2VydmVyKHRoaXMucHJvcHNPYnNlcnZlciwgdGhpcy5vblByb3BzQ2hhbmdlKTtcbiAgICAgIGlmICh0aGlzLnByb3BzLnBhcmVudFNpemUgJiYgaXNBbmltYXRhYmxlMih0aGlzLnByb3BzLnBhcmVudFNpemUud2lkdGgpICYmIGlzQW5pbWF0YWJsZTIodGhpcy5wcm9wcy5wYXJlbnRTaXplLmhlaWdodCkpIHtcbiAgICAgICAgdGhpcy5zaXplT2JzZXJ2ZXIgPSBPYnNlcnZhYmxlT2JqZWN0KHRoaXMucHJvcHMucGFyZW50U2l6ZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuc2l6ZU9ic2VydmVyQ2FuY2VsID0gT2JzZXJ2YWJsZU9iamVjdC5hZGRPYnNlcnZlcih0aGlzLnNpemVPYnNlcnZlciwgdGhpcy5vblNpemVDaGFuZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgY29uc3QgeyB0YXJnZXQgfSA9IFJlbmRlckVudmlyb25tZW50O1xuICAgIHRoaXMucHJvcHNPYnNlcnZlckNhbmNlbCAmJiB0aGlzLnByb3BzT2JzZXJ2ZXJDYW5jZWwoKTtcbiAgICB0aGlzLnNpemVPYnNlcnZlckNhbmNlbCAmJiB0aGlzLnNpemVPYnNlcnZlckNhbmNlbCgpO1xuICAgIGlmICh0YXJnZXQgPT09IFJlbmRlclRhcmdldC5wcmV2aWV3KSB7XG4gICAgICB0aGlzLnByb3BzT2JzZXJ2ZXIgPSBPYnNlcnZhYmxlT2JqZWN0KHRoaXMucHJvcHMsIHRydWUpO1xuICAgICAgdGhpcy5wcm9wc09ic2VydmVyQ2FuY2VsID0gT2JzZXJ2YWJsZU9iamVjdC5hZGRPYnNlcnZlcih0aGlzLnByb3BzT2JzZXJ2ZXIsIHRoaXMub25Qcm9wc0NoYW5nZSk7XG4gICAgICBpZiAodGhpcy5wcm9wcy5wYXJlbnRTaXplICYmIGlzQW5pbWF0YWJsZTIodGhpcy5wcm9wcy5wYXJlbnRTaXplLndpZHRoKSAmJiBpc0FuaW1hdGFibGUyKHRoaXMucHJvcHMucGFyZW50U2l6ZS5oZWlnaHQpKSB7XG4gICAgICAgIHRoaXMuc2l6ZU9ic2VydmVyID0gT2JzZXJ2YWJsZU9iamVjdCh0aGlzLnByb3BzLnBhcmVudFNpemUsIHRydWUpO1xuICAgICAgICB0aGlzLnNpemVPYnNlcnZlckNhbmNlbCA9IE9ic2VydmFibGVPYmplY3QuYWRkT2JzZXJ2ZXIodGhpcy5zaXplT2JzZXJ2ZXIsIHRoaXMub25TaXplQ2hhbmdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5wcm9wc09ic2VydmVyQ2FuY2VsICYmIHRoaXMucHJvcHNPYnNlcnZlckNhbmNlbCgpO1xuICAgIHRoaXMucHJvcHNPYnNlcnZlckNhbmNlbCA9IHZvaWQgMDtcbiAgICB0aGlzLnNpemVPYnNlcnZlckNhbmNlbCAmJiB0aGlzLnNpemVPYnNlcnZlckNhbmNlbCgpO1xuICAgIHRoaXMuc2l6ZU9ic2VydmVyQ2FuY2VsID0gdm9pZCAwO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoc2FmZVdpbmRvd1tcInBlcmZcIl0pXG4gICAgICBzYWZlV2luZG93W1wicGVyZlwiXS5ub2RlUmVuZGVyKCk7XG4gICAgY29uc3QgeyB2aXNpYmxlLCBpZCwgY2xhc3NOYW1lIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5nZXRTdHlsZSgpO1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLnJlY3Q7XG4gICAgY29uc3QgcGFyZW50U2l6ZSA9IHsgd2lkdGg6IHJlY3Qud2lkdGgsIGhlaWdodDogcmVjdC5oZWlnaHQgfTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQyMChcImRpdlwiLCB7XG4gICAgICBpZCxcbiAgICAgIHN0eWxlLFxuICAgICAgcmVmOiB0aGlzLnNldEVsZW1lbnQsXG4gICAgICBjbGFzc05hbWVcbiAgICB9LCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDIwKFByb3ZpZGVQYXJlbnRTaXplLCB7XG4gICAgICBwYXJlbnRTaXplXG4gICAgfSwgdGhpcy5sYXlvdXRDaGlsZHJlbigpKSwgLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQyMChCb3JkZXIsIHtcbiAgICAgIC4uLnRoaXMucHJvcHNcbiAgICB9KSk7XG4gIH1cbiAgbGF5b3V0Q2hpbGRyZW4oKSB7XG4gICAgbGV0IF9mb3J3YXJkZWRPdmVycmlkZXMgPSB0aGlzLnByb3BzLl9mb3J3YXJkZWRPdmVycmlkZXM7XG4gICAgY29uc3QgZXh0cmFjdGlvbnMgPSB0aGlzLnByb3BzLl9vdmVycmlkZUZvcndhcmRpbmdEZXNjcmlwdGlvbjtcbiAgICBpZiAoZXh0cmFjdGlvbnMpIHtcbiAgICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgICAgX2ZvcndhcmRlZE92ZXJyaWRlcyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBrZXk2IGluIGV4dHJhY3Rpb25zKSB7XG4gICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgICAgX2ZvcndhcmRlZE92ZXJyaWRlc1trZXk2XSA9IHRoaXMucHJvcHNbZXh0cmFjdGlvbnNba2V5Nl1dO1xuICAgICAgfVxuICAgICAgaWYgKCFhZGRlZCkge1xuICAgICAgICBfZm9yd2FyZGVkT3ZlcnJpZGVzID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgY2hpbGRyZW4gPSBDaGlsZHJlbjQubWFwKHRoaXMucHJvcHMuY2hpbGRyZW4sIChjaGlsZCkgPT4ge1xuICAgICAgaWYgKGlzQ29uc3RyYWludFN1cHBvcnRpbmdDaGlsZChjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lRWxlbWVudDMoY2hpbGQsIHtcbiAgICAgICAgICBwYXJlbnRTaXplOiB0aGlzLnN0YXRlLnNpemUsXG4gICAgICAgICAgX2ZvcndhcmRlZE92ZXJyaWRlc1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoX2ZvcndhcmRlZE92ZXJyaWRlcyAmJiBjaGlsZCkge1xuICAgICAgICByZXR1cm4gY2xvbmVFbGVtZW50MyhjaGlsZCwgeyBfZm9yd2FyZGVkT3ZlcnJpZGVzIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGNoaWxkcmVuWzBdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjaGlsZHJlbiA9IFsvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDIwKENlbnRlciwge1xuICAgICAgICBrZXk6IFwiMFwiXG4gICAgICB9LCBjaGlsZHJlbildO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbn07XG52YXIgRGVwcmVjYXRlZEZyYW1lID0gX0RlcHJlY2F0ZWRGcmFtZTtcbkRlcHJlY2F0ZWRGcmFtZS5zdXBwb3J0c0NvbnN0cmFpbnRzID0gdHJ1ZTtcbkRlcHJlY2F0ZWRGcmFtZS5kZWZhdWx0RnJhbWVTcGVjaWZpY1Byb3BzID0ge1xuICAuLi5jb25zdHJhaW50RGVmYXVsdHMsXG4gIC4uLnRyYW5zZm9ybURlZmF1bHRzLFxuICBvcGFjaXR5OiAxLFxuICBiYWNrZ3JvdW5kOiBDb2xvcihcInJnYmEoMCwgMTcwLCAyNTUsIDAuMylcIiksXG4gIHZpc2libGU6IHRydWUsXG4gIGJvcmRlcldpZHRoOiAwLFxuICBib3JkZXJDb2xvcjogXCIjMjIyXCIsXG4gIGJvcmRlclN0eWxlOiBcInNvbGlkXCJcbn07XG5EZXByZWNhdGVkRnJhbWUuZGVmYXVsdFByb3BzID0ge1xuICAuLi5MYXllci5kZWZhdWx0UHJvcHMsXG4gIC4uLl9EZXByZWNhdGVkRnJhbWUuZGVmYXVsdEZyYW1lU3BlY2lmaWNQcm9wc1xufTtcbkRlcHJlY2F0ZWRGcmFtZS5jb250ZXh0VHlwZSA9IENvbnN0cmFpbnRzQ29udGV4dDtcbnZhciBDZW50ZXIgPSAocHJvcHMpID0+IHtcbiAgY29uc3Qgc3R5bGUgPSBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxuICAgIGZvbnRGYW1pbHk6IFwiSGVsdmV0aWNhXCJcbiAgfSwgcHJvcHMuc3R5bGUgfHwge30pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQyMChcImRpdlwiLCB7XG4gICAgc3R5bGVcbiAgfSwgcHJvcHMuY2hpbGRyZW4pO1xufTtcblxuLy8gc3JjL3JlbmRlci9wcmVzZW50YXRpb24vRnJhbWUvaXNEZXByZWNhdGVkRnJhbWVQcm9wcy50c1xudmFyIGZyYW1lV2l0aE1vdGlvblByb3BzRmllbGRzID0gW1xuICBcIl9ib3JkZXJcIixcbiAgXCJfY29uc3RyYWludHNcIixcbiAgXCJhbmltYXRlXCIsXG4gIFwiaW5pdGlhbFwiLFxuICBcInZhcmlhbnRzXCIsXG4gIFwidHJhbnNpdGlvblwiLFxuICBcImluaGVyaXRcIixcbiAgXCJjZW50ZXJcIixcbiAgXCJpbml0aWFsXCIsXG4gIFwidHJhbnNmb3JtVGVtcGxhdGVcIixcbiAgXCJ0cmFuc2Zvcm1WYWx1ZXNcIixcbiAgXCJhbmltYXRlXCIsXG4gIFwidmFyaWFudHNcIixcbiAgXCJ0cmFuc2l0aW9uXCIsXG4gIFwib25VcGRhdGVcIixcbiAgXCJvbkFuaW1hdGlvbkNvbXBsZXRlXCIsXG4gIFwib25QYW5TZXNzaW9uU3RhcnRcIixcbiAgXCJvblRhcENhbmNlbFwiLFxuICBcIndoaWxlVGFwXCIsXG4gIFwid2hpbGVIb3ZlclwiLFxuICBcIm9uSG92ZXJTdGFydFwiLFxuICBcIm9uSG92ZXJFbmRcIixcbiAgXCJkcmFnXCIsXG4gIFwiZHJhZ0RpcmVjdGlvbkxvY2tcIixcbiAgXCJkcmFnUHJvcGFnYXRpb25cIixcbiAgXCJkcmFnQ29uc3RyYWludHNcIixcbiAgXCJkcmFnRWxhc3RpY1wiLFxuICBcImRyYWdNb21lbnR1bVwiLFxuICBcImRyYWdUcmFuc2l0aW9uXCIsXG4gIFwib25EcmFnU3RhcnRcIixcbiAgXCJvbkRyYWdFbmRcIixcbiAgXCJvbkRyYWdcIixcbiAgXCJvbkRpcmVjdGlvbkxvY2tcIixcbiAgXCJvbkRyYWdUcmFuc2l0aW9uRW5kXCIsXG4gIFwieFwiLFxuICBcInlcIixcbiAgXCJyb3RhdGVcIixcbiAgXCJyb3RhdGVYXCIsXG4gIFwicm90YXRlWVwiLFxuICBcInJvdGF0ZVpcIixcbiAgXCJwb3NpdGlvblwiLFxuICBcImJvcmRlclwiLFxuICBcImJvcmRlclJhZGl1c1wiLFxuICBcInNoYWRvd1wiLFxuICBcInNpemVcIlxuXTtcbnZhciBkZXByZWNhdGVkRnJhbWVQcm9wc0ZpZWxkcyA9IFtcbiAgXCJhdXRvU2l6ZVwiLFxuICBcImFzcGVjdFJhdGlvXCIsXG4gIFwiYm9yZGVyV2lkdGhcIixcbiAgXCJib3JkZXJTdHlsZVwiLFxuICBcImJvcmRlckNvbG9yXCIsXG4gIFwiY2VudGVyWFwiLFxuICBcImNlbnRlcllcIlxuXTtcbmZ1bmN0aW9uIGlzRGVwcmVjYXRlZEZyYW1lUHJvcHMocHJvcHMpIHtcbiAgbGV0IGZpZWxkO1xuICBmb3IgKGNvbnN0IHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaXNBbmltYXRhYmxlMihwcm9wc1twcm9wS2V5XSkpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb3IgKGZpZWxkIG9mIGZyYW1lV2l0aE1vdGlvblByb3BzRmllbGRzKSB7XG4gICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KGZpZWxkKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGZpZWxkIG9mIGRlcHJlY2F0ZWRGcmFtZVByb3BzRmllbGRzKSB7XG4gICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KGZpZWxkKSlcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gc3JjL3JlbmRlci9wcmVzZW50YXRpb24vRnJhbWUvaW5kZXgudHN4XG52YXIgRGVwcmVjYXRlZEZyYW1lV2l0aEV2ZW50cyA9IFdpdGhFdmVudHMoRGVwcmVjYXRlZEZyYW1lKTtcbnZhciBGcmFtZSA9IGZvcndhcmRSZWYzKGZ1bmN0aW9uIEZyYW1lMihwcm9wcywgcmVmKSB7XG4gIGNvbnN0IHBhcmVudFNpemUgPSB1c2VQYXJlbnRTaXplKCk7XG4gIGlmIChpc0RlcHJlY2F0ZWRGcmFtZVByb3BzKHByb3BzKSkge1xuICAgIGNvbnN0IGN1cnJlbnRQYXJlbnRTaXplID0gcHJvcHMucGFyZW50U2l6ZSB8fCBkZXByZWNhdGVkUGFyZW50U2l6ZShwYXJlbnRTaXplKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQyMShEZXByZWNhdGVkRnJhbWVXaXRoRXZlbnRzLCB7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIHBhcmVudFNpemU6IGN1cnJlbnRQYXJlbnRTaXplXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MjEoRnJhbWVXaXRoTW90aW9uLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgcmVmXG4gIH0pO1xufSk7XG5cbi8vIHNyYy9jb21wb25lbnRzL0VtcHR5U3RhdGUudHN4XG5mdW5jdGlvbiBFbXB0eVN0YXRlKHtcbiAgdGl0bGUgPSBcIlwiLFxuICBkZXNjcmlwdGlvbiA9IFwiQ2xpY2sgYW5kIGRyYWcgdGhlIGNvbm5lY3RvciB0byBhbnkgZnJhbWUgb24gdGhlIGNhbnZhcyBcXHUyMTkyXCIsXG4gIGNoaWxkcmVuLFxuICBzaXplOiBzaXplMixcbiAgaGlkZSxcbiAgaW5zaWRlVXNlckNvZGVDb21wb25lbnQgPSBmYWxzZVxufSkge1xuICBjb25zdCB7IHRhcmdldCB9ID0gUmVuZGVyRW52aXJvbm1lbnQ7XG4gIGNvbnN0IGNoaWxkQ291bnQgPSBDaGlsZHJlbjUuY291bnQoY2hpbGRyZW4pO1xuICBpZiAoaW5zaWRlVXNlckNvZGVDb21wb25lbnQgJiYgY2hpbGRDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDIyKEZyYW1lV2l0aE1vdGlvbiwge1xuICAgICAgLi4uc2l6ZTIsXG4gICAgICBcImRhdGEtbmFtZVwiOiBcInBsYWNlaG9sZGVyXCJcbiAgICB9KTtcbiAgfVxuICBpZiAodGFyZ2V0ICE9PSBSZW5kZXJUYXJnZXQuY2FudmFzKVxuICAgIHJldHVybiBudWxsO1xuICBpZiAoaGlkZSlcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKGNoaWxkQ291bnQgIT09IDApXG4gICAgcmV0dXJuIG51bGw7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDIyKEZyYW1lV2l0aE1vdGlvbiwge1xuICAgIGtleTogXCJlbXB0eS1zdGF0ZVwiLFxuICAgIGNsYXNzTmFtZTogXCJmcmFtZXJJbnRlcm5hbFVJLWNhbnZhc1BsYWNlaG9sZGVyXCIsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIHN0eWxlOiB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIgfVxuICB9LCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDIyKFwiZGl2XCIsIHtcbiAgICBzdHlsZToge1xuICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgICAgbGluZUhlaWdodDogXCIxLjRcIixcbiAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICB3aWR0aDogXCIxMDAlXCJcbiAgICB9XG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MjIoXCJkaXZcIiwge1xuICAgIHN0eWxlOiB7XG4gICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICBXZWJraXRNYXNrSW1hZ2U6IGBsaW5lYXItZ3JhZGllbnQoOTBkZWcsIGJsYWNrLCBibGFjayBjYWxjKDEwMCUgLSAxMnB4ICogJHtzY2FsZUZhY3Rvcn0pLCB0cmFuc3BhcmVudClgXG4gICAgfVxuICB9LCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDIyKFRpdGxlLCBudWxsLCB0aXRsZSksIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MjIoRGVzY3JpcHRpb24sIG51bGwsIGRlc2NyaXB0aW9uKSkpKTtcbn1cbnZhciBzY2FsZUZhY3RvciA9IFwidmFyKC0tZnJhbWVySW50ZXJuYWxDYW52YXMtY2FudmFzUGxhY2Vob2xkZXJDb250ZW50U2NhbGVGYWN0b3IsIDEpXCI7XG52YXIgVGl0bGUgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDIyKFwic3BhblwiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgIGZsZXhHcm93OiAxLFxuICAgICAgZmxleFNocmluazogMCxcbiAgICAgIGZvbnRXZWlnaHQ6IDYwMCxcbiAgICAgIG1hcmdpbkJvdHRvbTogXCI1cHhcIlxuICAgIH1cbiAgfSwgY2hpbGRyZW4pO1xufTtcbnZhciBEZXNjcmlwdGlvbiA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MjIoXCJzcGFuXCIsIHtcbiAgICBzdHlsZToge1xuICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgICAgZmxleEdyb3c6IDEsXG4gICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgZm9udFdlaWdodDogNDAwLFxuICAgICAgbWF4V2lkdGg6IFwiMjAwcHhcIlxuICAgIH1cbiAgfSwgY2hpbGRyZW4pO1xufTtcblxuLy8gc3JjL2NvbXBvbmVudHMvU2Nyb2xsL3VzZVdoZWVsU2Nyb2xsLnRzXG5pbXBvcnQgeyB1c2VSZWYgYXMgdXNlUmVmMTUsIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrNSB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvcmVuZGVyL3V0aWxzL2RlYm91bmNlLnRzXG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgdGltZTMpIHtcbiAgbGV0IHRpbWVvdXQ7XG4gIGNvbnN0IGRlYm91bmNlZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgc2FmZVdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNhZmVXaW5kb3cuc2V0VGltZW91dChmbiwgdGltZTMsIC4uLmFyZ3MpO1xuICB9O1xuICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgc2FmZVdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gIH07XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL1Njcm9sbC91c2VXaGVlbFNjcm9sbC50c1xuZnVuY3Rpb24gdXNlV2hlZWxTY3JvbGwocmVmLCB7XG4gIGVuYWJsZWQsXG4gIGluaXRpYWwsXG4gIHByZXYsXG4gIGRpcmVjdGlvbixcbiAgY29uc3RyYWludHMsXG4gIG9mZnNldFgsXG4gIG9mZnNldFksXG4gIG9uU2Nyb2xsU3RhcnQsXG4gIG9uU2Nyb2xsLFxuICBvblNjcm9sbEVuZFxufSkge1xuICBjb25zdCBpc1doZWVsU2Nyb2xsQWN0aXZlID0gdXNlUmVmMTUoZmFsc2UpO1xuICBjb25zdCBnZXRQb2ludERhdGEgPSB1c2VDYWxsYmFjazUoKCkgPT4ge1xuICAgIGNvbnN0IHBvaW50ID0gZ2V0UG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIHBvaW50LFxuICAgICAgdmVsb2NpdHk6IHsgeDogb2Zmc2V0WC5nZXRWZWxvY2l0eSgpLCB5OiBvZmZzZXRZLmdldFZlbG9jaXR5KCkgfSxcbiAgICAgIG9mZnNldDogeyB4OiBwb2ludC54IC0gaW5pdGlhbC54LCB5OiBwb2ludC55IC0gaW5pdGlhbC55IH0sXG4gICAgICBkZWx0YTogeyB4OiBwb2ludC54IC0gcHJldi54LCB5OiBwb2ludC55IC0gcHJldi55IH1cbiAgICB9O1xuICAgIHByZXYueCA9IHBvaW50Lng7XG4gICAgcHJldi55ID0gcG9pbnQueTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfSwgW10pO1xuICBsZXQgaGFuZGxlcjtcbiAgaWYgKGVuYWJsZWQpIHtcbiAgICBsZXQgY2xhbXBYID0gZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzLmN1cnJlbnQgPT09IG51bGwgPyB2IDogY2xhbXAzKHYsIGNvbnN0cmFpbnRzLmN1cnJlbnQubGVmdCwgY29uc3RyYWludHMuY3VycmVudC5yaWdodCk7XG4gICAgfSwgY2xhbXBZID0gZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzLmN1cnJlbnQgPT09IG51bGwgPyB2IDogY2xhbXAzKHYsIGNvbnN0cmFpbnRzLmN1cnJlbnQudG9wLCBjb25zdHJhaW50cy5jdXJyZW50LmJvdHRvbSk7XG4gICAgfSwgdXBkYXRlWCA9IGZ1bmN0aW9uKGRlbHRhMikge1xuICAgICAgb2Zmc2V0WC5zdG9wKCk7XG4gICAgICBvZmZzZXRYLnNldChjbGFtcFgob2Zmc2V0WC5nZXQoKSAtIGRlbHRhMikpO1xuICAgIH0sIHVwZGF0ZVkgPSBmdW5jdGlvbihkZWx0YTIpIHtcbiAgICAgIG9mZnNldFkuc3RvcCgpO1xuICAgICAgb2Zmc2V0WS5zZXQoY2xhbXBZKG9mZnNldFkuZ2V0KCkgLSBkZWx0YTIpKTtcbiAgICB9O1xuICAgIGNvbnN0IGRlYm91bmNlZE9uU2Nyb2xsRW5kID0gZGVib3VuY2UoKCkgPT4ge1xuICAgICAgb25TY3JvbGxFbmQgJiYgb25TY3JvbGxFbmQoZ2V0UG9pbnREYXRhKCkpO1xuICAgICAgaXNXaGVlbFNjcm9sbEFjdGl2ZS5jdXJyZW50ID0gZmFsc2U7XG4gICAgfSwgMjAwKTtcbiAgICBoYW5kbGVyID0gKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmICghaXNXaGVlbFNjcm9sbEFjdGl2ZS5jdXJyZW50KSB7XG4gICAgICAgIGNvbnN0IHggPSBvZmZzZXRYLmdldCgpO1xuICAgICAgICBjb25zdCB5ID0gb2Zmc2V0WS5nZXQoKTtcbiAgICAgICAgaW5pdGlhbC54ID0geDtcbiAgICAgICAgaW5pdGlhbC55ID0geTtcbiAgICAgICAgcHJldi54ID0geDtcbiAgICAgICAgcHJldi55ID0geTtcbiAgICAgICAgb25TY3JvbGxTdGFydCAmJiBvblNjcm9sbFN0YXJ0KGdldFBvaW50RGF0YSgpKTtcbiAgICAgICAgaXNXaGVlbFNjcm9sbEFjdGl2ZS5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJob3Jpem9udGFsXCI6XG4gICAgICAgICAgdXBkYXRlWChlLmRlbHRhWCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxuICAgICAgICAgIHVwZGF0ZVkoZS5kZWx0YVkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHVwZGF0ZVgoZS5kZWx0YVgpO1xuICAgICAgICAgIHVwZGF0ZVkoZS5kZWx0YVkpO1xuICAgICAgfVxuICAgICAgb25TY3JvbGwgJiYgb25TY3JvbGwoZ2V0UG9pbnREYXRhKCkpO1xuICAgICAgZGVib3VuY2VkT25TY3JvbGxFbmQoKTtcbiAgICB9O1xuICB9XG4gIHVzZURvbUV2ZW50KHJlZiwgXCJ3aGVlbFwiLCBoYW5kbGVyLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xufVxuZnVuY3Rpb24gZ2V0UG9pbnQoeCwgeSkge1xuICByZXR1cm4geyB4OiB4LmdldCgpLCB5OiB5LmdldCgpIH07XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL1Njcm9sbC9FbXVsYXRlZFNjcm9sbC50c3hcbnZhciBkaXJlY3Rpb25NYXAgPSB7XG4gIGhvcml6b250YWw6IFwieFwiLFxuICB2ZXJ0aWNhbDogXCJ5XCIsXG4gIGJvdGg6IHRydWVcbn07XG5mdW5jdGlvbiBjb252ZXJ0U2Nyb2xsRGlyZWN0aW9uVG9EcmFnKHNjcm9sbERpcmVjdGlvbikge1xuICByZXR1cm4gc2Nyb2xsRGlyZWN0aW9uID8gZGlyZWN0aW9uTWFwW3Njcm9sbERpcmVjdGlvbl0gOiBzY3JvbGxEaXJlY3Rpb247XG59XG52YXIgdXNlVXBkYXRlQ2hpbGRTaXplID0gKHtcbiAgZHJhZ0RpcmVjdGlvbixcbiAgY2hpbGRyZW4sXG4gIGZyb21DYW52YXNDb21wb25lbnRcbn0pID0+IHtcbiAgcmV0dXJuIHVzZU1lbW8xMCgoKSA9PiB7XG4gICAgcmV0dXJuIENoaWxkcmVuNi5tYXAoY2hpbGRyZW4sIChjaGlsZCkgPT4ge1xuICAgICAgaWYgKGNoaWxkID09PSBudWxsIHx8IHR5cGVvZiBjaGlsZCAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2hpbGQudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG4gICAgICBjb25zdCB1cGRhdGVkU2l6ZSA9IHt9O1xuICAgICAgc3dpdGNoIChkcmFnRGlyZWN0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxuICAgICAgICAgIHVwZGF0ZWRTaXplLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJob3Jpem9udGFsXCI6XG4gICAgICAgICAgdXBkYXRlZFNpemUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuICAgICAgY29uc3QgdXBkYXRlID0gZnJvbUNhbnZhc0NvbXBvbmVudCA/IHsgc3R5bGU6IE9iamVjdC5hc3NpZ24oe30sIGNoaWxkLnByb3BzLnN0eWxlLCB1cGRhdGVkU2l6ZSkgfSA6IHVwZGF0ZWRTaXplO1xuICAgICAgcmV0dXJuIGNsb25lRWxlbWVudDQoY2hpbGQsIHVwZGF0ZSk7XG4gICAgfSk7XG4gIH0sIFtkcmFnRGlyZWN0aW9uLCBjaGlsZHJlbl0pO1xufTtcbnZhciBudW1iZXJGcm9tT3B0aW9uYWxNb3Rpb25WYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiID8gdmFsdWUgOiB2YWx1ZS5nZXQoKTtcbn07XG52YXIgRW11bGF0ZWRTY3JvbGwgPSBmb3J3YXJkUmVmNChmdW5jdGlvbiBFbXVsYXRlZFNjcm9sbDIocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICBjb25zdCB7XG4gICAgZGlyZWN0aW9uID0gXCJ2ZXJ0aWNhbFwiLFxuICAgIGRpcmVjdGlvbkxvY2sgPSBmYWxzZSxcbiAgICBkcmFnRW5hYmxlZCA9IHRydWUsXG4gICAgZHJhZ0VsYXN0aWMsXG4gICAgZHJhZ01vbWVudHVtLFxuICAgIGRyYWdUcmFuc2l0aW9uLFxuICAgIHdoZWVsRW5hYmxlZCA9IHRydWUsXG4gICAgY29udGVudE9mZnNldFggPSAwLFxuICAgIGNvbnRlbnRPZmZzZXRZID0gMCxcbiAgICBjb250ZW50V2lkdGgsXG4gICAgY29udGVudEhlaWdodCxcbiAgICBvblNjcm9sbFN0YXJ0LFxuICAgIG9uU2Nyb2xsLFxuICAgIG9uU2Nyb2xsRW5kLFxuICAgIG9uRHJhZ1N0YXJ0LFxuICAgIG9uRHJhZyxcbiAgICBvbkRyYWdFbmQsXG4gICAgb25VcGRhdGUsXG4gICAgb25EaXJlY3Rpb25Mb2NrLFxuICAgIHN0eWxlLFxuICAgIGNoaWxkcmVuLFxuICAgIHNjcm9sbEFuaW1hdGUsXG4gICAgcmVzZXRPZmZzZXQsXG4gICAgb3ZlcmRyYWdFbmFibGVkID0gdHJ1ZSxcbiAgICBsYXlvdXRJZDogc3BlY2lmaWNMYXlvdXRJZCxcbiAgICBuYXRpdmUsXG4gICAgLi4uY29udGFpbmVyUHJvcHNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBsYXlvdXRJZCA9IHVzZUxheW91dElkMihwcm9wcywgeyBzcGVjaWZpY0xheW91dElkLCBwb3N0Zml4OiBcInNjcm9sbFwiIH0pO1xuICBjb25zdCBkZWZhdWx0WCA9IHVzZU1vdGlvblZhbHVlKHR5cGVvZiBjb250ZW50T2Zmc2V0WCA9PT0gXCJudW1iZXJcIiA/IGNvbnRlbnRPZmZzZXRYIDogMCk7XG4gIGNvbnN0IGRlZmF1bHRZID0gdXNlTW90aW9uVmFsdWUodHlwZW9mIGNvbnRlbnRPZmZzZXRZID09PSBcIm51bWJlclwiID8gY29udGVudE9mZnNldFkgOiAwKTtcbiAgY29uc3QgeCA9IGlzTW90aW9uVmFsdWUyKGNvbnRlbnRPZmZzZXRYKSA/IGNvbnRlbnRPZmZzZXRYIDogZGVmYXVsdFg7XG4gIGNvbnN0IHkgPSBpc01vdGlvblZhbHVlMihjb250ZW50T2Zmc2V0WSkgPyBjb250ZW50T2Zmc2V0WSA6IGRlZmF1bHRZO1xuICBjb25zdCBtZWFzdXJlZENvbnN0cmFpbnRzID0gdXNlUmVmMTYobnVsbCk7XG4gIGNvbnN0IGRyYWdDb250cm9scyA9IHVzZURyYWdDb250cm9scygpO1xuICBjb25zdCBpc0luVGFyZ2V0ID0gdXNlSXNJbkN1cnJlbnROYXZpZ2F0aW9uVGFyZ2V0KCk7XG4gIGNvbnN0IHdhc0luVGFyZ2V0UmVmID0gdXNlUmVmMTYodHJ1ZSk7XG4gIGluamVjdENvbXBvbmVudENTU1J1bGVzKCk7XG4gIHVzZUVmZmVjdDE3KCgpID0+IHtcbiAgICBkcmFnQ29udHJvbHMudXBkYXRlQ29uc3RyYWludHMoKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIHNldE1lYXN1cmVEcmFnQ29uc3RyYWludHMoY29uc3RyYWludHMpIHtcbiAgICBjb25zdHJhaW50cyA9IG9mZnNldFRvWmVybyhjb25zdHJhaW50cyk7XG4gICAgaWYgKGNvbnRlbnRXaWR0aCAhPT0gdm9pZCAwKVxuICAgICAgY29uc3RyYWludHMubGVmdCA9IC1jb250ZW50V2lkdGg7XG4gICAgaWYgKGNvbnRlbnRIZWlnaHQgIT09IHZvaWQgMClcbiAgICAgIGNvbnN0cmFpbnRzLnRvcCA9IC1jb250ZW50SGVpZ2h0O1xuICAgIHJldHVybiBtZWFzdXJlZENvbnN0cmFpbnRzLmN1cnJlbnQgPSBjb25zdHJhaW50cztcbiAgfVxuICBjb25zdCB7IGluaXRpYWwsIHByZXYgfSA9IHVzZVJlZjE2KHtcbiAgICBpbml0aWFsOiB7IHg6IDAsIHk6IDAgfSxcbiAgICBwcmV2OiB7IHg6IDAsIHk6IDAgfVxuICB9KS5jdXJyZW50O1xuICBjb25zdCBpc1ByZXZpZXcgPSBSZW5kZXJUYXJnZXQuY3VycmVudCgpID09PSBSZW5kZXJUYXJnZXQucHJldmlldztcbiAgY29uc3QgY29udGFpbmVyRmFsbGJhY2tSZWYgPSB1c2VSZWYxNihudWxsKTtcbiAgY29uc3QgY29udGFpbmVyUmVmID0gZm9yd2FyZGVkUmVmIHx8IGNvbnRhaW5lckZhbGxiYWNrUmVmO1xuICBjb25zdCBjb250ZW50UmVmID0gdXNlUmVmMTYobnVsbCk7XG4gIGNvbnN0IGxhc3RPZmZzZXRSZWYgPSB1c2VSZWYxNihudWxsKTtcbiAgZnVuY3Rpb24gc2hvdWxkUmVzZXRTY3JvbGwoaW5UYXJnZXQpIHtcbiAgICBjb25zdCBoYXNFbnRlcmVkVGFyZ2V0ID0gaW5UYXJnZXQgJiYgd2FzSW5UYXJnZXRSZWYuY3VycmVudCA9PT0gZmFsc2U7XG4gICAgcmV0dXJuIHJlc2V0T2Zmc2V0ICYmIGhhc0VudGVyZWRUYXJnZXQ7XG4gIH1cbiAgZnVuY3Rpb24gbWVhc3VyZUFuZFVwZGF0ZVNjcm9sbE9mZnNldCgpIHtcbiAgICBpZiAoIWNvbnRlbnRSZWYuY3VycmVudCB8fCAhY29udGFpbmVyUmVmLmN1cnJlbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbXVzdFJlc2V0ID0gc2hvdWxkUmVzZXRTY3JvbGwoaXNJblRhcmdldCk7XG4gICAgd2FzSW5UYXJnZXRSZWYuY3VycmVudCA9IGlzSW5UYXJnZXQ7XG4gICAgY29uc3QgcHJldmlvdXMgPSBsYXN0T2Zmc2V0UmVmLmN1cnJlbnQ7XG4gICAgaWYgKHByZXZpb3VzID09PSBudWxsICYmIGNvbnRlbnRPZmZzZXRYID09PSB2b2lkIDAgJiYgY29udGVudE9mZnNldFkgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBzaG91bGRVcGRhdGVPZmZzZXQgPSBwcmV2aW91cyA9PT0gbnVsbCB8fCAhaXNNb3Rpb25WYWx1ZTIoY29udGVudE9mZnNldFgpICYmIGNvbnRlbnRPZmZzZXRYICE9PSBwcmV2aW91cy5vZmZzZXRYIHx8ICFpc01vdGlvblZhbHVlMihjb250ZW50T2Zmc2V0WSkgJiYgY29udGVudE9mZnNldFkgIT09IHByZXZpb3VzLm9mZnNldFk7XG4gICAgY29uc3QgY3VycmVudE1heFhPZmZzZXQgPSBjb250ZW50UmVmLmN1cnJlbnQub2Zmc2V0V2lkdGggLSBjb250YWluZXJSZWYuY3VycmVudC5vZmZzZXRXaWR0aDtcbiAgICBjb25zdCBjdXJyZW50TWF4WU9mZnNldCA9IGNvbnRlbnRSZWYuY3VycmVudC5vZmZzZXRIZWlnaHQgLSBjb250YWluZXJSZWYuY3VycmVudC5vZmZzZXRIZWlnaHQ7XG4gICAgY29uc3QgaGFzU2l6ZUNoYW5nZWQgPSBjdXJyZW50TWF4WE9mZnNldCAhPT0gKHByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91cy5tYXhYT2Zmc2V0KSB8fCBjdXJyZW50TWF4WU9mZnNldCAhPT0gKHByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91cy5tYXhZT2Zmc2V0KTtcbiAgICBjb25zdCBoYXNTY3JvbGxPZmZzZXRDaGFuZ2VkID0gKHByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91cy54KSAhPT0geC5nZXQoKSB8fCAocHJldmlvdXMgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZpb3VzLnkpICE9PSB5LmdldCgpO1xuICAgIGNvbnN0IHNob3VsZFN0YXlQaW5uZWQgPSBoYXNTaXplQ2hhbmdlZCAmJiAhaGFzU2Nyb2xsT2Zmc2V0Q2hhbmdlZDtcbiAgICBpZiAobXVzdFJlc2V0IHx8IHNob3VsZFVwZGF0ZU9mZnNldCB8fCBzaG91bGRTdGF5UGlubmVkKSB7XG4gICAgICBjb25zdCBjdXJyZW50T2Zmc2V0WCA9IGRpcmVjdGlvbiAhPT0gXCJ2ZXJ0aWNhbFwiID8gbnVtYmVyRnJvbU9wdGlvbmFsTW90aW9uVmFsdWUoY29udGVudE9mZnNldFgpIDogMDtcbiAgICAgIGNvbnN0IGN1cnJlbnRPZmZzZXRZID0gZGlyZWN0aW9uICE9PSBcImhvcml6b250YWxcIiA/IG51bWJlckZyb21PcHRpb25hbE1vdGlvblZhbHVlKGNvbnRlbnRPZmZzZXRZKSA6IDA7XG4gICAgICBjb25zdCBuZXh0WE9mZnNldCA9IC1NYXRoLm1pbihjdXJyZW50T2Zmc2V0WCwgY3VycmVudE1heFhPZmZzZXQpO1xuICAgICAgY29uc3QgbmV4dFlPZmZzZXQgPSAtTWF0aC5taW4oY3VycmVudE9mZnNldFksIGN1cnJlbnRNYXhZT2Zmc2V0KTtcbiAgICAgIHguc2V0KG5leHRYT2Zmc2V0KTtcbiAgICAgIHkuc2V0KG5leHRZT2Zmc2V0KTtcbiAgICAgIGxhc3RPZmZzZXRSZWYuY3VycmVudCA9IHtcbiAgICAgICAgbWF4WE9mZnNldDogY3VycmVudE1heFhPZmZzZXQsXG4gICAgICAgIG1heFlPZmZzZXQ6IGN1cnJlbnRNYXhZT2Zmc2V0LFxuICAgICAgICBvZmZzZXRYOiBjdXJyZW50T2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WTogY3VycmVudE9mZnNldFksXG4gICAgICAgIHg6IG5leHRYT2Zmc2V0LFxuICAgICAgICB5OiBuZXh0WU9mZnNldFxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgdXNlTGF5b3V0RWZmZWN0NSgoKSA9PiB7XG4gICAgaWYgKFJlbmRlclRhcmdldC5jdXJyZW50KCkgIT09IFJlbmRlclRhcmdldC5jYW52YXMpXG4gICAgICByZXR1cm47XG4gICAgbWVhc3VyZUFuZFVwZGF0ZVNjcm9sbE9mZnNldCgpO1xuICB9KTtcbiAgdXNlTGF5b3V0RWZmZWN0NSgoKSA9PiB7XG4gICAgaWYgKFJlbmRlclRhcmdldC5jdXJyZW50KCkgPT09IFJlbmRlclRhcmdldC5jYW52YXMpXG4gICAgICByZXR1cm47XG4gICAgbWVhc3VyZUFuZFVwZGF0ZVNjcm9sbE9mZnNldCgpO1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdDE3KCgpID0+IHtcbiAgICBpZiAoc2hvdWxkUmVzZXRTY3JvbGwoaXNJblRhcmdldCkpXG4gICAgICBtZWFzdXJlQW5kVXBkYXRlU2Nyb2xsT2Zmc2V0KCk7XG4gICAgaWYgKGlzSW5UYXJnZXQgPT09IGZhbHNlKVxuICAgICAgd2FzSW5UYXJnZXRSZWYuY3VycmVudCA9IGZhbHNlO1xuICB9LCBbaXNJblRhcmdldF0pO1xuICBjb25zdCBnZXRMYXRlc3RQb2ludCA9ICgpID0+ICh7IHg6IHguZ2V0KCksIHk6IHkuZ2V0KCkgfSk7XG4gIGNvbnN0IHJlc2V0SW5pdGlhbFBvaW50ID0gdXNlQ2FsbGJhY2s3KCgpID0+IHtcbiAgICBjb25zdCBwb2ludCA9IGdldExhdGVzdFBvaW50KCk7XG4gICAgaW5pdGlhbC54ID0gcG9pbnQueDtcbiAgICBpbml0aWFsLnkgPSBwb2ludC55O1xuICAgIHByZXYueCA9IHBvaW50Lng7XG4gICAgcHJldi55ID0gcG9pbnQueTtcbiAgfSwgW10pO1xuICBjb25zdCBnZXRQb2ludERhdGEgPSB1c2VDYWxsYmFjazcoKCkgPT4ge1xuICAgIGNvbnN0IHBvaW50ID0gZ2V0TGF0ZXN0UG9pbnQoKTtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgcG9pbnQsXG4gICAgICB2ZWxvY2l0eTogeyB4OiB4LmdldFZlbG9jaXR5KCksIHk6IHkuZ2V0VmVsb2NpdHkoKSB9LFxuICAgICAgb2Zmc2V0OiB7IHg6IHBvaW50LnggLSBpbml0aWFsLngsIHk6IHBvaW50LnkgLSBpbml0aWFsLnkgfSxcbiAgICAgIGRlbHRhOiB7IHg6IHBvaW50LnggLSBwcmV2LngsIHk6IHBvaW50LnkgLSBwcmV2LnkgfVxuICAgIH07XG4gICAgcHJldi54ID0gcG9pbnQueDtcbiAgICBwcmV2LnkgPSBwb2ludC55O1xuICAgIHJldHVybiBkYXRhO1xuICB9LCBbeCwgeV0pO1xuICBjb25zdCB1cGRhdGVTY3JvbGxMaXN0ZW5lcnMgPSB1c2VDYWxsYmFjazcoKCkgPT4ge1xuICAgIG9uVXBkYXRlICYmIG9uVXBkYXRlKHsgeDogeC5nZXQoKSwgeTogeS5nZXQoKSB9KTtcbiAgICBvblNjcm9sbCAmJiBvblNjcm9sbChnZXRQb2ludERhdGEoKSk7XG4gIH0sIFtvblNjcm9sbCwgb25VcGRhdGUsIGdldFBvaW50RGF0YSwgeCwgeV0pO1xuICBjb25zdCBzY2hlZHVsZVVwZGF0ZVNjcm9sbExpc3RlbmVycyA9IHVzZUNhbGxiYWNrNygoKSA9PiB7XG4gICAgZXNfZGVmYXVsdC51cGRhdGUodXBkYXRlU2Nyb2xsTGlzdGVuZXJzLCBmYWxzZSwgdHJ1ZSk7XG4gIH0sIFt1cGRhdGVTY3JvbGxMaXN0ZW5lcnNdKTtcbiAgY29uc3Qgb25Nb3Rpb25EcmFnU3RhcnQgPSAoZXZlbnQsIGluZm8pID0+IHtcbiAgICByZXNldEluaXRpYWxQb2ludCgpO1xuICAgIG9uRHJhZ1N0YXJ0ICYmIG9uRHJhZ1N0YXJ0KGV2ZW50LCBpbmZvKTtcbiAgICBvblNjcm9sbFN0YXJ0ICYmIG9uU2Nyb2xsU3RhcnQoaW5mbyk7XG4gIH07XG4gIGNvbnN0IG9uTW90aW9uRHJhZ1RyYW5zaXRpb25FbmQgPSAoKSA9PiBvblNjcm9sbEVuZCAmJiBvblNjcm9sbEVuZChnZXRQb2ludERhdGEoKSk7XG4gIGNvbnN0IG9uV2hlZWxTY3JvbGxTdGFydCA9IChpbmZvKSA9PiB7XG4gICAgZHJhZ0NvbnRyb2xzLnVwZGF0ZUNvbnN0cmFpbnRzKCk7XG4gICAgb25TY3JvbGxTdGFydCA9PSBudWxsID8gdm9pZCAwIDogb25TY3JvbGxTdGFydChpbmZvKTtcbiAgfTtcbiAgdXNlV2hlZWxTY3JvbGwoY29udGFpbmVyUmVmLCB7XG4gICAgZW5hYmxlZDogd2hlZWxFbmFibGVkLFxuICAgIGluaXRpYWwsXG4gICAgcHJldixcbiAgICBkaXJlY3Rpb24sXG4gICAgb2Zmc2V0WDogeCxcbiAgICBvZmZzZXRZOiB5LFxuICAgIG9uU2Nyb2xsU3RhcnQ6IG9uV2hlZWxTY3JvbGxTdGFydCxcbiAgICBvblNjcm9sbCxcbiAgICBvblNjcm9sbEVuZCxcbiAgICBjb25zdHJhaW50czogbWVhc3VyZWRDb25zdHJhaW50c1xuICB9KTtcbiAgY29uc3Qgb3ZlcmRyYWdYID0gdXNlTW90aW9uVmFsdWUoMCk7XG4gIGNvbnN0IG92ZXJkcmFnWSA9IHVzZU1vdGlvblZhbHVlKDApO1xuICB1c2VMYXlvdXRFZmZlY3Q1KCgpID0+IHtcbiAgICBjb25zdCBzZXRTY3JvbGxYID0gKHhWYWx1ZSkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxEaXZFbGVtZW50KSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZWxlbWVudC5zY3JvbGxMZWZ0ID0gLXhWYWx1ZTtcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gbWVhc3VyZWRDb25zdHJhaW50cy5jdXJyZW50O1xuICAgICAgaWYgKGNvbnN0cmFpbnRzICYmIG92ZXJkcmFnRW5hYmxlZCkge1xuICAgICAgICBsZXQgb3ZlcmRyYWdYVmFsdWUgPSAwO1xuICAgICAgICBpZiAoeFZhbHVlID4gY29uc3RyYWludHMucmlnaHQpXG4gICAgICAgICAgb3ZlcmRyYWdYVmFsdWUgPSB4VmFsdWU7XG4gICAgICAgIGlmICh4VmFsdWUgPCBjb25zdHJhaW50cy5sZWZ0KVxuICAgICAgICAgIG92ZXJkcmFnWFZhbHVlID0geFZhbHVlIC0gY29uc3RyYWludHMubGVmdDtcbiAgICAgICAgb3ZlcmRyYWdYLnNldChvdmVyZHJhZ1hWYWx1ZSk7XG4gICAgICB9XG4gICAgICBzY2hlZHVsZVVwZGF0ZVNjcm9sbExpc3RlbmVycygpO1xuICAgIH07XG4gICAgY29uc3QgY3VycmVudFggPSB4LmdldCgpO1xuICAgIGlmIChjdXJyZW50WCAhPT0gMClcbiAgICAgIHNldFNjcm9sbFgoY3VycmVudFgpO1xuICAgIHJldHVybiB4Lm9uQ2hhbmdlKHNldFNjcm9sbFgpO1xuICB9LCBbeCwgb3ZlcmRyYWdYLCBzY2hlZHVsZVVwZGF0ZVNjcm9sbExpc3RlbmVycywgb3ZlcmRyYWdFbmFibGVkXSk7XG4gIHVzZUxheW91dEVmZmVjdDUoKCkgPT4ge1xuICAgIGNvbnN0IHNldFNjcm9sbFkgPSAoeVZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgSFRNTERpdkVsZW1lbnQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IC15VmFsdWU7XG4gICAgICBjb25zdCBjb25zdHJhaW50cyA9IG1lYXN1cmVkQ29uc3RyYWludHMuY3VycmVudDtcbiAgICAgIGlmIChjb25zdHJhaW50cyAmJiBvdmVyZHJhZ0VuYWJsZWQpIHtcbiAgICAgICAgbGV0IG92ZXJkcmFnWVZhbHVlID0gMDtcbiAgICAgICAgaWYgKHlWYWx1ZSA+IGNvbnN0cmFpbnRzLmJvdHRvbSlcbiAgICAgICAgICBvdmVyZHJhZ1lWYWx1ZSA9IHlWYWx1ZTtcbiAgICAgICAgaWYgKHlWYWx1ZSA8IGNvbnN0cmFpbnRzLnRvcClcbiAgICAgICAgICBvdmVyZHJhZ1lWYWx1ZSA9IHlWYWx1ZSAtIGNvbnN0cmFpbnRzLnRvcDtcbiAgICAgICAgb3ZlcmRyYWdZLnNldChvdmVyZHJhZ1lWYWx1ZSk7XG4gICAgICB9XG4gICAgICBzY2hlZHVsZVVwZGF0ZVNjcm9sbExpc3RlbmVycygpO1xuICAgIH07XG4gICAgY29uc3QgY3VycmVudFkgPSB5LmdldCgpO1xuICAgIGlmIChjdXJyZW50WSAhPT0gMClcbiAgICAgIHNldFNjcm9sbFkoY3VycmVudFkpO1xuICAgIHJldHVybiB5Lm9uQ2hhbmdlKHNldFNjcm9sbFkpO1xuICB9LCBbeSwgb3ZlcmRyYWdZLCBzY2hlZHVsZVVwZGF0ZVNjcm9sbExpc3RlbmVycywgb3ZlcmRyYWdFbmFibGVkXSk7XG4gIGNvbnN0IG5hdGl2ZU9uU2Nyb2xsID0gdXNlQ2FsbGJhY2s2KCgpID0+IHtcbiAgICBjb25zdCBlbGVtZW50ID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxEaXZFbGVtZW50KSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB4RGVsdGEgPSBNYXRoLmFicyh4LmdldCgpICsgZWxlbWVudC5zY3JvbGxMZWZ0KTtcbiAgICBjb25zdCB5RGVsdGEgPSBNYXRoLmFicyh5LmdldCgpICsgZWxlbWVudC5zY3JvbGxUb3ApO1xuICAgIGlmICh4RGVsdGEgPiAxKVxuICAgICAgeC5zZXQoLWVsZW1lbnQuc2Nyb2xsTGVmdCk7XG4gICAgaWYgKHlEZWx0YSA+IDEpXG4gICAgICB5LnNldCgtZWxlbWVudC5zY3JvbGxUb3ApO1xuICB9LCBbeCwgeV0pO1xuICBjb25zdCBpc0VtcHR5MiA9IENoaWxkcmVuNi5jb3VudChjaGlsZHJlbikgPT09IDA7XG4gIGNvbnN0IHdpZHRoID0gZGlyZWN0aW9uICE9PSBcInZlcnRpY2FsXCIgJiYgIWlzRW1wdHkyID8gXCJhdXRvXCIgOiBcIjEwMCVcIjtcbiAgY29uc3QgaGVpZ2h0ID0gZGlyZWN0aW9uICE9PSBcImhvcml6b250YWxcIiAmJiAhaXNFbXB0eTIgPyBcImF1dG9cIiA6IFwiMTAwJVwiO1xuICBjb25zdCBzaXplMiA9ICFjb250YWluZXJQcm9wcy5fX2Zyb21DYW52YXNDb21wb25lbnQgPyB7XG4gICAgd2lkdGg6IGNvbnRhaW5lclByb3BzLl9fZnJvbUNvZGVDb21wb25lbnROb2RlID8gXCIxMDAlXCIgOiBjb250YWluZXJQcm9wcy53aWR0aCxcbiAgICBoZWlnaHQ6IGNvbnRhaW5lclByb3BzLl9fZnJvbUNvZGVDb21wb25lbnROb2RlID8gXCIxMDAlXCIgOiBjb250YWluZXJQcm9wcy5oZWlnaHRcbiAgfSA6IHt9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQyMyhGcmFtZVdpdGhNb3Rpb24sIHtcbiAgICBcImRhdGEtZnJhbWVyLWNvbXBvbmVudC10eXBlXCI6IFwiU2Nyb2xsXCIsXG4gICAgYmFja2dyb3VuZDogXCJub25lXCIsXG4gICAgLi4uY29udGFpbmVyUHJvcHMsXG4gICAgLi4uc2l6ZTIsXG4gICAgc3R5bGU6IHtcbiAgICAgIC4uLnN0eWxlLFxuICAgICAgd2lsbENoYW5nZTogaXNQcmV2aWV3ID8gXCJ0cmFuc2Zvcm1cIiA6IHZvaWQgMCxcbiAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiXG4gICAgfSxcbiAgICBvblNjcm9sbDogbmF0aXZlT25TY3JvbGwsXG4gICAgcHJlc2VydmUzZDogY29udGFpbmVyUHJvcHMucHJlc2VydmUzZCxcbiAgICByZWY6IGNvbnRhaW5lclJlZixcbiAgICBsYXlvdXRJZCxcbiAgICBvbkJlZm9yZUxheW91dE1lYXN1cmU6IG1lYXN1cmVBbmRVcGRhdGVTY3JvbGxPZmZzZXRcbiAgfSwgLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQyMyhGcmFtZVdpdGhNb3Rpb24sIHtcbiAgICBcImRhdGEtZnJhbWVyLWNvbXBvbmVudC10eXBlXCI6IFwiU2Nyb2xsQ29udGVudFdyYXBwZXJcIixcbiAgICBhbmltYXRlOiBzY3JvbGxBbmltYXRlLFxuICAgIGRyYWc6IGRyYWdFbmFibGVkICYmIGNvbnZlcnRTY3JvbGxEaXJlY3Rpb25Ub0RyYWcoZGlyZWN0aW9uKSxcbiAgICBkcmFnRGlyZWN0aW9uTG9jazogZGlyZWN0aW9uTG9jayxcbiAgICBkcmFnRWxhc3RpYyxcbiAgICBkcmFnTW9tZW50dW0sXG4gICAgZHJhZ1RyYW5zaXRpb24sXG4gICAgZHJhZ0NvbnN0cmFpbnRzOiBjb250YWluZXJSZWYsXG4gICAgZHJhZ0NvbnRyb2xzLFxuICAgIG9uRHJhZ1N0YXJ0OiBvbk1vdGlvbkRyYWdTdGFydCxcbiAgICBvbkRyYWcsXG4gICAgb25EcmFnRW5kLFxuICAgIG9uRHJhZ1RyYW5zaXRpb25FbmQ6IG9uTW90aW9uRHJhZ1RyYW5zaXRpb25FbmQsXG4gICAgb25EaXJlY3Rpb25Mb2NrLFxuICAgIG9uTWVhc3VyZURyYWdDb25zdHJhaW50czogc2V0TWVhc3VyZURyYWdDb25zdHJhaW50cyxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgX2RyYWdYOiB4LFxuICAgIF9kcmFnWTogeSxcbiAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgIHg6IG92ZXJkcmFnRW5hYmxlZCA/IG92ZXJkcmFnWCA6IHZvaWQgMCxcbiAgICB5OiBvdmVyZHJhZ0VuYWJsZWQgPyBvdmVyZHJhZ1kgOiB2b2lkIDAsXG4gICAgcmVmOiBjb250ZW50UmVmLFxuICAgIHN0eWxlOiB7XG4gICAgICBkaXNwbGF5OiBpc0VtcHR5MiA/IFwiYmxvY2tcIiA6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICB3aWxsQ2hhbmdlOiBpc1ByZXZpZXcgPyBcInRyYW5zZm9ybVwiIDogdm9pZCAwLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICBvdmVyZmxvdzogXCJ2aXNpYmxlXCIsXG4gICAgICBtaW5XaWR0aDogXCIxMDAlXCIsXG4gICAgICBtaW5IZWlnaHQ6IFwiMTAwJVwiXG4gICAgfSxcbiAgICBwcmVzZXJ2ZTNkOiBjb250YWluZXJQcm9wcy5wcmVzZXJ2ZTNkXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MjMoRW1wdHlTdGF0ZSwge1xuICAgIGNoaWxkcmVuLFxuICAgIHNpemU6IHtcbiAgICAgIHdpZHRoOiBpc0Zpbml0ZU51bWJlcihjb250YWluZXJQcm9wcy53aWR0aCkgPyBjb250YWluZXJQcm9wcy53aWR0aCA6IFwiMTAwJVwiLFxuICAgICAgaGVpZ2h0OiBpc0Zpbml0ZU51bWJlcihjb250YWluZXJQcm9wcy5oZWlnaHQpID8gY29udGFpbmVyUHJvcHMuaGVpZ2h0IDogXCIxMDAlXCJcbiAgICB9LFxuICAgIGluc2lkZVVzZXJDb2RlQ29tcG9uZW50OiAhY29udGFpbmVyUHJvcHMuX19mcm9tQ29kZUNvbXBvbmVudE5vZGUsXG4gICAgdGl0bGU6IFwiU2Nyb2xsXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQ2xpY2sgYW5kIGRyYWcgdGhlIGNvbm5lY3RvciB0byBhbnkgZnJhbWUgb24gdGhlIGNhbnZhcyBcXHUyMTkyXCJcbiAgfSksIHVzZVVwZGF0ZUNoaWxkU2l6ZSh7XG4gICAgZHJhZ0RpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgIGNoaWxkcmVuLFxuICAgIGZyb21DYW52YXNDb21wb25lbnQ6IGNvbnRhaW5lclByb3BzLl9fZnJvbUNhbnZhc0NvbXBvbmVudFxuICB9KSkpO1xufSk7XG5mdW5jdGlvbiBvZmZzZXRUb1plcm8oeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20gfSkge1xuICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICByZXR1cm4ge1xuICAgIHRvcDogLWhlaWdodCxcbiAgICBsZWZ0OiAtd2lkdGgsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwXG4gIH07XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL1Njcm9sbC9OYXRpdmVTY3JvbGwudHN4XG5pbXBvcnQge1xuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQyNCxcbiAgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmNSxcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDcsXG4gIHVzZVJlZiBhcyB1c2VSZWYxN1xufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL21vZHVsZXMvY3gudHNcbmZ1bmN0aW9uIGN4KC4uLmNsYXNzTmFtZXMpIHtcbiAgcmV0dXJuIGNsYXNzTmFtZXMuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy91dGlscy91c2VFbXVsYXRlZFRvdWNoU2Nyb2xsLnRzXG5pbXBvcnQgUmVhY3QyNywgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MTggfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2NvbXBvbmVudHMvdXRpbHMvYW5pbWF0ZVBvaW50V2l0aEluZXJ0aWEudHNcbnZhciBBbmltYXRpb25QaGFzZTtcbihmdW5jdGlvbihBbmltYXRpb25QaGFzZTIpIHtcbiAgQW5pbWF0aW9uUGhhc2UyW0FuaW1hdGlvblBoYXNlMltcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICBBbmltYXRpb25QaGFzZTJbQW5pbWF0aW9uUGhhc2UyW1wiUnVubmluZ1wiXSA9IDFdID0gXCJSdW5uaW5nXCI7XG4gIEFuaW1hdGlvblBoYXNlMltBbmltYXRpb25QaGFzZTJbXCJDb21wbGV0ZWRcIl0gPSAyXSA9IFwiQ29tcGxldGVkXCI7XG4gIEFuaW1hdGlvblBoYXNlMltBbmltYXRpb25QaGFzZTJbXCJDYW5jZWxsZWRcIl0gPSAzXSA9IFwiQ2FuY2VsbGVkXCI7XG59KShBbmltYXRpb25QaGFzZSB8fCAoQW5pbWF0aW9uUGhhc2UgPSB7fSkpO1xuZnVuY3Rpb24gaXNSdW5uaW5nQW5pbWF0aW9uKC4uLnBoYXNlcykge1xuICBsZXQgcnVubmluZ0FueSA9IGZhbHNlO1xuICBsZXQgY2FuY2VsbGVkQW55ID0gZmFsc2U7XG4gIHBoYXNlcy5mb3JFYWNoKChwaGFzZSkgPT4ge1xuICAgIHJ1bm5pbmdBbnkgPSBydW5uaW5nQW55IHx8IHBoYXNlID09PSAxO1xuICAgIGNhbmNlbGxlZEFueSA9IGNhbmNlbGxlZEFueSB8fCBwaGFzZSA9PT0gMztcbiAgfSk7XG4gIHJldHVybiBydW5uaW5nQW55ICYmICFjYW5jZWxsZWRBbnk7XG59XG5mdW5jdGlvbiBkaWRGaW5pc2hBbmltYXRpb25zKC4uLnBoYXNlcykge1xuICByZXR1cm4gcGhhc2VzLmV2ZXJ5KChwaGFzZSkgPT4gcGhhc2UgPT09IDAgfHwgcGhhc2UgPT09IDIpO1xufVxudmFyIHRpbWVDb25zdGFudCA9IDQwMDtcbmZ1bmN0aW9uIGFuaW1hdGVQb2ludFdpdGhJbmVydGlhKHtcbiAgZnJvbSxcbiAgdmVsb2NpdHksXG4gIG9uVXBkYXRlLFxuICBvbkNvbXBsZXRlLFxuICBvblN0b3Bcbn0pIHtcbiAgY29uc3QgbGF0ZXN0ID0gZnJvbTtcbiAgbGV0IGFuaW1hdGlvblBoYXNlWCA9IDA7XG4gIGxldCBhbmltYXRpb25QaGFzZVkgPSAwO1xuICBjb25zdCBhbmltYXRpb25zMiA9IFtdO1xuICBjb25zdCB1cGRhdGVIYW5kbGVyID0gKCkgPT4ge1xuICAgIGlmIChpc1J1bm5pbmdBbmltYXRpb24oYW5pbWF0aW9uUGhhc2VYLCBhbmltYXRpb25QaGFzZVkpKSB7XG4gICAgICBvblVwZGF0ZShsYXRlc3QpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY29tcGxldGlvbkhhbmRsZXIgPSAoKSA9PiB7XG4gICAgaWYgKGRpZEZpbmlzaEFuaW1hdGlvbnMoYW5pbWF0aW9uUGhhc2VYLCBhbmltYXRpb25QaGFzZVkpKSB7XG4gICAgICBvbkNvbXBsZXRlKCk7XG4gICAgfVxuICB9O1xuICBpZiAodmVsb2NpdHkueCkge1xuICAgIGFuaW1hdGlvblBoYXNlWCA9IDE7XG4gICAgYW5pbWF0aW9uczIucHVzaChpbmVydGlhKHtcbiAgICAgIGZyb206IGZyb20ueCxcbiAgICAgIHZlbG9jaXR5OiAtdmVsb2NpdHkueCxcbiAgICAgIHRpbWVDb25zdGFudCxcbiAgICAgIG9uVXBkYXRlOiAodmFsdWUpID0+IHtcbiAgICAgICAgbGF0ZXN0LnggPSB2YWx1ZTtcbiAgICAgICAgZXNfZGVmYXVsdC51cGRhdGUodXBkYXRlSGFuZGxlciwgZmFsc2UsIHRydWUpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgaWYgKGFuaW1hdGlvblBoYXNlWCAhPT0gMSkge1xuICAgICAgICAgIHRocm93IEVycm9yKFwiYW5pbWF0aW9uIHggc2hvdWxkIGJlIHJ1bm5pbmcgd2hlbiBjb21wbGV0aW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGFuaW1hdGlvblBoYXNlWCA9IDI7XG4gICAgICAgIGNvbXBsZXRpb25IYW5kbGVyKCk7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG4gIGlmICh2ZWxvY2l0eS55KSB7XG4gICAgYW5pbWF0aW9uUGhhc2VZID0gMTtcbiAgICBhbmltYXRpb25zMi5wdXNoKGluZXJ0aWEoe1xuICAgICAgZnJvbTogZnJvbS55LFxuICAgICAgdmVsb2NpdHk6IC12ZWxvY2l0eS55LFxuICAgICAgdGltZUNvbnN0YW50LFxuICAgICAgb25VcGRhdGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgICBsYXRlc3QueSA9IHZhbHVlO1xuICAgICAgICBlc19kZWZhdWx0LnVwZGF0ZSh1cGRhdGVIYW5kbGVyLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICBpZiAoYW5pbWF0aW9uUGhhc2VZICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJhbmltYXRpb24geSBzaG91bGQgYmUgcnVubmluZyB3aGVuIGNvbXBsZXRpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgYW5pbWF0aW9uUGhhc2VZID0gMjtcbiAgICAgICAgY29tcGxldGlvbkhhbmRsZXIoKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cbiAgaWYgKCFpc1J1bm5pbmdBbmltYXRpb24oYW5pbWF0aW9uUGhhc2VYLCBhbmltYXRpb25QaGFzZVkpKSB7XG4gICAgY29tcGxldGlvbkhhbmRsZXIoKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0b3A6ICgpID0+IHtcbiAgICAgIGlmICghaXNSdW5uaW5nQW5pbWF0aW9uKGFuaW1hdGlvblBoYXNlWCwgYW5pbWF0aW9uUGhhc2VZKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgYW5pbWF0aW9uczIuZm9yRWFjaCgoYW5pbWF0aW9uKSA9PiBhbmltYXRpb24uc3RvcCgpKTtcbiAgICAgIGFuaW1hdGlvblBoYXNlWCA9IGFuaW1hdGlvblBoYXNlWCA9PT0gMSA/IDMgOiBhbmltYXRpb25QaGFzZVg7XG4gICAgICBhbmltYXRpb25QaGFzZVkgPSBhbmltYXRpb25QaGFzZVkgPT09IDEgPyAzIDogYW5pbWF0aW9uUGhhc2VZO1xuICAgICAgb25TdG9wKCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy91dGlscy91c2VFbXVsYXRlZFRvdWNoU2Nyb2xsLnRzXG52YXIgc2Nyb2xsVGhyZXNob2xkID0gMztcbnZhciBpc1RvdWNoRGV2aWNlID0gaXNUb3VjaCgpO1xudmFyIGlzU2FmYXJpQnJvd3NlciA9IGlzU2FmYXJpKCk7XG5mdW5jdGlvbiBnZXRUb3VjaEFjdGlvbihlbGVtZW50KSB7XG4gIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpXG4gICAgcmV0dXJuIG51bGw7XG4gIHJldHVybiBlbGVtZW50LnN0eWxlLnRvdWNoQWN0aW9uO1xufVxuZnVuY3Rpb24gY2FuUGFuSW5EaXJlY3Rpb24oZWxlbWVudCwgZGlyZWN0aW9uKSB7XG4gIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgY2FzZSBcImhvcml6b250YWxcIjpcbiAgICAgIHJldHVybiBnZXRUb3VjaEFjdGlvbihlbGVtZW50KSA9PT0gXCJwYW4teFwiO1xuICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxuICAgICAgcmV0dXJuIGdldFRvdWNoQWN0aW9uKGVsZW1lbnQpID09PSBcInBhbi15XCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZUVsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCB0YWcgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKHRhZyA9PT0gXCJpbnB1dFwiKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAodGFnID09PSBcInRleHRcIilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKHRhZyA9PT0gXCJ0ZXh0YXJlYVwiKVxuICAgIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjYW5TdGFydFNjcm9sbEZyb21FbGVtZW50KGVsZW1lbnQsIGRpcmVjdGlvbikge1xuICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoaXNJbnRlcmFjdGl2ZUVsZW1lbnQoZWxlbWVudCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIikpIHtcbiAgICBpZiAoIWNhblBhbkluRGlyZWN0aW9uKGVsZW1lbnQsIGRpcmVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRFdmVudFBvaW50KGV2ZW50KSB7XG4gIHJldHVybiB7XG4gICAgeDogZXZlbnQucGFnZVgsXG4gICAgeTogZXZlbnQucGFnZVlcbiAgfTtcbn1cbmZ1bmN0aW9uIHNldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICBpZiAoZWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudC5zdHlsZSkge1xuICAgIGVsZW1lbnQuc3R5bGVbcHJvcGVydHldID0gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChfYSA9IGVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGVsZW1lbnQuc3R5bGUpID09IG51bGwgPyB2b2lkIDAgOiBfYVtwcm9wZXJ0eV07XG59XG52YXIgVG91Y2hTY3JvbGxQaGFzZTtcbihmdW5jdGlvbihUb3VjaFNjcm9sbFBoYXNlMikge1xuICBUb3VjaFNjcm9sbFBoYXNlMltUb3VjaFNjcm9sbFBoYXNlMltcIklkbGVcIl0gPSAwXSA9IFwiSWRsZVwiO1xuICBUb3VjaFNjcm9sbFBoYXNlMltUb3VjaFNjcm9sbFBoYXNlMltcIlRvdWNoRG93blwiXSA9IDFdID0gXCJUb3VjaERvd25cIjtcbiAgVG91Y2hTY3JvbGxQaGFzZTJbVG91Y2hTY3JvbGxQaGFzZTJbXCJEcmFnXCJdID0gMl0gPSBcIkRyYWdcIjtcbiAgVG91Y2hTY3JvbGxQaGFzZTJbVG91Y2hTY3JvbGxQaGFzZTJbXCJEcmFnTG9ja2VkXCJdID0gM10gPSBcIkRyYWdMb2NrZWRcIjtcbiAgVG91Y2hTY3JvbGxQaGFzZTJbVG91Y2hTY3JvbGxQaGFzZTJbXCJEcmFnQW5pbWF0aW9uXCJdID0gNF0gPSBcIkRyYWdBbmltYXRpb25cIjtcbiAgVG91Y2hTY3JvbGxQaGFzZTJbVG91Y2hTY3JvbGxQaGFzZTJbXCJJbnRlcnJ1cHRlZFwiXSA9IDVdID0gXCJJbnRlcnJ1cHRlZFwiO1xufSkoVG91Y2hTY3JvbGxQaGFzZSB8fCAoVG91Y2hTY3JvbGxQaGFzZSA9IHt9KSk7XG52YXIgZW1wdHlPYmplY3QgPSB7fTtcbk9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xuZnVuY3Rpb24gdXNlRW11bGF0ZVRvdWNoU2Nyb2xsKHJlZiwgZGlyZWN0aW9uLCBlbmFibGVkKSB7XG4gIGlmIChpc1RvdWNoRGV2aWNlKVxuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgaWYgKFJlbmRlclRhcmdldC5jdXJyZW50KCkgIT09IFJlbmRlclRhcmdldC5wcmV2aWV3KVxuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgY29uc3Qgc2Nyb2xsQW5pbWF0aW9uQ29udHJvbHNSZWYgPSBSZWFjdDI3LnVzZVJlZihudWxsKTtcbiAgdXNlRWZmZWN0MTgoKCkgPT4ge1xuICAgIGlmICghcmVmLmN1cnJlbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZWxlbWVudCA9IHJlZi5jdXJyZW50O1xuICAgIGxldCBwaGFzZSA9IDA7XG4gICAgbGV0IHRhcmdldHMgPSBudWxsO1xuICAgIGxldCBkb3duUG9pbnQgPSBudWxsO1xuICAgIGxldCBzY3JvbGxPZmZzZXRTdGFydCA9IG51bGw7XG4gICAgbGV0IG1vdXNlTW92ZUV2ZW50cyA9IFtdO1xuICAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBzd2l0Y2ggKHBoYXNlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50Lm1ldGFLZXkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHBvaW50ID0gZ2V0RXZlbnRQb2ludChldmVudCk7XG4gICAgICBpZiAoIWRvd25Qb2ludClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gUG9pbnQuc3VidHJhY3QocG9pbnQsIGRvd25Qb2ludCk7XG4gICAgICBpZiAocGhhc2UgPT09IDEgfHwgcGhhc2UgPT09IDUpIHtcbiAgICAgICAgY29uc3QgZGVsdGFYID0gTWF0aC5hYnMob2Zmc2V0LngpO1xuICAgICAgICBjb25zdCBkZWx0YVkgPSBNYXRoLmFicyhvZmZzZXQueSk7XG4gICAgICAgIGlmICgoZGVsdGFYID4gc2Nyb2xsVGhyZXNob2xkIHx8IGRlbHRhWSA+IHNjcm9sbFRocmVzaG9sZCkgJiYgZGVsdGFYICE9PSBkZWx0YVkpIHtcbiAgICAgICAgICBjb25zdCBzY3JvbGxEaXJlY3Rpb24gPSBkZWx0YVggPiBkZWx0YVkgPyBcImhvcml6b250YWxcIiA6IFwidmVydGljYWxcIjtcbiAgICAgICAgICBjb25zdCBzaG91bGRJZ25vcmVCZWNhdXNlT2ZEaXJlY3Rpb25Mb2NrID0gZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIiAmJiBzY3JvbGxEaXJlY3Rpb24gPT09IFwidmVydGljYWxcIiB8fCBkaXJlY3Rpb24gPT09IFwidmVydGljYWxcIiAmJiBzY3JvbGxEaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiO1xuICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVCZWNhdXNlT2ZEaXJlY3Rpb25Mb2NrKSB7XG4gICAgICAgICAgICBwaGFzZSA9IDM7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHBoYXNlID0gMjtcbiAgICAgICAgICB0YXJnZXRzID09IG51bGwgPyB2b2lkIDAgOiB0YXJnZXRzLmZvckVhY2goKFt0YXJnZXRdKSA9PiBzZXRTdHlsZSh0YXJnZXQsIFwicG9pbnRlckV2ZW50c1wiLCBcIm5vbmVcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNTYWZhcmlCcm93c2VyKVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKHBoYXNlICE9PSAyKVxuICAgICAgICByZXR1cm47XG4gICAgICAoX2EgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5lbXB0eSgpO1xuICAgICAgbW91c2VNb3ZlRXZlbnRzID0gZ2V0UmVjZW50RXZlbnRzKFsuLi5tb3VzZU1vdmVFdmVudHMsIGV2ZW50XSk7XG4gICAgICBpZiAoc2Nyb2xsT2Zmc2V0U3RhcnQpIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAhPT0gXCJ2ZXJ0aWNhbFwiKVxuICAgICAgICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IHNjcm9sbE9mZnNldFN0YXJ0LnggLSBvZmZzZXQueDtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiAhPT0gXCJob3Jpem9udGFsXCIpXG4gICAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSBzY3JvbGxPZmZzZXRTdGFydC55IC0gb2Zmc2V0Lnk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VVcChldmVudCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgb25Nb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBvbk1vdXNlVXApO1xuICAgICAgaWYgKHBoYXNlID09PSAyICYmIHRhcmdldHMpIHtcbiAgICAgICAgdGFyZ2V0cy5mb3JFYWNoKChbdGFyZ2V0LCBvcmlnaW5hbFBvaW50ZXJFdmVudHNWYWx1ZV0pID0+IHNldFN0eWxlKHRhcmdldCwgXCJwb2ludGVyRXZlbnRzXCIsIG9yaWdpbmFsUG9pbnRlckV2ZW50c1ZhbHVlIHx8IFwiYXV0b1wiKSk7XG4gICAgICB9XG4gICAgICB0YXJnZXRzID0gbnVsbDtcbiAgICAgIGNvbnN0IHZlbG9jaXR5ID0gY2FsY3VsYXRlVmVsb2NpdHkoeyBtb3VzZU1vdmVFdmVudHMsIG1vdXNlVXBFdmVudDogZXZlbnQgfSk7XG4gICAgICBkb3duUG9pbnQgPSBudWxsO1xuICAgICAgaWYgKHBoYXNlID09PSAyKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZEFuaW1hdGVZID0gZGlyZWN0aW9uICE9PSBcImhvcml6b250YWxcIiAmJiB2ZWxvY2l0eS55ICE9PSAwO1xuICAgICAgICBjb25zdCBzaG91bGRBbmltYXRlWCA9IGRpcmVjdGlvbiAhPT0gXCJ2ZXJ0aWNhbFwiICYmIHZlbG9jaXR5LnggIT09IDA7XG4gICAgICAgIGlmICghc2hvdWxkQW5pbWF0ZVkgJiYgIXNob3VsZEFuaW1hdGVYKSB7XG4gICAgICAgICAgcGhhc2UgPSAwO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwaGFzZSA9IDQ7XG4gICAgICAgIHNjcm9sbEFuaW1hdGlvbkNvbnRyb2xzUmVmLmN1cnJlbnQgPSBhbmltYXRlUG9pbnRXaXRoSW5lcnRpYSh7XG4gICAgICAgICAgZnJvbTogeyB4OiBlbGVtZW50LnNjcm9sbExlZnQsIHk6IGVsZW1lbnQuc2Nyb2xsVG9wIH0sXG4gICAgICAgICAgdmVsb2NpdHk6IHtcbiAgICAgICAgICAgIHg6IHNob3VsZEFuaW1hdGVYID8gdmVsb2NpdHkueCA6IDAsXG4gICAgICAgICAgICB5OiBzaG91bGRBbmltYXRlWSA/IHZlbG9jaXR5LnkgOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvblVwZGF0ZTogKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQW5pbWF0ZVgpXG4gICAgICAgICAgICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IHBvc2l0aW9uLng7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQW5pbWF0ZVkpXG4gICAgICAgICAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gcG9zaXRpb24ueTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uU3RvcDogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBoYXNlICE9PSA1KSB7XG4gICAgICAgICAgICAgIHBoYXNlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjcm9sbEFuaW1hdGlvbkNvbnRyb2xzUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBoYXNlICE9PSA0KSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFwiT24gYW5pbWF0aW9uIGNvbXBsZXRpb24gd2Ugc2hvdWxkIHN0aWxsIGJlIGluIHRoZSBhbmltYXRpb24gcGhhc2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwaGFzZSA9IDA7XG4gICAgICAgICAgICBzY3JvbGxBbmltYXRpb25Db250cm9sc1JlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGhhc2UgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlV2hlZWwoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSBzY3JvbGxBbmltYXRpb25Db250cm9sc1JlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3RvcCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCFlbmFibGVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoZXZlbnQubWV0YUtleSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKCFjYW5TdGFydFNjcm9sbEZyb21FbGVtZW50KGV2ZW50LnRhcmdldCwgZGlyZWN0aW9uKSkge1xuICAgICAgICBpZiAocGhhc2UgPT09IDQpIHtcbiAgICAgICAgICBwaGFzZSA9IDA7XG4gICAgICAgICAgKF9hID0gc2Nyb2xsQW5pbWF0aW9uQ29udHJvbHNSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2aW91c1BoYXNlID0gcGhhc2U7XG4gICAgICBwaGFzZSA9IHByZXZpb3VzUGhhc2UgPT09IDQgPyA1IDogMTtcbiAgICAgIGRvd25Qb2ludCA9IGdldEV2ZW50UG9pbnQoZXZlbnQpO1xuICAgICAgdGFyZ2V0cyA9IGRvY3VtZW50LmVsZW1lbnRzRnJvbVBvaW50KGRvd25Qb2ludC54LCBkb3duUG9pbnQueSkuZmlsdGVyKCh0YXJnZXRFbCkgPT4gdGFyZ2V0RWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCB0YXJnZXRFbCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpLm1hcCgodGFyZ2V0RWwpID0+IFt0YXJnZXRFbCwgZ2V0U3R5bGUodGFyZ2V0RWwsIFwicG9pbnRlckV2ZW50c1wiKV0pO1xuICAgICAgc2Nyb2xsT2Zmc2V0U3RhcnQgPSB7IHg6IGVsZW1lbnQuc2Nyb2xsTGVmdCwgeTogZWxlbWVudC5zY3JvbGxUb3AgfTtcbiAgICAgIG1vdXNlTW92ZUV2ZW50cyA9IFtdO1xuICAgICAgaWYgKHNjcm9sbEFuaW1hdGlvbkNvbnRyb2xzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgaWYgKHByZXZpb3VzUGhhc2UgIT09IDQpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIldoZW4gc3RvcHBpbmcgYSBkcmFnIGFuaW1hdGlvbiB3ZSBuZWVkIHRvIGJlIGFuaW1hdGluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBzY3JvbGxBbmltYXRpb25Db250cm9sc1JlZi5jdXJyZW50LnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uTW91c2VNb3ZlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBvbk1vdXNlVXApO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V3aGVlbFwiLCBvbk1vdXNlV2hlZWwpO1xuICAgIH1cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgb25Nb3VzZURvd24pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgb25Nb3VzZURvd24pO1xuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V3aGVlbFwiLCBvbk1vdXNlV2hlZWwpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgb25Nb3VzZU1vdmUpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIG9uTW91c2VVcCk7XG4gICAgICBwaGFzZSA9IDU7XG4gICAgICAoX2EgPSBzY3JvbGxBbmltYXRpb25Db250cm9sc1JlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3RvcCgpO1xuICAgIH07XG4gIH0sIFtyZWYsIGRpcmVjdGlvbiwgZW5hYmxlZF0pO1xuICByZXR1cm4gUmVhY3QyNy51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY2FuY2VsRW11bGF0ZWRUb3VjaFNjcm9sbEFuaW1hdGlvbjogKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHNjcm9sbEFuaW1hdGlvbkNvbnRyb2xzUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zdG9wKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xufVxudmFyIHRpbWVEZWx0YSA9IDQgLyA2MCAqIDFlMztcbmZ1bmN0aW9uIGdldFJlY2VudEV2ZW50cyhldmVudHMyKSB7XG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IEN1c3RvbUV2ZW50KFwiZ2V0VGltZVwiKS50aW1lU3RhbXA7XG4gIGNvbnN0IG1heEFnZSA9IGN1cnJlbnRUaW1lIC0gdGltZURlbHRhO1xuICByZXR1cm4gZXZlbnRzMi5maWx0ZXIoKGV2ZW50KSA9PiBldmVudC50aW1lU3RhbXAgPiBtYXhBZ2UpO1xufVxudmFyIHplcm9Qb2ludCA9IHsgeDogMCwgeTogMCB9O1xuZnVuY3Rpb24gY2FsY3VsYXRlVmVsb2NpdHkoe1xuICBtb3VzZU1vdmVFdmVudHMsXG4gIG1vdXNlVXBFdmVudFxufSkge1xuICBjb25zdCByZWNlbnRNb3VzZU1vdmVFdmVudHMgPSBnZXRSZWNlbnRFdmVudHMobW91c2VNb3ZlRXZlbnRzKTtcbiAgY29uc3Qgb2xkZXN0TW91c2VNb3ZlRXZlbnQgPSByZWNlbnRNb3VzZU1vdmVFdmVudHNbMF07XG4gIGlmICghb2xkZXN0TW91c2VNb3ZlRXZlbnQpXG4gICAgcmV0dXJuIHplcm9Qb2ludDtcbiAgY29uc3QgZGVsdGFYID0gbW91c2VVcEV2ZW50LmNsaWVudFggLSBvbGRlc3RNb3VzZU1vdmVFdmVudC5jbGllbnRYO1xuICBjb25zdCBkZWx0YVkgPSBtb3VzZVVwRXZlbnQuY2xpZW50WSAtIG9sZGVzdE1vdXNlTW92ZUV2ZW50LmNsaWVudFk7XG4gIGNvbnN0IHRpbWUzID0gbW91c2VVcEV2ZW50LnRpbWVTdGFtcCAtIG9sZGVzdE1vdXNlTW92ZUV2ZW50LnRpbWVTdGFtcDtcbiAgaWYgKHRpbWUzID09PSAwKVxuICAgIHJldHVybiB6ZXJvUG9pbnQ7XG4gIHJldHVybiB7XG4gICAgeDogZGVsdGFYIC8gdGltZTMgKiAxZTMsXG4gICAgeTogZGVsdGFZIC8gdGltZTMgKiAxZTNcbiAgfTtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvTmF2aWdhdGlvbkNvbnRhaW5lckNvbnRleHQudHN4XG5pbXBvcnQge1xuICBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxMlxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDIyIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgTmF2aWdhdGlvbkNvbnRhaW5lckNvbnRleHQgPSBjcmVhdGVDb250ZXh0MTIodHJ1ZSk7XG5mdW5jdGlvbiB1c2VJc0luQ3VycmVudE5hdmlnYXRpb25UYXJnZXQoKSB7XG4gIGNvbnN0IGlzSW5DdXJyZW50TmF2aWdhdGlvblRhcmdldCA9IHVzZUNvbnRleHQyMihOYXZpZ2F0aW9uQ29udGFpbmVyQ29udGV4dCk7XG4gIHJldHVybiBpc0luQ3VycmVudE5hdmlnYXRpb25UYXJnZXQ7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL3V0aWxzL3VzZVVwZGF0ZVNjcm9sbE9mZnNldC50c1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDYgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZVVwZGF0ZVNjcm9sbE9mZnNldChyZWYsIHNpZGUsIG9mZnNldCwgY2FuY2VsRW11bGF0ZWRUb3VjaFNjcm9sbEFuaW1hdGlvbikge1xuICB1c2VMYXlvdXRFZmZlY3Q2KCgpID0+IHtcbiAgICBpZiAoaXNNb3Rpb25WYWx1ZTIob2Zmc2V0KSkge1xuICAgICAgY29uc3QgdXBkYXRlU2Nyb2xsTGVmdCA9ICgpID0+IHtcbiAgICAgICAgY2FuY2VsRW11bGF0ZWRUb3VjaFNjcm9sbEFuaW1hdGlvbiA9PSBudWxsID8gdm9pZCAwIDogY2FuY2VsRW11bGF0ZWRUb3VjaFNjcm9sbEFuaW1hdGlvbigpO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChlbGVtZW50KVxuICAgICAgICAgIGVsZW1lbnRbc2lkZV0gPSBNYXRoLmFicyhvZmZzZXQuZ2V0KCkpO1xuICAgICAgfTtcbiAgICAgIHVwZGF0ZVNjcm9sbExlZnQoKTtcbiAgICAgIHJldHVybiBvZmZzZXQub25DaGFuZ2UodXBkYXRlU2Nyb2xsTGVmdCk7XG4gICAgfSBlbHNlIGlmIChpc0Zpbml0ZU51bWJlcihvZmZzZXQpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIWVsZW1lbnQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhbmNlbEVtdWxhdGVkVG91Y2hTY3JvbGxBbmltYXRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGNhbmNlbEVtdWxhdGVkVG91Y2hTY3JvbGxBbmltYXRpb24oKTtcbiAgICAgIGVsZW1lbnRbc2lkZV0gPSBNYXRoLmFicyhvZmZzZXQpO1xuICAgIH1cbiAgfSwgW29mZnNldF0pO1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9TY3JvbGwvTmF0aXZlU2Nyb2xsLnRzeFxudmFyIE5hdGl2ZVNjcm9sbCA9IGZvcndhcmRSZWY1KGZ1bmN0aW9uIE5hdGl2ZVNjcm9sbDIocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICBjb25zdCB7XG4gICAgZGlyZWN0aW9uID0gXCJ2ZXJ0aWNhbFwiLFxuICAgIHNjcm9sbEJhclZpc2libGUgPSBmYWxzZSxcbiAgICBkcmFnRW5hYmxlZCA9IHRydWUsXG4gICAgY29udGVudE9mZnNldFggPSAwLFxuICAgIGNvbnRlbnRPZmZzZXRZID0gMCxcbiAgICBjb250ZW50V2lkdGgsXG4gICAgY29udGVudEhlaWdodCxcbiAgICBjaGlsZHJlbixcbiAgICByZXNldE9mZnNldCxcbiAgICBvblNjcm9sbCxcbiAgICBjbGFzc05hbWUsXG4gICAgZGlyZWN0aW9uTG9jayA9IGZhbHNlLFxuICAgIHdoZWVsRW5hYmxlZCA9IHRydWUsXG4gICAgc2Nyb2xsQW5pbWF0ZSxcbiAgICBkcmFnVHJhbnNpdGlvbixcbiAgICBkcmFnTW9tZW50dW0sXG4gICAgZHJhZ0VsYXN0aWMsXG4gICAgb3ZlcmRyYWdFbmFibGVkID0gdHJ1ZSxcbiAgICBvblNjcm9sbFN0YXJ0LFxuICAgIG9uU2Nyb2xsRW5kLFxuICAgIG9uRHJhZ1N0YXJ0LFxuICAgIG9uRHJhZyxcbiAgICBvbkRyYWdFbmQsXG4gICAgb25VcGRhdGUsXG4gICAgb25EaXJlY3Rpb25Mb2NrLFxuICAgIGxheW91dElkOiBzcGVjaWZpY0xheW91dElkLFxuICAgIG5hdGl2ZSxcbiAgICAuLi5jb250YWluZXJQcm9wc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGxheW91dElkID0gdXNlTGF5b3V0SWQyKHByb3BzLCB7IHNwZWNpZmljTGF5b3V0SWQsIHBvc3RmaXg6IFwic2Nyb2xsXCIgfSk7XG4gIGNvbnN0IGZhbGxiYWNrUmVmID0gdXNlUmVmMTcobnVsbCk7XG4gIGNvbnN0IHJlZiA9IGZvcndhcmRlZFJlZiB8fCBmYWxsYmFja1JlZjtcbiAgY29uc3QgeyBjYW5jZWxFbXVsYXRlZFRvdWNoU2Nyb2xsQW5pbWF0aW9uIH0gPSB1c2VFbXVsYXRlVG91Y2hTY3JvbGwocmVmLCBkaXJlY3Rpb24sIGRyYWdFbmFibGVkKTtcbiAgaW5qZWN0Q29tcG9uZW50Q1NTUnVsZXMoKTtcbiAgY29uc3QgaXNJblRhcmdldCA9IHVzZUlzSW5DdXJyZW50TmF2aWdhdGlvblRhcmdldCgpO1xuICBjb25zdCBwcmV2aW91c0lzSW5UYXJnZXRSZWYgPSB1c2VSZWYxNyhpc0luVGFyZ2V0KTtcbiAgY29uc3QgdXBkYXRlU2Nyb2xsT2Zmc2V0SGFuZGxlciA9ICgpID0+IHtcbiAgICBpZiAoIXJlc2V0T2Zmc2V0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHByZXZpb3VzSXNUYXJnZXQgPSBwcmV2aW91c0lzSW5UYXJnZXRSZWYuY3VycmVudDtcbiAgICBwcmV2aW91c0lzSW5UYXJnZXRSZWYuY3VycmVudCA9IGlzSW5UYXJnZXQ7XG4gICAgY29uc3Qgc2hvdWxkUmVzZXRPZmZzZXQgPSBpc0luVGFyZ2V0ICYmICFwcmV2aW91c0lzVGFyZ2V0O1xuICAgIGlmICghc2hvdWxkUmVzZXRPZmZzZXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZWxlbWVudCA9IHJlZi5jdXJyZW50O1xuICAgIGlmICghZWxlbWVudClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoZGlyZWN0aW9uICE9PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgIGNhbmNlbEVtdWxhdGVkVG91Y2hTY3JvbGxBbmltYXRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGNhbmNlbEVtdWxhdGVkVG91Y2hTY3JvbGxBbmltYXRpb24oKTtcbiAgICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IE1hdGguYWJzKGlzTW90aW9uVmFsdWUyKGNvbnRlbnRPZmZzZXRYKSA/IGNvbnRlbnRPZmZzZXRYLmdldCgpIDogY29udGVudE9mZnNldFgpO1xuICAgIH1cbiAgICBpZiAoZGlyZWN0aW9uICE9PSBcImhvcml6b250YWxcIikge1xuICAgICAgY2FuY2VsRW11bGF0ZWRUb3VjaFNjcm9sbEFuaW1hdGlvbiA9PSBudWxsID8gdm9pZCAwIDogY2FuY2VsRW11bGF0ZWRUb3VjaFNjcm9sbEFuaW1hdGlvbigpO1xuICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSBNYXRoLmFicyhpc01vdGlvblZhbHVlMihjb250ZW50T2Zmc2V0WSkgPyBjb250ZW50T2Zmc2V0WS5nZXQoKSA6IGNvbnRlbnRPZmZzZXRZKTtcbiAgICB9XG4gIH07XG4gIHVzZUxheW91dEVmZmVjdDcodXBkYXRlU2Nyb2xsT2Zmc2V0SGFuZGxlciwgW2lzSW5UYXJnZXRdKTtcbiAgdXNlVXBkYXRlU2Nyb2xsT2Zmc2V0KHJlZiwgXCJzY3JvbGxMZWZ0XCIsIGNvbnRlbnRPZmZzZXRYLCBjYW5jZWxFbXVsYXRlZFRvdWNoU2Nyb2xsQW5pbWF0aW9uKTtcbiAgdXNlVXBkYXRlU2Nyb2xsT2Zmc2V0KHJlZiwgXCJzY3JvbGxUb3BcIiwgY29udGVudE9mZnNldFksIGNhbmNlbEVtdWxhdGVkVG91Y2hTY3JvbGxBbmltYXRpb24pO1xuICBjb25zdCBzaXplMiA9ICFjb250YWluZXJQcm9wcy5fX2Zyb21DYW52YXNDb21wb25lbnQgPyB7XG4gICAgd2lkdGg6IGNvbnRhaW5lclByb3BzLl9fZnJvbUNvZGVDb21wb25lbnROb2RlID8gXCIxMDAlXCIgOiBjb250YWluZXJQcm9wcy53aWR0aCxcbiAgICBoZWlnaHQ6IGNvbnRhaW5lclByb3BzLl9fZnJvbUNvZGVDb21wb25lbnROb2RlID8gXCIxMDAlXCIgOiBjb250YWluZXJQcm9wcy5oZWlnaHRcbiAgfSA6IHt9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQyNChGcmFtZVdpdGhNb3Rpb24sIHtcbiAgICByZWYsXG4gICAgXCJkYXRhLWZyYW1lci1jb21wb25lbnQtdHlwZVwiOiBcIk5hdGl2ZVNjcm9sbFwiLFxuICAgIGJhY2tncm91bmQ6IFwibm9uZVwiLFxuICAgIC4uLmNvbnRhaW5lclByb3BzLFxuICAgIC4uLnNpemUyLFxuICAgIG9uU2Nyb2xsLFxuICAgIGxheW91dElkLFxuICAgIG9uQmVmb3JlTGF5b3V0TWVhc3VyZTogdXBkYXRlU2Nyb2xsT2Zmc2V0SGFuZGxlcixcbiAgICBjbGFzc05hbWU6IGN4KGNsYXNzTmFtZSwgYGRpcmVjdGlvbi0ke2RpcmVjdGlvbn1gLCAhc2Nyb2xsQmFyVmlzaWJsZSAmJiBcInNjcm9sbGJhci1oaWRkZW5cIilcbiAgfSwgLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQyNChFbXB0eVN0YXRlLCB7XG4gICAgY2hpbGRyZW4sXG4gICAgc2l6ZToge1xuICAgICAgd2lkdGg6IGlzRmluaXRlTnVtYmVyKGNvbnRhaW5lclByb3BzLndpZHRoKSA/IGNvbnRhaW5lclByb3BzLndpZHRoIDogXCIxMDAlXCIsXG4gICAgICBoZWlnaHQ6IGlzRmluaXRlTnVtYmVyKGNvbnRhaW5lclByb3BzLmhlaWdodCkgPyBjb250YWluZXJQcm9wcy5oZWlnaHQgOiBcIjEwMCVcIlxuICAgIH0sXG4gICAgaW5zaWRlVXNlckNvZGVDb21wb25lbnQ6ICFjb250YWluZXJQcm9wcy5fX2Zyb21Db2RlQ29tcG9uZW50Tm9kZSxcbiAgICB0aXRsZTogXCJTY3JvbGxcIixcbiAgICBkZXNjcmlwdGlvbjogXCJDbGljayBhbmQgZHJhZyB0aGUgY29ubmVjdG9yIHRvIGFueSBmcmFtZSBvbiB0aGUgY2FudmFzIFxcdTIxOTJcIlxuICB9KSwgY2hpbGRyZW4pO1xufSk7XG5cbi8vIHNyYy9jb21wb25lbnRzL1Njcm9sbC9TY3JvbGwudHN4XG52YXIgU2Nyb2xsID0gZm9yd2FyZFJlZjYoZnVuY3Rpb24gU2Nyb2xsMihwcm9wcywgZm9yd2FyZGVkUmVmKSB7XG4gIGlmIChwcm9wcy5uYXRpdmUpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQyNShOYXRpdmVTY3JvbGwsIHtcbiAgICAgIHJlZjogZm9yd2FyZGVkUmVmLFxuICAgICAgLi4ucHJvcHNcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQyNShFbXVsYXRlZFNjcm9sbCwge1xuICAgICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgICAuLi5wcm9wc1xuICAgIH0pO1xuICB9XG59KTtcbmFkZFByb3BlcnR5Q29udHJvbHMoU2Nyb2xsLCB7XG4gIG5hdGl2ZToge1xuICAgIHR5cGU6IENvbnRyb2xUeXBlLkJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiBmYWxzZVxuICB9LFxuICBkaXJlY3Rpb246IHtcbiAgICB0eXBlOiBDb250cm9sVHlwZS5TZWdtZW50ZWRFbnVtLFxuICAgIHRpdGxlOiBcIkRpcmVjdGlvblwiLFxuICAgIG9wdGlvbnM6IFtcInZlcnRpY2FsXCIsIFwiaG9yaXpvbnRhbFwiLCBcImJvdGhcIl0sXG4gICAgZGVmYXVsdFZhbHVlOiBcInZlcnRpY2FsXCJcbiAgfSxcbiAgY29udGVudE9mZnNldFg6IHtcbiAgICB0eXBlOiBDb250cm9sVHlwZS5OdW1iZXIsXG4gICAgdGl0bGU6IFwiT2Zmc2V0IFhcIixcbiAgICBkZWZhdWx0VmFsdWU6IDAsXG4gICAgbWluOiAwLFxuICAgIHN0ZXA6IDEwLFxuICAgIGRpc3BsYXlTdGVwcGVyOiB0cnVlLFxuICAgIGhpZGRlbjogKHsgZGlyZWN0aW9uIH0pID0+IGRpcmVjdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiXG4gIH0sXG4gIGNvbnRlbnRPZmZzZXRZOiB7XG4gICAgdHlwZTogQ29udHJvbFR5cGUuTnVtYmVyLFxuICAgIHRpdGxlOiBcIk9mZnNldCBZXCIsXG4gICAgZGVmYXVsdFZhbHVlOiAwLFxuICAgIG1pbjogMCxcbiAgICBzdGVwOiAxMCxcbiAgICBkaXNwbGF5U3RlcHBlcjogdHJ1ZSxcbiAgICBoaWRkZW46ICh7IGRpcmVjdGlvbiB9KSA9PiBkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiXG4gIH0sXG4gIGRpcmVjdGlvbkxvY2s6IHtcbiAgICB0eXBlOiBDb250cm9sVHlwZS5Cb29sZWFuLFxuICAgIHRpdGxlOiBcIkxvY2tcIixcbiAgICBlbmFibGVkVGl0bGU6IFwiMSBBeGlzXCIsXG4gICAgZGlzYWJsZWRUaXRsZTogXCJPZmZcIixcbiAgICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gICAgaGlkZGVuOiAoeyBuYXRpdmUgfSkgPT4gbmF0aXZlID09PSB0cnVlXG4gIH0sXG4gIGRyYWdFbmFibGVkOiB7XG4gICAgdHlwZTogQ29udHJvbFR5cGUuQm9vbGVhbixcbiAgICB0aXRsZTogXCJEcmFnXCIsXG4gICAgZW5hYmxlZFRpdGxlOiBcIk9uXCIsXG4gICAgZGlzYWJsZWRUaXRsZTogXCJPZmZcIixcbiAgICBkZWZhdWx0VmFsdWU6IHRydWVcbiAgfSxcbiAgb3ZlcmRyYWdFbmFibGVkOiB7XG4gICAgdHlwZTogQ29udHJvbFR5cGUuQm9vbGVhbixcbiAgICB0aXRsZTogXCJPdmVyZHJhZ1wiLFxuICAgIGVuYWJsZWRUaXRsZTogXCJPblwiLFxuICAgIGRpc2FibGVkVGl0bGU6IFwiT2ZmXCIsXG4gICAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICAgIGhpZGRlbjogKHsgbmF0aXZlIH0pID0+IG5hdGl2ZSA9PT0gdHJ1ZVxuICB9LFxuICB3aGVlbEVuYWJsZWQ6IHtcbiAgICB0eXBlOiBDb250cm9sVHlwZS5Cb29sZWFuLFxuICAgIHRpdGxlOiBcIldoZWVsXCIsXG4gICAgZW5hYmxlZFRpdGxlOiBcIk9uXCIsXG4gICAgZGlzYWJsZWRUaXRsZTogXCJPZmZcIixcbiAgICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gICAgaGlkZGVuOiAoeyBuYXRpdmUgfSkgPT4gbmF0aXZlID09PSB0cnVlXG4gIH0sXG4gIHNjcm9sbEJhclZpc2libGU6IHtcbiAgICB0eXBlOiBDb250cm9sVHlwZS5Cb29sZWFuLFxuICAgIHRpdGxlOiBcIlNjcm9sbCBCYXJcIixcbiAgICBlbmFibGVkVGl0bGU6IFwiVmlzaWJsZVwiLFxuICAgIGRpc2FibGVkVGl0bGU6IFwiSGlkZGVuXCIsXG4gICAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgICBoaWRkZW46ICh7IG5hdGl2ZSB9KSA9PiBuYXRpdmUgPT09IGZhbHNlXG4gIH0sXG4gIHJlc2V0T2Zmc2V0OiB7XG4gICAgdHlwZTogQ29udHJvbFR5cGUuQm9vbGVhbixcbiAgICB0aXRsZTogXCJSZXNldFwiLFxuICAgIGVuYWJsZWRUaXRsZTogXCJUcnVlXCIsXG4gICAgZGlzYWJsZWRUaXRsZTogXCJGYWxzZVwiLFxuICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgfVxufSk7XG5TY3JvbGwuc3VwcG9ydHNDb25zdHJhaW50cyA9IHRydWU7XG5cbi8vIHNyYy9jb21wb25lbnRzL0RyYWdnYWJsZS50c1xudmFyIERyYWdnYWJsZSA9IFdpdGhEcmFnZ2luZyhEZXByZWNhdGVkRnJhbWVXaXRoRXZlbnRzKTtcblxuLy8gc3JjL2NvbXBvbmVudHMvU2Nyb2xsL0RlcHJlY2F0ZWRTY3JvbGwudHN4XG5pbXBvcnQge1xuICBDaGlsZHJlbiBhcyBDaGlsZHJlbjcsXG4gIENvbXBvbmVudCBhcyBDb21wb25lbnQ2LFxuICBjbG9uZUVsZW1lbnQgYXMgY2xvbmVFbGVtZW50NSxcbiAgY3JlYXRlRWxlbWVudCBhcyBjcmVhdGVFbGVtZW50MjZcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9jb21wb25lbnRzL3V0aWxzL1JlY3RQcm92aWRlci50c1xuZnVuY3Rpb24gaXNSZWN0UHJvdmlkaW5nKGMyKSB7XG4gIHJldHVybiBcInJlY3RcIiBpbiBjMiAmJiBjMi5yZWN0IGluc3RhbmNlb2YgRnVuY3Rpb247XG59XG5cbi8vIHNyYy91dGlscy9vYnNlcnZhYmxlLnRzXG5mdW5jdGlvbiBnZXRPYnNlcnZhYmxlTnVtYmVyKHZhbHVlLCBkZWZhdWx0VmFsdWUgPSAwKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICB9XG4gIGlmIChpc0FuaW1hdGFibGUyKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5nZXQoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL1Njcm9sbC9EZXByZWNhdGVkU2Nyb2xsLnRzeFxudmFyIF9EZXByZWNhdGVkU2Nyb2xsID0gY2xhc3MgZXh0ZW5kcyBDb21wb25lbnQ2IHtcbiAgd3JhcEhhbmRsZXJzKGRyYWdIYW5kbGVyLCBzY3JvbGxIYW5kbGVyKSB7XG4gICAgaWYgKCFzY3JvbGxIYW5kbGVyKSB7XG4gICAgICByZXR1cm4gZHJhZ0hhbmRsZXI7XG4gICAgfVxuICAgIHJldHVybiAoZXZlbnQsIGRyYWdnYWJsZSkgPT4ge1xuICAgICAgaWYgKGRyYWdIYW5kbGVyKSB7XG4gICAgICAgIGRyYWdIYW5kbGVyKGV2ZW50LCBkcmFnZ2FibGUpO1xuICAgICAgfVxuICAgICAgc2Nyb2xsSGFuZGxlcihldmVudCwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MjYoQ29uc3VtZVBhcmVudFNpemUsIG51bGwsICh7IHNpemU6IG5ld1BhcmVudFNpemUgfSkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50U2l6ZSA9IGRlcHJlY2F0ZWRQYXJlbnRTaXplKG5ld1BhcmVudFNpemUpO1xuICAgICAgY29uc3QgZnJhbWVQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHtcbiAgICAgICAgcGFyZW50U2l6ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3Qua2V5cyhfRGVwcmVjYXRlZFNjcm9sbC5zY3JvbGxQcm9wcykubWFwKChrZXk2KSA9PiB7XG4gICAgICAgIGRlbGV0ZSBmcmFtZVByb3BzW2tleTZdO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXRoaXMucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MjYoRGVwcmVjYXRlZEZyYW1lLCB7XG4gICAgICAgICAgLi4uZnJhbWVQcm9wc1xuICAgICAgICB9LCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDI2KERyYWdnYWJsZSwge1xuICAgICAgICAgIHdpZHRoOiBmcmFtZVByb3BzLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogZnJhbWVQcm9wcy5oZWlnaHRcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udGVudFNpemUgPSB7IHRvcDogMCwgbGVmdDogMCwgYm90dG9tOiAwLCByaWdodDogMCB9O1xuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBEZXByZWNhdGVkRnJhbWUucmVjdChmcmFtZVByb3BzKTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gQ2hpbGRyZW43Lm1hcCh0aGlzLnByb3BzLmNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkID09PSBudWxsIHx8IHR5cGVvZiBjaGlsZCAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2hpbGQudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gY2hpbGQudHlwZTtcbiAgICAgICAgaWYgKGlzUmVjdFByb3ZpZGluZyh0eXBlKSkge1xuICAgICAgICAgIGNvbnN0IGZyYW1lMiA9IHR5cGUucmVjdChjaGlsZC5wcm9wcywgcGFyZW50U2l6ZSk7XG4gICAgICAgICAgaWYgKGZyYW1lMikge1xuICAgICAgICAgICAgY29udGVudFNpemUudG9wID0gTWF0aC5taW4oUmVjdC5taW5ZKGZyYW1lMiksIGNvbnRlbnRTaXplLnRvcCk7XG4gICAgICAgICAgICBjb250ZW50U2l6ZS5sZWZ0ID0gTWF0aC5taW4oUmVjdC5taW5YKGZyYW1lMiksIGNvbnRlbnRTaXplLmxlZnQpO1xuICAgICAgICAgICAgY29udGVudFNpemUuYm90dG9tID0gTWF0aC5tYXgoUmVjdC5tYXhZKGZyYW1lMiksIGNvbnRlbnRTaXplLmJvdHRvbSk7XG4gICAgICAgICAgICBjb250ZW50U2l6ZS5yaWdodCA9IE1hdGgubWF4KFJlY3QubWF4WChmcmFtZTIpLCBjb250ZW50U2l6ZS5yaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwZGF0ZSA9IHt9O1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5kaXJlY3Rpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICAgIHVwZGF0ZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJvcHMuZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgIHVwZGF0ZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lRWxlbWVudDUoY2hpbGQsIHVwZGF0ZSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb25TY3JvbGxTdGFydCxcbiAgICAgICAgb25TY3JvbGwsXG4gICAgICAgIG9uU2Nyb2xsRW5kLFxuICAgICAgICBvblNjcm9sbFNlc3Npb25TdGFydCxcbiAgICAgICAgb25TY3JvbGxTZXNzaW9uRW5kXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHcgPSBnZXRPYnNlcnZhYmxlTnVtYmVyKHdpZHRoKTtcbiAgICAgIGNvbnN0IGggPSBnZXRPYnNlcnZhYmxlTnVtYmVyKGhlaWdodCk7XG4gICAgICBjb25zdCBjb250ZW50VyA9IE1hdGgubWF4KGNvbnRlbnRTaXplLnJpZ2h0LCB3KTtcbiAgICAgIGNvbnN0IGNvbnRlbnRIID0gTWF0aC5tYXgoY29udGVudFNpemUuYm90dG9tLCBoKTtcbiAgICAgIGNvbnN0IHggPSBNYXRoLm1pbigwLCB3IC0gY29udGVudFcpO1xuICAgICAgY29uc3QgeSA9IE1hdGgubWluKDAsIGggLSBjb250ZW50SCk7XG4gICAgICBjb25zdCBjb25zdHJhaW50cyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgd2lkdGg6IGNvbnRlbnRXICsgY29udGVudFcgLSB3LFxuICAgICAgICBoZWlnaHQ6IGNvbnRlbnRIICsgY29udGVudEggLSBoXG4gICAgICB9O1xuICAgICAgY29uc3QgZHJhZ2dhYmxlUHJvcHMgPSB7fTtcbiAgICAgIGRyYWdnYWJsZVByb3BzLmVuYWJsZWQgPSB0aGlzLnByb3BzLmRyYWdnaW5nRW5hYmxlZDtcbiAgICAgIGRyYWdnYWJsZVByb3BzLmJhY2tncm91bmQgPSBcIm5vbmVcIjtcbiAgICAgIGRyYWdnYWJsZVByb3BzLndpZHRoID0gY29udGVudFc7XG4gICAgICBkcmFnZ2FibGVQcm9wcy5oZWlnaHQgPSBjb250ZW50SDtcbiAgICAgIGRyYWdnYWJsZVByb3BzLmNvbnN0cmFpbnRzID0gY29uc3RyYWludHM7XG4gICAgICBkcmFnZ2FibGVQcm9wcy5vbk1vdmUgPSB0aGlzLnByb3BzLm9uTW92ZTtcbiAgICAgIGRyYWdnYWJsZVByb3BzLm9uRHJhZ1Nlc3Npb25TdGFydCA9IHRoaXMud3JhcEhhbmRsZXJzKHRoaXMucHJvcHMub25EcmFnU2Vzc2lvblN0YXJ0LCBvblNjcm9sbFNlc3Npb25TdGFydCk7XG4gICAgICBkcmFnZ2FibGVQcm9wcy5vbkRyYWdTZXNzaW9uTW92ZSA9IHRoaXMucHJvcHMub25EcmFnU2Vzc2lvbk1vdmU7XG4gICAgICBkcmFnZ2FibGVQcm9wcy5vbkRyYWdTZXNzaW9uRW5kID0gdGhpcy53cmFwSGFuZGxlcnModGhpcy5wcm9wcy5vbkRyYWdTZXNzaW9uRW5kLCBvblNjcm9sbFNlc3Npb25FbmQpO1xuICAgICAgZHJhZ2dhYmxlUHJvcHMub25EcmFnQW5pbWF0aW9uU3RhcnQgPSB0aGlzLnByb3BzLm9uRHJhZ0FuaW1hdGlvblN0YXJ0O1xuICAgICAgZHJhZ2dhYmxlUHJvcHMub25EcmFnQW5pbWF0aW9uRW5kID0gdGhpcy5wcm9wcy5vbkRyYWdBbmltYXRpb25FbmQ7XG4gICAgICBkcmFnZ2FibGVQcm9wcy5vbkRyYWdEaWRNb3ZlID0gdGhpcy53cmFwSGFuZGxlcnModGhpcy5wcm9wcy5vbkRyYWdEaWRNb3ZlLCBvblNjcm9sbCk7XG4gICAgICBkcmFnZ2FibGVQcm9wcy5vbkRyYWdEaXJlY3Rpb25Mb2NrU3RhcnQgPSB0aGlzLnByb3BzLm9uRHJhZ0RpcmVjdGlvbkxvY2tTdGFydDtcbiAgICAgIGRyYWdnYWJsZVByb3BzLm9uRHJhZ1N0YXJ0ID0gdGhpcy53cmFwSGFuZGxlcnModGhpcy5wcm9wcy5vbkRyYWdTdGFydCwgb25TY3JvbGxTdGFydCk7XG4gICAgICBkcmFnZ2FibGVQcm9wcy5vbkRyYWdFbmQgPSB0aGlzLndyYXBIYW5kbGVycyh0aGlzLnByb3BzLm9uRHJhZ0VuZCwgb25TY3JvbGxFbmQpO1xuICAgICAgZHJhZ2dhYmxlUHJvcHMub25EcmFnV2lsbE1vdmUgPSB0aGlzLnByb3BzLm9uRHJhZ1dpbGxNb3ZlO1xuICAgICAgZHJhZ2dhYmxlUHJvcHMuaG9yaXpvbnRhbCA9IHRoaXMucHJvcHMuZGlyZWN0aW9uICE9PSBcInZlcnRpY2FsXCI7XG4gICAgICBkcmFnZ2FibGVQcm9wcy52ZXJ0aWNhbCA9IHRoaXMucHJvcHMuZGlyZWN0aW9uICE9PSBcImhvcml6b250YWxcIjtcbiAgICAgIGRyYWdnYWJsZVByb3BzLmRpcmVjdGlvbkxvY2sgPSB0aGlzLnByb3BzLmRpcmVjdGlvbkxvY2s7XG4gICAgICBkcmFnZ2FibGVQcm9wcy5tb3VzZVdoZWVsID0gdHJ1ZTtcbiAgICAgIGRyYWdnYWJsZVByb3BzLmxlZnQgPSB0aGlzLnByb3BzLmNvbnRlbnRPZmZzZXRYO1xuICAgICAgZHJhZ2dhYmxlUHJvcHMudG9wID0gdGhpcy5wcm9wcy5jb250ZW50T2Zmc2V0WTtcbiAgICAgIGRyYWdnYWJsZVByb3BzLnByZXNlcnZlM2QgPSB0aGlzLnByb3BzLnByZXNlcnZlM2Q7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQyNihEZXByZWNhdGVkRnJhbWUsIHtcbiAgICAgICAgLi4uZnJhbWVQcm9wc1xuICAgICAgfSwgLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQyNihEcmFnZ2FibGUsIHtcbiAgICAgICAgLi4uZHJhZ2dhYmxlUHJvcHNcbiAgICAgIH0sIGNoaWxkcmVuKSwgLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQyNihFbXB0eVN0YXRlLCB7XG4gICAgICAgIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuLFxuICAgICAgICBzaXplOiB7IHdpZHRoOiB3LCBoZWlnaHQ6IGggfSxcbiAgICAgICAgdGl0bGU6IFwiQ29ubmVjdCB0byBzY3JvbGxhYmxlIGFyZWFcIlxuICAgICAgfSkpO1xuICAgIH0pO1xuICB9XG59O1xudmFyIERlcHJlY2F0ZWRTY3JvbGwgPSBfRGVwcmVjYXRlZFNjcm9sbDtcbkRlcHJlY2F0ZWRTY3JvbGwuc3VwcG9ydHNDb25zdHJhaW50cyA9IHRydWU7XG5EZXByZWNhdGVkU2Nyb2xsLnNjcm9sbFByb3BzID0ge1xuICBkcmFnZ2luZ0VuYWJsZWQ6IHRydWUsXG4gIGRpcmVjdGlvbjogXCJ2ZXJ0aWNhbFwiLFxuICBkaXJlY3Rpb25Mb2NrOiB0cnVlLFxuICBtb3VzZVdoZWVsOiB0cnVlLFxuICBjb250ZW50T2Zmc2V0WDogbnVsbCxcbiAgY29udGVudE9mZnNldFk6IG51bGxcbn07XG5EZXByZWNhdGVkU2Nyb2xsLmRlZmF1bHRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIERlcHJlY2F0ZWRGcmFtZS5kZWZhdWx0UHJvcHMsIF9EZXByZWNhdGVkU2Nyb2xsLnNjcm9sbFByb3BzLCB7XG4gIG92ZXJmbG93OiBcInZpc2libGVcIixcbiAgYmFja2dyb3VuZDogXCJub25lXCIsXG4gIHdpZHRoOiBcIjEwMCVcIixcbiAgaGVpZ2h0OiBcIjEwMCVcIlxufSk7XG5EZXByZWNhdGVkU2Nyb2xsLnByb3BlcnR5Q29udHJvbHMgPSB7XG4gIGRpcmVjdGlvbjoge1xuICAgIHR5cGU6IENvbnRyb2xUeXBlLlNlZ21lbnRlZEVudW0sXG4gICAgdGl0bGU6IFwiRGlyZWN0aW9uXCIsXG4gICAgb3B0aW9uczogW1widmVydGljYWxcIiwgXCJob3Jpem9udGFsXCIsIFwiYm90aFwiXVxuICB9LFxuICBkaXJlY3Rpb25Mb2NrOiB7XG4gICAgdHlwZTogQ29udHJvbFR5cGUuQm9vbGVhbixcbiAgICB0aXRsZTogXCJMb2NrXCIsXG4gICAgZW5hYmxlZFRpdGxlOiBcIjEgQXhpc1wiLFxuICAgIGRpc2FibGVkVGl0bGU6IFwiT2ZmXCIsXG4gICAgaGlkZGVuKHByb3BzKSB7XG4gICAgICByZXR1cm4gcHJvcHMuZGlyZWN0aW9uICE9PSBcImJvdGhcIjtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9jb21wb25lbnRzL1NjcmVlbi50c3hcbmltcG9ydCB7XG4gIENvbXBvbmVudCBhcyBDb21wb25lbnQ5LFxuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQyNyxcbiAgY3JlYXRlUmVmIGFzIGNyZWF0ZVJlZjJcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9ldmVudHMvcmVjb2duaXplci9HZXN0dXJlUmVjb2duaXplci50c1xudmFyIFN0YXRlMztcbihmdW5jdGlvbihTdGF0ZTQpIHtcbiAgU3RhdGU0W1N0YXRlNFtcIlBvc3NpYmxlXCJdID0gMl0gPSBcIlBvc3NpYmxlXCI7XG4gIFN0YXRlNFtTdGF0ZTRbXCJCZWdhblwiXSA9IDRdID0gXCJCZWdhblwiO1xuICBTdGF0ZTRbU3RhdGU0W1wiQ2hhbmdlZFwiXSA9IDhdID0gXCJDaGFuZ2VkXCI7XG4gIFN0YXRlNFtTdGF0ZTRbXCJFbmRlZFwiXSA9IDE2XSA9IFwiRW5kZWRcIjtcbiAgU3RhdGU0W1N0YXRlNFtcIkZhaWxlZFwiXSA9IDMyXSA9IFwiRmFpbGVkXCI7XG4gIFN0YXRlNFtTdGF0ZTRbXCJDYW5jZWxsZWRcIl0gPSA2NF0gPSBcIkNhbmNlbGxlZFwiO1xuICBTdGF0ZTRbU3RhdGU0W1wiUmVjb2duaXplZFwiXSA9IDEyOF0gPSBcIlJlY29nbml6ZWRcIjtcbn0pKFN0YXRlMyB8fCAoU3RhdGUzID0ge30pKTtcbmZ1bmN0aW9uIHN0YXRlTmFtZShzdGF0ZSkge1xuICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIFwiUG9zc2libGVcIjtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gXCJCZWdhblwiO1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiBcIkNoYW5nZWRcIjtcbiAgICBjYXNlIDE2OlxuICAgICAgcmV0dXJuIFwiRW5kZWRcIjtcbiAgICBjYXNlIDMyOlxuICAgICAgcmV0dXJuIFwiRmFpbGVkXCI7XG4gICAgY2FzZSA2NDpcbiAgICAgIHJldHVybiBcIkNhbmNlbGxlZFwiO1xuICAgIGNhc2UgMTI4OlxuICAgICAgcmV0dXJuIFwiUmVjb2duaXplZFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJVbmtub3duXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbnRhaW5zQml0bWFzayh2YWx1ZSwgYml0bWFzaykge1xuICByZXR1cm4gKHZhbHVlICYgYml0bWFzaykgIT09IDA7XG59XG52YXIgR2VzdHVyZVJlY29nbml6ZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3N0YXRlID0gMjtcbiAgICB0aGlzLnByZXZlbnRlcnMgPSBbXTtcbiAgfVxuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG4gIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgfVxuICBnZXQgaXNQcmV2ZW50ZWQoKSB7XG4gICAgbGV0IHByZXZlbnRlZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgcmVjb2duaXplciBvZiB0aGlzLnByZXZlbnRlcnMpIHtcbiAgICAgIGlmIChyZWNvZ25pemVyLnN0YXRlICYgKDQgfCA4IHwgMTYpKSB7XG4gICAgICAgIHByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJldmVudGVkO1xuICB9XG4gIGNhbkJlUHJldmVudGVkQnkocmVjb2duaXplcikge1xuICAgIHRoaXMucHJldmVudGVycy5wdXNoKHJlY29nbml6ZXIpO1xuICB9XG4gIGhhc1N0YXRlKGJpdG1hc2spIHtcbiAgICByZXR1cm4gY29udGFpbnNCaXRtYXNrKHRoaXMuc3RhdGUsIGJpdG1hc2spO1xuICB9XG4gIHN0YXRlU3dpdGNoKG5ld1N0YXRlKSB7XG4gICAgbGV0IGFsbG93ZWRTdGF0ZXM7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGFsbG93ZWRTdGF0ZXMgPSA0IHwgMTI4IHwgMzI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICBhbGxvd2VkU3RhdGVzID0gOCB8IDY0IHwgMTY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA4OlxuICAgICAgICBhbGxvd2VkU3RhdGVzID0gOCB8IDY0IHwgMTY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjg6XG4gICAgICBjYXNlIDE2OlxuICAgICAgY2FzZSA2NDpcbiAgICAgIGNhc2UgMzI6XG4gICAgICAgIGFsbG93ZWRTdGF0ZXMgPSAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFsbG93ZWRTdGF0ZXMgPSAwO1xuICAgIH1cbiAgICBpZiAoIWNvbnRhaW5zQml0bWFzayhuZXdTdGF0ZSwgYWxsb3dlZFN0YXRlcykpIHtcbiAgICAgIGNvbnNvbGUud2FybihgVW5hbGxvd2VkIHN0YXRlIGNoYW5nZSBmcm9tICR7c3RhdGVOYW1lKHRoaXMuc3RhdGUpfSB0byAke3N0YXRlTmFtZShuZXdTdGF0ZSl9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdGUobmV3U3RhdGUpO1xuICB9XG4gIGNhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5oYXNTdGF0ZSg0IHwgOCkpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoNjQpO1xuICAgIH1cbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgaWYgKCF0aGlzLmhhc1N0YXRlKDIpKSB7XG4gICAgICB0aGlzLnN0YXRlU3dpdGNoKDIpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9yZWNvZ25pemVyL1Bhbkdlc3R1cmVSZWNvZ25pemVyLnRzXG52YXIgUGFuR2VzdHVyZVJlY29nbml6ZXIgPSBjbGFzcyBleHRlbmRzIEdlc3R1cmVSZWNvZ25pemVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmV2ZW50VHlwZSA9IFwicGFuXCI7XG4gIH1cbiAgcG9pbnRlclNlc3Npb25CZWdhbihzZXNzaW9uLCBldmVudCkge1xuICAgIHRoaXMucmVjb2duaXplKHNlc3Npb24sIGV2ZW50KTtcbiAgfVxuICBwb2ludGVyU2Vzc2lvbk1vdmVkKHNlc3Npb24sIGV2ZW50KSB7XG4gICAgdGhpcy5yZWNvZ25pemUoc2Vzc2lvbiwgZXZlbnQpO1xuICB9XG4gIHBvaW50ZXJTZXNzaW9uRW5kZWQoc2Vzc2lvbiwgZXZlbnQpIHtcbiAgICB0aGlzLnBhbmVuZChldmVudCk7XG4gIH1cbiAgcmVjb2duaXplKHNlc3Npb24sIGV2ZW50KSB7XG4gICAgaWYgKE1hdGguYWJzKGV2ZW50LmRlbHRhLngpID4gMCB8fCBNYXRoLmFicyhldmVudC5kZWx0YS55KSA+IDApIHtcbiAgICAgIGlmICh0aGlzLnN0YXJ0RXZlbnQpIHtcbiAgICAgICAgdGhpcy5wYW4oZXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYW5zdGFydChldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuc3RhcnRFdmVudCA9IG51bGw7XG4gICAgc3VwZXIucmVzZXQoKTtcbiAgfVxuICBwYW5zdGFydChldmVudCkge1xuICAgIGlmICghdGhpcy5oYXNTdGF0ZShTdGF0ZTMuUG9zc2libGUpIHx8IGV2ZW50LmlzTGVmdE1vdXNlQ2xpY2sgIT09IHZvaWQgMCAmJiAhZXZlbnQuaXNMZWZ0TW91c2VDbGljaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlU3dpdGNoKFN0YXRlMy5CZWdhbik7XG4gICAgdGhpcy5zdGFydEV2ZW50ID0gZXZlbnQ7XG4gICAgaWYgKHRoaXMuaGFuZGxlciAmJiB0aGlzLnN0YXJ0RXZlbnQudGFyZ2V0KSB7XG4gICAgICB0aGlzLmhhbmRsZXIuZ2VzdHVyZUJlZ2FuKHRoaXMuZXZlbnRUeXBlLCBldmVudCwgdGhpcy5zdGFydEV2ZW50LnRhcmdldCk7XG4gICAgfVxuICB9XG4gIHBhbihldmVudCkge1xuICAgIGlmICghdGhpcy5oYXNTdGF0ZShTdGF0ZTMuQmVnYW4gfCBTdGF0ZTMuQ2hhbmdlZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnN0YXJ0RXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZVN3aXRjaChTdGF0ZTMuQ2hhbmdlZCk7XG4gICAgaWYgKHRoaXMuaGFuZGxlciAmJiB0aGlzLnN0YXJ0RXZlbnQudGFyZ2V0KSB7XG4gICAgICB0aGlzLmhhbmRsZXIuZ2VzdHVyZUNoYW5nZWQodGhpcy5ldmVudFR5cGUsIGV2ZW50LCB0aGlzLnN0YXJ0RXZlbnQudGFyZ2V0KTtcbiAgICB9XG4gIH1cbiAgcGFuZW5kKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmhhc1N0YXRlKFN0YXRlMy5CZWdhbiB8IFN0YXRlMy5DaGFuZ2VkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc3RhcnRFdmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlU3dpdGNoKFN0YXRlMy5FbmRlZCk7XG4gICAgaWYgKHRoaXMuaGFuZGxlciAmJiB0aGlzLnN0YXJ0RXZlbnQudGFyZ2V0KSB7XG4gICAgICB0aGlzLmhhbmRsZXIuZ2VzdHVyZUVuZGVkKHRoaXMuZXZlbnRUeXBlLCBldmVudCwgdGhpcy5zdGFydEV2ZW50LnRhcmdldCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL3JlY29nbml6ZXIvVGFwR2VzdHVyZVJlY29nbml6ZXIudHNcbnZhciBUYXBHZXN0dXJlUmVjb2duaXplciA9IGNsYXNzIGV4dGVuZHMgR2VzdHVyZVJlY29nbml6ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZXZlbnRUeXBlID0gXCJ0YXBcIjtcbiAgfVxuICBwb2ludGVyU2Vzc2lvbkJlZ2FuKHNlc3Npb24sIGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlciAmJiAoZXZlbnQuaXNMZWZ0TW91c2VDbGljayA9PT0gdm9pZCAwIHx8IGV2ZW50LmlzTGVmdE1vdXNlQ2xpY2spKSB7XG4gICAgICB0aGlzLmhhbmRsZXIuZ2VzdHVyZUJlZ2FuKHRoaXMuZXZlbnRUeXBlLCBldmVudCwgbnVsbCk7XG4gICAgfVxuICB9XG4gIHBvaW50ZXJTZXNzaW9uTW92ZWQoc2Vzc2lvbiwgZXZlbnQpIHtcbiAgfVxuICBwb2ludGVyU2Vzc2lvbkVuZGVkKHNlc3Npb24sIGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuaXNQcmV2ZW50ZWQpIHtcbiAgICAgIHRoaXMuc3RhdGVTd2l0Y2goU3RhdGUzLkZhaWxlZCk7XG4gICAgfSBlbHNlIGlmICghc2Vzc2lvbi5zdGFydEV2ZW50IHx8IHNlc3Npb24uc3RhcnRFdmVudC50YXJnZXQgPT09IGV2ZW50LnRhcmdldCkge1xuICAgICAgdGhpcy5zdGF0ZVN3aXRjaChTdGF0ZTMuUmVjb2duaXplZCk7XG4gICAgICBpZiAodGhpcy5oYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlci5nZXN0dXJlQ2hhbmdlZCh0aGlzLmV2ZW50VHlwZSwgZXZlbnQsIG51bGwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlU3dpdGNoKFN0YXRlMy5GYWlsZWQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYW5kbGVyKSB7XG4gICAgICB0aGlzLmhhbmRsZXIuZ2VzdHVyZUVuZGVkKHRoaXMuZXZlbnRUeXBlLCBldmVudCwgbnVsbCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL3JlY29nbml6ZXIvTW91c2VXaGVlbEdlc3R1cmVSZWNvZ25pemVyLnRzXG52YXIgTW91c2VXaGVlbEdlc3R1cmVSZWNvZ25pemVyID0gY2xhc3MgZXh0ZW5kcyBHZXN0dXJlUmVjb2duaXplciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5ldmVudFR5cGUgPSBcIm1vdXNld2hlZWxcIjtcbiAgICB0aGlzLm9uTW91c2VXaGVlbEVuZCA9IGRlYm91bmNlKChldmVudCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaGFuZGxlciAmJiB0aGlzLnN0YXJ0RXZlbnQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZVN3aXRjaChTdGF0ZTMuRW5kZWQpO1xuICAgICAgICB0aGlzLmhhbmRsZXIuZ2VzdHVyZUVuZGVkKHRoaXMuZXZlbnRUeXBlLCBldmVudCwgdGhpcy5zdGFydEV2ZW50LnRhcmdldCk7XG4gICAgICAgIHRoaXMuc3RhcnRFdmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9LCAzMDApO1xuICB9XG4gIHBvaW50ZXJTZXNzaW9uQmVnYW4oc2Vzc2lvbiwgZXZlbnQpIHtcbiAgfVxuICBwb2ludGVyU2Vzc2lvbk1vdmVkKHNlc3Npb24sIGV2ZW50KSB7XG4gIH1cbiAgcG9pbnRlclNlc3Npb25FbmRlZChzZXNzaW9uLCBldmVudCkge1xuICB9XG4gIG1vdXNlV2hlZWwoc2Vzc2lvbiwgZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuaGFuZGxlcilcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5oYXNTdGF0ZShTdGF0ZTMuUG9zc2libGUpKSB7XG4gICAgICB0aGlzLnN0YXJ0RXZlbnQgPSBldmVudDtcbiAgICAgIHRoaXMuc3RhdGVTd2l0Y2goU3RhdGUzLkJlZ2FuKTtcbiAgICAgIHRoaXMuaGFuZGxlci5nZXN0dXJlQmVnYW4odGhpcy5ldmVudFR5cGUsIGV2ZW50LCB0aGlzLnN0YXJ0RXZlbnQudGFyZ2V0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzU3RhdGUoU3RhdGUzLkJlZ2FuIHwgU3RhdGUzLkNoYW5nZWQpICYmIHRoaXMuc3RhcnRFdmVudCkge1xuICAgICAgdGhpcy5zdGF0ZVN3aXRjaChTdGF0ZTMuQ2hhbmdlZCk7XG4gICAgICB0aGlzLmhhbmRsZXIuZ2VzdHVyZUNoYW5nZWQodGhpcy5ldmVudFR5cGUsIGV2ZW50LCB0aGlzLnN0YXJ0RXZlbnQudGFyZ2V0KTtcbiAgICB9XG4gICAgdGhpcy5vbk1vdXNlV2hlZWxFbmQoZXZlbnQpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL0ZyYW1lckV2ZW50U2Vzc2lvbi50c1xudmFyIEZyYW1lckV2ZW50U2Vzc2lvbiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZGlzcGF0Y2hlciwgY3VzdG9tT3JpZ2luKSB7XG4gICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICB0aGlzLnJlY29nbml6ZXJzID0gW107XG4gICAgdGhpcy5tb3VzZVdoZWVsUmVjb2duaXplciA9IG5ldyBNb3VzZVdoZWVsR2VzdHVyZVJlY29nbml6ZXIoKTtcbiAgICB0aGlzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xuICAgIGlmIChjdXN0b21PcmlnaW4pIHtcbiAgICAgIHRoaXMub3JpZ2luRWxlbWVudCA9IGN1c3RvbU9yaWdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcmlnaW5FbGVtZW50ID0gZG9jdW1lbnQuYm9keTtcbiAgICB9XG4gICAgY29uc3QgcGFuID0gbmV3IFBhbkdlc3R1cmVSZWNvZ25pemVyKCk7XG4gICAgY29uc3QgdGFwID0gbmV3IFRhcEdlc3R1cmVSZWNvZ25pemVyKCk7XG4gICAgcGFuLmhhbmRsZXIgPSB0aGlzO1xuICAgIHRhcC5oYW5kbGVyID0gdGhpcztcbiAgICB0aGlzLm1vdXNlV2hlZWxSZWNvZ25pemVyLmhhbmRsZXIgPSB0aGlzO1xuICAgIHRoaXMucmVjb2duaXplcnMgPSBbdGFwLCBwYW5dO1xuICB9XG4gIGdldCBpc1N0YXJ0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRzLmxlbmd0aCAhPT0gMDtcbiAgfVxuICBnZXQgc3RhcnRFdmVudCgpIHtcbiAgICBpZiAodGhpcy5pc1N0YXJ0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmV2ZW50c1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGdldCBsYXN0RXZlbnQoKSB7XG4gICAgaWYgKHRoaXMuZXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmV2ZW50c1t0aGlzLmV2ZW50cy5sZW5ndGggLSAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHByb2Nlc3NFdmVudChldmVudCkge1xuICAgIHRoaXMuZXZlbnRzLnB1c2goZXZlbnQpO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICBwb2ludGVyRG93bihldmVudCkge1xuICAgIGlmICh0aGlzLmlzU3RhcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NFdmVudChldmVudCk7XG4gICAgdGhpcy5yZWNvZ25pemVycy5tYXAoKHIpID0+IHtcbiAgICAgIHIuY2FuY2VsKCk7XG4gICAgICByLnBvaW50ZXJTZXNzaW9uQmVnYW4odGhpcywgZXZlbnQpO1xuICAgIH0pO1xuICB9XG4gIHBvaW50ZXJNb3ZlKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmlzU3RhcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NFdmVudChldmVudCk7XG4gICAgdGhpcy5yZWNvZ25pemVycy5tYXAoKHIpID0+IHtcbiAgICAgIHIucG9pbnRlclNlc3Npb25Nb3ZlZCh0aGlzLCBldmVudCk7XG4gICAgfSk7XG4gIH1cbiAgcG9pbnRlclVwKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmlzU3RhcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NFdmVudChldmVudCk7XG4gICAgdGhpcy5yZWNvZ25pemVycy5tYXAoKHIpID0+IHtcbiAgICAgIHIucG9pbnRlclNlc3Npb25FbmRlZCh0aGlzLCBldmVudCk7XG4gICAgfSk7XG4gICAgdGhpcy5jbGVhckV2ZW50cygpO1xuICAgIHRoaXMucmVjb2duaXplcnMubWFwKChyKSA9PiB7XG4gICAgICByLnJlc2V0KCk7XG4gICAgfSk7XG4gIH1cbiAgbW91c2VXaGVlbChldmVudCkge1xuICAgIHRoaXMucHJvY2Vzc0V2ZW50KGV2ZW50KTtcbiAgICB0aGlzLm1vdXNlV2hlZWxSZWNvZ25pemVyLm1vdXNlV2hlZWwodGhpcywgZXZlbnQpO1xuICAgIHRoaXMuY2xlYXJFdmVudHMoKTtcbiAgfVxuICBjbGVhckV2ZW50cygpIHtcbiAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICB9XG4gIGRpc3BhdGNoKHR5cGUsIGV2ZW50LCB0YXJnZXQgPSBudWxsKSB7XG4gICAgY29uc3QgZGlzcGF0Y2hUYXJnZXQgPSB0YXJnZXQgfHwgdGhpcy5zdGFydEV2ZW50ICYmIHRoaXMuc3RhcnRFdmVudC50YXJnZXQgfHwgZXZlbnQudGFyZ2V0O1xuICAgIGlmIChkaXNwYXRjaFRhcmdldCkge1xuICAgICAgdGhpcy5kaXNwYXRjaGVyKHR5cGUsIGV2ZW50LCBkaXNwYXRjaFRhcmdldCk7XG4gICAgfVxuICB9XG4gIGdlc3R1cmVCZWdhbih0eXBlLCBldmVudCwgdGFyZ2V0KSB7XG4gICAgdGhpcy5kaXNwYXRjaChgJHt0eXBlfXN0YXJ0YCwgZXZlbnQsIHRhcmdldCk7XG4gIH1cbiAgZ2VzdHVyZUNoYW5nZWQodHlwZSwgZXZlbnQsIHRhcmdldCkge1xuICAgIHRoaXMuZGlzcGF0Y2godHlwZSwgZXZlbnQsIHRhcmdldCk7XG4gIH1cbiAgZ2VzdHVyZUVuZGVkKHR5cGUsIGV2ZW50LCB0YXJnZXQpIHtcbiAgICB0aGlzLmRpc3BhdGNoKGAke3R5cGV9ZW5kYCwgZXZlbnQsIHRhcmdldCk7XG4gIH1cbiAgdmVsb2NpdHkodCA9IExvb3AuVGltZVN0ZXAgKiAyKSB7XG4gICAgaWYgKCF0aGlzLmlzU3RhcnRlZCB8fCB0aGlzLmV2ZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50czIgPSB0aGlzLmV2ZW50cztcbiAgICBsZXQgaSA9IGV2ZW50czIubGVuZ3RoIC0gMTtcbiAgICBsZXQgZXZlbnQgPSBudWxsO1xuICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgIGV2ZW50ID0gZXZlbnRzMltpXTtcbiAgICAgIGlmIChNYWluTG9vcC50aW1lIC0gZXZlbnQubG9vcFRpbWUgPiB0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaS0tO1xuICAgIH1cbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnQgPSBldmVudHMyW2V2ZW50czIubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgdGltZTMgPSAoTWFpbkxvb3AudGltZSAtIGV2ZW50Lmxvb3BUaW1lKSAqIDFlMztcbiAgICBpZiAodGltZTMgPT09IDApIHtcbiAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgICB9XG4gICAgY29uc3QgdmVsb2NpdHkgPSB7XG4gICAgICB4OiAoY3VycmVudC5kZXZpY2VQb2ludC54IC0gZXZlbnQuZGV2aWNlUG9pbnQueCkgLyB0aW1lMyxcbiAgICAgIHk6IChjdXJyZW50LmRldmljZVBvaW50LnkgLSBldmVudC5kZXZpY2VQb2ludC55KSAvIHRpbWUzXG4gICAgfTtcbiAgICBpZiAodmVsb2NpdHkueCA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHZlbG9jaXR5LnggPSAwO1xuICAgIH1cbiAgICBpZiAodmVsb2NpdHkueSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHZlbG9jaXR5LnkgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdmVsb2NpdHk7XG4gIH1cbiAgb2Zmc2V0KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnN0YXJ0RXZlbnQpIHtcbiAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgICB9XG4gICAgY29uc3Qgc3VidHJhY3QgPSAocG9pbnRBLCBwb2ludEIpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBvaW50QS54IC0gcG9pbnRCLngsXG4gICAgICAgIHk6IHBvaW50QS55IC0gcG9pbnRCLnlcbiAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gc3VidHJhY3QoZXZlbnQuZGV2aWNlUG9pbnQsIHRoaXMuc3RhcnRFdmVudC5kZXZpY2VQb2ludCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMvcmVjb2duaXplci9Ub3VjaEV2ZW50TGlzdGVuZXIudHNcbmltcG9ydCB7XG4gIENvbXBvbmVudCBhcyBDb21wb25lbnQ3XG59IGZyb20gXCJyZWFjdFwiO1xudmFyIFRvdWNoRXZlbnRMaXN0ZW5lciA9IGNsYXNzIGV4dGVuZHMgQ29tcG9uZW50NyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5kb21Ub3VjaFN0YXJ0ID0gKG9yaWdpbmFsRXZlbnQpID0+IHtcbiAgICAgIHNhZmVXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLmRvbVRvdWNoTW92ZSk7XG4gICAgICBzYWZlV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLmRvbVRvdWNoRW5kKTtcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEZyYW1lckV2ZW50KG9yaWdpbmFsRXZlbnQsIHRoaXMucHJvcHMuc2Vzc2lvbik7XG4gICAgICB0aGlzLnByb3BzLnNlc3Npb24ucG9pbnRlckRvd24oZXZlbnQpO1xuICAgIH07XG4gICAgdGhpcy5kb21Ub3VjaE1vdmUgPSAob3JpZ2luYWxFdmVudCkgPT4ge1xuICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRnJhbWVyRXZlbnQob3JpZ2luYWxFdmVudCwgdGhpcy5wcm9wcy5zZXNzaW9uKTtcbiAgICAgIHRoaXMucHJvcHMuc2Vzc2lvbi5wb2ludGVyTW92ZShldmVudCk7XG4gICAgfTtcbiAgICB0aGlzLmRvbVRvdWNoRW5kID0gKG9yaWdpbmFsRXZlbnQpID0+IHtcbiAgICAgIHNhZmVXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLmRvbVRvdWNoTW92ZSk7XG4gICAgICBzYWZlV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLmRvbVRvdWNoRW5kKTtcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEZyYW1lckV2ZW50KG9yaWdpbmFsRXZlbnQsIHRoaXMucHJvcHMuc2Vzc2lvbik7XG4gICAgICB0aGlzLnByb3BzLnNlc3Npb24ucG9pbnRlclVwKGV2ZW50KTtcbiAgICB9O1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBzYWZlV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuZG9tVG91Y2hTdGFydCk7XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgc2FmZVdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLmRvbVRvdWNoU3RhcnQpO1xuICAgIHNhZmVXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLmRvbVRvdWNoTW92ZSk7XG4gICAgc2FmZVdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5kb21Ub3VjaEVuZCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMvcmVjb2duaXplci9Nb3VzZUV2ZW50TGlzdGVuZXIudHNcbmltcG9ydCB7XG4gIENvbXBvbmVudCBhcyBDb21wb25lbnQ4XG59IGZyb20gXCJyZWFjdFwiO1xudmFyIE1vdXNlRXZlbnRMaXN0ZW5lciA9IGNsYXNzIGV4dGVuZHMgQ29tcG9uZW50OCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5kb21Nb3VzZURvd24gPSAob3JpZ2luYWxFdmVudCkgPT4ge1xuICAgICAgc2FmZVdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuZG9tTW91c2VNb3ZlKTtcbiAgICAgIHNhZmVXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5kb21Nb3VzZVVwKTtcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEZyYW1lckV2ZW50KG9yaWdpbmFsRXZlbnQsIHRoaXMucHJvcHMuc2Vzc2lvbik7XG4gICAgICB0aGlzLnByb3BzLnNlc3Npb24ucG9pbnRlckRvd24oZXZlbnQpO1xuICAgIH07XG4gICAgdGhpcy5kb21Nb3VzZU1vdmUgPSAob3JpZ2luYWxFdmVudCkgPT4ge1xuICAgICAgY29uc3QgbGVmdE1vdXNlQnV0dG9uT25seURvd24gPSBvcmlnaW5hbEV2ZW50LmJ1dHRvbnMgPT09IHZvaWQgMCA/IG9yaWdpbmFsRXZlbnQud2hpY2ggPT09IDEgOiBvcmlnaW5hbEV2ZW50LmJ1dHRvbnMgPT09IDE7XG4gICAgICBpZiAoIWxlZnRNb3VzZUJ1dHRvbk9ubHlEb3duKSB7XG4gICAgICAgIHRoaXMuZG9tTW91c2VVcChvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRnJhbWVyRXZlbnQob3JpZ2luYWxFdmVudCwgdGhpcy5wcm9wcy5zZXNzaW9uKTtcbiAgICAgIHRoaXMucHJvcHMuc2Vzc2lvbi5wb2ludGVyTW92ZShldmVudCk7XG4gICAgfTtcbiAgICB0aGlzLmRvbU1vdXNlVXAgPSAob3JpZ2luYWxFdmVudCkgPT4ge1xuICAgICAgc2FmZVdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuZG9tTW91c2VNb3ZlKTtcbiAgICAgIHNhZmVXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5kb21Nb3VzZVVwKTtcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEZyYW1lckV2ZW50KG9yaWdpbmFsRXZlbnQsIHRoaXMucHJvcHMuc2Vzc2lvbik7XG4gICAgICB0aGlzLnByb3BzLnNlc3Npb24ucG9pbnRlclVwKGV2ZW50KTtcbiAgICB9O1xuICAgIHRoaXMuZG9tTW91c2VXaGVlbCA9IChvcmlnaW5hbEV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBldmVudCA9IG5ldyBGcmFtZXJFdmVudChvcmlnaW5hbEV2ZW50LCB0aGlzLnByb3BzLnNlc3Npb24pO1xuICAgICAgdGhpcy5wcm9wcy5zZXNzaW9uLm1vdXNlV2hlZWwoZXZlbnQpO1xuICAgIH07XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHNhZmVXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLmRvbU1vdXNlRG93bik7XG4gICAgc2FmZVdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgdGhpcy5kb21Nb3VzZVdoZWVsKTtcbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBzYWZlV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5kb21Nb3VzZU1vdmUpO1xuICAgIHNhZmVXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLmRvbU1vdXNlRG93bik7XG4gICAgc2FmZVdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLmRvbU1vdXNlVXApO1xuICAgIHNhZmVXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMuZG9tTW91c2VXaGVlbCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMvRnJhbWVyRXZlbnRMaXN0ZW5lci50c1xudmFyIEZyYW1lckV2ZW50TGlzdGVuZXIgPSBlbnZpcm9ubWVudF9leHBvcnRzLmlzVG91Y2goKSA/IFRvdWNoRXZlbnRMaXN0ZW5lciA6IE1vdXNlRXZlbnRMaXN0ZW5lcjtcblxuLy8gc3JjL2NvbXBvbmVudHMvTmF2aWdhdGlvbi50c3hcbmltcG9ydCB7XG4gIENoaWxkcmVuIGFzIENoaWxkcmVuOCxcbiAgQ29tcG9uZW50IGFzIENvbXBvbmVudDEyLFxuICBTdXNwZW5zZSxcbiAgY2xvbmVFbGVtZW50IGFzIGNsb25lRWxlbWVudDYsXG4gIGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDE1LFxuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQzMlxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2NvbXBvbmVudHMvTmF2aWdhdGlvblRyYW5zaXRpb25zLnRzXG52YXIgVHJhbnNpdGlvbkRlZmF1bHRzO1xuKGZ1bmN0aW9uKFRyYW5zaXRpb25EZWZhdWx0czIpIHtcbiAgVHJhbnNpdGlvbkRlZmF1bHRzMi5GYWRlID0ge1xuICAgIGV4aXQ6IHsgb3BhY2l0eTogMCB9LFxuICAgIGVudGVyOiB7IG9wYWNpdHk6IDAgfVxuICB9O1xuICBUcmFuc2l0aW9uRGVmYXVsdHMyLlB1c2hMZWZ0ID0ge1xuICAgIGV4aXQ6IHsgeDogXCItMzAlXCIgfSxcbiAgICBlbnRlcjogeyB4OiBcIjEwMCVcIiB9XG4gIH07XG4gIFRyYW5zaXRpb25EZWZhdWx0czIuUHVzaFJpZ2h0ID0ge1xuICAgIGV4aXQ6IHsgeDogXCIzMCVcIiB9LFxuICAgIGVudGVyOiB7IHg6IFwiLTEwMCVcIiB9XG4gIH07XG4gIFRyYW5zaXRpb25EZWZhdWx0czIuUHVzaFVwID0ge1xuICAgIGV4aXQ6IHsgeTogXCItMzAlXCIgfSxcbiAgICBlbnRlcjogeyB5OiBcIjEwMCVcIiB9XG4gIH07XG4gIFRyYW5zaXRpb25EZWZhdWx0czIuUHVzaERvd24gPSB7XG4gICAgZXhpdDogeyB5OiBcIjMwJVwiIH0sXG4gICAgZW50ZXI6IHsgeTogXCItMTAwJVwiIH1cbiAgfTtcbiAgVHJhbnNpdGlvbkRlZmF1bHRzMi5JbnN0YW50ID0ge1xuICAgIGFuaW1hdGlvbjogeyB0eXBlOiBmYWxzZSB9LFxuICAgIGVudGVyOiB7IG9wYWNpdHk6IDAgfVxuICB9O1xuICBUcmFuc2l0aW9uRGVmYXVsdHMyLk1vZGFsID0ge1xuICAgIG92ZXJDdXJyZW50Q29udGV4dDogdHJ1ZSxcbiAgICBnb0JhY2tPblRhcE91dHNpZGU6IHRydWUsXG4gICAgcG9zaXRpb246IHsgY2VudGVyOiB0cnVlIH0sXG4gICAgZW50ZXI6IHsgb3BhY2l0eTogMCwgc2NhbGU6IDEuMiB9XG4gIH07XG4gIFRyYW5zaXRpb25EZWZhdWx0czIuT3ZlcmxheUxlZnQgPSB7XG4gICAgb3ZlckN1cnJlbnRDb250ZXh0OiB0cnVlLFxuICAgIGdvQmFja09uVGFwT3V0c2lkZTogdHJ1ZSxcbiAgICBwb3NpdGlvbjogeyByaWdodDogMCwgdG9wOiAwLCBib3R0b206IDAgfSxcbiAgICBlbnRlcjogeyB4OiBcIjEwMCVcIiB9XG4gIH07XG4gIFRyYW5zaXRpb25EZWZhdWx0czIuT3ZlcmxheVJpZ2h0ID0ge1xuICAgIG92ZXJDdXJyZW50Q29udGV4dDogdHJ1ZSxcbiAgICBnb0JhY2tPblRhcE91dHNpZGU6IHRydWUsXG4gICAgcG9zaXRpb246IHsgbGVmdDogMCwgdG9wOiAwLCBib3R0b206IDAgfSxcbiAgICBlbnRlcjogeyB4OiBcIi0xMDAlXCIgfVxuICB9O1xuICBUcmFuc2l0aW9uRGVmYXVsdHMyLk92ZXJsYXlVcCA9IHtcbiAgICBvdmVyQ3VycmVudENvbnRleHQ6IHRydWUsXG4gICAgZ29CYWNrT25UYXBPdXRzaWRlOiB0cnVlLFxuICAgIHBvc2l0aW9uOiB7IGJvdHRvbTogMCwgbGVmdDogMCwgcmlnaHQ6IDAgfSxcbiAgICBlbnRlcjogeyB5OiBcIjEwMCVcIiB9XG4gIH07XG4gIFRyYW5zaXRpb25EZWZhdWx0czIuT3ZlcmxheURvd24gPSB7XG4gICAgb3ZlckN1cnJlbnRDb250ZXh0OiB0cnVlLFxuICAgIGdvQmFja09uVGFwT3V0c2lkZTogdHJ1ZSxcbiAgICBwb3NpdGlvbjogeyB0b3A6IDAsIGxlZnQ6IDAsIHJpZ2h0OiAwIH0sXG4gICAgZW50ZXI6IHsgeTogXCItMTAwJVwiIH1cbiAgfTtcbiAgVHJhbnNpdGlvbkRlZmF1bHRzMi5GbGlwTGVmdCA9IHtcbiAgICBiYWNrZmFjZVZpc2libGU6IGZhbHNlLFxuICAgIGV4aXQ6IHsgcm90YXRlWTogLTE4MCB9LFxuICAgIGVudGVyOiB7IHJvdGF0ZVk6IDE4MCB9XG4gIH07XG4gIFRyYW5zaXRpb25EZWZhdWx0czIuRmxpcFJpZ2h0ID0ge1xuICAgIGJhY2tmYWNlVmlzaWJsZTogZmFsc2UsXG4gICAgZXhpdDogeyByb3RhdGVZOiAxODAgfSxcbiAgICBlbnRlcjogeyByb3RhdGVZOiAtMTgwIH1cbiAgfTtcbiAgVHJhbnNpdGlvbkRlZmF1bHRzMi5GbGlwVXAgPSB7XG4gICAgYmFja2ZhY2VWaXNpYmxlOiBmYWxzZSxcbiAgICBleGl0OiB7IHJvdGF0ZVg6IDE4MCB9LFxuICAgIGVudGVyOiB7IHJvdGF0ZVg6IC0xODAgfVxuICB9O1xuICBUcmFuc2l0aW9uRGVmYXVsdHMyLkZsaXBEb3duID0ge1xuICAgIGJhY2tmYWNlVmlzaWJsZTogZmFsc2UsXG4gICAgZXhpdDogeyByb3RhdGVYOiAtMTgwIH0sXG4gICAgZW50ZXI6IHsgcm90YXRlWDogMTgwIH1cbiAgfTtcbiAgVHJhbnNpdGlvbkRlZmF1bHRzMi5NYWdpY01vdGlvbiA9IHtcbiAgICB3aXRoTWFnaWNNb3Rpb246IHRydWVcbiAgfTtcbn0pKFRyYW5zaXRpb25EZWZhdWx0cyB8fCAoVHJhbnNpdGlvbkRlZmF1bHRzID0ge30pKTtcbmZ1bmN0aW9uIHB1c2hUcmFuc2l0aW9uKG9wdGlvbnMpIHtcbiAgY29uc3Qgc2lkZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hcHBlYXJzRnJvbSA/IG9wdGlvbnMuYXBwZWFyc0Zyb20gOiBcInJpZ2h0XCI7XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgcmV0dXJuIFRyYW5zaXRpb25EZWZhdWx0cy5QdXNoTGVmdDtcbiAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgcmV0dXJuIFRyYW5zaXRpb25EZWZhdWx0cy5QdXNoUmlnaHQ7XG4gICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgcmV0dXJuIFRyYW5zaXRpb25EZWZhdWx0cy5QdXNoVXA7XG4gICAgY2FzZSBcInRvcFwiOlxuICAgICAgcmV0dXJuIFRyYW5zaXRpb25EZWZhdWx0cy5QdXNoRG93bjtcbiAgfVxufVxuZnVuY3Rpb24gb3ZlcmxheVRyYW5zaXRpb24ob3B0aW9ucykge1xuICBjb25zdCBzaWRlID0gb3B0aW9ucyAmJiBvcHRpb25zLmFwcGVhcnNGcm9tID8gb3B0aW9ucy5hcHBlYXJzRnJvbSA6IFwiYm90dG9tXCI7XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgcmV0dXJuIFRyYW5zaXRpb25EZWZhdWx0cy5PdmVybGF5TGVmdDtcbiAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgcmV0dXJuIFRyYW5zaXRpb25EZWZhdWx0cy5PdmVybGF5UmlnaHQ7XG4gICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgcmV0dXJuIFRyYW5zaXRpb25EZWZhdWx0cy5PdmVybGF5VXA7XG4gICAgY2FzZSBcInRvcFwiOlxuICAgICAgcmV0dXJuIFRyYW5zaXRpb25EZWZhdWx0cy5PdmVybGF5RG93bjtcbiAgfVxufVxuZnVuY3Rpb24gZmxpcFRyYW5zaXRpb24ob3B0aW9ucykge1xuICBjb25zdCBzaWRlID0gb3B0aW9ucyAmJiBvcHRpb25zLmFwcGVhcnNGcm9tID8gb3B0aW9ucy5hcHBlYXJzRnJvbSA6IFwiYm90dG9tXCI7XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgcmV0dXJuIFRyYW5zaXRpb25EZWZhdWx0cy5GbGlwTGVmdDtcbiAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgcmV0dXJuIFRyYW5zaXRpb25EZWZhdWx0cy5GbGlwUmlnaHQ7XG4gICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgcmV0dXJuIFRyYW5zaXRpb25EZWZhdWx0cy5GbGlwVXA7XG4gICAgY2FzZSBcInRvcFwiOlxuICAgICAgcmV0dXJuIFRyYW5zaXRpb25EZWZhdWx0cy5GbGlwRG93bjtcbiAgfVxufVxuXG4vLyBzcmMvY29tcG9uZW50cy9OYXZpZ2F0aW9uQ29udGFpbmVyLnRzeFxuaW1wb3J0IHtcbiAgY3JlYXRlRWxlbWVudCBhcyBjcmVhdGVFbGVtZW50MzEsXG4gIG1lbW9cbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VSZWYgYXMgdXNlUmVmMjAsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyMCwgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjUgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2NvbXBvbmVudHMvQW5pbWF0ZUxheW91dC9BbmltYXRlTGF5b3V0VHJlZXMudHN4XG5pbXBvcnQge1xuICBDb21wb25lbnQgYXMgQ29tcG9uZW50MTAsXG4gIGNyZWF0ZUVsZW1lbnQgYXMgY3JlYXRlRWxlbWVudDI4XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvY29tcG9uZW50cy9BbmltYXRlTGF5b3V0L2FuaW1hdGlvbi50c1xuZnVuY3Rpb24gY3JlYXRlQW5pbWF0aW9uKGFuaW1hdGlvbikge1xuICBjb25zdCB7IHNob3VsZFN0YWNrQW5pbWF0ZSwgdHJhbnNpdGlvbiwgY3VycmVudCwgcHJldlZpZXdwb3J0Qm94LCBvbkNvbXBsZXRlLCBwcmV2UGFyZW50IH0gPSBhbmltYXRpb247XG4gIGNvbnN0IGNvbmZpZyA9IHtcbiAgICBzaG91bGRTdGFja0FuaW1hdGUsXG4gICAgdHJhbnNpdGlvbixcbiAgICBjdXJyZW50LFxuICAgIG9uQ29tcGxldGUsXG4gICAgcHJldlBhcmVudDogcHJldlBhcmVudCA/IHByZXZQYXJlbnQgOiB2b2lkIDBcbiAgfTtcbiAgaWYgKCFzaG91bGRTdGFja0FuaW1hdGUpXG4gICAgcmV0dXJuIGNvbmZpZztcbiAgY29uZmlnLm9yaWdpbkJveCA9IHByZXZWaWV3cG9ydEJveDtcbiAgcmV0dXJuIGNvbmZpZztcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvQW5pbWF0ZUxheW91dC9UcmVlQ29udGV4dC50c1xuaW1wb3J0IHtcbiAgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTNcbn0gZnJvbSBcInJlYWN0XCI7XG52YXIgTGF5b3V0VHJlZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0MTMoe1xuICBwcm9tb3RlVHJlZTogKCkgPT4gZmFsc2UsXG4gIG1hcmtUcmVlQXNTYWZlVG9SZW1vdmU6ICgpID0+IHtcbiAgfVxufSk7XG5cbi8vIHNyYy9jb21wb25lbnRzL0FuaW1hdGVMYXlvdXQvQW5pbWF0ZUxheW91dFRyZWVzLnRzeFxudmFyIHN5bmNDb250ZXh0U3R1YiA9IHtcbiAgcmVnaXN0ZXI6ICgpID0+IHtcbiAgfSxcbiAgcmVtb3ZlOiAoKSA9PiB7XG4gIH0sXG4gIGFkZDogKCkgPT4ge1xuICB9LFxuICBmbHVzaDogKCkgPT4ge1xuICB9LFxuICBzeW5jVXBkYXRlOiAoKSA9PiB7XG4gIH1cbn07XG52YXIgVFJFRV9ST09UX0lEID0gXCJfX19fdHJlZXJvb3RcIjtcbnZhciBBbmltYXRlTGF5b3V0VHJlZXMgPSBjbGFzcyBleHRlbmRzIENvbXBvbmVudDEwIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVzZXRTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxheW91dElkQ29uZmlnID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudHJlZUNvbnRleHQgPSB7XG4gICAgICBwcm9tb3RlVHJlZTogKC4uLmFyZ3MpID0+IHRoaXMucHJvbW90ZVRyZWUoLi4uYXJncyksXG4gICAgICBtYXJrVHJlZUFzU2FmZVRvUmVtb3ZlOiAodHJlZSkgPT4gdGhpcy5tYXJrVHJlZUFzU2FmZVRvUmVtb3ZlKHRyZWUpXG4gICAgfTtcbiAgICB0aGlzLnN5bmNDb250ZXh0ID0ge1xuICAgICAgLi4uc3luY0NvbnRleHRTdHViLFxuICAgICAgZm9yY2VVcGRhdGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5zeW5jQ29udGV4dCA9IHtcbiAgICAgICAgICAuLi50aGlzLnN5bmNDb250ZXh0XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYmF0Y2ggPSBjcmVhdGVCYXRjaGVyKCk7XG4gICAgdGhpcy5zdGFja0Nyb3NzZmFkZXJzID0gbmV3IE1hcChbW1RSRUVfUk9PVF9JRCwgY3JlYXRlQ3Jvc3NmYWRlcigpXV0pO1xuICB9XG4gIHByb21vdGVUcmVlKHRyZWUsIHNob3VsZEFuaW1hdGUsIHRyYW5zaXRpb24sIHJlc2V0cykge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGlmICh0cmVlID09PSB0aGlzLmxlYWQpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcHJldkZvbGxvdyA9IHRoaXMuZm9sbG93O1xuICAgIHRoaXMuZm9sbG93ID0gdGhpcy5sZWFkO1xuICAgIHRoaXMubGVhZCA9IHRyZWU7XG4gICAgaWYgKHJlc2V0cylcbiAgICAgIHRoaXMucmVzZXRTY2hlZHVsZWQgPSB0cnVlO1xuICAgIGlmICghc2hvdWxkQW5pbWF0ZSkge1xuICAgICAgdGhpcy5zdGFydENyb3NzZmFkZShuZXcgTWFwKFtbVFJFRV9ST09UX0lELCB7fV1dKSwgeyB0eXBlOiBmYWxzZSB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5sYXlvdXRJZENvbmZpZy5jbGVhcigpO1xuICAgIGNvbnN0IGN1cnJlbnRTdHlsZSA9IHt9O1xuICAgIGZvciAoY29uc3QgW2xheW91dElkLCBsZWFkXSBvZiB0aGlzLmxlYWQuY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGZvbGxvdyA9IChfYSA9IHRoaXMuZm9sbG93KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2hpbGRyZW4uZ2V0KGxheW91dElkKTtcbiAgICAgIHNuYXBzaG90Um90YXRlKGxheW91dElkLCBsZWFkLCBmb2xsb3csIGN1cnJlbnRTdHlsZSk7XG4gICAgICBmb2xsb3cgJiYgcmVzZXRSb3RhdGUyKGZvbGxvdyk7XG4gICAgICByZXNldFJvdGF0ZTIobGVhZCk7XG4gICAgfVxuICAgIHRoaXMubGVhZC5jaGlsZHJlblRvUmVzZXRUcmFuc2Zvcm0uZm9yRWFjaCgoY2hpbGQpID0+IGNoaWxkLnJlc2V0VHJhbnNmb3JtKCkpO1xuICAgIGZvciAoY29uc3QgW2xheW91dElkLCBsZWFkXSBvZiB0aGlzLmxlYWQuY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGZvbGxvdyA9IChfYiA9IHRoaXMuZm9sbG93KSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2hpbGRyZW4uZ2V0KGxheW91dElkKTtcbiAgICAgIGZvbGxvdyAmJiBzbmFwc2hvdFZpZXdwb3J0Qm94KGZvbGxvdyk7XG4gICAgICBzbmFwc2hvdFZpZXdwb3J0Qm94KGxlYWQpO1xuICAgICAgY29uc3QgcHJldlZpZXdwb3J0Qm94ID0gKGZvbGxvdyA9PSBudWxsID8gdm9pZCAwIDogZm9sbG93LnByZXZWaWV3cG9ydEJveCkgPyBjb3B5QXhpc0JveDIoZm9sbG93ID09IG51bGwgPyB2b2lkIDAgOiBmb2xsb3cucHJldlZpZXdwb3J0Qm94KSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgbGVhZCxcbiAgICAgICAgY3VycmVudDogY3VycmVudFN0eWxlW2xheW91dElkXSxcbiAgICAgICAgdHJhbnNpdGlvbixcbiAgICAgICAgcHJldlZpZXdwb3J0Qm94LFxuICAgICAgICBzaG91bGRTdGFja0FuaW1hdGU6IGZvbGxvdyA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgcHJldlBhcmVudDogZm9sbG93ID09IG51bGwgPyB2b2lkIDAgOiBmb2xsb3cuZ2V0UHJvamVjdGlvblBhcmVudCgpXG4gICAgICB9O1xuICAgICAgdGhpcy5sYXlvdXRJZENvbmZpZy5zZXQobGF5b3V0SWQsIGNvbmZpZyk7XG4gICAgfVxuICAgIGlmIChwcmV2Rm9sbG93ICE9PSB0aGlzLmxlYWQgJiYgcHJldkZvbGxvdyAhPT0gdGhpcy5mb2xsb3cpIHtcbiAgICAgIChfYyA9IHByZXZGb2xsb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZGb2xsb3cucm9vdENoaWxkKSA9PSBudWxsID8gdm9pZCAwIDogX2Muc2V0VmlzaWJpbGl0eShmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMuc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBtYXJrVHJlZUFzU2FmZVRvUmVtb3ZlKHRyZWUpIHtcbiAgICB0aGlzLnNhZmVUb1JlbW92ZVRyZWUgPSB0cmVlO1xuICB9XG4gIG1hcmtUcmVlQ2hpbGRyZW5Bc1NhZmVUb1JlbW92ZSh0cmVlKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghdHJlZSlcbiAgICAgIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IFtfLCBjaGlsZF0gb2YgdHJlZS5jaGlsZHJlbikge1xuICAgICAgKF9hID0gY2hpbGQubGF5b3V0U2FmZVRvUmVtb3ZlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChjaGlsZCk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5zY2hlZHVsZWQpXG4gICAgICB0aGlzLnN0YXJ0TGF5b3V0QW5pbWF0aW9uKHRoaXMucmVzZXRTY2hlZHVsZWQpO1xuICAgIGlmICh0aGlzLnNhZmVUb1JlbW92ZVRyZWUpXG4gICAgICB0aGlzLm1hcmtUcmVlQ2hpbGRyZW5Bc1NhZmVUb1JlbW92ZSh0aGlzLnNhZmVUb1JlbW92ZVRyZWUpO1xuICAgIHRoaXMuc2FmZVRvUmVtb3ZlVHJlZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVzZXRTY2hlZHVsZWQgPSBmYWxzZTtcbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnN0b3BDcm9zc2ZhZGVBbmltYXRpb24oKTtcbiAgfVxuICBzdGFydExheW91dEFuaW1hdGlvbihzaG91bGRSZXNldCkge1xuICAgIGNvbnN0IHsgbGVhZCwgZm9sbG93IH0gPSB0aGlzO1xuICAgIGNvbnN0IGxlYWRDaGlsZHJlbiA9IGxlYWQgPT0gbnVsbCA/IHZvaWQgMCA6IGxlYWQuY2hpbGRyZW47XG4gICAgY29uc3QgZm9sbG93Q2hpbGRyZW4gPSBmb2xsb3cgPT0gbnVsbCA/IHZvaWQgMCA6IGZvbGxvdy5jaGlsZHJlbjtcbiAgICBjb25zdCB0b0Nyb3NzZmFkZSA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBoYW5kbGVyID0ge1xuICAgICAgbGF5b3V0UmVhZHk6IChjaGlsZCkgPT4ge1xuICAgICAgICBjb25zdCBsYXlvdXRJZCA9IGNoaWxkLmdldExheW91dElkKCk7XG4gICAgICAgIGlmIChsYXlvdXRJZCA9PT0gdm9pZCAwKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5sYXlvdXRJZENvbmZpZy5nZXQobGF5b3V0SWQpO1xuICAgICAgICBpZiAoIWNvbmZpZylcbiAgICAgICAgICByZXR1cm4gY2hpbGQubm90aWZ5TGF5b3V0UmVhZHkoeyBzaG91bGRTdGFja0FuaW1hdGU6IGZhbHNlIH0pO1xuICAgICAgICBjb25zdCBmb2xsb3dDaGlsZCA9IGZvbGxvd0NoaWxkcmVuID09IG51bGwgPyB2b2lkIDAgOiBmb2xsb3dDaGlsZHJlbi5nZXQobGF5b3V0SWQpO1xuICAgICAgICBjb25zdCBsZWFkQ2hpbGQgPSBsZWFkQ2hpbGRyZW4gPT0gbnVsbCA/IHZvaWQgMCA6IGxlYWRDaGlsZHJlbi5nZXQobGF5b3V0SWQpO1xuICAgICAgICBjaGlsZC5wb2ludFRvKGxlYWRDaGlsZCAhPSBudWxsID8gbGVhZENoaWxkIDogY2hpbGQpO1xuICAgICAgICBjb25zdCBpc0xlYWQgPSBCb29sZWFuKGxlYWRDaGlsZHJlbiAmJiBsZWFkQ2hpbGQgPT09IGNoaWxkKTtcbiAgICAgICAgaWYgKGlzTGVhZCkge1xuICAgICAgICAgIGlmIChmb2xsb3dDaGlsZCAmJiBsZWFkQ2hpbGQpXG4gICAgICAgICAgICB0b0Nyb3NzZmFkZS5zZXQobGF5b3V0SWQsIGNvbmZpZyk7XG4gICAgICAgICAgY2hpbGQubm90aWZ5TGF5b3V0UmVhZHkoY3JlYXRlQW5pbWF0aW9uKHtcbiAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAoX2EgPSBmb2xsb3dDaGlsZCA9PSBudWxsID8gdm9pZCAwIDogZm9sbG93Q2hpbGQubGF5b3V0U2FmZVRvUmVtb3ZlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChmb2xsb3dDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAobGVhZCAmJiBsZWFkQ2hpbGRyZW4pIHtcbiAgICAgIGZvciAoY29uc3QgW18sIGNoaWxkXSBvZiBsZWFkQ2hpbGRyZW4pXG4gICAgICAgIHRoaXMuYmF0Y2guYWRkKGNoaWxkKTtcbiAgICAgIGxlYWQubGF5b3V0TWF5QmVNdXRhdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICghc2hvdWxkUmVzZXQgJiYgZm9sbG93ICYmIGZvbGxvd0NoaWxkcmVuKSB7XG4gICAgICBmb3IgKGNvbnN0IFtfLCBjaGlsZF0gb2YgZm9sbG93Q2hpbGRyZW4pXG4gICAgICAgIHRoaXMuYmF0Y2guYWRkKGNoaWxkKTtcbiAgICAgIGZvbGxvdy5sYXlvdXRNYXlCZU11dGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmJhdGNoLmZsdXNoKGhhbmRsZXIpO1xuICAgIHRoaXMuc3RhcnRDcm9zc2ZhZGUodG9Dcm9zc2ZhZGUpO1xuICB9XG4gIHN0YXJ0Q3Jvc3NmYWRlKHRvQ3Jvc3NmYWRlLCB0cmFuc2l0aW9uKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBpZiAoISgoX2EgPSB0aGlzLmxlYWQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yb290Q2hpbGQpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGlzRXhpdCA9IChfYiA9IHRoaXMuZm9sbG93KSA9PSBudWxsID8gdm9pZCAwIDogX2IuaXNFeGl0aW5nO1xuICAgIGxldCByb290VHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG4gICAgY29uc3QgbGVhZFJvb3QgPSAoX2MgPSB0aGlzLmxlYWQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5yb290Q2hpbGQ7XG4gICAgY29uc3QgZm9sbG93Um9vdCA9IChfZCA9IHRoaXMuZm9sbG93KSA9PSBudWxsID8gdm9pZCAwIDogX2Qucm9vdENoaWxkO1xuICAgIGxlYWRSb290ID09IG51bGwgPyB2b2lkIDAgOiBsZWFkUm9vdC5zZXRWaXNpYmlsaXR5KHRydWUpO1xuICAgIGZvbGxvd1Jvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IGZvbGxvd1Jvb3Quc2V0VmlzaWJpbGl0eSh0cnVlKTtcbiAgICBjb25zdCBjcmVhdGVDcm9zc2ZhZGVBbmltYXRpb24gPSAoY29uZmlnLCBpZCkgPT4ge1xuICAgICAgdmFyIF9hMiwgX2IyO1xuICAgICAgY29uc3QgZm9sbG93Q2hpbGQgPSAoX2EyID0gdGhpcy5mb2xsb3cpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY2hpbGRyZW4uZ2V0KGlkKTtcbiAgICAgIGNvbnN0IGxlYWRDaGlsZCA9IChfYjIgPSB0aGlzLmxlYWQpID09IG51bGwgPyB2b2lkIDAgOiBfYjIuY2hpbGRyZW4uZ2V0KGlkKTtcbiAgICAgIGlmIChsZWFkQ2hpbGQgPT09IGxlYWRSb290IHx8IGZvbGxvd0NoaWxkID09PSBmb2xsb3dSb290KSB7XG4gICAgICAgIGlmIChsZWFkQ2hpbGQgPT09IGxlYWRSb290KVxuICAgICAgICAgIHJvb3RUcmFuc2l0aW9uID0gY29uZmlnLnRyYW5zaXRpb247XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zdGFja0Nyb3NzZmFkZXJzLmhhcyhpZCkpIHtcbiAgICAgICAgdGhpcy5zdGFja0Nyb3NzZmFkZXJzLnNldChpZCwgY3JlYXRlQ3Jvc3NmYWRlcigpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNyb3NzZmFkZXIgPSB0aGlzLnN0YWNrQ3Jvc3NmYWRlcnMuZ2V0KGlkKTtcbiAgICAgIGNyb3NzZmFkZXIuc2V0T3B0aW9ucyh7XG4gICAgICAgIGxlYWQ6IGxlYWRDaGlsZCxcbiAgICAgICAgZm9sbG93OiBmb2xsb3dDaGlsZFxuICAgICAgfSk7XG4gICAgICBsZWFkQ2hpbGQgPT0gbnVsbCA/IHZvaWQgMCA6IGxlYWRDaGlsZC5zZXRDcm9zc2ZhZGVyKGNyb3NzZmFkZXIpO1xuICAgICAgZm9sbG93Q2hpbGQgPT0gbnVsbCA/IHZvaWQgMCA6IGZvbGxvd0NoaWxkLnNldENyb3NzZmFkZXIoY3Jvc3NmYWRlcik7XG4gICAgICBjcm9zc2ZhZGVyLnRvTGVhZChjb25maWcgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy50cmFuc2l0aW9uKTtcbiAgICB9O1xuICAgIHRvQ3Jvc3NmYWRlLmZvckVhY2goY3JlYXRlQ3Jvc3NmYWRlQW5pbWF0aW9uKTtcbiAgICBpZiAoIWxlYWRSb290IHx8ICFmb2xsb3dSb290KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJvb3RDcm9zc2ZhZGVyID0gdGhpcy5zdGFja0Nyb3NzZmFkZXJzLmdldChUUkVFX1JPT1RfSUQpO1xuICAgIHJvb3RDcm9zc2ZhZGVyLnNldE9wdGlvbnMoe1xuICAgICAgbGVhZDogbGVhZFJvb3QsXG4gICAgICBmb2xsb3c6IGZvbGxvd1Jvb3QsXG4gICAgICBwcmVzZXJ2ZUZvbGxvd09wYWNpdHk6ICFpc0V4aXQsXG4gICAgICBjcm9zc2ZhZGVPcGFjaXR5OiB0cnVlXG4gICAgfSk7XG4gICAgbGVhZFJvb3Quc2V0Q3Jvc3NmYWRlcihyb290Q3Jvc3NmYWRlcik7XG4gICAgZm9sbG93Um9vdC5zZXRDcm9zc2ZhZGVyKHJvb3RDcm9zc2ZhZGVyKTtcbiAgICBjb25zdCBsZWFkUm9vdElkID0gbGVhZFJvb3QuZ2V0TGF5b3V0SWQoKTtcbiAgICBjb25zdCBsZWFkVHJhbnNpdGlvbiA9IGxlYWRSb290SWQgPyAoKF9lID0gdGhpcy5sYXlvdXRJZENvbmZpZy5nZXQobGVhZFJvb3RJZCkpID09IG51bGwgPyB2b2lkIDAgOiBfZS50cmFuc2l0aW9uKSB8fCByb290VHJhbnNpdGlvbiA6IHJvb3RUcmFuc2l0aW9uO1xuICAgIHJvb3RDcm9zc2ZhZGVyLnRvTGVhZChsZWFkVHJhbnNpdGlvbik7XG4gIH1cbiAgc3RvcENyb3NzZmFkZUFuaW1hdGlvbigpIHtcbiAgICB0aGlzLnN0YWNrQ3Jvc3NmYWRlcnMuZm9yRWFjaCgoY3Jvc3NmYWRlcikgPT4gY3Jvc3NmYWRlci5zdG9wKCkpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQyOChMYXlvdXRUcmVlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHRoaXMudHJlZUNvbnRleHRcbiAgICB9LCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDI4KFNoYXJlZExheW91dENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiB0aGlzLnN5bmNDb250ZXh0XG4gICAgfSwgdGhpcy5wcm9wcy5jaGlsZHJlbikpO1xuICB9XG59O1xuZnVuY3Rpb24gY29weUF4aXNCb3gyKGJveCkge1xuICBpZiAoIWJveClcbiAgICByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4ge1xuICAgIHg6IHsgLi4uYm94LnggfSxcbiAgICB5OiB7IC4uLmJveC55IH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHNuYXBzaG90Um90YXRlKGxheW91dElkLCBsZWFkLCBmb2xsb3csIHN0eWxlTWFwKSB7XG4gIGNvbnN0IGZvbGxvd1JvdGF0ZSA9IGZvbGxvdyA9PSBudWxsID8gdm9pZCAwIDogZm9sbG93LmdldFZhbHVlKFwicm90YXRlXCIpO1xuICBjb25zdCBsZWFkUm90YXRlID0gbGVhZC5nZXRWYWx1ZShcInJvdGF0ZVwiKTtcbiAgc3R5bGVNYXBbbGF5b3V0SWRdID0geyByb3RhdGU6IChsZWFkUm90YXRlID09IG51bGwgPyB2b2lkIDAgOiBsZWFkUm90YXRlLmlzQW5pbWF0aW5nKCkpID8gbGVhZFJvdGF0ZS5nZXQoKSA6IChmb2xsb3dSb3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvbGxvd1JvdGF0ZS5nZXQoKSkgfHwgMCB9O1xufVxudmFyIHRyYW5zZm9ybUF4ZXMyID0gW1wiXCIsIFwiWFwiLCBcIllcIiwgXCJaXCJdO1xuZnVuY3Rpb24gcmVzZXRSb3RhdGUyKGNoaWxkKSB7XG4gIGxldCBoYXNSb3RhdGUgPSBmYWxzZTtcbiAgY29uc3QgcmVzZXRWYWx1ZXMgPSB7fTtcbiAgdHJhbnNmb3JtQXhlczIuZm9yRWFjaCgoYXhpcykgPT4ge1xuICAgIGNvbnN0IGtleTYgPSBcInJvdGF0ZVwiICsgYXhpcztcbiAgICBpZiAoIWNoaWxkLmhhc1ZhbHVlKGtleTYpKVxuICAgICAgcmV0dXJuO1xuICAgIGhhc1JvdGF0ZSA9IHRydWU7XG4gICAgcmVzZXRWYWx1ZXNba2V5Nl0gPSBjaGlsZC5nZXRTdGF0aWNWYWx1ZShrZXk2KTtcbiAgICBjaGlsZC5zZXRTdGF0aWNWYWx1ZShrZXk2LCAwKTtcbiAgfSk7XG4gIGlmICghaGFzUm90YXRlKVxuICAgIHJldHVybjtcbiAgY2hpbGQuc3luY1JlbmRlcigpO1xuICBmb3IgKGNvbnN0IGtleTYgaW4gcmVzZXRWYWx1ZXMpIHtcbiAgICBjaGlsZC5zZXRTdGF0aWNWYWx1ZShrZXk2LCByZXNldFZhbHVlc1trZXk2XSk7XG4gIH1cbiAgY2hpbGQuc2NoZWR1bGVSZW5kZXIoKTtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvQW5pbWF0ZUxheW91dC9TaGFyZWRMYXlvdXRUcmVlLnRzeFxuaW1wb3J0IHtcbiAgQ29tcG9uZW50IGFzIENvbXBvbmVudDExLFxuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQyOSxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjNcbn0gZnJvbSBcInJlYWN0XCI7XG52YXIgTGF5b3V0VHJlZSA9IGNsYXNzIGV4dGVuZHMgQ29tcG9uZW50MTEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jaGlsZHJlblRvUmVzZXRUcmFuc2Zvcm0gPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5sYXlvdXRNYXlCZU11dGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN5bmNDb250ZXh0ID0ge1xuICAgICAgYWRkOiAoKSA9PiB7XG4gICAgICB9LFxuICAgICAgZmx1c2g6ICgpID0+IHtcbiAgICAgIH0sXG4gICAgICBzeW5jVXBkYXRlOiAoZm9yY2UpID0+IHtcbiAgICAgIH0sXG4gICAgICBmb3JjZVVwZGF0ZTogKCkgPT4ge1xuICAgICAgICB0aGlzLnN5bmNDb250ZXh0ID0geyAuLi50aGlzLnN5bmNDb250ZXh0IH07XG4gICAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICByZWdpc3RlcjogKGNoaWxkKSA9PiB0aGlzLmFkZENoaWxkKGNoaWxkKSxcbiAgICAgIHJlbW92ZTogKGNoaWxkKSA9PiB0aGlzLnJlbW92ZUNoaWxkKGNoaWxkKVxuICAgIH07XG4gIH1cbiAgYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICBjb25zdCBsYXlvdXRJZCA9IGNoaWxkLmdldExheW91dElkKCk7XG4gICAgaWYgKGxheW91dElkKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnNldChsYXlvdXRJZCwgY2hpbGQpO1xuICAgICAgdGhpcy5zZXRSb290Q2hpbGQoY2hpbGQpO1xuICAgIH0gZWxzZSBpZiAoY2hpbGQuc2hvdWxkUmVzZXRUcmFuc2Zvcm0oKSkge1xuICAgICAgdGhpcy5jaGlsZHJlblRvUmVzZXRUcmFuc2Zvcm0uYWRkKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgc2V0Um9vdENoaWxkKGNoaWxkKSB7XG4gICAgaWYgKCF0aGlzLnJvb3RDaGlsZClcbiAgICAgIHJldHVybiB0aGlzLnJvb3RDaGlsZCA9IGNoaWxkO1xuICAgIHRoaXMucm9vdENoaWxkID0gdGhpcy5yb290Q2hpbGQuZGVwdGggPCBjaGlsZC5kZXB0aCA/IHRoaXMucm9vdENoaWxkIDogY2hpbGQ7XG4gIH1cbiAgcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcbiAgICBjb25zdCBsYXlvdXRJZCA9IGNoaWxkLmdldExheW91dElkKCk7XG4gICAgaWYgKGxheW91dElkKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLmRlbGV0ZShsYXlvdXRJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hpbGRyZW5Ub1Jlc2V0VHJhbnNmb3JtLmRlbGV0ZShjaGlsZCk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHsgaXNMZWFkLCBhbmltYXRlc0xheW91dCwgdHJhbnNpdGlvbiB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoaXNMZWFkICE9PSB2b2lkIDAgJiYgaXNMZWFkKVxuICAgICAgdGhpcy5wcm9wcy50cmVlQ29udGV4dC5wcm9tb3RlVHJlZSh0aGlzLCAhIWFuaW1hdGVzTGF5b3V0LCB0cmFuc2l0aW9uKTtcbiAgfVxuICBzaG91bGRDb21wb25lbnRVcGRhdGUoeyBpc0xlYWQsIGlzRXhpdGluZywgYW5pbWF0ZXNMYXlvdXQsIHRyYW5zaXRpb24gfSkge1xuICAgIHRoaXMuaXNFeGl0aW5nID0gaXNFeGl0aW5nO1xuICAgIGlmICh0aGlzLnByb3BzLmlzTGVhZCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY29uc3QgaGFzQmVjb21lTGVhZCA9ICF0aGlzLnByb3BzLmlzTGVhZCAmJiBpc0xlYWQ7XG4gICAgY29uc3QgaGFzRXhpdEJlZW5DYW5jZWxsZWQgPSB0aGlzLnByb3BzLmlzRXhpdGluZyAmJiAhaXNFeGl0aW5nO1xuICAgIGNvbnN0IHNob3VsZFByb21vdGUgPSBoYXNCZWNvbWVMZWFkIHx8IGhhc0V4aXRCZWVuQ2FuY2VsbGVkO1xuICAgIGlmICh0aGlzLmxheW91dE1heUJlTXV0YXRlZCAmJiBzaG91bGRQcm9tb3RlICYmICFhbmltYXRlc0xheW91dCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMudHJlZUNvbnRleHQucHJvbW90ZVRyZWUodGhpcywgdHJ1ZSwgeyB0eXBlOiBmYWxzZSB9LCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHNob3VsZFByb21vdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLnRyZWVDb250ZXh0LnByb21vdGVUcmVlKHRoaXMsICEhYW5pbWF0ZXNMYXlvdXQsIHRyYW5zaXRpb24pO1xuICAgIH0gZWxzZSBpZiAoaXNFeGl0aW5nICYmICFhbmltYXRlc0xheW91dCkge1xuICAgICAgdGhpcy5wcm9wcy50cmVlQ29udGV4dC5tYXJrVHJlZUFzU2FmZVRvUmVtb3ZlKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDI5KEZyYW1lclRyZWVMYXlvdXRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogdGhpcy5zeW5jQ29udGV4dFxuICAgIH0sIHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICB9XG59O1xudmFyIFNoYXJlZExheW91dFRyZWUgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdHJlZUNvbnRleHQgPSB1c2VDb250ZXh0MjMoTGF5b3V0VHJlZUNvbnRleHQpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQyOShMYXlvdXRUcmVlLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgdHJlZUNvbnRleHRcbiAgfSk7XG59O1xuXG4vLyBzcmMvY29tcG9uZW50cy9OYXZpZ2F0aW9uVGFyZ2V0Q29udGV4dC50c3hcbmltcG9ydCB7XG4gIGNyZWF0ZUVsZW1lbnQgYXMgY3JlYXRlRWxlbWVudDMwXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTQsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDI0LCB1c2VSZWYgYXMgdXNlUmVmMTksIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrOCwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDE5IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9jb21wb25lbnRzL3V0aWxzL3VzZUNvbnN0YW50LnRzXG5pbXBvcnQgeyB1c2VSZWYgYXMgdXNlUmVmMTggfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZUNvbnN0YW50Mihpbml0KSB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZjE4KG51bGwpO1xuICBpZiAocmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICByZWYuY3VycmVudCA9IGluaXQoKTtcbiAgfVxuICByZXR1cm4gcmVmLmN1cnJlbnQ7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL3V0aWxzL3VzZU1hcC50c1xuZnVuY3Rpb24gbmV3TWFwKCkge1xuICByZXR1cm4gbmV3IE1hcCgpO1xufVxuZnVuY3Rpb24gdXNlTWFwKCkge1xuICByZXR1cm4gdXNlQ29uc3RhbnQyKG5ld01hcCk7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL05hdmlnYXRpb25UYXJnZXRDb250ZXh0LnRzeFxudmFyIE5hdmlnYXRpb25UYXJnZXRDb250ZXh0ID0gY3JlYXRlQ29udGV4dDE0KHsgcmVnaXN0ZXI6ICgpID0+IHtcbn0sIGRlcmVnaXN0ZXI6ICgpID0+IHtcbn0gfSk7XG52YXIgTmF2aWdhdGlvblRhcmdldFdyYXBwZXIgPSAoeyBpc0N1cnJlbnQsIGlzT3ZlcmxheWVkLCBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IGNhbGxiYWNrczIgPSB1c2VNYXAoKTtcbiAgY29uc3QgcmVnaXN0ZXIgPSB1c2VDYWxsYmFjazgoKGZuKSA9PiB7XG4gICAgaWYgKGNhbGxiYWNrczIuaGFzKGZuKSkge1xuICAgICAgY29uc29sZS53YXJuKFwiTmF2aWdhdGlvblRhcmdldFdyYXBwZXI6IGFscmVhZHkgcmVnaXN0ZXJlZFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2tzMi5zZXQoZm4sIHZvaWQgMCk7XG4gIH0sIFtjYWxsYmFja3MyXSk7XG4gIGNvbnN0IGRlcmVnaXN0ZXIgPSB1c2VDYWxsYmFjazgoKGZuKSA9PiB7XG4gICAgY29uc3QgY2xlYW51cCA9IGNhbGxiYWNrczIuZ2V0KGZuKTtcbiAgICBjbGVhbnVwID09IG51bGwgPyB2b2lkIDAgOiBjbGVhbnVwKCk7XG4gICAgY2FsbGJhY2tzMi5kZWxldGUoZm4pO1xuICB9LCBbY2FsbGJhY2tzMl0pO1xuICBjb25zdCB2YWx1ZSA9IHVzZVJlZjE5KHsgcmVnaXN0ZXIsIGRlcmVnaXN0ZXIgfSkuY3VycmVudDtcbiAgdXNlRWZmZWN0MTkoKCkgPT4ge1xuICAgIGNhbGxiYWNrczIuZm9yRWFjaCgoXywgY2IyKSA9PiB7XG4gICAgICBjb25zdCBuZXdDbGVhbnVwID0gY2IyKGlzQ3VycmVudCwgaXNPdmVybGF5ZWQpO1xuICAgICAgY2FsbGJhY2tzMi5zZXQoY2IyLCBpc0Z1bmN0aW9uKG5ld0NsZWFudXApID8gbmV3Q2xlYW51cCA6IHZvaWQgMCk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbGxiYWNrczIuZm9yRWFjaCgoY2xlYW51cCwgY2IyKSA9PiB7XG4gICAgICAgIGlmICghY2xlYW51cClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgY2FsbGJhY2tzMi5zZXQoY2IyLCB2b2lkIDApO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgW2lzQ3VycmVudCwgaXNPdmVybGF5ZWQsIGNhbGxiYWNrczJdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MzAoTmF2aWdhdGlvblRhcmdldENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZVxuICB9LCBjaGlsZHJlbik7XG59O1xuZnVuY3Rpb24gdXNlT25DdXJyZW50VGFyZ2V0Q2hhbmdlKGNhbGxiYWNrLCBkZXBzID0gW10pIHtcbiAgY29uc3QgeyByZWdpc3RlciwgZGVyZWdpc3RlciB9ID0gdXNlQ29udGV4dDI0KE5hdmlnYXRpb25UYXJnZXRDb250ZXh0KTtcbiAgdXNlRWZmZWN0MTkoKCkgPT4ge1xuICAgIGlmICghY2FsbGJhY2spXG4gICAgICByZXR1cm47XG4gICAgcmVnaXN0ZXIoY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiBkZXJlZ2lzdGVyKGNhbGxiYWNrKTtcbiAgfSwgW3JlZ2lzdGVyLCBkZXJlZ2lzdGVyLCAuLi5kZXBzXSk7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL05hdmlnYXRpb25Db250YWluZXIudHN4XG52YXIgTmF2aWdhdGlvbkNvbnRhaW5lciA9IG1lbW8oZnVuY3Rpb24gTmF2aWdhdGlvbkNvbnRhaW5lcjIoe1xuICBpc0xheWVyZWRDb250YWluZXIsXG4gIGlzQ3VycmVudCxcbiAgaXNQcmV2aW91cyxcbiAgaXNPdmVybGF5ZWQgPSBmYWxzZSxcbiAgdmlzaWJsZSxcbiAgdHJhbnNpdGlvblByb3BzLFxuICBjaGlsZHJlbixcbiAgYmFja2Ryb3BDb2xvcixcbiAgb25UYXBCYWNrZHJvcCxcbiAgYmFja2ZhY2VWaXNpYmxlLFxuICBleGl0QmFja2ZhY2VWaXNpYmxlLFxuICBhbmltYXRpb24sXG4gIGV4aXRBbmltYXRpb24sXG4gIGluc3RhbnQsXG4gIGluaXRpYWxQcm9wcyxcbiAgZXhpdFByb3BzLFxuICBwb3NpdGlvbiA9IHsgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwIH0sXG4gIHdpdGhNYWdpY01vdGlvbixcbiAgaW5kZXgsXG4gIGFyZU1hZ2ljTW90aW9uTGF5ZXJzUHJlc2VudCxcbiAgaWRcbn0pIHtcbiAgY29uc3QgYW5pbWF0ZTQgPSB1c2VBbmltYXRpb24oKTtcbiAgY29uc3QgcHJlc2VuY2UgPSB1c2VDb250ZXh0MjUoUHJlc2VuY2VDb250ZXh0KTtcbiAgY29uc3QgeyBwZXJzaXN0TGF5b3V0SWRDYWNoZSB9ID0gdXNlQ29udGV4dDI1KExheW91dElkQ29udGV4dCk7XG4gIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB1c2VSZWYyMCh7XG4gICAgd2FzQ3VycmVudDogdm9pZCAwLFxuICAgIHdhc1ByZXZpb3VzOiBmYWxzZSxcbiAgICB3YXNCZWluZ1JlbW92ZWQ6IGZhbHNlLFxuICAgIHdhc1Jlc2V0OiB0cnVlLFxuICAgIG9yaWdpbnM6IGdldE9yaWdpblByb3BzKHt9LCBpbml0aWFsUHJvcHMsIHRyYW5zaXRpb25Qcm9wcylcbiAgfSk7XG4gIGNvbnN0IGlzQmVpbmdSZW1vdmVkID0gcHJlc2VuY2UgIT09IG51bGwgJiYgIXByZXNlbmNlLmlzUHJlc2VudDtcbiAgaWYgKGlzQ3VycmVudCAmJiBwcmV2aW91c1N0YXRlLmN1cnJlbnQud2FzQ3VycmVudCA9PT0gdm9pZCAwKVxuICAgIHBlcnNpc3RMYXlvdXRJZENhY2hlKCk7XG4gIHVzZUVmZmVjdDIwKCgpID0+IHtcbiAgICBpZiAoaXNMYXllcmVkQ29udGFpbmVyIHx8ICFhbmltYXRlNClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoaXNCZWluZ1JlbW92ZWQpIHtcbiAgICAgIHByZXZpb3VzU3RhdGUuY3VycmVudCA9IHtcbiAgICAgICAgLi4ucHJldmlvdXNTdGF0ZS5jdXJyZW50LFxuICAgICAgICB3YXNCZWluZ1JlbW92ZWQ6IGlzQmVpbmdSZW1vdmVkXG4gICAgICB9O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHdhc1ByZXZpb3VzLCB3YXNDdXJyZW50IH0gPSBwcmV2aW91c1N0YXRlLmN1cnJlbnQ7XG4gICAgY29uc3Qgc2hvdWxkQW5pbWF0ZUluID0gaXNDdXJyZW50ICYmICF3YXNDdXJyZW50IHx8ICFpc0JlaW5nUmVtb3ZlZCAmJiBwcmV2aW91c1N0YXRlLmN1cnJlbnQud2FzQmVpbmdSZW1vdmVkICYmIGlzQ3VycmVudDtcbiAgICBjb25zdCBzaG91bGRBbmltYXRlT3V0ID0gaXNQcmV2aW91cyAmJiAhd2FzUHJldmlvdXM7XG4gICAgY29uc3Qgb3JpZ2lucyA9IGdldE9yaWdpblByb3BzKHByZXZpb3VzU3RhdGUuY3VycmVudC5vcmlnaW5zLCBpbml0aWFsUHJvcHMsIHRyYW5zaXRpb25Qcm9wcyk7XG4gICAgbGV0IHdhc1Jlc2V0ID0gcHJldmlvdXNTdGF0ZS5jdXJyZW50Lndhc1Jlc2V0O1xuICAgIGlmIChzaG91bGRBbmltYXRlSW4gfHwgc2hvdWxkQW5pbWF0ZU91dCkge1xuICAgICAgYW5pbWF0ZTQuc3RvcCgpO1xuICAgICAgYW5pbWF0ZTQuc3RhcnQoe1xuICAgICAgICB6SW5kZXg6IGluZGV4LFxuICAgICAgICAuLi5vcmlnaW5zLFxuICAgICAgICAuLi50cmFuc2l0aW9uUHJvcHNcbiAgICAgIH0pO1xuICAgICAgd2FzUmVzZXQgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHdhc1Jlc2V0ID09PSBmYWxzZSkge1xuICAgICAgYW5pbWF0ZTQuc3RvcCgpO1xuICAgICAgYW5pbWF0ZTQuc2V0KHsgekluZGV4OiBpbmRleCwgLi4uYWxsQW5pbWF0YWJsZVByb3BlcnRpZXMsIG9wYWNpdHk6IDAgfSk7XG4gICAgICB3YXNSZXNldCA9IHRydWU7XG4gICAgfVxuICAgIHByZXZpb3VzU3RhdGUuY3VycmVudCA9IHtcbiAgICAgIHdhc0N1cnJlbnQ6ICEhaXNDdXJyZW50LFxuICAgICAgd2FzUHJldmlvdXM6ICEhaXNQcmV2aW91cyxcbiAgICAgIHdhc0JlaW5nUmVtb3ZlZDogZmFsc2UsXG4gICAgICB3YXNSZXNldCxcbiAgICAgIG9yaWdpbnNcbiAgICB9O1xuICB9LCBbaXNDdXJyZW50LCBpc1ByZXZpb3VzLCBpc0JlaW5nUmVtb3ZlZF0pO1xuICBjb25zdCB0cmFuc2l0aW9uID0gaW5zdGFudCA/IHsgdHlwZTogZmFsc2UgfSA6IHsgLi4uYW5pbWF0aW9uLCB2ZWxvY2l0eTogMCB9O1xuICBjb25zdCBleGl0VHJhbnNpdGlvbiA9IGluc3RhbnQgPyB7IHR5cGU6IGZhbHNlIH0gOiBleGl0QW5pbWF0aW9uIHx8IGFuaW1hdGlvbjtcbiAgY29uc3QgbGF5b3V0ID0geyAuLi5wb3NpdGlvbiB9O1xuICBpZiAobGF5b3V0LmxlZnQgPT09IHZvaWQgMCB8fCBsYXlvdXQucmlnaHQgPT09IHZvaWQgMClcbiAgICBsYXlvdXQud2lkdGggPSBcImF1dG9cIjtcbiAgaWYgKGxheW91dC50b3AgPT09IHZvaWQgMCB8fCBsYXlvdXQuYm90dG9tID09PSB2b2lkIDApXG4gICAgbGF5b3V0LmhlaWdodCA9IFwiYXV0b1wiO1xuICBjb25zdCBuZWVkc1BlcnNwZWN0aXZlID0gY29udGFpbnMzRHByb3BzKHRyYW5zaXRpb25Qcm9wcykgfHwgY29udGFpbnMzRHByb3BzKGluaXRpYWxQcm9wcyk7XG4gIGNvbnN0IHBlcnNwZWN0aXZlID0gbmVlZHNQZXJzcGVjdGl2ZSAmJiAoaXNMYXllcmVkQ29udGFpbmVyIHx8IGlzQ3VycmVudCB8fCBpc1ByZXZpb3VzKSA/IDEyMDAgOiB2b2lkIDA7XG4gIGNvbnN0IGlkZW50aXR5ID0geyAuLi5hbGxBbmltYXRhYmxlUHJvcGVydGllcywgLi4ucHJldmlvdXNTdGF0ZS5jdXJyZW50Lm9yaWdpbnMgfTtcbiAgY29uc3QgYW5pbWF0aW9uczIgPSBpc0xheWVyZWRDb250YWluZXIgPyB7XG4gICAgaW5pdGlhbDogeyAuLi5pZGVudGl0eSwgLi4uaW5pdGlhbFByb3BzIH0sXG4gICAgYW5pbWF0ZTogeyAuLi5pZGVudGl0eSwgLi4udHJhbnNpdGlvblByb3BzLCB0cmFuc2l0aW9uIH0sXG4gICAgZXhpdDogeyAuLi5pZGVudGl0eSwgLi4uZXhpdFByb3BzLCB0cmFuc2l0aW9uOiBhbmltYXRlNCB9XG4gIH0gOiB7XG4gICAgYW5pbWF0ZTogYW5pbWF0ZTQsXG4gICAgZXhpdDogeyAuLi5pZGVudGl0eSwgLi4uZXhpdFByb3BzLCB0cmFuc2l0aW9uOiBleGl0VHJhbnNpdGlvbiB9XG4gIH07XG4gIGNvbnN0IGlzUHJlc2VudDIgPSBpc0JlaW5nUmVtb3ZlZCB8fCBhcmVNYWdpY01vdGlvbkxheWVyc1ByZXNlbnQgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xuICBjb25zdCBpc0N1cnJlbnRUYXJnZXQgPSAhIWlzQ3VycmVudCAmJiBpc1ByZXNlbnQyO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQzMShGcmFtZVdpdGhNb3Rpb24sIHtcbiAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgIHRyYW5zZm9ybVN0eWxlOiBcImZsYXRcIixcbiAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgICB6SW5kZXg6IGlzTGF5ZXJlZENvbnRhaW5lciB8fCBpc0JlaW5nUmVtb3ZlZCB8fCBpc0N1cnJlbnQgJiYgd2l0aE1hZ2ljTW90aW9uID8gaW5kZXggOiB2b2lkIDAsXG4gICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICAgIHZpc2liaWxpdHk6IHZpc2libGUgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIsXG4gICAgICBwZXJzcGVjdGl2ZVxuICAgIH1cbiAgfSwgaXNMYXllcmVkQ29udGFpbmVyICYmIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MzEoRnJhbWVXaXRoTW90aW9uLCB7XG4gICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgdHJhbnNpdGlvbjogYW5pbWF0aW9uLFxuICAgIGluaXRpYWw6IHsgb3BhY2l0eTogaW5zdGFudCAmJiB2aXNpYmxlID8gMSA6IDAgfSxcbiAgICBhbmltYXRlOiB7IG9wYWNpdHk6IDEgfSxcbiAgICBleGl0OiB7IG9wYWNpdHk6IDAgfSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tkcm9wQ29sb3IgPyBiYWNrZHJvcENvbG9yIDogXCJ0cmFuc3BhcmVudFwiLFxuICAgIG9uVGFwOiAhaXNCZWluZ1JlbW92ZWQgPyBvblRhcEJhY2tkcm9wIDogdm9pZCAwXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDMxKEZyYW1lV2l0aE1vdGlvbiwge1xuICAgIC4uLmxheW91dCxcbiAgICAuLi5hbmltYXRpb25zMixcbiAgICB0cmFuc2l0aW9uOiB7XG4gICAgICBkZWZhdWx0OiB0cmFuc2l0aW9uLFxuICAgICAgb3JpZ2luWDogeyB0eXBlOiBmYWxzZSB9LFxuICAgICAgb3JpZ2luWTogeyB0eXBlOiBmYWxzZSB9LFxuICAgICAgb3JpZ2luWjogeyB0eXBlOiBmYWxzZSB9XG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgICBiYWNrZmFjZVZpc2libGU6ICFpc0JlaW5nUmVtb3ZlZCA/IGJhY2tmYWNlVmlzaWJsZSA6IGV4aXRCYWNrZmFjZVZpc2libGUsXG4gICAgXCJkYXRhLWZyYW1lci1jb21wb25lbnQtdHlwZVwiOiBcIk5hdmlnYXRpb25Db250YWluZXJcIixcbiAgICBcImRhdGEtZnJhbWVyLWlzLWN1cnJlbnQtbmF2aWdhdGlvbi10YXJnZXRcIjogISFpc0N1cnJlbnQsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvaW50ZXJFdmVudHM6IFwiaW5pdGlhbFwiLFxuICAgICAgb3BhY2l0eTogaXNMYXllcmVkQ29udGFpbmVyIHx8IGlzQ3VycmVudCAmJiB3aXRoTWFnaWNNb3Rpb24gPyAxIDogMFxuICAgIH0sXG4gICAgXCJkYXRhLWlzLXByZXNlbnRcIjogaXNQcmVzZW50MiA/IHZvaWQgMCA6IGZhbHNlXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MzEoTmF2aWdhdGlvbkNvbnRhaW5lckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogaXNDdXJyZW50VGFyZ2V0XG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MzEoTmF2aWdhdGlvblRhcmdldFdyYXBwZXIsIHtcbiAgICBpc0N1cnJlbnQ6IGlzQ3VycmVudFRhcmdldCxcbiAgICBpc092ZXJsYXllZFxuICB9LCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDMxKFNoYXJlZExheW91dFRyZWUsIHtcbiAgICBpc0xlYWQ6IGlzQ3VycmVudCxcbiAgICBhbmltYXRlc0xheW91dDogISF3aXRoTWFnaWNNb3Rpb24sXG4gICAgdHJhbnNpdGlvbixcbiAgICBpc0V4aXRpbmc6ICFpc1ByZXNlbnQyLFxuICAgIGlkXG4gIH0sIGNoaWxkcmVuKSkpKSk7XG59LCBzaG91bGRVc2VQcmV2aW91c1ZhbHVlKTtcbmZ1bmN0aW9uIHNob3VsZFVzZVByZXZpb3VzVmFsdWUocHJldlByb3BzLCBuZXh0UHJvcHMpIHtcbiAgaWYgKG5leHRQcm9wcy5pc0N1cnJlbnQgPT09IHZvaWQgMClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChwcmV2UHJvcHMuaXNDdXJyZW50ICE9PSBuZXh0UHJvcHMuaXNDdXJyZW50KVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHByZXZQcm9wcy5pc1ByZXZpb3VzICE9PSBuZXh0UHJvcHMuaXNQcmV2aW91cylcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChuZXh0UHJvcHMuaXNDdXJyZW50ICYmIHByZXZQcm9wcy5pc092ZXJsYXllZCAhPT0gbmV4dFByb3BzLmlzT3ZlcmxheWVkKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRPcmlnaW5Qcm9wcyhjdXJyZW50T3JpZ2luUHJvcHMsIGluaXRpYWxQcm9wcywgdHJhbnNpdGlvblByb3BzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHsgLi4uY3VycmVudE9yaWdpblByb3BzIH07XG4gIGlmIChpbml0aWFsUHJvcHMpIHtcbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIoaW5pdGlhbFByb3BzLm9yaWdpblgpKVxuICAgICAgcmVzdWx0Lm9yaWdpblggPSBpbml0aWFsUHJvcHMub3JpZ2luWDtcbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIoaW5pdGlhbFByb3BzLm9yaWdpblkpKVxuICAgICAgcmVzdWx0Lm9yaWdpblkgPSBpbml0aWFsUHJvcHMub3JpZ2luWTtcbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIoaW5pdGlhbFByb3BzLm9yaWdpblopKVxuICAgICAgcmVzdWx0Lm9yaWdpblogPSBpbml0aWFsUHJvcHMub3JpZ2luWjtcbiAgfVxuICBpZiAodHJhbnNpdGlvblByb3BzKSB7XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKHRyYW5zaXRpb25Qcm9wcy5vcmlnaW5YKSlcbiAgICAgIHJlc3VsdC5vcmlnaW5YID0gdHJhbnNpdGlvblByb3BzLm9yaWdpblg7XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKHRyYW5zaXRpb25Qcm9wcy5vcmlnaW5ZKSlcbiAgICAgIHJlc3VsdC5vcmlnaW5ZID0gdHJhbnNpdGlvblByb3BzLm9yaWdpblk7XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKHRyYW5zaXRpb25Qcm9wcy5vcmlnaW5aKSlcbiAgICAgIHJlc3VsdC5vcmlnaW5aID0gdHJhbnNpdGlvblByb3BzLm9yaWdpblo7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zM0Rwcm9wcyhjb250YWluZXJQcm9wcykge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgaWYgKCFjb250YWluZXJQcm9wcylcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGNvbnRhaW5zUHJvcHMgPSBcInJvdGF0ZVhcIiBpbiBjb250YWluZXJQcm9wcyB8fCBcInJvdGF0ZVlcIiBpbiBjb250YWluZXJQcm9wcyB8fCBcInpcIiBpbiBjb250YWluZXJQcm9wcztcbiAgaWYgKCFjb250YWluc1Byb3BzKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgdG9Qcm9wc0NvbnRhaW4zZCA9IGNvbnRhaW5lclByb3BzLnJvdGF0ZVggIT09IDAgfHwgY29udGFpbmVyUHJvcHMucm90YXRlWSAhPT0gMCB8fCBjb250YWluZXJQcm9wcy56ICE9PSAwO1xuICBjb25zdCBmcm9tUHJvcHNDb250YWluM2QgPSAoKF9hID0gY29udGFpbmVyUHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRhaW5lclByb3BzLnRyYW5zaXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYS5yb3RhdGVYLmZyb20pICE9PSAwIHx8ICgoX2IgPSBjb250YWluZXJQcm9wcyA9PSBudWxsID8gdm9pZCAwIDogY29udGFpbmVyUHJvcHMudHJhbnNpdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnJvdGF0ZVkuZnJvbSkgIT09IDAgfHwgKChfYyA9IGNvbnRhaW5lclByb3BzID09IG51bGwgPyB2b2lkIDAgOiBjb250YWluZXJQcm9wcy50cmFuc2l0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2Muei5mcm9tKSAhPT0gMDtcbiAgcmV0dXJuIHRvUHJvcHNDb250YWluM2QgfHwgZnJvbVByb3BzQ29udGFpbjNkO1xufVxudmFyIGFsbEFuaW1hdGFibGVQcm9wZXJ0aWVzID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICB6OiAwLFxuICByb3RhdGU6IDAsXG4gIHJvdGF0ZVg6IDAsXG4gIHJvdGF0ZVk6IDAsXG4gIHJvdGF0ZVo6IDAsXG4gIHNjYWxlOiAxLFxuICBzY2FsZVg6IDEsXG4gIHNjYWxlWTogMSxcbiAgc2NhbGVaOiAxLFxuICBza2V3OiAwLFxuICBza2V3WDogMCxcbiAgc2tld1k6IDAsXG4gIG9yaWdpblg6IDAuNSxcbiAgb3JpZ2luWTogMC41LFxuICBvcmlnaW5aOiAwLFxuICBvcGFjaXR5OiAxXG59O1xuXG4vLyBzcmMvY29tcG9uZW50cy9OYXZpZ2F0b3JNb2NrLnRzeFxudmFyIE5hdmlnYXRvck1vY2sgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMud2FybmluZyA9ICgpID0+IHtcbiAgICAgIHdhcm5PbmNlKFwiVGhlIE5hdmlnYXRvciBBUEkgaXMgb25seSBhdmFpbGFibGUgaW5zaWRlIG9mIEZyYW1lcjogaHR0cHM6Ly93d3cuZnJhbWVyLmNvbS9cIik7XG4gICAgfTtcbiAgICB0aGlzLmdvQmFjayA9ICgpID0+IHRoaXMud2FybmluZygpO1xuICAgIHRoaXMuaW5zdGFudCA9ICgpID0+IHRoaXMud2FybmluZygpO1xuICAgIHRoaXMuZmFkZSA9ICgpID0+IHRoaXMud2FybmluZygpO1xuICAgIHRoaXMucHVzaCA9ICgpID0+IHRoaXMud2FybmluZygpO1xuICAgIHRoaXMubW9kYWwgPSAoKSA9PiB0aGlzLndhcm5pbmcoKTtcbiAgICB0aGlzLm92ZXJsYXkgPSAoKSA9PiB0aGlzLndhcm5pbmcoKTtcbiAgICB0aGlzLmZsaXAgPSAoKSA9PiB0aGlzLndhcm5pbmcoKTtcbiAgICB0aGlzLmN1c3RvbVRyYW5zaXRpb24gPSAoKSA9PiB0aGlzLndhcm5pbmcoKTtcbiAgICB0aGlzLm1hZ2ljTW90aW9uID0gKCkgPT4gdGhpcy53YXJuaW5nKCk7XG4gIH1cbn07XG52YXIgbmF2aWdhdG9yTW9jayA9IG5ldyBOYXZpZ2F0b3JNb2NrKCk7XG5cbi8vIHNyYy9jb21wb25lbnRzL3JlZHVjZU5hdmlnYXRpb25TdGF0ZUZvckFjdGlvbi50c1xudmFyIGRlZmF1bHRTdGF0ZSA9ICgpID0+ICh7XG4gIGN1cnJlbnQ6IC0xLFxuICBwcmV2aW91czogLTEsXG4gIGN1cnJlbnRPdmVybGF5OiAtMSxcbiAgcHJldmlvdXNPdmVybGF5OiAtMSxcbiAgdmlzdWFsSW5kZXg6IDAsXG4gIG92ZXJsYXlJdGVtSWQ6IDAsXG4gIGhpc3RvcnlJdGVtSWQ6IDAsXG4gIGhpc3Rvcnk6IFtdLFxuICBvdmVybGF5U3RhY2s6IFtdLFxuICBjb250YWluZXJzOiB7fSxcbiAgY29udGFpbmVySW5kZXg6IHt9LFxuICBjb250YWluZXJWaXN1YWxJbmRleDoge30sXG4gIGNvbnRhaW5lcklzUmVtb3ZlZDoge30sXG4gIHRyYW5zaXRpb25Gb3JDb250YWluZXI6IHt9LFxuICBwcmV2aW91c1RyYW5zaXRpb246IG51bGxcbn0pO1xuZnVuY3Rpb24gcmVkdWNlTmF2aWdhdGlvblN0YXRlRm9yQWN0aW9uKHN0YXRlLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgXCJhZGRPdmVybGF5XCI6XG4gICAgICByZXR1cm4gYWRkT3ZlcmxheShzdGF0ZSwgYWN0aW9uLnRyYW5zaXRpb24sIGFjdGlvbi5jb21wb25lbnQpO1xuICAgIGNhc2UgXCJyZW1vdmVPdmVybGF5XCI6XG4gICAgICByZXR1cm4gcmVtb3ZlT3ZlcmxheShzdGF0ZSk7XG4gICAgY2FzZSBcImFkZFwiOlxuICAgICAgcmV0dXJuIGFkZChzdGF0ZSwgYWN0aW9uLmtleSwgYWN0aW9uLnRyYW5zaXRpb24sIGFjdGlvbi5jb21wb25lbnQpO1xuICAgIGNhc2UgXCJyZW1vdmVcIjpcbiAgICAgIHJldHVybiByZW1vdmUoc3RhdGUpO1xuICAgIGNhc2UgXCJ1cGRhdGVcIjpcbiAgICAgIHJldHVybiB1cGRhdGVDb21wb25lbnQoc3RhdGUsIGFjdGlvbi5rZXksIGFjdGlvbi5jb21wb25lbnQpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm47XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudChjdXJyZW50U3RhdGUsIGtleTYsIGNvbXBvbmVudCkge1xuICByZXR1cm4ge1xuICAgIC4uLmN1cnJlbnRTdGF0ZSxcbiAgICBjb250YWluZXJzOiB7XG4gICAgICAuLi5jdXJyZW50U3RhdGUuY29udGFpbmVycyxcbiAgICAgIFtrZXk2XTogY29tcG9uZW50XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYWRkT3ZlcmxheShjdXJyZW50U3RhdGUsIHRyYW5zaXRpb24sIGNvbXBvbmVudCkge1xuICBjb25zdCBjdXJyZW50T3ZlcmxheSA9IGN1cnJlbnRTdGF0ZS5vdmVybGF5U3RhY2tbY3VycmVudFN0YXRlLmN1cnJlbnRPdmVybGF5XTtcbiAgaWYgKGN1cnJlbnRPdmVybGF5ICYmIGN1cnJlbnRPdmVybGF5LmNvbXBvbmVudCA9PT0gY29tcG9uZW50KVxuICAgIHJldHVybjtcbiAgY29uc3Qgb3ZlcmxheUl0ZW1JZCA9IGN1cnJlbnRTdGF0ZS5vdmVybGF5SXRlbUlkICsgMTtcbiAgY29uc3Qgb3ZlcmxheVN0YWNrID0gW1xuICAgIC4uLmN1cnJlbnRTdGF0ZS5vdmVybGF5U3RhY2ssXG4gICAge1xuICAgICAga2V5OiBgc3RhY2stJHtvdmVybGF5SXRlbUlkfWAsXG4gICAgICBjb21wb25lbnQsXG4gICAgICB0cmFuc2l0aW9uXG4gICAgfVxuICBdO1xuICByZXR1cm4ge1xuICAgIC4uLmN1cnJlbnRTdGF0ZSxcbiAgICBvdmVybGF5U3RhY2ssXG4gICAgb3ZlcmxheUl0ZW1JZCxcbiAgICBjdXJyZW50T3ZlcmxheTogTWF0aC5tYXgoMCwgTWF0aC5taW4oY3VycmVudFN0YXRlLmN1cnJlbnRPdmVybGF5ICsgMSwgb3ZlcmxheVN0YWNrLmxlbmd0aCAtIDEpKSxcbiAgICBwcmV2aW91c092ZXJsYXk6IGN1cnJlbnRTdGF0ZS5jdXJyZW50T3ZlcmxheVxuICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlT3ZlcmxheShjdXJyZW50U3RhdGUpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5jdXJyZW50U3RhdGUsXG4gICAgb3ZlcmxheVN0YWNrOiBbXSxcbiAgICBjdXJyZW50T3ZlcmxheTogLTEsXG4gICAgcHJldmlvdXNPdmVybGF5OiBjdXJyZW50U3RhdGUuY3VycmVudE92ZXJsYXlcbiAgfTtcbn1cbmZ1bmN0aW9uIGFkZChjdXJyZW50U3RhdGUsIGtleTYsIHRyYW5zaXRpb24sIGNvbXBvbmVudCkge1xuICBpZiAoIWN1cnJlbnRTdGF0ZS5jb250YWluZXJzW2tleTZdKVxuICAgIGN1cnJlbnRTdGF0ZS5jb250YWluZXJzW2tleTZdID0gY29tcG9uZW50O1xuICBjdXJyZW50U3RhdGUuaGlzdG9yeSA9IGN1cnJlbnRTdGF0ZS5oaXN0b3J5LnNsaWNlKDAsIGN1cnJlbnRTdGF0ZS5jdXJyZW50ICsgMSk7XG4gIGN1cnJlbnRTdGF0ZS52aXN1YWxJbmRleCA9IE1hdGgubWF4KGN1cnJlbnRTdGF0ZS5oaXN0b3J5Lmxlbmd0aCwgMCk7XG4gIGNvbnN0IGN1cnJlbnRJdGVtID0gY3VycmVudFN0YXRlLmhpc3RvcnlbY3VycmVudFN0YXRlLmhpc3RvcnkubGVuZ3RoIC0gMV07XG4gIGNvbnN0IGlzQ3VycmVudFNjcmVlbiA9IGN1cnJlbnRJdGVtICYmIGN1cnJlbnRJdGVtLmtleSA9PT0ga2V5NjtcbiAgY3VycmVudFN0YXRlLm92ZXJsYXlTdGFjayA9IFtdO1xuICBpZiAoaXNDdXJyZW50U2NyZWVuICYmIGN1cnJlbnRTdGF0ZS5jdXJyZW50T3ZlcmxheSA+IC0xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmN1cnJlbnRTdGF0ZSxcbiAgICAgIGN1cnJlbnRPdmVybGF5OiAtMSxcbiAgICAgIHByZXZpb3VzT3ZlcmxheTogY3VycmVudFN0YXRlLmN1cnJlbnRPdmVybGF5XG4gICAgfTtcbiAgfVxuICBpZiAoaXNDdXJyZW50U2NyZWVuKVxuICAgIHJldHVybjtcbiAgY29uc3Qgc2hvdWxkTW92ZUZvcndhcmQgPSAoY3VycmVudEl0ZW0gPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlbnRJdGVtLmtleSkgJiYgdHJhbnNpdGlvbi53aXRoTWFnaWNNb3Rpb24gPyBpc05leHRUYXJnZXRGb3J3YXJkKGtleTYsIGN1cnJlbnRTdGF0ZS5jb250YWluZXJWaXN1YWxJbmRleFtrZXk2XSwgY3VycmVudFN0YXRlLmNvbnRhaW5lcklzUmVtb3ZlZFtrZXk2XSwgY3VycmVudFN0YXRlLmhpc3RvcnkpIDogdHJ1ZTtcbiAgY3VycmVudFN0YXRlLmhpc3RvcnkucHVzaCh7XG4gICAga2V5OiBrZXk2LFxuICAgIHRyYW5zaXRpb24sXG4gICAgdmlzdWFsSW5kZXg6IHNob3VsZE1vdmVGb3J3YXJkID8gTWF0aC5tYXgoY3VycmVudFN0YXRlLnZpc3VhbEluZGV4LCAwKSA6IGN1cnJlbnRTdGF0ZS5jb250YWluZXJWaXN1YWxJbmRleFtrZXk2XVxuICB9KTtcbiAgY29uc3QgY3VycmVudCA9IGN1cnJlbnRTdGF0ZS5jdXJyZW50ICsgMTtcbiAgY29uc3QgcHJldmlvdXMgPSBjdXJyZW50U3RhdGUuY3VycmVudDtcbiAgZm9yIChjb25zdCBjb250YWluZXJLZXkgaW4gY3VycmVudFN0YXRlLmNvbnRhaW5lckluZGV4KSB7XG4gICAgaWYgKGN1cnJlbnRTdGF0ZS5jb250YWluZXJJbmRleFtjb250YWluZXJLZXldID09PSBjdXJyZW50KSB7XG4gICAgICBjdXJyZW50U3RhdGUuY29udGFpbmVySW5kZXhbY29udGFpbmVyS2V5XSA9IGZpbmRMYXRlc3RIaXN0b3J5SW5kZXgoY29udGFpbmVyS2V5LCBjdXJyZW50U3RhdGUuaGlzdG9yeSk7XG4gICAgfVxuICB9XG4gIGN1cnJlbnRTdGF0ZS5jb250YWluZXJJbmRleFtrZXk2XSA9IGN1cnJlbnQ7XG4gIGNvbnN0IHsgY29udGFpbmVyVmlzdWFsSW5kZXgsIGNvbnRhaW5lcklzUmVtb3ZlZCB9ID0gbWFnaWNNb3Rpb25Qcm9wc0ZvckFkZChjdXJyZW50U3RhdGUsIGtleTYsIGN1cnJlbnRJdGVtID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50SXRlbS5rZXksIHNob3VsZE1vdmVGb3J3YXJkKTtcbiAgY29uc3QgdHJhbnNpdGlvbkZvckNvbnRhaW5lciA9IHVwZGF0ZVRyYW5zaXRpb25zKGN1cnJlbnQsIHByZXZpb3VzLCBjdXJyZW50U3RhdGUuaGlzdG9yeSwgY3VycmVudFN0YXRlLmNvbnRhaW5lckluZGV4LCBjdXJyZW50U3RhdGUudHJhbnNpdGlvbkZvckNvbnRhaW5lcik7XG4gIHJldHVybiB7XG4gICAgLi4uY3VycmVudFN0YXRlLFxuICAgIGN1cnJlbnQsXG4gICAgcHJldmlvdXMsXG4gICAgY29udGFpbmVyVmlzdWFsSW5kZXgsXG4gICAgY29udGFpbmVySXNSZW1vdmVkLFxuICAgIHRyYW5zaXRpb25Gb3JDb250YWluZXIsXG4gICAgcHJldmlvdXNUcmFuc2l0aW9uOiBudWxsLFxuICAgIGN1cnJlbnRPdmVybGF5OiAtMSxcbiAgICBoaXN0b3J5SXRlbUlkOiBjdXJyZW50U3RhdGUuaGlzdG9yeUl0ZW1JZCArIDEsXG4gICAgcHJldmlvdXNPdmVybGF5OiBjdXJyZW50U3RhdGUuY3VycmVudE92ZXJsYXlcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlbW92ZShjdXJyZW50U3RhdGUpIHtcbiAgY29uc3QgaGlzdG9yeSA9IFsuLi5jdXJyZW50U3RhdGUuaGlzdG9yeS5zbGljZSgwLCBjdXJyZW50U3RhdGUuY3VycmVudCArIDEpXTtcbiAgaWYgKGhpc3RvcnkubGVuZ3RoID09PSAxKVxuICAgIHJldHVybjtcbiAgY29uc3QgY3VycmVudEl0ZW0gPSBoaXN0b3J5LnBvcCgpO1xuICBpZiAoIWN1cnJlbnRJdGVtKVxuICAgIHJldHVybjtcbiAgY29uc3QgdGFyZ2V0ID0gaGlzdG9yeVtoaXN0b3J5Lmxlbmd0aCAtIDFdO1xuICBjdXJyZW50U3RhdGUuY29udGFpbmVySW5kZXhbdGFyZ2V0LmtleV0gPSBoaXN0b3J5Lmxlbmd0aCAtIDE7XG4gIGNvbnN0IHNob3VsZFJlbW92ZUNvbnRhaW5lciA9IGhpc3RvcnkuZXZlcnkoKGl0ZW0pID0+IGl0ZW0ua2V5ICE9PSBjdXJyZW50SXRlbS5rZXkpO1xuICBpZiAoc2hvdWxkUmVtb3ZlQ29udGFpbmVyKSB7XG4gICAgZGVsZXRlIGN1cnJlbnRTdGF0ZS5jb250YWluZXJzW2N1cnJlbnRJdGVtLmtleV07XG4gIH1cbiAgY29uc3QgY3VycmVudCA9IGN1cnJlbnRTdGF0ZS5jdXJyZW50IC0gMTtcbiAgY29uc3QgcHJldmlvdXMgPSBjdXJyZW50U3RhdGUuY3VycmVudDtcbiAgY29uc3QgeyBjb250YWluZXJJc1JlbW92ZWQsIGNvbnRhaW5lclZpc3VhbEluZGV4LCBwcmV2aW91c1RyYW5zaXRpb24sIHZpc3VhbEluZGV4IH0gPSBtYWdpY01vdGlvblByb3BzRm9yUmVtb3ZlKGN1cnJlbnRTdGF0ZSwgdGFyZ2V0LCBjdXJyZW50SXRlbSk7XG4gIGNvbnN0IHRyYW5zaXRpb25Gb3JDb250YWluZXIgPSB1cGRhdGVUcmFuc2l0aW9ucyhjdXJyZW50LCBwcmV2aW91cywgY3VycmVudFN0YXRlLmhpc3RvcnksIGN1cnJlbnRTdGF0ZS5jb250YWluZXJJbmRleCwgY3VycmVudFN0YXRlLnRyYW5zaXRpb25Gb3JDb250YWluZXIpO1xuICByZXR1cm4ge1xuICAgIC4uLmN1cnJlbnRTdGF0ZSxcbiAgICBjdXJyZW50LFxuICAgIHByZXZpb3VzLFxuICAgIGNvbnRhaW5lcklzUmVtb3ZlZCxcbiAgICBjb250YWluZXJWaXN1YWxJbmRleCxcbiAgICBwcmV2aW91c1RyYW5zaXRpb24sXG4gICAgdmlzdWFsSW5kZXgsXG4gICAgdHJhbnNpdGlvbkZvckNvbnRhaW5lclxuICB9O1xufVxuZnVuY3Rpb24gbWFnaWNNb3Rpb25Qcm9wc0ZvckFkZChjdXJyZW50U3RhdGUsIG5leHRLZXksIGN1cnJlbnRLZXksIHNob3VsZE1vdmVGb3J3YXJkKSB7XG4gIGNvbnN0IHVwZGF0ZSA9IHtcbiAgICBjb250YWluZXJWaXN1YWxJbmRleDogeyAuLi5jdXJyZW50U3RhdGUuY29udGFpbmVyVmlzdWFsSW5kZXggfSxcbiAgICBjb250YWluZXJJc1JlbW92ZWQ6IHsgLi4uY3VycmVudFN0YXRlLmNvbnRhaW5lcklzUmVtb3ZlZCB9XG4gIH07XG4gIGlmIChzaG91bGRNb3ZlRm9yd2FyZCkge1xuICAgIHVwZGF0ZS5jb250YWluZXJWaXN1YWxJbmRleFtuZXh0S2V5XSA9IGN1cnJlbnRTdGF0ZS5oaXN0b3J5Lmxlbmd0aCAtIDE7XG4gICAgdXBkYXRlLmNvbnRhaW5lcklzUmVtb3ZlZFtuZXh0S2V5XSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5leHRWaXN1YWxJbmRleCA9IGN1cnJlbnRTdGF0ZS5jb250YWluZXJWaXN1YWxJbmRleFtuZXh0S2V5XTtcbiAgICBmb3IgKGNvbnN0IGtleTYgaW4gY3VycmVudFN0YXRlLmNvbnRhaW5lclZpc3VhbEluZGV4KSB7XG4gICAgICBpZiAoY3VycmVudFN0YXRlLmNvbnRhaW5lclZpc3VhbEluZGV4W2tleTZdID4gbmV4dFZpc3VhbEluZGV4KSB7XG4gICAgICAgIHVwZGF0ZS5jb250YWluZXJJc1JlbW92ZWRba2V5Nl0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdXBkYXRlO1xufVxuZnVuY3Rpb24gbWFnaWNNb3Rpb25Qcm9wc0ZvclJlbW92ZShjdXJyZW50U3RhdGUsIHRhcmdldCwgY3VycmVudEl0ZW0pIHtcbiAgY29uc3QgeyBoaXN0b3J5IH0gPSBnbG9iYWxUaGlzO1xuICBjb25zdCB2YWxpZFRhcmdldHMgPSBbdGFyZ2V0LmtleSwgY3VycmVudEl0ZW0ua2V5XTtcbiAgY29uc3QgbmV4dFZhbGlkVGFyZ2V0ID0gaGlzdG9yeVtoaXN0b3J5Lmxlbmd0aCAtIDJdO1xuICBjb25zdCBwcmV2aW91c1RyYW5zaXRpb24gPSBjdXJyZW50U3RhdGUucHJldmlvdXNUcmFuc2l0aW9uID09PSBudWxsID8gbnVsbCA6IHsgLi4uY3VycmVudFN0YXRlLnByZXZpb3VzVHJhbnNpdGlvbiB9O1xuICBjb25zdCB1cGRhdGUgPSB7XG4gICAgY29udGFpbmVySXNSZW1vdmVkOiB7IC4uLmN1cnJlbnRTdGF0ZS5jb250YWluZXJJc1JlbW92ZWQgfSxcbiAgICBjb250YWluZXJWaXN1YWxJbmRleDogeyAuLi5jdXJyZW50U3RhdGUuY29udGFpbmVyVmlzdWFsSW5kZXggfSxcbiAgICBwcmV2aW91c1RyYW5zaXRpb24sXG4gICAgdmlzdWFsSW5kZXg6IGN1cnJlbnRTdGF0ZS52aXN1YWxJbmRleFxuICB9O1xuICBpZiAobmV4dFZhbGlkVGFyZ2V0KVxuICAgIHZhbGlkVGFyZ2V0cy5wdXNoKG5leHRWYWxpZFRhcmdldC5rZXkpO1xuICBjb25zdCBzaG91bGRSZW1vdmVMYXN0S2V5ID0gY3VycmVudFN0YXRlLmNvbnRhaW5lclZpc3VhbEluZGV4W3RhcmdldC5rZXldIDw9IGN1cnJlbnRTdGF0ZS5jb250YWluZXJWaXN1YWxJbmRleFtjdXJyZW50SXRlbS5rZXldIHx8IHRhcmdldC52aXN1YWxJbmRleCAhPT0gdm9pZCAwICYmIHRhcmdldC52aXN1YWxJbmRleCA8IGhpc3RvcnkubGVuZ3RoIC0gMTtcbiAgY29uc3QgbmV4dEluZGV4ID0gdGFyZ2V0LnZpc3VhbEluZGV4O1xuICBpZiAoc2hvdWxkUmVtb3ZlTGFzdEtleSkge1xuICAgIHVwZGF0ZS5jb250YWluZXJJc1JlbW92ZWRbY3VycmVudEl0ZW0ua2V5XSA9IHRydWU7XG4gICAgdXBkYXRlLmNvbnRhaW5lclZpc3VhbEluZGV4W3RhcmdldC5rZXldID0gbmV4dEluZGV4ICE9PSB2b2lkIDAgPyBuZXh0SW5kZXggOiBoaXN0b3J5Lmxlbmd0aCAtIDE7XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlLnZpc3VhbEluZGV4ID0gY3VycmVudFN0YXRlLnZpc3VhbEluZGV4ICsgMTtcbiAgICB1cGRhdGUuY29udGFpbmVyVmlzdWFsSW5kZXhbdGFyZ2V0LmtleV0gPSBjdXJyZW50U3RhdGUudmlzdWFsSW5kZXggKyAxO1xuICB9XG4gIGlmIChjdXJyZW50SXRlbS50cmFuc2l0aW9uLndpdGhNYWdpY01vdGlvbilcbiAgICB1cGRhdGUucHJldmlvdXNUcmFuc2l0aW9uID0gY3VycmVudEl0ZW0udHJhbnNpdGlvbiB8fCBudWxsO1xuICBjdXJyZW50U3RhdGUuY29udGFpbmVySXNSZW1vdmVkW3RhcmdldC5rZXldID0gZmFsc2U7XG4gIHJldHVybiB1cGRhdGU7XG59XG5mdW5jdGlvbiBmaW5kTGF0ZXN0SGlzdG9yeUluZGV4KGtleTYsIGhpc3RvcnkpIHtcbiAgZm9yIChsZXQgaW5kZXggPSBoaXN0b3J5Lmxlbmd0aDsgaW5kZXggPiBoaXN0b3J5Lmxlbmd0aDsgaW5kZXgtLSkge1xuICAgIGlmIChoaXN0b3J5W2luZGV4XS5rZXkgPT09IGtleTYpXG4gICAgICByZXR1cm4gaW5kZXg7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gdXBkYXRlVHJhbnNpdGlvbnMoY3VycmVudCwgcHJldmlvdXMsIGhpc3RvcnksIGNvbnRhaW5lckluZGV4LCB0cmFuc2l0aW9uRm9yQ29udGFpbmVyKSB7XG4gIGNvbnN0IHRyYW5zaXRpb25zID0geyAuLi50cmFuc2l0aW9uRm9yQ29udGFpbmVyIH07XG4gIE9iamVjdC5rZXlzKGNvbnRhaW5lckluZGV4KS5mb3JFYWNoKChrZXk2KSA9PiB7XG4gICAgY29uc3QgdHJhbnNpdGlvbiA9IHRyYW5zaXRpb25Gb3JTY3JlZW4oY29udGFpbmVySW5kZXhba2V5Nl0sIHsgY3VycmVudCwgcHJldmlvdXMsIGhpc3RvcnkgfSk7XG4gICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgIHRyYW5zaXRpb25zW2tleTZdID0gdHJhbnNpdGlvbjtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdHJhbnNpdGlvbnM7XG59XG5mdW5jdGlvbiBpc05leHRUYXJnZXRGb3J3YXJkKGtleTYsIGluZGV4LCByZW1vdmVkLCBoaXN0b3J5KSB7XG4gIGlmIChyZW1vdmVkKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAoaW5kZXggPT09IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBmb3J3YXJkSGlzdG9yeSA9IGhpc3Rvcnkuc2xpY2UoaW5kZXgsIGhpc3RvcnkubGVuZ3RoKTtcbiAgaWYgKGZvcndhcmRIaXN0b3J5LmZpbmRJbmRleCgoaXRlbSkgPT4gaXRlbS5rZXkgPT09IGtleTYpID4gLTEpXG4gICAgcmV0dXJuIHRydWU7XG4gIGNvbnN0IGJhY2t3YXJkc0hpc3RvcnkgPSBoaXN0b3J5LnNsaWNlKDAsIGluZGV4IC0gMSk7XG4gIGlmIChiYWNrd2FyZHNIaXN0b3J5LmZpbmRJbmRleCgoaXRlbSkgPT4gaXRlbS5rZXkgPT09IGtleTYpID4gLTEpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb25Gb3JTY3JlZW4oc2NyZWVuSW5kZXgsIHN0YWNrU3RhdGUpIHtcbiAgY29uc3QgeyBjdXJyZW50LCBwcmV2aW91cywgaGlzdG9yeSB9ID0gc3RhY2tTdGF0ZTtcbiAgaWYgKHNjcmVlbkluZGV4ICE9PSBjdXJyZW50ICYmIHNjcmVlbkluZGV4ICE9PSBwcmV2aW91cylcbiAgICByZXR1cm4gdm9pZCAwO1xuICBpZiAoc2NyZWVuSW5kZXggPT09IGN1cnJlbnQgJiYgY3VycmVudCA+IHByZXZpb3VzKSB7XG4gICAgY29uc3QgaXRlbSA9IGhpc3Rvcnlbc2NyZWVuSW5kZXhdO1xuICAgIHJldHVybiBzZXF1ZW5jZShcImVudGVyXCIsIGl0ZW0udHJhbnNpdGlvbi5lbnRlciwgaXRlbS50cmFuc2l0aW9uLmFuaW1hdGlvbik7XG4gIH1cbiAgaWYgKHNjcmVlbkluZGV4ID09PSBwcmV2aW91cyAmJiBjdXJyZW50ID4gcHJldmlvdXMpIHtcbiAgICBjb25zdCBpdGVtID0gaGlzdG9yeVtzY3JlZW5JbmRleCArIDFdO1xuICAgIHJldHVybiBzZXF1ZW5jZShcImV4aXRcIiwgaXRlbS50cmFuc2l0aW9uLmV4aXQsIGl0ZW0udHJhbnNpdGlvbi5hbmltYXRpb24pO1xuICB9XG4gIGlmIChzY3JlZW5JbmRleCA9PT0gY3VycmVudCAmJiBjdXJyZW50IDwgcHJldmlvdXMpIHtcbiAgICBjb25zdCBpdGVtID0gaGlzdG9yeVtzY3JlZW5JbmRleCArIDFdO1xuICAgIHJldHVybiBzZXF1ZW5jZShcImVudGVyXCIsIGl0ZW0udHJhbnNpdGlvbi5leGl0LCBpdGVtLnRyYW5zaXRpb24uYW5pbWF0aW9uKTtcbiAgfVxuICBpZiAoc2NyZWVuSW5kZXggPT09IHByZXZpb3VzICYmIGN1cnJlbnQgPCBwcmV2aW91cykge1xuICAgIGNvbnN0IGl0ZW0gPSBoaXN0b3J5W3NjcmVlbkluZGV4XTtcbiAgICByZXR1cm4gc2VxdWVuY2UoXCJleGl0XCIsIGl0ZW0udHJhbnNpdGlvbi5lbnRlciwgaXRlbS50cmFuc2l0aW9uLmFuaW1hdGlvbik7XG4gIH1cbn1cbnZhciBhbGxBbmltYXRhYmxlS2V5cyA9IE9iamVjdC5rZXlzKGFsbEFuaW1hdGFibGVQcm9wZXJ0aWVzKTtcbmZ1bmN0aW9uIHNlcXVlbmNlKGRpcmVjdGlvbiwgdHJhbnNpdGlvbiwgYW5pbWF0aW9uKSB7XG4gIGNvbnN0IHZhbHVlID0ge307XG4gIGNvbnN0IGZyb20gPSB7fTtcbiAgYWxsQW5pbWF0YWJsZUtleXMuZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgICB2YWx1ZVtwcm9wZXJ0eV0gPSBhbGxBbmltYXRhYmxlUHJvcGVydGllc1twcm9wZXJ0eV07XG4gICAgZnJvbVtwcm9wZXJ0eV0gPSB7XG4gICAgICAuLi5hbmltYXRpb24sXG4gICAgICBmcm9tOiBhbGxBbmltYXRhYmxlUHJvcGVydGllc1twcm9wZXJ0eV1cbiAgICB9O1xuICB9KTtcbiAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICBPYmplY3Qua2V5cyh0cmFuc2l0aW9uKS5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICAgICAgaWYgKHRyYW5zaXRpb25bcHJvcGVydHldID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25UbyA9IHRyYW5zaXRpb25bcHJvcGVydHldO1xuICAgICAgY29uc3QgdHJhbnNpdGlvbkZyb20gPSB0eXBlb2YgdHJhbnNpdGlvbltwcm9wZXJ0eV0gPT09IFwic3RyaW5nXCIgPyBgJHthbGxBbmltYXRhYmxlUHJvcGVydGllc1twcm9wZXJ0eV19JWAgOiBhbGxBbmltYXRhYmxlUHJvcGVydGllc1twcm9wZXJ0eV07XG4gICAgICB2YWx1ZVtwcm9wZXJ0eV0gPSBkaXJlY3Rpb24gPT09IFwiZW50ZXJcIiA/IHRyYW5zaXRpb25Gcm9tIDogdHJhbnNpdGlvblRvO1xuICAgICAgZnJvbVtwcm9wZXJ0eV0gPSB7XG4gICAgICAgIC4uLmFuaW1hdGlvbixcbiAgICAgICAgZnJvbTogZGlyZWN0aW9uID09PSBcImVudGVyXCIgPyB0cmFuc2l0aW9uVG8gOiB0cmFuc2l0aW9uRnJvbSxcbiAgICAgICAgdmVsb2NpdHk6IDBcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi52YWx1ZSxcbiAgICB0cmFuc2l0aW9uOiB7XG4gICAgICAuLi5mcm9tXG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9OYXZpZ2F0aW9uLnRzeFxudmFyIE5hdmlnYXRpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dDE1KG5hdmlnYXRvck1vY2spO1xudmFyIE5hdmlnYXRpb25Db25zdW1lciA9IE5hdmlnYXRpb25Db250ZXh0LkNvbnN1bWVyO1xudmFyIE5hdmlnYXRpb25DYWxsYmFja0NvbnRleHQgPSBjcmVhdGVDb250ZXh0MTUodm9pZCAwKTtcbnZhciBOYXZpZ2F0aW9uQ2FsbGJhY2tQcm92aWRlciA9IE5hdmlnYXRpb25DYWxsYmFja0NvbnRleHQuUHJvdmlkZXI7XG52YXIgTmF2aWdhdGlvbiA9IGNsYXNzIGV4dGVuZHMgQ29tcG9uZW50MTIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubGFzdEV2ZW50VGltZVN0YW1wID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gZGVmYXVsdFN0YXRlKCk7XG4gICAgdGhpcy5uYXZpZ2F0aW9uQWN0aW9uID0gKGFjdGlvbikgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCF0aGlzLnByb3BzLmVuYWJsZWQgJiYgdGhpcy5zdGF0ZS5oaXN0b3J5Lmxlbmd0aCA+IDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gcmVkdWNlTmF2aWdhdGlvblN0YXRlRm9yQWN0aW9uKHRoaXMuc3RhdGUsIGFjdGlvbik7XG4gICAgICBpZiAobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJdGVtID0gbmV3U3RhdGUuaGlzdG9yeVtuZXdTdGF0ZS5jdXJyZW50XTtcbiAgICAgICAgKF9hID0gdGhpcy5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBjdXJyZW50SXRlbS5rZXkpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nb0JhY2sgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAodGhpcy5pc1NhbWVFdmVudFRyYW5zaXRpb24oKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5sYXN0RXZlbnRUaW1lU3RhbXAgPSAoKF9hID0gZ2xvYmFsVGhpcy5ldmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRpbWVTdGFtcCkgfHwgbnVsbDtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmN1cnJlbnRPdmVybGF5ICE9PSAtMSlcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvbkFjdGlvbih7IHR5cGU6IFwicmVtb3ZlT3ZlcmxheVwiIH0pO1xuICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvbkFjdGlvbih7IHR5cGU6IFwicmVtb3ZlXCIgfSk7XG4gICAgfTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5oaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uKHRoaXMucHJvcHMuY2hpbGRyZW4sIFRyYW5zaXRpb25EZWZhdWx0cy5JbnN0YW50KTtcbiAgICB9XG4gICAgaW5qZWN0Q29tcG9uZW50Q1NTUnVsZXMoKTtcbiAgfVxuICBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhwcm9wcykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBjb21wb25lbnQgPSBwcm9wc1tcImNoaWxkcmVuXCJdO1xuICAgIGlmICghaXNSZWFjdENoaWxkKGNvbXBvbmVudCkgfHwgIWlzUmVhY3RFbGVtZW50KGNvbXBvbmVudCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qga2V5NiA9IChfYSA9IGNvbXBvbmVudC5rZXkpID09IG51bGwgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpO1xuICAgIGlmICgha2V5NilcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5zdGF0ZS5oaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uKGNvbXBvbmVudCwgVHJhbnNpdGlvbkRlZmF1bHRzLkluc3RhbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5hdmlnYXRpb25BY3Rpb24oeyB0eXBlOiBcInVwZGF0ZVwiLCBrZXk6IGtleTYsIGNvbXBvbmVudCB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0U3RhY2tTdGF0ZShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjdXJyZW50LCBwcmV2aW91cywgY3VycmVudE92ZXJsYXksIHByZXZpb3VzT3ZlcmxheSB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAob3B0aW9ucy5vdmVyQ3VycmVudENvbnRleHQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGN1cnJlbnQ6IGN1cnJlbnRPdmVybGF5LFxuICAgICAgICBwcmV2aW91czogcHJldmlvdXNPdmVybGF5LFxuICAgICAgICBoaXN0b3J5OiB0aGlzLnN0YXRlLm92ZXJsYXlTdGFja1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBwcmV2aW91cyxcbiAgICAgIGhpc3Rvcnk6IHRoaXMuc3RhdGUuaGlzdG9yeVxuICAgIH07XG4gIH1cbiAgaXNTYW1lRXZlbnRUcmFuc2l0aW9uKCkge1xuICAgIGlmICghZ2xvYmFsVGhpcy5ldmVudClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5sYXN0RXZlbnRUaW1lU3RhbXAgPT09IGdsb2JhbFRoaXMuZXZlbnQudGltZVN0YW1wO1xuICB9XG4gIHRyYW5zaXRpb24oY29tcG9uZW50LCB0cmFuc2l0aW9uVHJhaXRzLCB0cmFuc2l0aW9uT3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKHRoaXMuaXNTYW1lRXZlbnRUcmFuc2l0aW9uKCkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5sYXN0RXZlbnRUaW1lU3RhbXAgPSAoKF9hID0gZ2xvYmFsVGhpcy5ldmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRpbWVTdGFtcCkgfHwgbnVsbDtcbiAgICBpZiAoIWNvbXBvbmVudCB8fCAhaXNSZWFjdENoaWxkKGNvbXBvbmVudCkgfHwgIWlzUmVhY3RFbGVtZW50KGNvbXBvbmVudCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdHJhbnNpdGlvbiA9IHsgLi4udHJhbnNpdGlvblRyYWl0cywgLi4udHJhbnNpdGlvbk9wdGlvbnMgfTtcbiAgICBjb25zdCBvdmVyQ3VycmVudENvbnRleHQgPSAhIXRyYW5zaXRpb24ub3ZlckN1cnJlbnRDb250ZXh0O1xuICAgIGlmIChvdmVyQ3VycmVudENvbnRleHQpXG4gICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0aW9uQWN0aW9uKHsgdHlwZTogXCJhZGRPdmVybGF5XCIsIHRyYW5zaXRpb24sIGNvbXBvbmVudCB9KTtcbiAgICBjb25zdCBrZXk2ID0gKChfYiA9IGNvbXBvbmVudCA9PSBudWxsID8gdm9pZCAwIDogY29tcG9uZW50LmtleSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnRvU3RyaW5nKCkpIHx8IGBzdGFjay0ke3RoaXMuc3RhdGUuaGlzdG9yeUl0ZW1JZCArIDF9YDtcbiAgICB0aGlzLm5hdmlnYXRpb25BY3Rpb24oeyB0eXBlOiBcImFkZFwiLCBrZXk6IGtleTYsIHRyYW5zaXRpb24sIGNvbXBvbmVudCB9KTtcbiAgfVxuICBpbnN0YW50KGNvbXBvbmVudCkge1xuICAgIHRoaXMudHJhbnNpdGlvbihjb21wb25lbnQsIFRyYW5zaXRpb25EZWZhdWx0cy5JbnN0YW50KTtcbiAgfVxuICBmYWRlKGNvbXBvbmVudCwgb3B0aW9ucykge1xuICAgIHRoaXMudHJhbnNpdGlvbihjb21wb25lbnQsIFRyYW5zaXRpb25EZWZhdWx0cy5GYWRlLCBvcHRpb25zKTtcbiAgfVxuICBwdXNoKGNvbXBvbmVudCwgb3B0aW9ucykge1xuICAgIHRoaXMudHJhbnNpdGlvbihjb21wb25lbnQsIHB1c2hUcmFuc2l0aW9uKG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgfVxuICBtb2RhbChjb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnRyYW5zaXRpb24oY29tcG9uZW50LCBUcmFuc2l0aW9uRGVmYXVsdHMuTW9kYWwsIG9wdGlvbnMpO1xuICB9XG4gIG92ZXJsYXkoY29tcG9uZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy50cmFuc2l0aW9uKGNvbXBvbmVudCwgb3ZlcmxheVRyYW5zaXRpb24ob3B0aW9ucyksIG9wdGlvbnMpO1xuICB9XG4gIGZsaXAoY29tcG9uZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy50cmFuc2l0aW9uKGNvbXBvbmVudCwgZmxpcFRyYW5zaXRpb24ob3B0aW9ucyksIG9wdGlvbnMpO1xuICB9XG4gIG1hZ2ljTW90aW9uKGNvbXBvbmVudCwgb3B0aW9ucykge1xuICAgIHRoaXMudHJhbnNpdGlvbihjb21wb25lbnQsIFRyYW5zaXRpb25EZWZhdWx0cy5NYWdpY01vdGlvbiwgb3B0aW9ucyk7XG4gIH1cbiAgY3VzdG9tVHJhbnNpdGlvbihjb21wb25lbnQsIHRyYW5zaXRpb24pIHtcbiAgICB0aGlzLnRyYW5zaXRpb24oY29tcG9uZW50LCB0cmFuc2l0aW9uKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qgc3RhY2tTdGF0ZSA9IHRoaXMuZ2V0U3RhY2tTdGF0ZSh7IG92ZXJDdXJyZW50Q29udGV4dDogZmFsc2UgfSk7XG4gICAgY29uc3Qgb3ZlcmxheVN0YWNrU3RhdGUgPSB0aGlzLmdldFN0YWNrU3RhdGUoeyBvdmVyQ3VycmVudENvbnRleHQ6IHRydWUgfSk7XG4gICAgY29uc3QgYWN0aXZlT3ZlcmxheSA9IGFjdGl2ZU92ZXJsYXlJdGVtKG92ZXJsYXlTdGFja1N0YXRlKTtcbiAgICBjb25zdCBpc092ZXJsYXlWaXNpYmxlID0gb3ZlcmxheVN0YWNrU3RhdGUuY3VycmVudCA+IC0xO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDMyKEZyYW1lV2l0aE1vdGlvbiwge1xuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgc3R5bGU6IHsgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsIGJhY2tncm91bmRDb2xvcjogXCJ1bnNldFwiLCAuLi50aGlzLnByb3BzLnN0eWxlIH1cbiAgICB9LCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDMyKE5hdmlnYXRpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogdGhpc1xuICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MzIoTmF2aWdhdGlvbkNvbnRhaW5lciwge1xuICAgICAgaXNMYXllcmVkQ29udGFpbmVyOiB0cnVlLFxuICAgICAgcG9zaXRpb246IHZvaWQgMCxcbiAgICAgIGluaXRpYWxQcm9wczoge30sXG4gICAgICBpbnN0YW50OiBmYWxzZSxcbiAgICAgIHRyYW5zaXRpb25Qcm9wczogdHJhbnNpdGlvblByb3BzRm9yU3RhY2tXcmFwcGVyKGFjdGl2ZU92ZXJsYXkpLFxuICAgICAgYW5pbWF0aW9uOiBhbmltYXRpb25Gb3JTdGFja1dyYXBwZXIoYWN0aXZlT3ZlcmxheSksXG4gICAgICBiYWNrZmFjZVZpc2libGU6IGJhY2tmYWNlVmlzaWJsZUZvclN0YWNrV3JhcHBlcihhY3RpdmVPdmVybGF5KSxcbiAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICBiYWNrZHJvcENvbG9yOiB2b2lkIDAsXG4gICAgICBvblRhcEJhY2tkcm9wOiB2b2lkIDAsXG4gICAgICBpbmRleDogMFxuICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MzIoTGF5b3V0SWRQcm92aWRlciwgbnVsbCwgLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQzMihBbmltYXRlTGF5b3V0VHJlZXMsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MzIoQW5pbWF0ZVByZXNlbmNlLCB7XG4gICAgICBwcmVzZW5jZUFmZmVjdHNMYXlvdXQ6IGZhbHNlXG4gICAgfSwgT2JqZWN0LmtleXModGhpcy5zdGF0ZS5jb250YWluZXJzKS5tYXAoKGtleTYpID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLnN0YXRlLmNvbnRhaW5lcnNba2V5Nl07XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuc3RhdGUuY29udGFpbmVySW5kZXhba2V5Nl07XG4gICAgICBjb25zdCB2aXN1YWxJbmRleCA9IHRoaXMuc3RhdGUuY29udGFpbmVyVmlzdWFsSW5kZXhba2V5Nl07XG4gICAgICBjb25zdCByZW1vdmVkID0gdGhpcy5zdGF0ZS5jb250YWluZXJJc1JlbW92ZWRba2V5Nl07XG4gICAgICBjb25zdCBoaXN0b3J5SXRlbSA9IHRoaXMuc3RhdGUuaGlzdG9yeVtpbmRleF07XG4gICAgICBjb25zdCB0cmFuc2l0aW9uUHJvcHMgPSB0aGlzLnN0YXRlLnRyYW5zaXRpb25Gb3JDb250YWluZXJba2V5Nl07XG4gICAgICBjb25zdCBpc0N1cnJlbnQgPSBpbmRleCA9PT0gdGhpcy5zdGF0ZS5jdXJyZW50O1xuICAgICAgY29uc3QgaXNQcmV2aW91cyA9IGluZGV4ID09PSB0aGlzLnN0YXRlLnByZXZpb3VzO1xuICAgICAgY29uc3QgYXJlTWFnaWNNb3Rpb25MYXllcnNQcmVzZW50ID0gaXNDdXJyZW50ID8gZmFsc2UgOiByZW1vdmVkO1xuICAgICAgY29uc3Qgd2l0aE1hZ2ljTW90aW9uID0gKChfYSA9IGhpc3RvcnlJdGVtID09IG51bGwgPyB2b2lkIDAgOiBoaXN0b3J5SXRlbS50cmFuc2l0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2Eud2l0aE1hZ2ljTW90aW9uKSB8fCBpc0N1cnJlbnQgJiYgISF0aGlzLnN0YXRlLnByZXZpb3VzVHJhbnNpdGlvbjtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDMyKE5hdmlnYXRpb25Db250YWluZXIsIHtcbiAgICAgICAga2V5OiBrZXk2LFxuICAgICAgICBpZDoga2V5NixcbiAgICAgICAgaW5kZXg6IHZpc3VhbEluZGV4LFxuICAgICAgICBpc0N1cnJlbnQsXG4gICAgICAgIGlzUHJldmlvdXMsXG4gICAgICAgIGlzT3ZlcmxheWVkOiBpc092ZXJsYXlWaXNpYmxlLFxuICAgICAgICB2aXNpYmxlOiBpc0N1cnJlbnQgfHwgaXNQcmV2aW91cyxcbiAgICAgICAgcG9zaXRpb246IChfYiA9IGhpc3RvcnlJdGVtID09IG51bGwgPyB2b2lkIDAgOiBoaXN0b3J5SXRlbS50cmFuc2l0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2IucG9zaXRpb24sXG4gICAgICAgIGluc3RhbnQ6IGlzSW5zdGFudENvbnRhaW5lclRyYW5zaXRpb24oaW5kZXgsIHN0YWNrU3RhdGUpLFxuICAgICAgICB0cmFuc2l0aW9uUHJvcHMsXG4gICAgICAgIGFuaW1hdGlvbjogYW5pbWF0aW9uUHJvcHNGb3JDb250YWluZXIoaW5kZXgsIHN0YWNrU3RhdGUpLFxuICAgICAgICBiYWNrZmFjZVZpc2libGU6IGdldEJhY2tmYWNlVmlzaWJsZUZvclNjcmVlbihpbmRleCwgc3RhY2tTdGF0ZSksXG4gICAgICAgIGV4aXRBbmltYXRpb246IChfYyA9IGhpc3RvcnlJdGVtID09IG51bGwgPyB2b2lkIDAgOiBoaXN0b3J5SXRlbS50cmFuc2l0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2MuYW5pbWF0aW9uLFxuICAgICAgICBleGl0QmFja2ZhY2VWaXNpYmxlOiAoX2QgPSBoaXN0b3J5SXRlbSA9PSBudWxsID8gdm9pZCAwIDogaGlzdG9yeUl0ZW0udHJhbnNpdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmJhY2tmYWNlVmlzaWJsZSxcbiAgICAgICAgZXhpdFByb3BzOiAoX2UgPSBoaXN0b3J5SXRlbSA9PSBudWxsID8gdm9pZCAwIDogaGlzdG9yeUl0ZW0udHJhbnNpdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmVudGVyLFxuICAgICAgICB3aXRoTWFnaWNNb3Rpb24sXG4gICAgICAgIGFyZU1hZ2ljTW90aW9uTGF5ZXJzUHJlc2VudDogYXJlTWFnaWNNb3Rpb25MYXllcnNQcmVzZW50ID8gZmFsc2UgOiB2b2lkIDBcbiAgICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MzIoU3VzcGVuc2UsIHtcbiAgICAgICAgZmFsbGJhY2s6IFwiTG9hZGluZy4uLlwiXG4gICAgICB9LCBjb250YWluZXJDb250ZW50KHtcbiAgICAgICAgY29tcG9uZW50LFxuICAgICAgICB0cmFuc2l0aW9uOiBoaXN0b3J5SXRlbSA9PSBudWxsID8gdm9pZCAwIDogaGlzdG9yeUl0ZW0udHJhbnNpdGlvblxuICAgICAgfSkpKTtcbiAgICB9KSkpKSksIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MzIoQW5pbWF0ZVByZXNlbmNlLCBudWxsLCB0aGlzLnN0YXRlLm92ZXJsYXlTdGFjay5tYXAoKGl0ZW0sIHN0YWNrSW5kZXgpID0+IHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDMyKE5hdmlnYXRpb25Db250YWluZXIsIHtcbiAgICAgICAgaXNMYXllcmVkQ29udGFpbmVyOiB0cnVlLFxuICAgICAgICBrZXk6IGl0ZW0ua2V5LFxuICAgICAgICBpc0N1cnJlbnQ6IHN0YWNrSW5kZXggPT09IHRoaXMuc3RhdGUuY3VycmVudE92ZXJsYXksXG4gICAgICAgIHBvc2l0aW9uOiBpdGVtLnRyYW5zaXRpb24ucG9zaXRpb24sXG4gICAgICAgIGluaXRpYWxQcm9wczogaW5pdGlhbFByb3BzRm9yT3ZlcmxheShzdGFja0luZGV4LCBvdmVybGF5U3RhY2tTdGF0ZSksXG4gICAgICAgIHRyYW5zaXRpb25Qcm9wczogdHJhbnNpdGlvblByb3BzRm9yT3ZlcmxheShzdGFja0luZGV4LCBvdmVybGF5U3RhY2tTdGF0ZSksXG4gICAgICAgIGluc3RhbnQ6IGlzSW5zdGFudENvbnRhaW5lclRyYW5zaXRpb24oc3RhY2tJbmRleCwgb3ZlcmxheVN0YWNrU3RhdGUsIHRydWUpLFxuICAgICAgICBhbmltYXRpb246IGFuaW1hdGlvblByb3BzRm9yQ29udGFpbmVyKHN0YWNrSW5kZXgsIG92ZXJsYXlTdGFja1N0YXRlKSxcbiAgICAgICAgZXhpdFByb3BzOiBpdGVtLnRyYW5zaXRpb24uZW50ZXIsXG4gICAgICAgIHZpc2libGU6IGNvbnRhaW5lcklzVmlzaWJsZShzdGFja0luZGV4LCBvdmVybGF5U3RhY2tTdGF0ZSksXG4gICAgICAgIGJhY2tkcm9wQ29sb3I6IGJhY2tkcm9wQ29sb3JGb3JUcmFuc2l0aW9uKGl0ZW0udHJhbnNpdGlvbiksXG4gICAgICAgIGJhY2tmYWNlVmlzaWJsZTogZ2V0QmFja2ZhY2VWaXNpYmxlRm9yT3ZlcmxheShzdGFja0luZGV4LCBvdmVybGF5U3RhY2tTdGF0ZSksXG4gICAgICAgIG9uVGFwQmFja2Ryb3A6IGJhY2tkcm9wVGFwQWN0aW9uKGl0ZW0udHJhbnNpdGlvbiwgdGhpcy5nb0JhY2spLFxuICAgICAgICBpbmRleDogdGhpcy5zdGF0ZS5jdXJyZW50ICsgMSArIHN0YWNrSW5kZXhcbiAgICAgIH0sIGNvbnRhaW5lckNvbnRlbnQoeyBjb21wb25lbnQ6IGl0ZW0uY29tcG9uZW50LCB0cmFuc2l0aW9uOiBpdGVtLnRyYW5zaXRpb24gfSkpO1xuICAgIH0pKSkpO1xuICB9XG59O1xuTmF2aWdhdGlvbi5kZWZhdWx0UHJvcHMgPSB7XG4gIGVuYWJsZWQ6IHRydWVcbn07XG5OYXZpZ2F0aW9uLmNvbnRleHRUeXBlID0gTmF2aWdhdGlvbkNhbGxiYWNrQ29udGV4dDtcbnZhciBhbmltYXRpb25EZWZhdWx0ID0ge1xuICBzdGlmZm5lc3M6IDUwMCxcbiAgZGFtcGluZzogNTAsXG4gIHJlc3REZWx0YTogMSxcbiAgdHlwZTogXCJzcHJpbmdcIlxufTtcbmZ1bmN0aW9uIGFjdGl2ZU92ZXJsYXlJdGVtKG92ZXJsYXlTdGFjaykge1xuICBsZXQgY3VycmVudE92ZXJsYXlJdGVtO1xuICBsZXQgcHJldmlvdXNPdmVybGF5SXRlbTtcbiAgaWYgKG92ZXJsYXlTdGFjay5jdXJyZW50ICE9PSAtMSkge1xuICAgIGN1cnJlbnRPdmVybGF5SXRlbSA9IG92ZXJsYXlTdGFjay5oaXN0b3J5W292ZXJsYXlTdGFjay5jdXJyZW50XTtcbiAgfSBlbHNlIHtcbiAgICBwcmV2aW91c092ZXJsYXlJdGVtID0gb3ZlcmxheVN0YWNrLmhpc3Rvcnlbb3ZlcmxheVN0YWNrLnByZXZpb3VzXTtcbiAgfVxuICByZXR1cm4geyBjdXJyZW50T3ZlcmxheUl0ZW0sIHByZXZpb3VzT3ZlcmxheUl0ZW0gfTtcbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb25Qcm9wc0ZvclN0YWNrV3JhcHBlcih7IGN1cnJlbnRPdmVybGF5SXRlbSB9KSB7XG4gIHJldHVybiBjdXJyZW50T3ZlcmxheUl0ZW0gJiYgY3VycmVudE92ZXJsYXlJdGVtLnRyYW5zaXRpb24uZXhpdDtcbn1cbmZ1bmN0aW9uIGFuaW1hdGlvbkZvclN0YWNrV3JhcHBlcih7IGN1cnJlbnRPdmVybGF5SXRlbSwgcHJldmlvdXNPdmVybGF5SXRlbSB9KSB7XG4gIGlmIChjdXJyZW50T3ZlcmxheUl0ZW0gJiYgY3VycmVudE92ZXJsYXlJdGVtLnRyYW5zaXRpb24uYW5pbWF0aW9uKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRPdmVybGF5SXRlbS50cmFuc2l0aW9uLmFuaW1hdGlvbjtcbiAgfVxuICBpZiAocHJldmlvdXNPdmVybGF5SXRlbSAmJiBwcmV2aW91c092ZXJsYXlJdGVtLnRyYW5zaXRpb24uYW5pbWF0aW9uKSB7XG4gICAgcmV0dXJuIHByZXZpb3VzT3ZlcmxheUl0ZW0udHJhbnNpdGlvbi5hbmltYXRpb247XG4gIH1cbiAgcmV0dXJuIGFuaW1hdGlvbkRlZmF1bHQ7XG59XG5mdW5jdGlvbiBiYWNrZmFjZVZpc2libGVGb3JTdGFja1dyYXBwZXIoeyBjdXJyZW50T3ZlcmxheUl0ZW0sIHByZXZpb3VzT3ZlcmxheUl0ZW0gfSkge1xuICBpZiAoY3VycmVudE92ZXJsYXlJdGVtKVxuICAgIHJldHVybiBjdXJyZW50T3ZlcmxheUl0ZW0udHJhbnNpdGlvbi5iYWNrZmFjZVZpc2libGU7XG4gIHJldHVybiBwcmV2aW91c092ZXJsYXlJdGVtICYmIHByZXZpb3VzT3ZlcmxheUl0ZW0udHJhbnNpdGlvbi5iYWNrZmFjZVZpc2libGU7XG59XG5mdW5jdGlvbiBiYWNrZHJvcENvbG9yRm9yVHJhbnNpdGlvbih0cmFuc2l0aW9uKSB7XG4gIGlmICh0cmFuc2l0aW9uLmJhY2tkcm9wQ29sb3IpXG4gICAgcmV0dXJuIHRyYW5zaXRpb24uYmFja2Ryb3BDb2xvcjtcbiAgaWYgKHRyYW5zaXRpb24ub3ZlckN1cnJlbnRDb250ZXh0KVxuICAgIHJldHVybiBcInJnYmEoNCw0LDE1LC40KVwiO1xuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gZ2V0QmFja2ZhY2VWaXNpYmxlRm9yT3ZlcmxheShjb250YWluZXJJbmRleCwgc3RhY2tTdGF0ZSkge1xuICBjb25zdCB7IGN1cnJlbnQsIGhpc3RvcnkgfSA9IHN0YWNrU3RhdGU7XG4gIGlmIChjb250YWluZXJJbmRleCA9PT0gY3VycmVudCkge1xuICAgIGNvbnN0IG5hdmlnYXRpb25JdGVtID0gaGlzdG9yeVtjb250YWluZXJJbmRleF07XG4gICAgaWYgKG5hdmlnYXRpb25JdGVtICYmIG5hdmlnYXRpb25JdGVtLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiBuYXZpZ2F0aW9uSXRlbS50cmFuc2l0aW9uLmJhY2tmYWNlVmlzaWJsZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoY29udGFpbmVySW5kZXggPCBjdXJyZW50KSB7XG4gICAgY29uc3QgbmF2aWdhdGlvbkl0ZW0gPSBoaXN0b3J5W2NvbnRhaW5lckluZGV4ICsgMV07XG4gICAgaWYgKG5hdmlnYXRpb25JdGVtICYmIG5hdmlnYXRpb25JdGVtLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiBuYXZpZ2F0aW9uSXRlbS50cmFuc2l0aW9uLmJhY2tmYWNlVmlzaWJsZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbmF2aWdhdGlvbkl0ZW0gPSBoaXN0b3J5W2NvbnRhaW5lckluZGV4XTtcbiAgICBpZiAobmF2aWdhdGlvbkl0ZW0gJiYgbmF2aWdhdGlvbkl0ZW0udHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIG5hdmlnYXRpb25JdGVtLnRyYW5zaXRpb24uYmFja2ZhY2VWaXNpYmxlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gaW5pdGlhbFByb3BzRm9yT3ZlcmxheShjb250YWluZXJJbmRleCwgc3RhY2tTdGF0ZSkge1xuICBjb25zdCBuYXZpZ2F0aW9uSXRlbSA9IHN0YWNrU3RhdGUuaGlzdG9yeVtjb250YWluZXJJbmRleF07XG4gIGlmIChuYXZpZ2F0aW9uSXRlbSlcbiAgICByZXR1cm4gbmF2aWdhdGlvbkl0ZW0udHJhbnNpdGlvbi5lbnRlcjtcbn1cbmZ1bmN0aW9uIGdldEJhY2tmYWNlVmlzaWJsZUZvclNjcmVlbihzY3JlZW5JbmRleCwgc3RhY2tTdGF0ZSkge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIGNvbnN0IHsgY3VycmVudCwgcHJldmlvdXMsIGhpc3RvcnkgfSA9IHN0YWNrU3RhdGU7XG4gIGlmIChzY3JlZW5JbmRleCA9PT0gcHJldmlvdXMgJiYgY3VycmVudCA+IHByZXZpb3VzIHx8IHNjcmVlbkluZGV4ID09PSBjdXJyZW50ICYmIGN1cnJlbnQgPCBwcmV2aW91cykge1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSBoaXN0b3J5W3NjcmVlbkluZGV4ICsgMV0pID09IG51bGwgPyB2b2lkIDAgOiBfYS50cmFuc2l0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2IuYmFja2ZhY2VWaXNpYmxlO1xuICB9XG4gIHJldHVybiAoX2QgPSAoX2MgPSBoaXN0b3J5W3NjcmVlbkluZGV4XSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnRyYW5zaXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZC5iYWNrZmFjZVZpc2libGU7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uUHJvcHNGb3JPdmVybGF5KG92ZXJsYXlJbmRleCwgc3RhY2tTdGF0ZSkge1xuICBjb25zdCB7IGN1cnJlbnQsIGhpc3RvcnkgfSA9IHN0YWNrU3RhdGU7XG4gIGlmIChvdmVybGF5SW5kZXggPT09IGN1cnJlbnQpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAob3ZlcmxheUluZGV4IDwgY3VycmVudCkge1xuICAgIGNvbnN0IG5hdmlnYXRpb25JdGVtID0gaGlzdG9yeVtvdmVybGF5SW5kZXggKyAxXTtcbiAgICBpZiAobmF2aWdhdGlvbkl0ZW0gJiYgbmF2aWdhdGlvbkl0ZW0udHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIG5hdmlnYXRpb25JdGVtLnRyYW5zaXRpb24uZXhpdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbmF2aWdhdGlvbkl0ZW0gPSBoaXN0b3J5W292ZXJsYXlJbmRleF07XG4gICAgaWYgKG5hdmlnYXRpb25JdGVtICYmIG5hdmlnYXRpb25JdGVtLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiBuYXZpZ2F0aW9uSXRlbS50cmFuc2l0aW9uLmVudGVyO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYW5pbWF0aW9uUHJvcHNGb3JDb250YWluZXIoY29udGFpbmVySW5kZXgsIHN0YWNrU3RhdGUpIHtcbiAgY29uc3QgeyBjdXJyZW50LCBwcmV2aW91cywgaGlzdG9yeSB9ID0gc3RhY2tTdGF0ZTtcbiAgY29uc3QgY29udGFpbmVyQ3VycmVudCA9IHByZXZpb3VzID4gY3VycmVudCA/IHByZXZpb3VzIDogY3VycmVudDtcbiAgaWYgKGNvbnRhaW5lckluZGV4IDwgY29udGFpbmVyQ3VycmVudCkge1xuICAgIGNvbnN0IG5hdmlnYXRpb25JdGVtID0gaGlzdG9yeVtjb250YWluZXJJbmRleCArIDFdO1xuICAgIGlmIChuYXZpZ2F0aW9uSXRlbSAmJiBuYXZpZ2F0aW9uSXRlbS50cmFuc2l0aW9uLmFuaW1hdGlvbikge1xuICAgICAgcmV0dXJuIG5hdmlnYXRpb25JdGVtLnRyYW5zaXRpb24uYW5pbWF0aW9uO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjb250YWluZXJJbmRleCAhPT0gY29udGFpbmVyQ3VycmVudCkge1xuICAgIGNvbnN0IG5hdmlnYXRpb25JdGVtID0gaGlzdG9yeVtjb250YWluZXJJbmRleF07XG4gICAgaWYgKG5hdmlnYXRpb25JdGVtICYmIG5hdmlnYXRpb25JdGVtLnRyYW5zaXRpb24uYW5pbWF0aW9uKSB7XG4gICAgICByZXR1cm4gbmF2aWdhdGlvbkl0ZW0udHJhbnNpdGlvbi5hbmltYXRpb247XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5hdmlnYXRpb25JdGVtID0gaGlzdG9yeVtjb250YWluZXJJbmRleF07XG4gICAgaWYgKG5hdmlnYXRpb25JdGVtLnRyYW5zaXRpb24uYW5pbWF0aW9uKSB7XG4gICAgICByZXR1cm4gbmF2aWdhdGlvbkl0ZW0udHJhbnNpdGlvbi5hbmltYXRpb247XG4gICAgfVxuICB9XG4gIHJldHVybiBhbmltYXRpb25EZWZhdWx0O1xufVxuZnVuY3Rpb24gaXNJbnN0YW50Q29udGFpbmVyVHJhbnNpdGlvbihjb250YWluZXJJbmRleCwgc3RhY2tTdGF0ZSwgb3ZlckN1cnJlbnRDb250ZXh0KSB7XG4gIGNvbnN0IHsgY3VycmVudCwgcHJldmlvdXMsIGhpc3RvcnkgfSA9IHN0YWNrU3RhdGU7XG4gIGlmIChvdmVyQ3VycmVudENvbnRleHQgJiYgaGlzdG9yeS5sZW5ndGggPiAxKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAoY29udGFpbmVySW5kZXggIT09IHByZXZpb3VzICYmIGNvbnRhaW5lckluZGV4ICE9PSBjdXJyZW50KVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAoY3VycmVudCA9PT0gcHJldmlvdXMpXG4gICAgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5lcklzVmlzaWJsZShjb250YWluZXJJbmRleCwgc3RhY2tTdGF0ZSkge1xuICBjb25zdCB7IGN1cnJlbnQsIHByZXZpb3VzIH0gPSBzdGFja1N0YXRlO1xuICBpZiAoY29udGFpbmVySW5kZXggPiBjdXJyZW50ICYmIGNvbnRhaW5lckluZGV4ID4gcHJldmlvdXMpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoY29udGFpbmVySW5kZXggPT09IGN1cnJlbnQpXG4gICAgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5lckNvbnRlbnQoaXRlbSkge1xuICByZXR1cm4gQ2hpbGRyZW44Lm1hcChpdGVtLmNvbXBvbmVudCwgKGNoaWxkKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghaXNSZWFjdENoaWxkKGNoaWxkKSB8fCAhaXNSZWFjdEVsZW1lbnQoY2hpbGQpIHx8ICFjaGlsZC5wcm9wcykge1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgIHN0eWxlOiBjaGlsZC5wcm9wcy5zdHlsZVxuICAgIH07XG4gICAgY29uc3QgcG9zaXRpb24gPSAoX2EgPSBpdGVtID09IG51bGwgPyB2b2lkIDAgOiBpdGVtLnRyYW5zaXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYS5wb3NpdGlvbjtcbiAgICBjb25zdCBzaG91bGRTdHJldGNoV2lkdGggPSAhcG9zaXRpb24gfHwgcG9zaXRpb24ubGVmdCAhPT0gdm9pZCAwICYmIHBvc2l0aW9uLnJpZ2h0ICE9PSB2b2lkIDA7XG4gICAgY29uc3Qgc2hvdWxkU3RyZXRjaEhlaWdodCA9ICFwb3NpdGlvbiB8fCBwb3NpdGlvbi50b3AgIT09IHZvaWQgMCAmJiBwb3NpdGlvbi5ib3R0b20gIT09IHZvaWQgMDtcbiAgICBjb25zdCBjYW5TdHJldGNoU3R5bGUgPSBcInN0eWxlXCIgaW4gY2hpbGQucHJvcHM7XG4gICAgaWYgKHNob3VsZFN0cmV0Y2hXaWR0aCkge1xuICAgICAgY29uc3QgY2FuU3RyZXRjaFdpZHRoID0gXCJ3aWR0aFwiIGluIGNoaWxkLnByb3BzO1xuICAgICAgaWYgKGNhblN0cmV0Y2hXaWR0aClcbiAgICAgICAgcHJvcHMud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgIGlmIChjYW5TdHJldGNoU3R5bGUgJiYgIWNhblN0cmV0Y2hXaWR0aClcbiAgICAgICAgcHJvcHMuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICB9XG4gICAgaWYgKHNob3VsZFN0cmV0Y2hIZWlnaHQpIHtcbiAgICAgIGNvbnN0IGNhblN0cmV0Y2hIZWlnaHQgPSBcImhlaWdodFwiIGluIGNoaWxkLnByb3BzO1xuICAgICAgaWYgKGNhblN0cmV0Y2hIZWlnaHQpXG4gICAgICAgIHByb3BzLmhlaWdodCA9IFwiMTAwJVwiO1xuICAgICAgaWYgKGNhblN0cmV0Y2hTdHlsZSAmJiAhY2FuU3RyZXRjaEhlaWdodClcbiAgICAgICAgcHJvcHMuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZUVsZW1lbnQ2KGNoaWxkLCBwcm9wcyk7XG4gIH0pO1xufVxuZnVuY3Rpb24gYmFja2Ryb3BUYXBBY3Rpb24odHJhbnNpdGlvbiwgZ29CYWNrQWN0aW9uKSB7XG4gIGlmICh0cmFuc2l0aW9uLmdvQmFja09uVGFwT3V0c2lkZSAhPT0gZmFsc2UpXG4gICAgcmV0dXJuIGdvQmFja0FjdGlvbjtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvUGFnZS9FbXVsYXRlZFBhZ2UudHN4XG5pbXBvcnQge1xuICBDaGlsZHJlbiBhcyBDaGlsZHJlbjEwLFxuICBjbG9uZUVsZW1lbnQgYXMgY2xvbmVFbGVtZW50OCxcbiAgY3JlYXRlRWxlbWVudCBhcyBjcmVhdGVFbGVtZW50MzUsXG4gIGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjgsXG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrOSxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIxLFxuICB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0OCxcbiAgdXNlUmVmIGFzIHVzZVJlZjIxLFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZThcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9jb21wb25lbnRzL1BhZ2UvUGFnZUNvbnRhaW5lci50c3hcbmltcG9ydCB7XG4gIGNyZWF0ZUVsZW1lbnQgYXMgY3JlYXRlRWxlbWVudDM0XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvY29tcG9uZW50cy9TdGFjay9TdGFjay50c3hcbmltcG9ydCB7XG4gIENoaWxkcmVuIGFzIENoaWxkcmVuOSxcbiAgY2xvbmVFbGVtZW50IGFzIGNsb25lRWxlbWVudDcsXG4gIGNyZWF0ZUVsZW1lbnQgYXMgY3JlYXRlRWxlbWVudDMzLFxuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWY3LFxuICBtZW1vIGFzIG1lbW8yXG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvY29tcG9uZW50cy91dGlscy9wYWRkaW5nRnJvbVByb3BzLnRzXG5mdW5jdGlvbiBoYXNQYWRkaW5nUGVyU2lkZShwcm9wcykge1xuICBjb25zdCB7IHBhZGRpbmdQZXJTaWRlLCBwYWRkaW5nVG9wLCBwYWRkaW5nQm90dG9tLCBwYWRkaW5nTGVmdCwgcGFkZGluZ1JpZ2h0IH0gPSBwcm9wcztcbiAgcmV0dXJuIHBhZGRpbmdQZXJTaWRlICE9PSBmYWxzZSAmJiAocGFkZGluZ1RvcCAhPT0gdm9pZCAwIHx8IHBhZGRpbmdCb3R0b20gIT09IHZvaWQgMCB8fCBwYWRkaW5nTGVmdCAhPT0gdm9pZCAwIHx8IHBhZGRpbmdSaWdodCAhPT0gdm9pZCAwKTtcbn1cbmZ1bmN0aW9uIHBhZGRpbmdGcm9tUHJvcHMocHJvcHMpIHtcbiAgY29uc3QgeyBwYWRkaW5nID0gMCwgcGFkZGluZ1RvcCwgcGFkZGluZ0JvdHRvbSwgcGFkZGluZ0xlZnQsIHBhZGRpbmdSaWdodCB9ID0gcHJvcHM7XG4gIGlmIChoYXNQYWRkaW5nUGVyU2lkZShwcm9wcykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBwYWRkaW5nVG9wICE9PSB2b2lkIDAgPyBwYWRkaW5nVG9wIDogcGFkZGluZyxcbiAgICAgIGJvdHRvbTogcGFkZGluZ0JvdHRvbSAhPT0gdm9pZCAwID8gcGFkZGluZ0JvdHRvbSA6IHBhZGRpbmcsXG4gICAgICBsZWZ0OiBwYWRkaW5nTGVmdCAhPT0gdm9pZCAwID8gcGFkZGluZ0xlZnQgOiBwYWRkaW5nLFxuICAgICAgcmlnaHQ6IHBhZGRpbmdSaWdodCAhPT0gdm9pZCAwID8gcGFkZGluZ1JpZ2h0IDogcGFkZGluZ1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3A6IHBhZGRpbmcsXG4gICAgYm90dG9tOiBwYWRkaW5nLFxuICAgIGxlZnQ6IHBhZGRpbmcsXG4gICAgcmlnaHQ6IHBhZGRpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VQYWRkaW5nU3RyaW5nKHtcbiAgdG9wLFxuICBsZWZ0LFxuICBib3R0b20sXG4gIHJpZ2h0XG59KSB7XG4gIHJldHVybiBgJHt0b3B9cHggJHtyaWdodH1weCAke2JvdHRvbX1weCAke2xlZnR9cHhgO1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9TdGFjay9TdGFjay50c3hcbnZhciBTdGFjayA9IG1lbW8yKGZvcndhcmRSZWY3KGZ1bmN0aW9uIFN0YWNrMihzdGFja1Byb3BzLCByZWYpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3Qge1xuICAgIGRpcmVjdGlvbiA9IFwidmVydGljYWxcIixcbiAgICBkaXN0cmlidXRpb24gPSBcInN0YXJ0XCIsXG4gICAgYWxpZ25tZW50ID0gXCJjZW50ZXJcIixcbiAgICBnYXAgPSAxMCxcbiAgICBjaGlsZHJlbixcbiAgICBzdHlsZTogc3R5bGVQcm9wLFxuICAgIGNsYXNzTmFtZSxcbiAgICB3aWxsQ2hhbmdlVHJhbnNmb3JtLFxuICAgIF9fZnJvbUNvZGVDb21wb25lbnROb2RlLFxuICAgIHBhcmVudFNpemUsXG4gICAgX19jb250ZW50V3JhcHBlclN0eWxlLFxuICAgIC4uLmNvbnRhaW5lclByb3BzXG4gIH0gPSBzdGFja1Byb3BzO1xuICBpbmplY3RDb21wb25lbnRDU1NSdWxlcygpO1xuICBjb25zdCBmbGV4RGlyZWN0aW9uID0gdG9GbGV4RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gIGNvbnN0IGlzUmV2ZXJzZSA9IGlzUmV2ZXJzZURpcmVjdGlvbihmbGV4RGlyZWN0aW9uKTtcbiAgY29uc3QganVzdGlmeUNvbnRlbnQgPSB0b0p1c3RpZnlPckFsaWdubWVudChkaXN0cmlidXRpb24pO1xuICBjb25zdCBwYWRkaW5nID0gaGFzUGFkZGluZ1BlclNpZGUoY29udGFpbmVyUHJvcHMpIHx8IGNvbnRhaW5lclByb3BzLnBhZGRpbmcgPyBtYWtlUGFkZGluZ1N0cmluZyhwYWRkaW5nRnJvbVByb3BzKGNvbnRhaW5lclByb3BzKSkgOiB2b2lkIDA7XG4gIGNvbnN0IHN0eWxlID0geyAuLi5zdHlsZVByb3AgfTtcbiAgTGF5ZXIuYXBwbHlXaWxsQ2hhbmdlKHsgd2lsbENoYW5nZVRyYW5zZm9ybSB9LCBzdHlsZSwgdHJ1ZSk7XG4gIGlmIChfX2Zyb21Db2RlQ29tcG9uZW50Tm9kZSAmJiAhY29uc3RyYWludHNFbmFibGVkKHVud3JhcEZyYW1lUHJvcHMoY29udGFpbmVyUHJvcHMpKSkge1xuICAgIGNvbnRhaW5lclByb3BzLndpZHRoID0gXCIxMDAlXCI7XG4gICAgY29udGFpbmVyUHJvcHMuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgY29udGFpbmVyUHJvcHMuX2NvbnN0cmFpbnRzID0geyBlbmFibGVkOiB0cnVlIH07XG4gIH1cbiAgY29uc3QgbGF5b3V0SWQgPSB1c2VMYXlvdXRJZDIoc3RhY2tQcm9wcyk7XG4gIGNvbnN0IHsgY2hpbGRyZW46IF9jaGlsZHJlbiwgcHJvcHMgfSA9IHByb2Nlc3NPdmVycmlkZUZvcndhcmRpbmcoY29udGFpbmVyUHJvcHMsIGNoaWxkcmVuKTtcbiAgY29uc3Qgd2lkdGhUeXBlID0gKF9hID0gY29udGFpbmVyUHJvcHMud2lkdGhUeXBlKSAhPSBudWxsID8gX2EgOiBjb250YWluZXJQcm9wcy53aWR0aCA9PT0gXCJhdXRvXCIgPyBEaW1lbnNpb25UeXBlLkF1dG8gOiBEaW1lbnNpb25UeXBlLkZpeGVkTnVtYmVyO1xuICBjb25zdCBoZWlnaHRUeXBlID0gKF9iID0gY29udGFpbmVyUHJvcHMuaGVpZ2h0VHlwZSkgIT0gbnVsbCA/IF9iIDogY29udGFpbmVyUHJvcHMuaGVpZ2h0ID09PSBcImF1dG9cIiA/IERpbWVuc2lvblR5cGUuQXV0byA6IERpbWVuc2lvblR5cGUuRml4ZWROdW1iZXI7XG4gIGNvbnN0IGZyYWN0aW9uQ2hpbGRyZW4gPSBoYW5kbGVGcmFjdGlvbihfY2hpbGRyZW4sIGRpcmVjdGlvbiwgd2lkdGhUeXBlLCBoZWlnaHRUeXBlKTtcbiAgY29uc3QgZ2FwQ2hpbGRyZW4gPSB3cmFwSW5HYXBFbGVtZW50KGZyYWN0aW9uQ2hpbGRyZW4sIGdhcCwgZmxleERpcmVjdGlvbiwganVzdGlmeUNvbnRlbnQpO1xuICBjb25zdCBjb250ZW50ID0gdXNlUHJvdmlkZVBhcmVudFNpemUoZ2FwQ2hpbGRyZW4sIHBhcmVudFNpemUgIT0gbnVsbCA/IHBhcmVudFNpemUgOiBQYXJlbnRTaXplU3RhdGUuRGlzYWJsZWQpO1xuICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgIFwiZGF0YS1mcmFtZXItY29tcG9uZW50LXR5cGVcIjogXCJTdGFja1wiXG4gIH07XG4gIGlmIChjb250YWluZXJQcm9wcy5fX2Zyb21DYW52YXNDb21wb25lbnQpXG4gICAgYXR0cmlidXRlc1tcImRhdGEtZnJhbWVyLWdlbmVyYXRlZFwiXSA9IHRydWU7XG4gIGNvbnN0IGNvbnRlbnRXcmFwcGVyU3R5bGUgPSB7XG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgZmxleERpcmVjdGlvbixcbiAgICBqdXN0aWZ5Q29udGVudCxcbiAgICBhbGlnbkl0ZW1zOiB0b0p1c3RpZnlPckFsaWdubWVudChhbGlnbm1lbnQpLFxuICAgIHBhZGRpbmcsXG4gICAgLi4uX19jb250ZW50V3JhcHBlclN0eWxlXG4gIH07XG4gIGlmIChjb250ZW50V3JhcHBlclN0eWxlLndpZHRoID09PSB2b2lkIDApIHtcbiAgICBjb250ZW50V3JhcHBlclN0eWxlLndpZHRoID0gd2lkdGhUeXBlID09PSBEaW1lbnNpb25UeXBlLkF1dG8gPyBcIm1pbi1jb250ZW50XCIgOiBcIjEwMCVcIjtcbiAgfVxuICBpZiAoY29udGVudFdyYXBwZXJTdHlsZS5oZWlnaHQgPT09IHZvaWQgMCkge1xuICAgIGNvbnRlbnRXcmFwcGVyU3R5bGUuaGVpZ2h0ID0gaGVpZ2h0VHlwZSA9PT0gRGltZW5zaW9uVHlwZS5BdXRvID8gXCJtaW4tY29udGVudFwiIDogXCIxMDAlXCI7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MzMoRnJhbWVXaXRoTW90aW9uLCB7XG4gICAgYmFja2dyb3VuZDogXCJub25lXCIsXG4gICAgLi4ucHJvcHMsXG4gICAgbGF5b3V0SWQsXG4gICAgcmVmLFxuICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgc3R5bGUsXG4gICAgY2xhc3NOYW1lXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MzMobW90aW9uLmRpdiwge1xuICAgIFwiZGF0YS1mcmFtZXItc3RhY2stY29udGVudC13cmFwcGVyXCI6IHRydWUsXG4gICAgXCJkYXRhLWZyYW1lci1zdGFjay1kaXJlY3Rpb24tcmV2ZXJzZVwiOiBpc1JldmVyc2UsXG4gICAgc3R5bGU6IGNvbnRlbnRXcmFwcGVyU3R5bGVcbiAgfSwgY29udGVudCkpO1xufSkpO1xuU3RhY2suZGlzcGxheU5hbWUgPSBcIlN0YWNrXCI7XG5mdW5jdGlvbiBpc0ZyYWN0aW9uRGltZW5zaW9uKGRpbWVuc2lvbikge1xuICByZXR1cm4gdHlwZW9mIGRpbWVuc2lvbiA9PT0gXCJzdHJpbmdcIiAmJiBkaW1lbnNpb24uZW5kc1dpdGgoXCJmclwiKTtcbn1cbmZ1bmN0aW9uIGZyYWN0aW9uKGRpbWVuc2lvbikge1xuICBjb25zdCB2YWx1ZSA9IHBhcnNlRmxvYXQoZGltZW5zaW9uKTtcbiAgcmV0dXJuIGlzRmluaXRlTnVtYmVyKHZhbHVlKSA/IHZhbHVlIDogMDtcbn1cbmZ1bmN0aW9uIGhhbmRsZUZyYWN0aW9uKGNoaWxkcmVuLCBkaXJlY3Rpb24sIHdpZHRoVHlwZSwgaGVpZ2h0VHlwZSkge1xuICByZXR1cm4gQ2hpbGRyZW45Lm1hcChjaGlsZHJlbiwgKGNoaWxkKSA9PiB7XG4gICAgaWYgKCFpc1JlYWN0Q2hpbGQoY2hpbGQpIHx8ICFpc1JlYWN0RWxlbWVudChjaGlsZCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaXNWZXJ0aWNhbCA9IGRpcmVjdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiO1xuICAgIGNvbnN0IHN0eWxlID0ge307XG4gICAgbGV0IGhhc0ZyYWN0aW9uID0gZmFsc2U7XG4gICAgY29uc3QgeyBzdHlsZTogcHJvcHNTdHlsZSwgc2l6ZTogc2l6ZTIgfSA9IGNoaWxkLnByb3BzO1xuICAgIGxldCB7IHdpZHRoLCBoZWlnaHQgfSA9IGNoaWxkLnByb3BzO1xuICAgIGlmIChzaXplMiAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAod2lkdGggPT09IHZvaWQgMClcbiAgICAgICAgd2lkdGggPSBzaXplMjtcbiAgICAgIGlmIChoZWlnaHQgPT09IHZvaWQgMClcbiAgICAgICAgaGVpZ2h0ID0gc2l6ZTI7XG4gICAgfVxuICAgIGxldCBuZXdXaWR0aCA9IHdpZHRoO1xuICAgIGxldCBuZXdIZWlnaHQgPSBoZWlnaHQ7XG4gICAgaWYgKGlzRnJhY3Rpb25EaW1lbnNpb24od2lkdGgpKSB7XG4gICAgICBoYXNGcmFjdGlvbiA9IHRydWU7XG4gICAgICBoYXNGcmFjdGlvbiA9IHRydWU7XG4gICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICBpZiAod2lkdGhUeXBlID09PSBEaW1lbnNpb25UeXBlLkF1dG8pIHtcbiAgICAgICAgICBzdHlsZS5hbGlnblNlbGYgPSBcInN0cmV0Y2hcIjtcbiAgICAgICAgICBuZXdXaWR0aCA9IFwiYXV0b1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1dpZHRoID0gYCR7ZnJhY3Rpb24od2lkdGgpICogMTAwfSVgO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdXaWR0aCA9IDE7XG4gICAgICAgIHN0eWxlLmZsZXhHcm93ID0gZnJhY3Rpb24od2lkdGgpO1xuICAgICAgICBzdHlsZS5mbGV4QmFzaXMgPSAwO1xuICAgICAgfVxuICAgICAgc3R5bGUud2lkdGggPSBuZXdXaWR0aDtcbiAgICB9XG4gICAgaWYgKGlzRnJhY3Rpb25EaW1lbnNpb24oaGVpZ2h0KSkge1xuICAgICAgaGFzRnJhY3Rpb24gPSB0cnVlO1xuICAgICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgICAgbmV3SGVpZ2h0ID0gMTtcbiAgICAgICAgc3R5bGUuZmxleEdyb3cgPSBmcmFjdGlvbihoZWlnaHQpO1xuICAgICAgICBzdHlsZS5mbGV4QmFzaXMgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGhlaWdodFR5cGUgPT09IERpbWVuc2lvblR5cGUuQXV0bykge1xuICAgICAgICAgIHN0eWxlLmFsaWduU2VsZiA9IFwic3RyZXRjaFwiO1xuICAgICAgICAgIG5ld0hlaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0hlaWdodCA9IGAke2ZyYWN0aW9uKGhlaWdodCkgKiAxMDB9JWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0eWxlLmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICB9XG4gICAgaWYgKCFoYXNGcmFjdGlvbilcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICBjb25zdCBuZXh0U3R5bGUgPSB7IC4uLnByb3BzU3R5bGUsIC4uLnN0eWxlIH07XG4gICAgcmV0dXJuIGNsb25lRWxlbWVudDcoY2hpbGQsIHtcbiAgICAgIHdpZHRoOiBuZXdXaWR0aCxcbiAgICAgIGhlaWdodDogbmV3SGVpZ2h0LFxuICAgICAgc3R5bGU6IG5leHRTdHlsZVxuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzR2FwRW5hYmxlZChnYXAsIGp1c3RpZnlDb250ZW50KSB7XG4gIGlmICghZ2FwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChqdXN0aWZ5Q29udGVudCAmJiBbXCJzcGFjZS1iZXR3ZWVuXCIsIFwic3BhY2UtYXJvdW5kXCIsIFwic3BhY2UtZXZlbmx5XCIsIFwic3RyZXRjaFwiXS5pbmNsdWRlcyhqdXN0aWZ5Q29udGVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB3cmFwSW5HYXBFbGVtZW50KGNoaWxkcmVuLCBnYXAsIGRpcmVjdGlvbiwganVzdGlmeUNvbnRlbnQpIHtcbiAgaWYgKCFpc0dhcEVuYWJsZWQoZ2FwLCBqdXN0aWZ5Q29udGVudCkpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgY29uc3QgaXNWZXJ0aWNhbCA9IGlzVmVydGljYWxEaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgY29uc3QgZ2FwU3R5bGUgPSB7XG4gICAgZGlzcGxheTogXCJjb250ZW50c1wiLFxuICAgIFtcIi0tc3RhY2stZ2FwLXhcIl06IGAke2lzVmVydGljYWwgPyAwIDogZ2FwfXB4YCxcbiAgICBbXCItLXN0YWNrLWdhcC15XCJdOiBgJHtpc1ZlcnRpY2FsID8gZ2FwIDogMH1weGBcbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MzMoXCJkaXZcIiwge1xuICAgIFwiZGF0YS1mcmFtZXItc3RhY2stZ2FwXCI6IHRydWUsXG4gICAgc3R5bGU6IGdhcFN0eWxlXG4gIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIHRvRmxleERpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgIHJldHVybiBcImNvbHVtblwiO1xuICAgIGNhc2UgXCJob3Jpem9udGFsXCI6XG4gICAgICByZXR1cm4gXCJyb3dcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgfVxufVxuZnVuY3Rpb24gaXNWZXJ0aWNhbERpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gXCJjb2x1bW5cIiB8fCBkaXJlY3Rpb24gPT09IFwiY29sdW1uLXJldmVyc2VcIjtcbn1cbmZ1bmN0aW9uIGlzUmV2ZXJzZURpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICBjYXNlIFwiY29sdW1uLXJldmVyc2VcIjpcbiAgICBjYXNlIFwicm93LXJldmVyc2VcIjpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvSnVzdGlmeU9yQWxpZ25tZW50KGRpc3RyaWJ1dGlvbikge1xuICBzd2l0Y2ggKGRpc3RyaWJ1dGlvbikge1xuICAgIGNhc2UgXCJzdGFydFwiOlxuICAgICAgcmV0dXJuIFwiZmxleC1zdGFydFwiO1xuICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgIHJldHVybiBcImZsZXgtZW5kXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBkaXN0cmlidXRpb247XG4gIH1cbn1cbmFkZFByb3BlcnR5Q29udHJvbHMoU3RhY2ssIHtcbiAgZGlyZWN0aW9uOiB7XG4gICAgdHlwZTogQ29udHJvbFR5cGUuU2VnbWVudGVkRW51bSxcbiAgICBvcHRpb25zOiBbXCJob3Jpem9udGFsXCIsIFwidmVydGljYWxcIl0sXG4gICAgdGl0bGU6IFwiRGlyZWN0aW9uXCIsXG4gICAgZGVmYXVsdFZhbHVlOiBcInZlcnRpY2FsXCJcbiAgfSxcbiAgZGlzdHJpYnV0aW9uOiB7XG4gICAgdHlwZTogQ29udHJvbFR5cGUuRW51bSxcbiAgICBvcHRpb25zOiBbXCJzdGFydFwiLCBcImNlbnRlclwiLCBcImVuZFwiLCBcInNwYWNlLWJldHdlZW5cIiwgXCJzcGFjZS1hcm91bmRcIiwgXCJzcGFjZS1ldmVubHlcIl0sXG4gICAgb3B0aW9uVGl0bGVzOiBbXCJTdGFydFwiLCBcIkNlbnRlclwiLCBcIkVuZFwiLCBcIlNwYWNlIEJldHdlZW5cIiwgXCJTcGFjZSBBcm91bmRcIiwgXCJTcGFjZSBFdmVubHlcIl0sXG4gICAgdGl0bGU6IFwiRGlzdHJpYnV0ZVwiLFxuICAgIGRlZmF1bHRWYWx1ZTogXCJzcGFjZS1hcm91bmRcIlxuICB9LFxuICBhbGlnbm1lbnQ6IHtcbiAgICB0eXBlOiBDb250cm9sVHlwZS5TZWdtZW50ZWRFbnVtLFxuICAgIG9wdGlvbnM6IFtcInN0YXJ0XCIsIFwiY2VudGVyXCIsIFwiZW5kXCJdLFxuICAgIHRpdGxlOiBcIkFsaWduXCIsXG4gICAgZGVmYXVsdFZhbHVlOiBcImNlbnRlclwiXG4gIH0sXG4gIGdhcDoge1xuICAgIHR5cGU6IENvbnRyb2xUeXBlLk51bWJlcixcbiAgICBtaW46IDAsXG4gICAgdGl0bGU6IFwiR2FwXCIsXG4gICAgaGlkZGVuOiAocHJvcHMpID0+IHtcbiAgICAgIHJldHVybiBwcm9wcy5kaXN0cmlidXRpb24gIT09IHZvaWQgMCAmJiBbXCJzcGFjZS1iZXR3ZWVuXCIsIFwic3BhY2UtYXJvdW5kXCIsIFwic3BhY2UtZXZlbmx5XCJdLmluY2x1ZGVzKHByb3BzLmRpc3RyaWJ1dGlvbik7XG4gICAgfSxcbiAgICBkZWZhdWx0VmFsdWU6IDEwXG4gIH0sXG4gIHBhZGRpbmc6IHtcbiAgICB0eXBlOiBDb250cm9sVHlwZS5GdXNlZE51bWJlcixcbiAgICB0b2dnbGVLZXk6IFwicGFkZGluZ1BlclNpZGVcIixcbiAgICB0b2dnbGVUaXRsZXM6IFtcIlBhZGRpbmdcIiwgXCJQYWRkaW5nIHBlciBzaWRlXCJdLFxuICAgIHZhbHVlS2V5czogW1wicGFkZGluZ1RvcFwiLCBcInBhZGRpbmdSaWdodFwiLCBcInBhZGRpbmdCb3R0b21cIiwgXCJwYWRkaW5nTGVmdFwiXSxcbiAgICB2YWx1ZUxhYmVsczogW1widFwiLCBcInJcIiwgXCJiXCIsIFwibFwiXSxcbiAgICBtaW46IDAsXG4gICAgdGl0bGU6IFwiUGFkZGluZ1wiLFxuICAgIGRlZmF1bHRWYWx1ZTogMFxuICB9XG59KTtcblxuLy8gc3JjL2NvbXBvbmVudHMvUGFnZS9QYWdlQ29udGFpbmVyLnRzeFxudmFyIHBhZ2VDb250ZW50V3JhcHBlclR5cGUgPSBcIlBhZ2VDb250ZW50V3JhcHBlclwiO1xuZnVuY3Rpb24gUGFnZUNvbnRhaW5lcih7XG4gIGNoaWxkcmVuLFxuICBlZmZlY3QsXG4gIGRyYWdFbmFibGVkLFxuICBkaXJlY3Rpb24sXG4gIGNvbnRlbnRIZWlnaHQsXG4gIGNvbnRlbnRXaWR0aCxcbiAgYWxpZ25tZW50LFxuICBnYXAsXG4gIGlzTGFzdFBhZ2UsXG4gIGNvbnRlbnRPZmZzZXRSZWYsXG4gIGNvbnN0cmFpbnRzUmVmLFxuICBkaXJlY3Rpb25Mb2NrLFxuICBvbkRyYWdTdGFydCxcbiAgb25EcmFnLFxuICBvbkRyYWdFbmQsXG4gIGxheW91dElkXG59KSB7XG4gIGNvbnN0IGlzSG9yaXpvbnRhbERpcmVjdGlvbiA9IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gIGNvbnN0IGRyYWdBeGlzID0gaXNIb3Jpem9udGFsRGlyZWN0aW9uID8gXCJ4XCIgOiBcInlcIjtcbiAgY29uc3QgaGFzSG9yaXpvbnRhbEdhcCA9IGlzSG9yaXpvbnRhbERpcmVjdGlvbiAmJiAhaXNMYXN0UGFnZSAmJiBnYXA7XG4gIGNvbnN0IGhhc1ZlcnRpY2FsR2FwID0gIWlzSG9yaXpvbnRhbERpcmVjdGlvbiAmJiAhaXNMYXN0UGFnZSAmJiBnYXA7XG4gIGNvbnN0IGhhc0F1dG9XaWR0aCA9IGNvbnRlbnRXaWR0aCAhPT0gXCJzdHJldGNoXCIgJiYgaXNIb3Jpem9udGFsRGlyZWN0aW9uO1xuICBjb25zdCBoYXNBdXRvSGVpZ2h0ID0gY29udGVudEhlaWdodCAhPT0gXCJzdHJldGNoXCIgJiYgIWlzSG9yaXpvbnRhbERpcmVjdGlvbjtcbiAgY29uc3Qgd3JhcHBlcldpZHRoID0gaGFzQXV0b1dpZHRoID8gXCJhdXRvXCIgOiBcIjEwMCVcIjtcbiAgY29uc3Qgd3JhcHBlckhlaWdodCA9IGhhc0F1dG9IZWlnaHQgPyBcImF1dG9cIiA6IFwiMTAwJVwiO1xuICBjb25zdCBjb250YWluZXJXaWR0aCA9IGhhc0hvcml6b250YWxHYXAgJiYgd3JhcHBlcldpZHRoID09PSBcIjEwMCVcIiA/IGBjYWxjKDEwMCUgKyAke2dhcH1weClgIDogd3JhcHBlcldpZHRoO1xuICBjb25zdCBjb250YWluZXJIZWlnaHQgPSBoYXNWZXJ0aWNhbEdhcCAmJiB3cmFwcGVySGVpZ2h0ID09PSBcIjEwMCVcIiA/IGBjYWxjKDEwMCUgKyAke2dhcH1weClgIDogd3JhcHBlckhlaWdodDtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MzQoRnJhbWVXaXRoTW90aW9uLCB7XG4gICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICBcImRhdGEtZnJhbWVyLWNvbXBvbmVudC10eXBlXCI6IFwiUGFnZUNvbnRhaW5lclwiLFxuICAgIHdpZHRoOiBjb250YWluZXJXaWR0aCxcbiAgICBoZWlnaHQ6IGNvbnRhaW5lckhlaWdodCxcbiAgICBsYXlvdXRJZDogbGF5b3V0SWQgPyBgJHtsYXlvdXRJZH0tY29udGFpbmVyYCA6IHZvaWQgMCxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgICBkcmFnOiBkcmFnRW5hYmxlZCA/IGRyYWdBeGlzIDogZmFsc2UsXG4gICAgZHJhZ0RpcmVjdGlvbkxvY2s6IGRpcmVjdGlvbkxvY2ssXG4gICAgX2RyYWdYOiBjb250ZW50T2Zmc2V0UmVmLmN1cnJlbnQueCxcbiAgICBfZHJhZ1k6IGNvbnRlbnRPZmZzZXRSZWYuY3VycmVudC55LFxuICAgIGRyYWdDb25zdHJhaW50czogY29uc3RyYWludHNSZWYuY3VycmVudCxcbiAgICBvbkRyYWcsXG4gICAgb25EcmFnU3RhcnQsXG4gICAgb25EcmFnRW5kLFxuICAgIHByZXNlcnZlM2Q6IHRydWUsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBhZGRpbmdSaWdodDogaGFzSG9yaXpvbnRhbEdhcCA/IGdhcCA6IDAsXG4gICAgICBwYWRkaW5nQm90dG9tOiBoYXNWZXJ0aWNhbEdhcCA/IGdhcCA6IDBcbiAgICB9XG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MzQoRnJhbWVXaXRoTW90aW9uLCB7XG4gICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICBcImRhdGEtZnJhbWVyLWNvbXBvbmVudC10eXBlXCI6IHBhZ2VDb250ZW50V3JhcHBlclR5cGUsXG4gICAgd2lkdGg6IHdyYXBwZXJXaWR0aCxcbiAgICBoZWlnaHQ6IHdyYXBwZXJIZWlnaHQsXG4gICAgcHJlc2VydmUzZDogZmFsc2UsXG4gICAgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gICAgX2xheW91dFJlc2V0VHJhbnNmb3JtOiB0cnVlLFxuICAgIGtleTogZWZmZWN0ID8gT2JqZWN0LmtleXMoZWZmZWN0KS5qb2luKFwiXCIpIDogXCJcIixcbiAgICBzdHlsZToge1xuICAgICAgLi4uZWZmZWN0LFxuICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICBmbGV4RGlyZWN0aW9uOiBpc0hvcml6b250YWxEaXJlY3Rpb24gPyBcInJvd1wiIDogXCJjb2x1bW5cIixcbiAgICAgIGFsaWduSXRlbXM6IGFsaWdubWVudCAmJiB0b0p1c3RpZnlPckFsaWdubWVudChhbGlnbm1lbnQpXG4gICAgfVxuICB9LCBjaGlsZHJlbikpO1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9QYWdlL0VtdWxhdGVkUGFnZS50c3hcbnZhciBQYWdlID0gZm9yd2FyZFJlZjgoZnVuY3Rpb24gUGFnZTIocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICBjb25zdCB7XG4gICAgZGlyZWN0aW9uID0gXCJob3Jpem9udGFsXCIsXG4gICAgY29udGVudFdpZHRoID0gXCJzdHJldGNoXCIsXG4gICAgY29udGVudEhlaWdodCA9IFwic3RyZXRjaFwiLFxuICAgIGFsaWdubWVudCA9IFwic3RhcnRcIixcbiAgICBjdXJyZW50UGFnZSA9IDAsXG4gICAgYW5pbWF0ZUN1cnJlbnRQYWdlVXBkYXRlID0gdHJ1ZSxcbiAgICBnYXA6IGdhcFZhbHVlID0gMTAsXG4gICAgcGFkZGluZyA9IDAsXG4gICAgbW9tZW50dW0gPSBmYWxzZSxcbiAgICBkcmFnRW5hYmxlZCA9IHRydWUsXG4gICAgZGVmYXVsdEVmZmVjdCA9IFwibm9uZVwiLFxuICAgIGJhY2tncm91bmQgPSBcInRyYW5zcGFyZW50XCIsXG4gICAgb3ZlcmZsb3cgPSBcImhpZGRlblwiLFxuICAgIF9fZnJvbUNvZGVDb21wb25lbnROb2RlLFxuICAgIGVmZmVjdCxcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZW50T2Zmc2V0WCxcbiAgICBjb250ZW50T2Zmc2V0WSxcbiAgICBvbkNoYW5nZVBhZ2UsXG4gICAgb25TY3JvbGxTdGFydCxcbiAgICBvblNjcm9sbCxcbiAgICBvbkRyYWdTdGFydCxcbiAgICBvbkRyYWcsXG4gICAgb25EcmFnRW5kLFxuICAgIGRpcmVjdGlvbkxvY2ssXG4gICAgb25TY3JvbGxFbmQsXG4gICAgb25EaXJlY3Rpb25Mb2NrLFxuICAgIG9uVXBkYXRlLFxuICAgIHdoZWVsRW5hYmxlZCA9IGZhbHNlLFxuICAgIGxheW91dElkOiBzcGVjaWZpY0xheW91dElkLFxuICAgIC4uLnJlc3RcbiAgfSA9IHByb3BzO1xuICBjb25zdCBsYXlvdXRJZCA9IHVzZUxheW91dElkMihwcm9wcywgeyBzcGVjaWZpY0xheW91dElkLCBwb3N0Zml4OiBcInBhZ2VcIiB9KTtcbiAgY29uc3QgY29udGFpbmVyUHJvcHMgPSB7IC4uLnJlc3QsIGJhY2tncm91bmQgfTtcbiAgY29uc3QgaGFzTW91bnRlZFJlZiA9IHVzZVJlZjIxKGZhbHNlKTtcbiAgY29uc3QgaGFzRml4ZWRTaXplID0gUmVuZGVyVGFyZ2V0Lmhhc1Jlc3RyaWN0aW9ucygpICYmIHByb3BzLl9fZnJvbUNvZGVDb21wb25lbnROb2RlICYmIGlzRmluaXRlTnVtYmVyKGNvbnRhaW5lclByb3BzLndpZHRoKSAmJiBpc0Zpbml0ZU51bWJlcihjb250YWluZXJQcm9wcy5oZWlnaHQpO1xuICBpZiAoIWhhc0ZpeGVkU2l6ZSAmJiBfX2Zyb21Db2RlQ29tcG9uZW50Tm9kZSAmJiAhY29udGFpbmVyUHJvcHMuX19mcm9tQ2FudmFzQ29tcG9uZW50KSB7XG4gICAgY29udGFpbmVyUHJvcHMud2lkdGggPSBcIjEwMCVcIjtcbiAgICBjb250YWluZXJQcm9wcy5oZWlnaHQgPSBcIjEwMCVcIjtcbiAgICBjb250YWluZXJQcm9wcy5fY29uc3RyYWludHMgPSB7IGVuYWJsZWQ6IHRydWUgfTtcbiAgfVxuICBjb25zdCB7IGluaXRpYWwsIHByZXYgfSA9IHVzZVJlZjIxKHtcbiAgICBpbml0aWFsOiB7IHg6IDAsIHk6IDAgfSxcbiAgICBwcmV2OiB7IHg6IDAsIHk6IDAgfVxuICB9KS5jdXJyZW50O1xuICBjb25zdCBpc0hvcml6b250YWwgPSBkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiO1xuICBsZXQgZ2FwID0gZ2FwVmFsdWU7XG4gIGlmIChnYXAgPCAwKSB7XG4gICAgd2Fybk9uY2UoYFRoZSAnZ2FwJyBwcm9wZXJ0eSBvZiBQYWdlIGNvbXBvbmVudCBjYW4gbm90IGJlIG5lZ2F0aXZlLCBidXQgaXMgJHtnYXBWYWx1ZX0uYCk7XG4gICAgZ2FwID0gMDtcbiAgfVxuICBpbmplY3RDb21wb25lbnRDU1NSdWxlcygpO1xuICBjb25zdCBwYWdlQ291bnQgPSBDaGlsZHJlbjEwLmNvdW50KGNoaWxkcmVuKTtcbiAgY29uc3QgbWF4T2Zmc2V0UmVmID0gdXNlUmVmMjEoMCk7XG4gIGNvbnN0IGNvbnN0cmFpbnRzID0gdXNlUmVmMjEoeyB0b3A6IDAsIGxlZnQ6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAgfSk7XG4gIGNvbnN0IGZhbGxiYWNrQ29udGFpbmVyUmVmID0gdXNlUmVmMjEobnVsbCk7XG4gIGNvbnN0IGNvbnRhaW5lclJlZiA9IGZvcndhcmRlZFJlZiB8fCBmYWxsYmFja0NvbnRhaW5lclJlZjtcbiAgY29uc3Qgc2Nyb2xsYWJsZVJlZiA9IHVzZVJlZjIxKG51bGwpO1xuICBjb25zdCBwYWdlRWZmZWN0VmFsdWVzUmVmID0gdXNlUmVmMjEoW10pO1xuICBjb25zdCBwYWdlUmVjdHNSZWYgPSB1c2VSZWYyMShbXSk7XG4gIGNvbnN0IGludGVybmFsWCA9IHVzZU1vdGlvblZhbHVlKGlzTW90aW9uVmFsdWUyKGNvbnRlbnRPZmZzZXRYKSA/IDAgOiBjb250ZW50T2Zmc2V0WCAhPSBudWxsID8gY29udGVudE9mZnNldFggOiAwKTtcbiAgY29uc3QgaW50ZXJuYWxZID0gdXNlTW90aW9uVmFsdWUoaXNNb3Rpb25WYWx1ZTIoY29udGVudE9mZnNldFkpID8gMCA6IGNvbnRlbnRPZmZzZXRZICE9IG51bGwgPyBjb250ZW50T2Zmc2V0WSA6IDApO1xuICBjb25zdCBjb250ZW50T2Zmc2V0UmVmID0gdXNlUmVmMjEoe1xuICAgIHg6IGlzTW90aW9uVmFsdWUyKGNvbnRlbnRPZmZzZXRYKSA/IGNvbnRlbnRPZmZzZXRYIDogaW50ZXJuYWxYLFxuICAgIHk6IGlzTW90aW9uVmFsdWUyKGNvbnRlbnRPZmZzZXRZKSA/IGNvbnRlbnRPZmZzZXRZIDogaW50ZXJuYWxZXG4gIH0pO1xuICBjb25zdCBjdXJyZW50Q29udGVudFBhZ2VSZWYgPSB1c2VSZWYyMSgwKTtcbiAgY29uc3QgcHJvcHNCb3VuZGVkQ3VycmVudFBhZ2VSZWYgPSB1c2VSZWYyMSgwKTtcbiAgY29uc3QgbGF0ZXN0UHJvcHNSZWYgPSB1c2VSZWYyMShwcm9wcyk7XG4gIGxhdGVzdFByb3BzUmVmLmN1cnJlbnQgPSBwcm9wcztcbiAgY29uc3QgbGFzdERpcmVjdGlvblJlZiA9IHVzZVJlZjIxKHByb3BzLmRpcmVjdGlvbik7XG4gIGNvbnN0IHNuYXBUb1BhZ2UgPSB1c2VTbmFwVG9QYWdlKGN1cnJlbnRDb250ZW50UGFnZVJlZiwgY29udGVudE9mZnNldFJlZiwgaXNIb3Jpem9udGFsKTtcbiAgY29uc3QgW18sIHNldEZvcmNlVXBkYXRlQ291bnRdID0gdXNlU3RhdGU4KDApO1xuICBjb25zdCBjb250YWluZXJTaXplUmVmID0gdXNlUmVmMjEoeyB3aWR0aDogMjAwLCBoZWlnaHQ6IDIwMCB9KTtcbiAgaWYgKGhhc0ZpeGVkU2l6ZSAmJiBpc0Zpbml0ZU51bWJlcihjb250YWluZXJQcm9wcy53aWR0aCkgJiYgaXNGaW5pdGVOdW1iZXIoY29udGFpbmVyUHJvcHMuaGVpZ2h0KSkge1xuICAgIGNvbnRhaW5lclNpemVSZWYuY3VycmVudC53aWR0aCA9IGNvbnRhaW5lclByb3BzLndpZHRoO1xuICAgIGNvbnRhaW5lclNpemVSZWYuY3VycmVudC5oZWlnaHQgPSBjb250YWluZXJQcm9wcy5oZWlnaHQ7XG4gIH1cbiAgY29uc3QgdXBkYXRlT25SZXNpemUgPSB1c2VDYWxsYmFjazkoKCkgPT4ge1xuICAgIGlmICghaGFzRml4ZWRTaXplKVxuICAgICAgc2V0Rm9yY2VVcGRhdGVDb3VudCgodikgPT4gdiArIDEpO1xuICB9LCBbaGFzRml4ZWRTaXplXSk7XG4gIHVzZUVmZmVjdDIxKCgpID0+IHtcbiAgICBpZiAoUmVuZGVyVGFyZ2V0LmN1cnJlbnQoKSAhPT0gUmVuZGVyVGFyZ2V0LnByZXZpZXcpXG4gICAgICByZXR1cm47XG4gICAgZ2xvYmFsVGhpcy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHVwZGF0ZU9uUmVzaXplKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZ2xvYmFsVGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHVwZGF0ZU9uUmVzaXplKTtcbiAgICB9O1xuICB9LCBbdXBkYXRlT25SZXNpemVdKTtcbiAgY29uc3QgYXBwbHlFZmZlY3RzID0gKCkgPT4ge1xuICAgIHBhZ2VFZmZlY3RWYWx1ZXNSZWYuY3VycmVudC5mb3JFYWNoKChlZmZlY3REaWN0aW9uYXJ5LCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWVzID0gZWZmZWN0VmFsdWVzKGluZGV4LCBsYXRlc3RQcm9wc1JlZiwgcGFnZVJlY3RzUmVmLCBjb250ZW50T2Zmc2V0UmVmLCBtYXhPZmZzZXRSZWYpO1xuICAgICAgaWYgKCFlZmZlY3REaWN0aW9uYXJ5IHx8ICF2YWx1ZXMpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGZvciAoY29uc3Qga2V5NiBpbiB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKGlzTW90aW9uVmFsdWUyKGVmZmVjdERpY3Rpb25hcnlba2V5Nl0pKSB7XG4gICAgICAgICAgZWZmZWN0RGljdGlvbmFyeVtrZXk2XS5zZXQodmFsdWVzW2tleTZdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBjb25zdCB1cGRhdGVNYXhPZmZzZXRGcm9tUGFnZUNvbnRlbnRzID0gKGNvbnRhaW5lclNpemUpID0+IHtcbiAgICBjb25zdCBuZXdQYWdlQ29udGVudFJlY3RzID0gZ2V0UGFnZUNvbnRlbnRSZWN0cyhjb250YWluZXJSZWYsIGNvbnRhaW5lclNpemUsIGRpcmVjdGlvbiwgZ2FwKTtcbiAgICBpZiAobmV3UGFnZUNvbnRlbnRSZWN0cylcbiAgICAgIHBhZ2VSZWN0c1JlZi5jdXJyZW50ID0gbmV3UGFnZUNvbnRlbnRSZWN0cztcbiAgICBjb25zdCBuZXdNYXhPZmZzZXQgPSBnZXRNYXhPZmZzZXQoY29udGFpbmVyU2l6ZVJlZi5jdXJyZW50LCBwYWdlUmVjdHNSZWYuY3VycmVudCwgZGlyZWN0aW9uLCBsYXRlc3RQcm9wc1JlZi5jdXJyZW50KTtcbiAgICBpZiAobmV3TWF4T2Zmc2V0ICE9PSBtYXhPZmZzZXRSZWYuY3VycmVudCkge1xuICAgICAgbWF4T2Zmc2V0UmVmLmN1cnJlbnQgPSBuZXdNYXhPZmZzZXQ7XG4gICAgICBjb25zdHJhaW50cy5jdXJyZW50LnRvcCA9IC1uZXdNYXhPZmZzZXQ7XG4gICAgICBjb25zdHJhaW50cy5jdXJyZW50LmxlZnQgPSAtbmV3TWF4T2Zmc2V0O1xuICAgICAgaWYgKFJlbmRlclRhcmdldC5jdXJyZW50KCkgPT09IFJlbmRlclRhcmdldC5jYW52YXMpXG4gICAgICAgIHNldEZvcmNlVXBkYXRlQ291bnQoKHYpID0+IHYgKyAxKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1lYXN1cmVDb250YWluZXJTaXplID0gKCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBjb250YWluZXJSZWYuY3VycmVudDtcbiAgICBpZiAoIWVsZW1lbnQpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB7IG9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQgfSA9IGVsZW1lbnQ7XG4gICAgY29uc3QgY3VycmVudFNpemUgPSBjb250YWluZXJTaXplUmVmLmN1cnJlbnQ7XG4gICAgaWYgKG9mZnNldFdpZHRoICE9PSBjdXJyZW50U2l6ZS53aWR0aCB8fCBvZmZzZXRIZWlnaHQgIT09IGN1cnJlbnRTaXplLmhlaWdodCkge1xuICAgICAgY29udGFpbmVyU2l6ZVJlZi5jdXJyZW50ID0ge1xuICAgICAgICB3aWR0aDogb2Zmc2V0V2lkdGgsXG4gICAgICAgIGhlaWdodDogb2Zmc2V0SGVpZ2h0XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGNvbnRhaW5lclNpemVSZWYuY3VycmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIGNvbnN0IHVwZGF0ZUFuZFNuYXBUb1BhZ2UgPSAobmV3UGFnZSwgbW91bnQgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IG5ld0JvdW5kZWRDdXJyZW50UGFnZSA9IGdldEJvdW5kZWRDdXJyZW50UGFnZShuZXdQYWdlLCBwYWdlQ291bnQpO1xuICAgIGNvbnN0IGJvdW5kZWRDdXJyZW50UGFnZURpZENoYW5nZSA9IG5ld0JvdW5kZWRDdXJyZW50UGFnZSAhPT0gcHJvcHNCb3VuZGVkQ3VycmVudFBhZ2VSZWYuY3VycmVudDtcbiAgICBpZiAoYm91bmRlZEN1cnJlbnRQYWdlRGlkQ2hhbmdlKSB7XG4gICAgICBwcm9wc0JvdW5kZWRDdXJyZW50UGFnZVJlZi5jdXJyZW50ID0gbmV3Qm91bmRlZEN1cnJlbnRQYWdlO1xuICAgICAgdXBkYXRlQ3VycmVudFBhZ2UobmV3Qm91bmRlZEN1cnJlbnRQYWdlLCBjdXJyZW50Q29udGVudFBhZ2VSZWYsIG9uQ2hhbmdlUGFnZSk7XG4gICAgfVxuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldEZvclBhZ2UobmV3Qm91bmRlZEN1cnJlbnRQYWdlLCBwYWdlQ291bnQsIHBhZ2VSZWN0c1JlZiwgaXNIb3Jpem9udGFsLCBtYXhPZmZzZXRSZWYpO1xuICAgIGNvbnN0IGFuaW1hdGVkID0gYW5pbWF0ZUN1cnJlbnRQYWdlVXBkYXRlICYmIFJlbmRlclRhcmdldC5jdXJyZW50KCkgIT09IFJlbmRlclRhcmdldC5jYW52YXMgJiYgIW1vdW50O1xuICAgIHNuYXBUb1BhZ2UobmV3Qm91bmRlZEN1cnJlbnRQYWdlLCBvZmZzZXQsIHsgYW5pbWF0ZWQgfSk7XG4gIH07XG4gIHVzZUxheW91dEVmZmVjdDgoKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoaGFzTW91bnRlZFJlZi5jdXJyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGN1cnJlbnRDb250ZW50UGFnZVJlZi5jdXJyZW50ID0gY3VycmVudFBhZ2U7XG4gICAgY29uc3QgY29udGVudE9mZnNldCA9IGNvbnRlbnRPZmZzZXRSZWYuY3VycmVudDtcbiAgICBjb250ZW50T2Zmc2V0Lngub25DaGFuZ2UoYXBwbHlFZmZlY3RzKTtcbiAgICBjb250ZW50T2Zmc2V0Lnkub25DaGFuZ2UoYXBwbHlFZmZlY3RzKTtcbiAgICBhcHBseUVmZmVjdHMoKTtcbiAgICBoYXNNb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSAoX2EgPSBtZWFzdXJlQ29udGFpbmVyU2l6ZSgpKSAhPSBudWxsID8gX2EgOiBjb250YWluZXJTaXplUmVmLmN1cnJlbnQ7XG4gICAgdXBkYXRlTWF4T2Zmc2V0RnJvbVBhZ2VDb250ZW50cyhjb250YWluZXJTaXplKTtcbiAgICB1cGRhdGVBbmRTbmFwVG9QYWdlKGN1cnJlbnRDb250ZW50UGFnZVJlZi5jdXJyZW50LCB0cnVlKTtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3QyMSgoKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRQYWdlICE9PSBjdXJyZW50Q29udGVudFBhZ2VSZWYuY3VycmVudClcbiAgICAgIHVwZGF0ZUFuZFNuYXBUb1BhZ2UoY3VycmVudFBhZ2UpO1xuICB9LCBbY3VycmVudFBhZ2VdKTtcbiAgY29uc3QgaGFuZGxlTWVhc3VyZUxpZmVjeWNsZSA9ICgpID0+IHtcbiAgICBjb25zdCBuZXdDb250YWluZXJTaXplID0gbWVhc3VyZUNvbnRhaW5lclNpemUoKTtcbiAgICB1cGRhdGVNYXhPZmZzZXRGcm9tUGFnZUNvbnRlbnRzKG5ld0NvbnRhaW5lclNpemUgIT0gbnVsbCA/IG5ld0NvbnRhaW5lclNpemUgOiBjb250YWluZXJTaXplUmVmLmN1cnJlbnQpO1xuICAgIHVwZGF0ZUFuZFNuYXBUb1BhZ2UoY3VycmVudENvbnRlbnRQYWdlUmVmLmN1cnJlbnQpO1xuICAgIGlmIChuZXdDb250YWluZXJTaXplIHx8IGRpcmVjdGlvbiAhPT0gbGFzdERpcmVjdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgICBjb250ZW50T2Zmc2V0UmVmLmN1cnJlbnQueS5zZXQoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50T2Zmc2V0UmVmLmN1cnJlbnQueC5zZXQoMCk7XG4gICAgICB9XG4gICAgICBsYXN0RGlyZWN0aW9uUmVmLmN1cnJlbnQgPSBkaXJlY3Rpb247XG4gICAgfVxuICB9O1xuICB1c2VMYXlvdXRFZmZlY3Q4KCgpID0+IHtcbiAgICBpZiAoUmVuZGVyVGFyZ2V0LmN1cnJlbnQoKSAhPT0gUmVuZGVyVGFyZ2V0LmNhbnZhcylcbiAgICAgIHJldHVybjtcbiAgICBoYW5kbGVNZWFzdXJlTGlmZWN5Y2xlKCk7XG4gIH0pO1xuICBjb25zdCBvbkRyYWdTdGFydEhhbmRsZXIgPSAoZXZlbnQsIGluZm8pID0+IHtcbiAgICBpZiAob25TY3JvbGxTdGFydClcbiAgICAgIG9uU2Nyb2xsU3RhcnQoaW5mbyk7XG4gICAgaWYgKG9uRHJhZ1N0YXJ0KVxuICAgICAgb25EcmFnU3RhcnQoZXZlbnQsIGluZm8pO1xuICAgIHByZXYueCA9IGluaXRpYWwueCA9IGluZm8ucG9pbnQueDtcbiAgICBwcmV2LnkgPSBpbml0aWFsLnkgPSBpbmZvLnBvaW50Lnk7XG4gIH07XG4gIGNvbnN0IG9uRHJhZ0hhbmRsZXIgPSAoZXZlbnQsIGluZm8pID0+IHtcbiAgICBpZiAob25TY3JvbGwpXG4gICAgICBvblNjcm9sbChpbmZvKTtcbiAgICBpZiAob25EcmFnKVxuICAgICAgb25EcmFnKGV2ZW50LCBpbmZvKTtcbiAgICBwcmV2LnggPSBpbmZvLnBvaW50Lng7XG4gICAgcHJldi55ID0gaW5mby5wb2ludC55O1xuICB9O1xuICBjb25zdCBvbkRyYWdUcmFuc2l0aW9uRW5kID0gKCkgPT4ge1xuICAgIGlmIChwcm9wcy5vbkRyYWdUcmFuc2l0aW9uRW5kKVxuICAgICAgcHJvcHMub25EcmFnVHJhbnNpdGlvbkVuZCgpO1xuICAgIGlmIChvblNjcm9sbEVuZCkge1xuICAgICAgY29uc3QgeyB4LCB5IH0gPSBjb250ZW50T2Zmc2V0UmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBwb2ludCA9IHsgeDogeC5nZXQoKSwgeTogeS5nZXQoKSB9O1xuICAgICAgb25TY3JvbGxFbmQoe1xuICAgICAgICBwb2ludCxcbiAgICAgICAgdmVsb2NpdHk6IHsgeDogeC5nZXRWZWxvY2l0eSgpLCB5OiB5LmdldFZlbG9jaXR5KCkgfSxcbiAgICAgICAgb2Zmc2V0OiB7IHg6IHBvaW50LnggLSBpbml0aWFsLngsIHk6IHBvaW50LnkgLSBpbml0aWFsLnkgfSxcbiAgICAgICAgZGVsdGE6IHsgeDogcG9pbnQueCAtIHByZXYueCwgeTogcG9pbnQueSAtIHByZXYueSB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG9uRHJhZ0VuZEhhbmRsZXIgPSBhc3luYyAoZXZlbnQsIGluZm8pID0+IHtcbiAgICBjb25zdCBjb250ZW50T2Zmc2V0ID0gaXNIb3Jpem9udGFsID8gY29udGVudE9mZnNldFJlZi5jdXJyZW50LnggOiBjb250ZW50T2Zmc2V0UmVmLmN1cnJlbnQueTtcbiAgICBjb250ZW50T2Zmc2V0LnN0b3AoKTtcbiAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gY29udGVudE9mZnNldC5nZXQoKTtcbiAgICBjb25zdCBheGlzID0gaXNIb3Jpem9udGFsID8gXCJ4XCIgOiBcInlcIjtcbiAgICBjb25zdCB2ZWxvY2l0eSA9IGluZm8udmVsb2NpdHlbYXhpc107XG4gICAgbGV0IGluZGV4ID0gbmVhcmVzdFBhZ2VJbmRleChwYWdlUmVjdHNSZWYuY3VycmVudCwgc3RhcnRQb3NpdGlvbiwgc3RhcnRQb3NpdGlvbiwgaXNIb3Jpem9udGFsLCBtb21lbnR1bSk7XG4gICAgaWYgKHZlbG9jaXR5KSB7XG4gICAgICBpbmVydGlhKHtcbiAgICAgICAgZnJvbTogc3RhcnRQb3NpdGlvbixcbiAgICAgICAgdmVsb2NpdHksXG4gICAgICAgIG1vZGlmeVRhcmdldDogKGVuZFBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgaW5kZXggPSBuZWFyZXN0UGFnZUluZGV4KHBhZ2VSZWN0c1JlZi5jdXJyZW50LCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbiwgaXNIb3Jpem9udGFsLCBtb21lbnR1bSk7XG4gICAgICAgICAgcmV0dXJuIGVuZFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICB9KS5zdG9wKCk7XG4gICAgfVxuICAgIHVwZGF0ZUN1cnJlbnRQYWdlKGluZGV4LCBjdXJyZW50Q29udGVudFBhZ2VSZWYsIG9uQ2hhbmdlUGFnZSk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gb2Zmc2V0Rm9yUGFnZShpbmRleCwgcGFnZUNvdW50LCBwYWdlUmVjdHNSZWYsIGlzSG9yaXpvbnRhbCwgbWF4T2Zmc2V0UmVmKTtcbiAgICBpZiAob25EcmFnRW5kKVxuICAgICAgb25EcmFnRW5kKGV2ZW50LCBpbmZvKTtcbiAgICBjb25zdCBoYW5kbGVyID0gY29udGVudE9mZnNldFJlZi5jdXJyZW50W2F4aXNdO1xuICAgIGFuaW1hdGUyKGhhbmRsZXIsIG9mZnNldCwge1xuICAgICAgdHlwZTogXCJzcHJpbmdcIixcbiAgICAgIGZyb206IHN0YXJ0UG9zaXRpb24sXG4gICAgICB2ZWxvY2l0eSxcbiAgICAgIHN0aWZmbmVzczogNTAwLFxuICAgICAgZGFtcGluZzogNTAsXG4gICAgICBvbkNvbXBsZXRlOiBvbkRyYWdUcmFuc2l0aW9uRW5kXG4gICAgfSk7XG4gIH07XG4gIHBhZ2VFZmZlY3RWYWx1ZXNSZWYuY3VycmVudCA9IFtdO1xuICBjb25zdCBjaGlsZENvbXBvbmVudHMgPSBDaGlsZHJlbjEwLm1hcChjaGlsZHJlbiwgKGNoaWxkLCBpbmRleCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIWlzUmVhY3RDaGlsZChjaGlsZCkgfHwgIWlzUmVhY3RFbGVtZW50KGNoaWxkKSkge1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGUgPSB7XG4gICAgICByaWdodDogdm9pZCAwLFxuICAgICAgYm90dG9tOiB2b2lkIDAsXG4gICAgICB0b3A6IHZvaWQgMCxcbiAgICAgIGxlZnQ6IHZvaWQgMCxcbiAgICAgIF9jb25zdHJhaW50czoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGNvbnRhaW5lclByb3BzLl9fZnJvbUNhbnZhc0NvbXBvbmVudCkge1xuICAgICAgdXBkYXRlLnN0eWxlID0gKF9hID0gY2hpbGQucHJvcHMuc3R5bGUpICE9IG51bGwgPyBfYSA6IHt9O1xuICAgICAgaWYgKGNvbnRlbnRXaWR0aCA9PT0gXCJzdHJldGNoXCIpXG4gICAgICAgIHVwZGF0ZS5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgICAgaWYgKGNvbnRlbnRIZWlnaHQgPT09IFwic3RyZXRjaFwiKVxuICAgICAgICB1cGRhdGUuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb250ZW50V2lkdGggPT09IFwic3RyZXRjaFwiKVxuICAgICAgICB1cGRhdGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgIGlmIChjb250ZW50SGVpZ2h0ID09PSBcInN0cmV0Y2hcIilcbiAgICAgICAgdXBkYXRlLmhlaWdodCA9IFwiMTAwJVwiO1xuICAgIH1cbiAgICBsZXQgZWZmZWN0RGljdGlvbmFyeTtcbiAgICBjb25zdCB2YWx1ZXMgPSBlZmZlY3RWYWx1ZXMoaW5kZXgsIGxhdGVzdFByb3BzUmVmLCBwYWdlUmVjdHNSZWYsIGNvbnRlbnRPZmZzZXRSZWYsIG1heE9mZnNldFJlZik7XG4gICAgaWYgKHZhbHVlcykge1xuICAgICAgZWZmZWN0RGljdGlvbmFyeSA9IHt9O1xuICAgICAgZm9yIChjb25zdCBrZXk2IGluIHZhbHVlcykge1xuICAgICAgICBlZmZlY3REaWN0aW9uYXJ5W2tleTZdID0gbW90aW9uVmFsdWUodmFsdWVzW2tleTZdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGFnZUVmZmVjdFZhbHVlc1JlZi5jdXJyZW50LnB1c2goZWZmZWN0RGljdGlvbmFyeSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MzUoUGFnZUNvbnRhaW5lciwge1xuICAgICAga2V5OiBpbmRleCxcbiAgICAgIGVmZmVjdDogZWZmZWN0RGljdGlvbmFyeSxcbiAgICAgIGRyYWdFbmFibGVkLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgY29udGVudEhlaWdodCxcbiAgICAgIGNvbnRlbnRXaWR0aCxcbiAgICAgIGFsaWdubWVudCxcbiAgICAgIGdhcCxcbiAgICAgIGlzTGFzdFBhZ2U6IGluZGV4ID09PSBwYWdlQ291bnQgLSAxLFxuICAgICAgY29udGVudE9mZnNldFJlZixcbiAgICAgIGNvbnN0cmFpbnRzUmVmOiBjb25zdHJhaW50cyxcbiAgICAgIGRpcmVjdGlvbkxvY2ssXG4gICAgICBvbkRyYWdTdGFydDogb25EcmFnU3RhcnRIYW5kbGVyLFxuICAgICAgb25EcmFnOiBvbkRyYWdIYW5kbGVyLFxuICAgICAgb25EcmFnRW5kOiBvbkRyYWdFbmRIYW5kbGVyLFxuICAgICAgbGF5b3V0SWQ6IGxheW91dElkID8gYCR7bGF5b3V0SWR9LSR7aW5kZXh9YCA6IHZvaWQgMFxuICAgIH0sIGNsb25lRWxlbWVudDgoY2hpbGQsIHVwZGF0ZSkpO1xuICB9KTtcbiAgdXNlV2hlZWxTY3JvbGwoc2Nyb2xsYWJsZVJlZiwge1xuICAgIGVuYWJsZWQ6IHdoZWVsRW5hYmxlZCxcbiAgICBpbml0aWFsLFxuICAgIHByZXYsXG4gICAgZGlyZWN0aW9uLFxuICAgIGNvbnN0cmFpbnRzLFxuICAgIG9mZnNldFg6IGNvbnRlbnRPZmZzZXRSZWYuY3VycmVudC54LFxuICAgIG9mZnNldFk6IGNvbnRlbnRPZmZzZXRSZWYuY3VycmVudC55LFxuICAgIG9uU2Nyb2xsU3RhcnQsXG4gICAgb25TY3JvbGwsXG4gICAgb25TY3JvbGxFbmRcbiAgfSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDM1KEZyYW1lV2l0aE1vdGlvbiwge1xuICAgIHByZXNlcnZlM2Q6IGZhbHNlLFxuICAgIHBlcnNwZWN0aXZlOiBoYXNFZmZlY3QocHJvcHMpID8gMTIwMCA6IHZvaWQgMCxcbiAgICBvdmVyZmxvdyxcbiAgICAuLi5jb250YWluZXJQcm9wcyxcbiAgICBsYXlvdXRJZCxcbiAgICByZWY6IGNvbnRhaW5lclJlZixcbiAgICBvbkxheW91dE1lYXN1cmU6IGhhbmRsZU1lYXN1cmVMaWZlY3ljbGVcbiAgfSwgLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQzNShGcmFtZVdpdGhNb3Rpb24sIHtcbiAgICBcImRhdGEtZnJhbWVyLWNvbXBvbmVudC10eXBlXCI6IFwiUGFnZVwiLFxuICAgIHJlZjogc2Nyb2xsYWJsZVJlZixcbiAgICBiYWNrZ3JvdW5kOiBudWxsLFxuICAgIHg6IGNvbnRlbnRPZmZzZXRSZWYuY3VycmVudC54LFxuICAgIHk6IGNvbnRlbnRPZmZzZXRSZWYuY3VycmVudC55LFxuICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgIHByZXNlcnZlM2Q6IHRydWUsXG4gICAgbGF5b3V0OiB0cnVlLFxuICAgIGxheW91dElkOiBsYXlvdXRJZCAhPT0gdm9pZCAwID8gbGF5b3V0SWQgKyBcIi1wYWdlXCIgOiB2b2lkIDAsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBhZGRpbmc6IG1ha2VQYWRkaW5nU3RyaW5nKHBhZGRpbmdGcm9tUHJvcHMocHJvcHMpKSxcbiAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgZmxleERpcmVjdGlvbjogaXNIb3Jpem9udGFsID8gXCJyb3dcIiA6IFwiY29sdW1uXCJcbiAgICB9XG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MzUoRW1wdHlTdGF0ZSwge1xuICAgIHRpdGxlOiBcIlBhZ2VcIixcbiAgICBkZXNjcmlwdGlvbjogXCJDbGljayBhbmQgZHJhZyB0aGUgY29ubmVjdG9yIHRvIGFueSBmcmFtZSBvbiB0aGUgY2FudmFzIFxcdTIxOTJcIixcbiAgICBjaGlsZHJlbixcbiAgICBzaXplOiBjb250YWluZXJTaXplUmVmLmN1cnJlbnQsXG4gICAgaW5zaWRlVXNlckNvZGVDb21wb25lbnQ6ICFfX2Zyb21Db2RlQ29tcG9uZW50Tm9kZVxuICB9KSwgY2hpbGRDb21wb25lbnRzKSk7XG59KTtcbmZ1bmN0aW9uIGN1YmVFZmZlY3QoaW5mbykge1xuICBjb25zdCB7IG5vcm1hbGl6ZWRPZmZzZXQsIGRpcmVjdGlvbiB9ID0gaW5mbztcbiAgY29uc3QgaXNIb3Jpem9udGFsID0gZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIjtcbiAgcmV0dXJuIHtcbiAgICBvcmlnaW5YOiBub3JtYWxpemVkT2Zmc2V0IDwgMCA/IDEgOiAwLFxuICAgIG9yaWdpblk6IG5vcm1hbGl6ZWRPZmZzZXQgPCAwID8gMSA6IDAsXG4gICAgcm90YXRlWTogaXNIb3Jpem9udGFsID8gTWF0aC5taW4oTWF0aC5tYXgoLTkwLCBub3JtYWxpemVkT2Zmc2V0ICogOTApLCA5MCkgOiAwLFxuICAgIHJvdGF0ZVg6IGlzSG9yaXpvbnRhbCA/IDAgOiBNYXRoLm1pbihNYXRoLm1heCgtOTAsIG5vcm1hbGl6ZWRPZmZzZXQgKiAtOTApLCA5MCksXG4gICAgYmFja2ZhY2VWaXNpYmlsaXR5OiBcImhpZGRlblwiLFxuICAgIFdlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eTogXCJoaWRkZW5cIlxuICB9O1xufVxuZnVuY3Rpb24gY292ZXJmbG93RWZmZWN0KGluZm8pIHtcbiAgY29uc3QgeyBub3JtYWxpemVkT2Zmc2V0LCBkaXJlY3Rpb24sIHNpemU6IHNpemUyIH0gPSBpbmZvO1xuICBjb25zdCBpc0hvcml6b250YWwgPSBkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiO1xuICByZXR1cm4ge1xuICAgIHJvdGF0ZVk6IGlzSG9yaXpvbnRhbCA/IE1hdGgubWluKDQ1LCBNYXRoLm1heCgtNDUsIG5vcm1hbGl6ZWRPZmZzZXQgKiAtNDUpKSA6IDAsXG4gICAgcm90YXRlWDogaXNIb3Jpem9udGFsID8gMCA6IE1hdGgubWluKDQ1LCBNYXRoLm1heCgtNDUsIG5vcm1hbGl6ZWRPZmZzZXQgKiA0NSkpLFxuICAgIG9yaWdpblg6IGlzSG9yaXpvbnRhbCA/IG5vcm1hbGl6ZWRPZmZzZXQgPCAwID8gMCA6IDEgOiAwLjUsXG4gICAgb3JpZ2luWTogaXNIb3Jpem9udGFsID8gMC41IDogbm9ybWFsaXplZE9mZnNldCA8IDAgPyAwIDogMSxcbiAgICB4OiBpc0hvcml6b250YWwgPyBgJHtub3JtYWxpemVkT2Zmc2V0ICogLTI1fSVgIDogMCxcbiAgICB5OiBpc0hvcml6b250YWwgPyAwIDogYCR7bm9ybWFsaXplZE9mZnNldCAqIC0yNX0lYCxcbiAgICB6OiAtTWF0aC5hYnMobm9ybWFsaXplZE9mZnNldCksXG4gICAgc2NhbGU6IDEgLSBNYXRoLmFicyhub3JtYWxpemVkT2Zmc2V0IC8gMTApXG4gIH07XG59XG5mdW5jdGlvbiBjYWxjUGlsZUF4aXNPZmZzZXQob2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG9mZnNldCAqIGxlbmd0aCAtIG9mZnNldCAqIDg7XG59XG5mdW5jdGlvbiBwaWxlRWZmZWN0KGluZm8pIHtcbiAgY29uc3QgeyBub3JtYWxpemVkT2Zmc2V0LCBkaXJlY3Rpb24sIHNpemU6IHNpemUyIH0gPSBpbmZvO1xuICBjb25zdCBpc0hvcml6b250YWwgPSBkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiO1xuICBjb25zdCBhYnNvbHV0ZU9mZnNldCA9IE1hdGguYWJzKG5vcm1hbGl6ZWRPZmZzZXQpO1xuICByZXR1cm4ge1xuICAgIHg6IG5vcm1hbGl6ZWRPZmZzZXQgPCAwICYmIGlzSG9yaXpvbnRhbCA/IGNhbGNQaWxlQXhpc09mZnNldChhYnNvbHV0ZU9mZnNldCwgc2l6ZTIud2lkdGgpIDogMCxcbiAgICB5OiBub3JtYWxpemVkT2Zmc2V0IDwgMCAmJiAhaXNIb3Jpem9udGFsID8gY2FsY1BpbGVBeGlzT2Zmc2V0KGFic29sdXRlT2Zmc2V0LCBzaXplMi5oZWlnaHQpIDogMCxcbiAgICBzY2FsZTogbm9ybWFsaXplZE9mZnNldCA8IDAgPyAxIC0gYWJzb2x1dGVPZmZzZXQgLyA1MCA6IDFcbiAgfTtcbn1cbmZ1bmN0aW9uIHdoZWVsRWZmZWN0KGluZm8pIHtcbiAgY29uc3QgeyBub3JtYWxpemVkT2Zmc2V0LCBkaXJlY3Rpb24sIHNpemU6IHNpemUyIH0gPSBpbmZvO1xuICBjb25zdCBpc0hvcml6b250YWwgPSBkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiO1xuICBjb25zdCBvcmlnaW5aID0gKGlzSG9yaXpvbnRhbCA/IHNpemUyLndpZHRoIDogc2l6ZTIuaGVpZ2h0KSAqIDE4IC8gKDIgKiBNYXRoLlBJKTtcbiAgY29uc3Qgcm90YXRlWCA9IGlzSG9yaXpvbnRhbCA/IDAgOiBub3JtYWxpemVkT2Zmc2V0ICogLTIwO1xuICBjb25zdCByb3RhdGVZID0gaXNIb3Jpem9udGFsID8gbm9ybWFsaXplZE9mZnNldCAqIDIwIDogMDtcbiAgY29uc3QgeSA9IGlzSG9yaXpvbnRhbCA/IDAgOiBub3JtYWxpemVkT2Zmc2V0ICogLXNpemUyLmhlaWdodDtcbiAgY29uc3QgeCA9IGlzSG9yaXpvbnRhbCA/IG5vcm1hbGl6ZWRPZmZzZXQgKiAtc2l6ZTIud2lkdGggOiAwO1xuICByZXR1cm4ge1xuICAgIG9wYWNpdHk6IDEgLSBNYXRoLmFicyhub3JtYWxpemVkT2Zmc2V0KSAvIDQsXG4gICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7eH1weCwgJHt5fXB4KSB0cmFuc2xhdGVaKC0ke29yaWdpblp9cHgpIHJvdGF0ZVgoJHtyb3RhdGVYfWRlZykgcm90YXRlWSgke3JvdGF0ZVl9ZGVnKSB0cmFuc2xhdGVaKCR7b3JpZ2luWn1weClgXG4gIH07XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0RWZmZWN0KHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImN1YmVcIjpcbiAgICAgIHJldHVybiBjdWJlRWZmZWN0O1xuICAgIGNhc2UgXCJjb3ZlcmZsb3dcIjpcbiAgICAgIHJldHVybiBjb3ZlcmZsb3dFZmZlY3Q7XG4gICAgY2FzZSBcInBpbGVcIjpcbiAgICAgIHJldHVybiBwaWxlRWZmZWN0O1xuICAgIGNhc2UgXCJ3aGVlbFwiOlxuICAgICAgcmV0dXJuIHdoZWVsRWZmZWN0O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gbmVhcmVzdFBhZ2VJbmRleChwYWdlUmVjdHMsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBpc0hvcml6b250YWxEaXJlY3Rpb24sIGFsbG93U2tpcHBpbmdQYWdlcykge1xuICBjb25zdCBkaXN0YW5jZVRvU3RhcnQgPSBmdW5jdGlvbihyZWN0KSB7XG4gICAgY29uc3QgcmVjdFBvc2l0aW9uID0gaXNIb3Jpem9udGFsRGlyZWN0aW9uID8gcmVjdC54IDogcmVjdC55O1xuICAgIHJldHVybiBNYXRoLmFicyhyZWN0UG9zaXRpb24gKyBzdGFydFBvc2l0aW9uKTtcbiAgfTtcbiAgY29uc3QgZGlzdGFuY2VUb0VuZCA9IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICBjb25zdCByZWN0UG9zaXRpb24gPSBpc0hvcml6b250YWxEaXJlY3Rpb24gPyByZWN0LnggOiByZWN0Lnk7XG4gICAgcmV0dXJuIE1hdGguYWJzKHJlY3RQb3NpdGlvbiArIGVuZFBvc2l0aW9uKTtcbiAgfTtcbiAgaWYgKGFsbG93U2tpcHBpbmdQYWdlcykge1xuICAgIGNvbnN0IGNsb3Nlc3RQYWdlcyA9IFsuLi5wYWdlUmVjdHNdLnNvcnQoKGEyLCBiMikgPT4gZGlzdGFuY2VUb0VuZChhMikgLSBkaXN0YW5jZVRvRW5kKGIyKSk7XG4gICAgcmV0dXJuIHBhZ2VSZWN0cy5pbmRleE9mKGNsb3Nlc3RQYWdlc1swXSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY2xvc2VzdFRvU3RhcnQgPSBbLi4ucGFnZVJlY3RzXS5zb3J0KChhMiwgYjIpID0+IGRpc3RhbmNlVG9TdGFydChhMikgLSBkaXN0YW5jZVRvU3RhcnQoYjIpKTtcbiAgICBpZiAoY2xvc2VzdFRvU3RhcnQubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuIHBhZ2VSZWN0cy5pbmRleE9mKGNsb3Nlc3RUb1N0YXJ0WzBdKTtcbiAgICBjb25zdCBwYWdlQSA9IGNsb3Nlc3RUb1N0YXJ0WzBdO1xuICAgIGNvbnN0IHBhZ2VCID0gY2xvc2VzdFRvU3RhcnRbMV07XG4gICAgY29uc3QgY2xvc2VzdFBhZ2VzID0gW3BhZ2VBLCBwYWdlQl0uc29ydCgoYTIsIGIyKSA9PiBkaXN0YW5jZVRvRW5kKGEyKSAtIGRpc3RhbmNlVG9FbmQoYjIpKTtcbiAgICByZXR1cm4gcGFnZVJlY3RzLmluZGV4T2YoY2xvc2VzdFBhZ2VzWzBdKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UGFnZUNvbnRlbnRSZWN0cyhjb250YWluZXJSZWYsIGNvbnRhaW5lclNpemUsIGRpcmVjdGlvbiwgZ2FwKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgY29udGFpbmVyRWxlbWVudCA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xuICBpZiAoIWNvbnRhaW5lckVsZW1lbnQpXG4gICAgcmV0dXJuO1xuICBjb25zdCBjb250ZW50V3JhcHBlcnMgPSBbXTtcbiAgKF9hID0gY29udGFpbmVyRWxlbWVudC5maXJzdENoaWxkKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2hpbGROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgY29uc3QgY2hpbGROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgIGlmICghKGNoaWxkTm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBjb21wb25lbnRUeXBlID0gY2hpbGROb2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZnJhbWVyLWNvbXBvbmVudC10eXBlXCIpO1xuICAgIGlmIChjb21wb25lbnRUeXBlID09PSBwYWdlQ29udGVudFdyYXBwZXJUeXBlKSB7XG4gICAgICBjb250ZW50V3JhcHBlcnMucHVzaChjaGlsZE5vZGUpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHNpemVzID0gW107XG4gIGNvbnRlbnRXcmFwcGVycy5mb3JFYWNoKChjb250ZW50V3JhcHBlcikgPT4ge1xuICAgIGlmIChjb250ZW50V3JhcHBlciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGNvbnRlbnRXcmFwcGVyLmZpcnN0Q2hpbGQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgbGV0IHdpZHRoID0gY29udGVudFdyYXBwZXIuZmlyc3RDaGlsZC5vZmZzZXRXaWR0aDtcbiAgICAgIGxldCBoZWlnaHQgPSBjb250ZW50V3JhcHBlci5maXJzdENoaWxkLm9mZnNldEhlaWdodDtcbiAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICB3aWR0aCA9IDEwMDtcbiAgICAgICAgaGVpZ2h0ID0gMTAwO1xuICAgICAgfVxuICAgICAgc2l6ZXMucHVzaCh7IHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpemVzLnB1c2gobnVsbCk7XG4gICAgfVxuICB9KTtcbiAgbGV0IG1heFggPSAwO1xuICBsZXQgbWF4WSA9IDA7XG4gIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gIHJldHVybiBzaXplcy5tYXAoKHF1ZXJpZWRTaXplKSA9PiB7XG4gICAgY29uc3Qgc2l6ZTIgPSBxdWVyaWVkU2l6ZSB8fCBjb250YWluZXJTaXplO1xuICAgIGNvbnN0IHggPSBtYXhYO1xuICAgIGNvbnN0IHkgPSBtYXhZO1xuICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIG1heFggKz0gc2l6ZTIud2lkdGggKyBnYXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heFkgKz0gc2l6ZTIuaGVpZ2h0ICsgZ2FwO1xuICAgIH1cbiAgICByZXR1cm4geyAuLi5zaXplMiwgeCwgeSB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldE1heE9mZnNldChjb250YWluZXJTaXplLCBwYWdlQ29udGVudFJlY3RzLCBkaXJlY3Rpb24sIHBhZGRpbmdQcm9wcykge1xuICBjb25zdCBsYXN0UGFnZVJlY3QgPSBwYWdlQ29udGVudFJlY3RzW3BhZ2VDb250ZW50UmVjdHMubGVuZ3RoIC0gMV07XG4gIGlmICghbGFzdFBhZ2VSZWN0KVxuICAgIHJldHVybiAwO1xuICBjb25zdCBwYWRkaW5nU2lkZXMgPSBwYWRkaW5nRnJvbVByb3BzKHBhZGRpbmdQcm9wcyk7XG4gIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gIGNvbnN0IHBhZGRpbmdTdGFydCA9IGlzSG9yaXpvbnRhbCA/IHBhZGRpbmdTaWRlcy5sZWZ0IDogcGFkZGluZ1NpZGVzLnRvcDtcbiAgY29uc3QgcGFkZGluZ0VuZCA9IGlzSG9yaXpvbnRhbCA/IHBhZGRpbmdTaWRlcy5yaWdodCA6IHBhZGRpbmdTaWRlcy5ib3R0b207XG4gIGNvbnN0IHBhZ2VXaWR0aCA9IGlzSG9yaXpvbnRhbCA/IGxhc3RQYWdlUmVjdC53aWR0aCA6IGxhc3RQYWdlUmVjdC5oZWlnaHQ7XG4gIGNvbnN0IGNvbnRhaW5lcldpZHRoID0gaXNIb3Jpem9udGFsID8gY29udGFpbmVyU2l6ZS53aWR0aCA6IGNvbnRhaW5lclNpemUuaGVpZ2h0O1xuICBjb25zdCBmcmVlU3BhY2UgPSBjb250YWluZXJXaWR0aCAtIHBhZGRpbmdTdGFydCAtIHBhZGRpbmdFbmQgLSBwYWdlV2lkdGg7XG4gIGNvbnN0IHRhcmdldCA9IGlzSG9yaXpvbnRhbCA/IGxhc3RQYWdlUmVjdC54IDogbGFzdFBhZ2VSZWN0Lnk7XG4gIGlmIChmcmVlU3BhY2UgPD0gMClcbiAgICByZXR1cm4gTWF0aC5tYXgodGFyZ2V0LCAwKTtcbiAgcmV0dXJuIE1hdGgubWF4KHRhcmdldCAtIGZyZWVTcGFjZSwgMCk7XG59XG5mdW5jdGlvbiBvZmZzZXRGb3JQYWdlKGluZGV4LCBwYWdlQ291bnQsIHBhZ2VSZWN0c1JlZiwgaXNIb3Jpem9udGFsLCBtYXhPZmZzZXRSZWYpIHtcbiAgY29uc3QgcGFnZUluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocGFnZUNvdW50IC0gMSwgaW5kZXgpKTtcbiAgY29uc3QgY3VycmVudFBhZ2VSZWN0ID0gcGFnZVJlY3RzUmVmLmN1cnJlbnRbcGFnZUluZGV4XTtcbiAgaWYgKCFjdXJyZW50UGFnZVJlY3QpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgcmV0dXJuIC1NYXRoLm1pbihjdXJyZW50UGFnZVJlY3QueCwgbWF4T2Zmc2V0UmVmLmN1cnJlbnQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAtTWF0aC5taW4oY3VycmVudFBhZ2VSZWN0LnksIG1heE9mZnNldFJlZi5jdXJyZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gdXNlU25hcFRvUGFnZShjdXJyZW50Q29udGVudFBhZ2VSZWYsIGNvbnRlbnRPZmZzZXRSZWYsIGlzSG9yaXpvbnRhbCkge1xuICByZXR1cm4gKHBhZ2VJbmRleCwgb2Zmc2V0LCBvcHRpb25zKSA9PiB7XG4gICAgY3VycmVudENvbnRlbnRQYWdlUmVmLmN1cnJlbnQgPSBwYWdlSW5kZXg7XG4gICAgY29uc3QgY29udGVudE9mZnNldCA9IGlzSG9yaXpvbnRhbCA/IGNvbnRlbnRPZmZzZXRSZWYuY3VycmVudC54IDogY29udGVudE9mZnNldFJlZi5jdXJyZW50Lnk7XG4gICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLmFuaW1hdGVkKSB7XG4gICAgICBjb250ZW50T2Zmc2V0LnNldChvZmZzZXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBheGlzID0gaXNIb3Jpem9udGFsID8gXCJ4XCIgOiBcInlcIjtcbiAgICBhbmltYXRlMihjb250ZW50T2Zmc2V0UmVmLmN1cnJlbnRbYXhpc10sIG9mZnNldCwge1xuICAgICAgdHlwZTogXCJzcHJpbmdcIixcbiAgICAgIGZyb206IGNvbnRlbnRPZmZzZXQuZ2V0KCksXG4gICAgICB2ZWxvY2l0eTogY29udGVudE9mZnNldC5nZXRWZWxvY2l0eSgpLFxuICAgICAgc3RpZmZuZXNzOiA1MDAsXG4gICAgICBkYW1waW5nOiA1MFxuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0Qm91bmRlZEN1cnJlbnRQYWdlKHBhZ2VJbmRleCwgcGFnZUNvdW50KSB7XG4gIHJldHVybiBwYWdlSW5kZXggPj0gMCA/IE1hdGgubWluKHBhZ2VJbmRleCwgcGFnZUNvdW50IC0gMSkgOiAocGFnZUluZGV4ICUgcGFnZUNvdW50ICsgcGFnZUNvdW50KSAlIHBhZ2VDb3VudDtcbn1cbmZ1bmN0aW9uIGVmZmVjdFZhbHVlcyhpbmRleCwgbGF0ZXN0UHJvcHNSZWYsIHBhZ2VSZWN0c1JlZiwgY29udGVudE9mZnNldFJlZiwgbWF4T2Zmc2V0UmVmKSB7XG4gIGNvbnN0IHtcbiAgICBkaXJlY3Rpb246IGxhdGVzdERpcmVjdGlvbiA9IFwiaG9yaXpvbnRhbFwiLFxuICAgIGRlZmF1bHRFZmZlY3Q6IGxhdGVzdERlZmF1bHRFZmZlY3QsXG4gICAgZWZmZWN0OiBsYXRlc3RFZmZlY3QsXG4gICAgZ2FwOiBsYXRlc3RHYXAgPSAwXG4gIH0gPSBsYXRlc3RQcm9wc1JlZi5jdXJyZW50O1xuICBjb25zdCBsYXRlc3RJc0hvcml6b250YWwgPSBsYXRlc3REaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiO1xuICBjb25zdCBwYWdlUmVjdCA9IHBhZ2VSZWN0c1JlZi5jdXJyZW50W2luZGV4XSB8fCB7XG4gICAgeDogbGF0ZXN0SXNIb3Jpem9udGFsID8gaW5kZXggKiAyMDAgKyBsYXRlc3RHYXAgOiAwLFxuICAgIHk6IGxhdGVzdElzSG9yaXpvbnRhbCA/IDAgOiBpbmRleCAqIDIwMCArIGxhdGVzdEdhcCxcbiAgICB3aWR0aDogMjAwLFxuICAgIGhlaWdodDogMjAwXG4gIH07XG4gIGNvbnN0IGVmZmVjdEZ1bmN0aW9uID0gbGF0ZXN0RWZmZWN0IHx8IGdldERlZmF1bHRFZmZlY3QobGF0ZXN0RGVmYXVsdEVmZmVjdCk7XG4gIGlmICghZWZmZWN0RnVuY3Rpb24pXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBvZmZzZXQ7XG4gIGxldCBub3JtYWxpemVkT2Zmc2V0O1xuICBjb25zdCBjb250ZW50T2Zmc2V0ID0gY29udGVudE9mZnNldFJlZi5jdXJyZW50O1xuICBjb25zdCBtYXhTY3JvbGxPZmZzZXQgPSBtYXhPZmZzZXRSZWYuY3VycmVudDtcbiAgaWYgKGxhdGVzdElzSG9yaXpvbnRhbCkge1xuICAgIG9mZnNldCA9IE1hdGgubWluKHBhZ2VSZWN0LngsIG1heFNjcm9sbE9mZnNldCkgKyAoY29udGVudE9mZnNldCA/IGNvbnRlbnRPZmZzZXQueC5nZXQoKSA6IDApO1xuICAgIG5vcm1hbGl6ZWRPZmZzZXQgPSBvZmZzZXQgLyAocGFnZVJlY3Qud2lkdGggKyBsYXRlc3RHYXApO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldCA9IE1hdGgubWluKHBhZ2VSZWN0LnksIG1heFNjcm9sbE9mZnNldCkgKyAoY29udGVudE9mZnNldCA/IGNvbnRlbnRPZmZzZXQueS5nZXQoKSA6IDApO1xuICAgIG5vcm1hbGl6ZWRPZmZzZXQgPSBvZmZzZXQgLyAocGFnZVJlY3QuaGVpZ2h0ICsgbGF0ZXN0R2FwKTtcbiAgfVxuICBjb25zdCBzaXplMiA9IHsgd2lkdGg6IHBhZ2VSZWN0LndpZHRoLCBoZWlnaHQ6IHBhZ2VSZWN0LmhlaWdodCB9O1xuICByZXR1cm4gZWZmZWN0RnVuY3Rpb24oe1xuICAgIG9mZnNldCxcbiAgICBub3JtYWxpemVkT2Zmc2V0LFxuICAgIHNpemU6IHNpemUyLFxuICAgIGluZGV4LFxuICAgIGRpcmVjdGlvbjogbGF0ZXN0RGlyZWN0aW9uLFxuICAgIGdhcDogbGF0ZXN0R2FwLFxuICAgIHBhZ2VDb3VudDogcGFnZVJlY3RzUmVmLmN1cnJlbnQubGVuZ3RoXG4gIH0pO1xufVxuZnVuY3Rpb24gaGFzRWZmZWN0KHByb3BzKSB7XG4gIHJldHVybiAhIXByb3BzLmVmZmVjdCB8fCAhIWdldERlZmF1bHRFZmZlY3QocHJvcHMuZGVmYXVsdEVmZmVjdCk7XG59XG5mdW5jdGlvbiB1cGRhdGVDdXJyZW50UGFnZShuZXdQYWdlSW5kZXgsIGN1cnJlbnRDb250ZW50UGFnZVJlZiwgb25DaGFuZ2VQYWdlKSB7XG4gIGlmIChjdXJyZW50Q29udGVudFBhZ2VSZWYuY3VycmVudCA9PT0gbmV3UGFnZUluZGV4KVxuICAgIHJldHVybjtcbiAgaWYgKG9uQ2hhbmdlUGFnZSlcbiAgICBvbkNoYW5nZVBhZ2UobmV3UGFnZUluZGV4LCBjdXJyZW50Q29udGVudFBhZ2VSZWYuY3VycmVudCk7XG4gIGN1cnJlbnRDb250ZW50UGFnZVJlZi5jdXJyZW50ID0gbmV3UGFnZUluZGV4O1xufVxuXG4vLyBzcmMvY29tcG9uZW50cy9QYWdlL1BhZ2UudHN4XG52YXIgQ29udGVudERpbWVuc2lvbjtcbihmdW5jdGlvbihDb250ZW50RGltZW5zaW9uMikge1xuICBDb250ZW50RGltZW5zaW9uMi5BdXRvID0gXCJhdXRvXCI7XG4gIENvbnRlbnREaW1lbnNpb24yLlN0cmV0Y2ggPSBcInN0cmV0Y2hcIjtcbn0pKENvbnRlbnREaW1lbnNpb24gfHwgKENvbnRlbnREaW1lbnNpb24gPSB7fSkpO1xudmFyIHBhZ2VDb250ZW50RGltZW5zaW9uT3B0aW9ucyA9IFtDb250ZW50RGltZW5zaW9uLkF1dG8sIENvbnRlbnREaW1lbnNpb24uU3RyZXRjaF07XG52YXIgcGFnZUNvbnRlbnREaW1lbnNpb25UaXRsZXMgPSBwYWdlQ29udGVudERpbWVuc2lvbk9wdGlvbnMubWFwKChvcHRpb24pID0+IHtcbiAgc3dpdGNoIChvcHRpb24pIHtcbiAgICBjYXNlIENvbnRlbnREaW1lbnNpb24uQXV0bzpcbiAgICAgIHJldHVybiBcIkF1dG9cIjtcbiAgICBjYXNlIENvbnRlbnREaW1lbnNpb24uU3RyZXRjaDpcbiAgICAgIHJldHVybiBcIlN0cmV0Y2hcIjtcbiAgfVxufSk7XG52YXIgcGFnZUVmZmVjdE9wdGlvbnMgPSBbXCJub25lXCIsIFwiY3ViZVwiLCBcImNvdmVyZmxvd1wiLCBcIndoZWVsXCIsIFwicGlsZVwiXTtcbnZhciBwYWdlRWZmZWN0VGl0bGVzID0gcGFnZUVmZmVjdE9wdGlvbnMubWFwKChvcHRpb24pID0+IHtcbiAgc3dpdGNoIChvcHRpb24pIHtcbiAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgcmV0dXJuIFwiTm9uZVwiO1xuICAgIGNhc2UgXCJjdWJlXCI6XG4gICAgICByZXR1cm4gXCJDdWJlXCI7XG4gICAgY2FzZSBcImNvdmVyZmxvd1wiOlxuICAgICAgcmV0dXJuIFwiQ292ZXIgRmxvd1wiO1xuICAgIGNhc2UgXCJ3aGVlbFwiOlxuICAgICAgcmV0dXJuIFwiV2hlZWxcIjtcbiAgICBjYXNlIFwicGlsZVwiOlxuICAgICAgcmV0dXJuIFwiUGlsZVwiO1xuICB9XG59KTtcbnZhciBwYWdlQWxpZ25tZW50T3B0aW9ucyA9IFtcInN0YXJ0XCIsIFwiY2VudGVyXCIsIFwiZW5kXCJdO1xudmFyIGdlbmVyaWNBbGlnbm1lbnRUaXRsZXMgPSBwYWdlQWxpZ25tZW50T3B0aW9ucy5tYXAoKG9wdGlvbikgPT4ge1xuICBzd2l0Y2ggKG9wdGlvbikge1xuICAgIGNhc2UgXCJzdGFydFwiOlxuICAgICAgcmV0dXJuIFwiU3RhcnRcIjtcbiAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICByZXR1cm4gXCJDZW50ZXJcIjtcbiAgICBjYXNlIFwiZW5kXCI6XG4gICAgICByZXR1cm4gXCJFbmRcIjtcbiAgfVxufSk7XG5hZGRQcm9wZXJ0eUNvbnRyb2xzKFBhZ2UsIHtcbiAgZGlyZWN0aW9uOiB7XG4gICAgdHlwZTogQ29udHJvbFR5cGUuRW51bSxcbiAgICBvcHRpb25zOiBbXCJob3Jpem9udGFsXCIsIFwidmVydGljYWxcIl0sXG4gICAgdGl0bGU6IFwiRGlyZWN0aW9uXCIsXG4gICAgZGVmYXVsdFZhbHVlOiBcImhvcml6b250YWxcIixcbiAgICBkaXNwbGF5U2VnbWVudGVkQ29udHJvbDogdHJ1ZSxcbiAgICBvcHRpb25JY29uczogW1wiZGlyZWN0aW9uLWhvcml6b250YWxcIiwgXCJkaXJlY3Rpb24tdmVydGljYWxcIl1cbiAgfSxcbiAgZGlyZWN0aW9uTG9jazoge1xuICAgIHR5cGU6IENvbnRyb2xUeXBlLkJvb2xlYW4sXG4gICAgdGl0bGU6IFwiTG9ja1wiLFxuICAgIGVuYWJsZWRUaXRsZTogXCIxIEF4aXNcIixcbiAgICBkaXNhYmxlZFRpdGxlOiBcIk9mZlwiLFxuICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZVxuICB9LFxuICBjb250ZW50V2lkdGg6IHtcbiAgICB0eXBlOiBDb250cm9sVHlwZS5FbnVtLFxuICAgIG9wdGlvbnM6IHBhZ2VDb250ZW50RGltZW5zaW9uT3B0aW9ucyxcbiAgICBvcHRpb25UaXRsZXM6IHBhZ2VDb250ZW50RGltZW5zaW9uVGl0bGVzLFxuICAgIHRpdGxlOiBcIldpZHRoXCIsXG4gICAgZGVmYXVsdFZhbHVlOiBDb250ZW50RGltZW5zaW9uLlN0cmV0Y2gsXG4gICAgZGlzcGxheVNlZ21lbnRlZENvbnRyb2w6IHRydWVcbiAgfSxcbiAgY29udGVudEhlaWdodDoge1xuICAgIHR5cGU6IENvbnRyb2xUeXBlLkVudW0sXG4gICAgb3B0aW9uczogcGFnZUNvbnRlbnREaW1lbnNpb25PcHRpb25zLFxuICAgIG9wdGlvblRpdGxlczogcGFnZUNvbnRlbnREaW1lbnNpb25UaXRsZXMsXG4gICAgdGl0bGU6IFwiSGVpZ2h0XCIsXG4gICAgZGVmYXVsdFZhbHVlOiBDb250ZW50RGltZW5zaW9uLlN0cmV0Y2gsXG4gICAgZGlzcGxheVNlZ21lbnRlZENvbnRyb2w6IHRydWVcbiAgfSxcbiAgYWxpZ25tZW50OiB7XG4gICAgdHlwZTogQ29udHJvbFR5cGUuRW51bSxcbiAgICBvcHRpb25zOiBwYWdlQWxpZ25tZW50T3B0aW9ucyxcbiAgICBvcHRpb25UaXRsZXM6IGdlbmVyaWNBbGlnbm1lbnRUaXRsZXMsXG4gICAgdGl0bGU6IFwiQWxpZ25cIixcbiAgICBoaWRkZW4ocHJvcHMpIHtcbiAgICAgIGNvbnN0IHsgZGlyZWN0aW9uLCBjb250ZW50V2lkdGgsIGNvbnRlbnRIZWlnaHQgfSA9IHByb3BzO1xuICAgICAgY29uc3QgaXNIb3Jpem9udGFsRGlyZWN0aW9uID0gZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIjtcbiAgICAgIGNvbnN0IGNyb3NzRGltZW5zaW9uID0gaXNIb3Jpem9udGFsRGlyZWN0aW9uID8gY29udGVudEhlaWdodCA6IGNvbnRlbnRXaWR0aDtcbiAgICAgIHJldHVybiBjcm9zc0RpbWVuc2lvbiA9PT0gQ29udGVudERpbWVuc2lvbi5TdHJldGNoO1xuICAgIH0sXG4gICAgZGVmYXVsdFZhbHVlOiBcInN0YXJ0XCIsXG4gICAgZGlzcGxheVNlZ21lbnRlZENvbnRyb2w6IHRydWUsXG4gICAgb3B0aW9uSWNvbnM6IHtcbiAgICAgIGRpcmVjdGlvbjoge1xuICAgICAgICBob3Jpem9udGFsOiBbXCJhbGlnbi10b3BcIiwgXCJhbGlnbi1taWRkbGVcIiwgXCJhbGlnbi1ib3R0b21cIl0sXG4gICAgICAgIHZlcnRpY2FsOiBbXCJhbGlnbi1sZWZ0XCIsIFwiYWxpZ24tY2VudGVyXCIsIFwiYWxpZ24tcmlnaHRcIl1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGdhcDoge1xuICAgIHR5cGU6IENvbnRyb2xUeXBlLk51bWJlcixcbiAgICBtaW46IDAsXG4gICAgdGl0bGU6IFwiR2FwXCIsXG4gICAgZGVmYXVsdFZhbHVlOiAwXG4gIH0sXG4gIHBhZGRpbmc6IHtcbiAgICB0eXBlOiBDb250cm9sVHlwZS5GdXNlZE51bWJlcixcbiAgICB0b2dnbGVLZXk6IFwicGFkZGluZ1BlclNpZGVcIixcbiAgICB0b2dnbGVUaXRsZXM6IFtcIlBhZGRpbmdcIiwgXCJQYWRkaW5nIHBlciBzaWRlXCJdLFxuICAgIHZhbHVlS2V5czogW1wicGFkZGluZ1RvcFwiLCBcInBhZGRpbmdSaWdodFwiLCBcInBhZGRpbmdCb3R0b21cIiwgXCJwYWRkaW5nTGVmdFwiXSxcbiAgICB2YWx1ZUxhYmVsczogW1wiVFwiLCBcIlJcIiwgXCJCXCIsIFwiTFwiXSxcbiAgICBtaW46IDAsXG4gICAgdGl0bGU6IFwiUGFkZGluZ1wiLFxuICAgIGRlZmF1bHRWYWx1ZTogMFxuICB9LFxuICBjdXJyZW50UGFnZToge1xuICAgIHR5cGU6IENvbnRyb2xUeXBlLk51bWJlcixcbiAgICBtaW46IDAsXG4gICAgdGl0bGU6IFwiQ3VycmVudFwiLFxuICAgIGRpc3BsYXlTdGVwcGVyOiB0cnVlLFxuICAgIGRlZmF1bHRWYWx1ZTogMFxuICB9LFxuICBtb21lbnR1bToge1xuICAgIHR5cGU6IENvbnRyb2xUeXBlLkJvb2xlYW4sXG4gICAgZW5hYmxlZFRpdGxlOiBcIk9uXCIsXG4gICAgZGlzYWJsZWRUaXRsZTogXCJPZmZcIixcbiAgICB0aXRsZTogXCJNb21lbnR1bVwiLFxuICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcbiAgfSxcbiAgZHJhZ0VuYWJsZWQ6IHtcbiAgICB0eXBlOiBDb250cm9sVHlwZS5Cb29sZWFuLFxuICAgIHRpdGxlOiBcIkRyYWdcIixcbiAgICBlbmFibGVkVGl0bGU6IFwiT25cIixcbiAgICBkaXNhYmxlZFRpdGxlOiBcIk9mZlwiLFxuICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZVxuICB9LFxuICB3aGVlbEVuYWJsZWQ6IHtcbiAgICB0eXBlOiBDb250cm9sVHlwZS5Cb29sZWFuLFxuICAgIHRpdGxlOiBcIldoZWVsXCIsXG4gICAgZW5hYmxlZFRpdGxlOiBcIk9uXCIsXG4gICAgZGlzYWJsZWRUaXRsZTogXCJPZmZcIixcbiAgICBkZWZhdWx0VmFsdWU6IGZhbHNlXG4gIH0sXG4gIGRlZmF1bHRFZmZlY3Q6IHtcbiAgICB0eXBlOiBDb250cm9sVHlwZS5FbnVtLFxuICAgIG9wdGlvbnM6IHBhZ2VFZmZlY3RPcHRpb25zLFxuICAgIG9wdGlvblRpdGxlczogcGFnZUVmZmVjdFRpdGxlcyxcbiAgICB0aXRsZTogXCJFZmZlY3RcIixcbiAgICBkZWZhdWx0VmFsdWU6IFwibm9uZVwiXG4gIH0sXG4gIGNoaWxkcmVuOiB7XG4gICAgdHlwZTogQ29udHJvbFR5cGUuQXJyYXksXG4gICAgdGl0bGU6IFwiQ29udGVudFwiLFxuICAgIGNvbnRyb2w6IHsgdHlwZTogQ29udHJvbFR5cGUuQ29tcG9uZW50SW5zdGFuY2UsIHRpdGxlOiBcIlBhZ2VcIiB9XG4gIH1cbn0pO1xuUGFnZS5zdXBwb3J0c0NvbnN0cmFpbnRzID0gdHJ1ZTtcblxuLy8gc3JjL2NvbXBvbmVudHMvaG9jL1dpdGhOYXZpZ2F0b3IudHN4XG5pbXBvcnQge1xuICBDb21wb25lbnQgYXMgQ29tcG9uZW50MTMsXG4gIGNyZWF0ZUVsZW1lbnQgYXMgY3JlYXRlRWxlbWVudDM2XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvcmVuZGVyL3R5cGVzL05hdmlnYXRpb25MaW5rLnRzXG52YXIgTmF2aWdhdGVUbztcbihmdW5jdGlvbihOYXZpZ2F0ZVRvMikge1xuICBOYXZpZ2F0ZVRvMltcIlByZXZpb3VzXCJdID0gXCJAUHJldmlvdXNcIjtcbn0pKE5hdmlnYXRlVG8gfHwgKE5hdmlnYXRlVG8gPSB7fSkpO1xudmFyIE5hdmlnYXRpb25UcmFuc2l0aW9uVHlwZTtcbihmdW5jdGlvbihOYXZpZ2F0aW9uVHJhbnNpdGlvblR5cGUyKSB7XG4gIE5hdmlnYXRpb25UcmFuc2l0aW9uVHlwZTJbXCJwdXNoXCJdID0gXCJwdXNoXCI7XG4gIE5hdmlnYXRpb25UcmFuc2l0aW9uVHlwZTJbXCJpbnN0YW50XCJdID0gXCJpbnN0YW50XCI7XG4gIE5hdmlnYXRpb25UcmFuc2l0aW9uVHlwZTJbXCJmYWRlXCJdID0gXCJmYWRlXCI7XG4gIE5hdmlnYXRpb25UcmFuc2l0aW9uVHlwZTJbXCJtb2RhbFwiXSA9IFwibW9kYWxcIjtcbiAgTmF2aWdhdGlvblRyYW5zaXRpb25UeXBlMltcIm92ZXJsYXlcIl0gPSBcIm92ZXJsYXlcIjtcbiAgTmF2aWdhdGlvblRyYW5zaXRpb25UeXBlMltcImZsaXBcIl0gPSBcImZsaXBcIjtcbiAgTmF2aWdhdGlvblRyYW5zaXRpb25UeXBlMltcIm1hZ2ljTW90aW9uXCJdID0gXCJtYWdpY01vdGlvblwiO1xufSkoTmF2aWdhdGlvblRyYW5zaXRpb25UeXBlIHx8IChOYXZpZ2F0aW9uVHJhbnNpdGlvblR5cGUgPSB7fSkpO1xuXG4vLyBzcmMvY29tcG9uZW50cy9ob2MvV2l0aE5hdmlnYXRvci50c3hcbnZhciBob2lzdE5vblJlYWN0U3RhdGljMyA9IHJlcXVpcmVfaG9pc3Rfbm9uX3JlYWN0X3N0YXRpY3NfY2pzKCk7XG5mdW5jdGlvbiBXaXRoTmF2aWdhdG9yKEJhc2VDb21wb25lbnQsIG5hdmlnYXRpb25UcmFuc2l0aW9uLCBuYXZpZ2F0aW9uVHJhbnNpdGlvbkRpcmVjdGlvbiwgTmF2aWdhdGlvblRhcmdldDIsIG5hdmlnYXRpb25UcmFuc2l0aW9uT3B0aW9ucykge1xuICBjb25zdCBJbnRlcm5hbFdpdGhOYXZpZ2F0b3IgPSBjbGFzcyBleHRlbmRzIENvbXBvbmVudDEzIHtcbiAgICByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQzNihOYXZpZ2F0aW9uQ29udGV4dC5Db25zdW1lciwgbnVsbCwgKG5hdmlnYXRpb24pID0+IHtcbiAgICAgICAgY29uc3QgbmF2aWdhdGUgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKG5hdmlnYXRpb25UcmFuc2l0aW9uID09PSBcImdvQmFja1wiKSB7XG4gICAgICAgICAgICBuYXZpZ2F0aW9uLmdvQmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIU5hdmlnYXRpb25UYXJnZXQyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IE5hdmlnYXRpb25UYXJnZXQyKCk7XG4gICAgICAgICAgY29uc3QgYXBwZWFyc0Zyb20gPSB0cmFuc2l0aW9uRGlyZWN0aW9uVG9TaWRlKG5hdmlnYXRpb25UcmFuc2l0aW9uRGlyZWN0aW9uKTtcbiAgICAgICAgICBzd2l0Y2ggKG5hdmlnYXRpb25UcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIE5hdmlnYXRpb25UcmFuc2l0aW9uVHlwZS5pbnN0YW50OlxuICAgICAgICAgICAgICBuYXZpZ2F0aW9uLmluc3RhbnQoY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE5hdmlnYXRpb25UcmFuc2l0aW9uVHlwZS5mYWRlOlxuICAgICAgICAgICAgICBuYXZpZ2F0aW9uLmZhZGUoY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE5hdmlnYXRpb25UcmFuc2l0aW9uVHlwZS5tb2RhbDpcbiAgICAgICAgICAgICAgbmF2aWdhdGlvbi5tb2RhbChjb21wb25lbnQsIG5hdmlnYXRpb25UcmFuc2l0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBOYXZpZ2F0aW9uVHJhbnNpdGlvblR5cGUucHVzaDpcbiAgICAgICAgICAgICAgbmF2aWdhdGlvbi5wdXNoKGNvbXBvbmVudCwgeyBhcHBlYXJzRnJvbSB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE5hdmlnYXRpb25UcmFuc2l0aW9uVHlwZS5vdmVybGF5OlxuICAgICAgICAgICAgICBuYXZpZ2F0aW9uLm92ZXJsYXkoY29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgLi4ubmF2aWdhdGlvblRyYW5zaXRpb25PcHRpb25zLFxuICAgICAgICAgICAgICAgIGFwcGVhcnNGcm9tXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTmF2aWdhdGlvblRyYW5zaXRpb25UeXBlLmZsaXA6XG4gICAgICAgICAgICAgIG5hdmlnYXRpb24uZmxpcChjb21wb25lbnQsIHsgYXBwZWFyc0Zyb20gfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBOYXZpZ2F0aW9uVHJhbnNpdGlvblR5cGUubWFnaWNNb3Rpb246XG4gICAgICAgICAgICAgIG5hdmlnYXRpb24ubWFnaWNNb3Rpb24oY29tcG9uZW50LCB7fSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgeyBvblRhcCwgLi4ucHJvcHMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChvblRhcCkge1xuICAgICAgICAgIHByb3BzLm9uVGFwID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIG9uVGFwLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgbmF2aWdhdGUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wcy5vblRhcCA9IG5hdmlnYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDM2KEJhc2VDb21wb25lbnQsIHtcbiAgICAgICAgICAuLi5wcm9wc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgaG9pc3ROb25SZWFjdFN0YXRpYzMoSW50ZXJuYWxXaXRoTmF2aWdhdG9yLCBCYXNlQ29tcG9uZW50KTtcbiAgcmV0dXJuIEludGVybmFsV2l0aE5hdmlnYXRvcjtcbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb25EaXJlY3Rpb25Ub1NpZGUoZGlyZWN0aW9uKSB7XG4gIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgY2FzZSBcImxlZnRcIjpcbiAgICAgIHJldHVybiBcInJpZ2h0XCI7XG4gICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICByZXR1cm4gXCJsZWZ0XCI7XG4gICAgY2FzZSBcInVwXCI6XG4gICAgICByZXR1cm4gXCJib3R0b21cIjtcbiAgICBjYXNlIFwiZG93blwiOlxuICAgICAgcmV0dXJuIFwidG9wXCI7XG4gIH1cbn1cblxuLy8gc3JjL2FuaW1hdGlvbi9BbmltYXRvcnMvUHJlY2FsY3VsYXRlZEFuaW1hdG9yLnRzXG52YXIgRGVmYXVsdHMyID0ge1xuICBkZWx0YTogMSAvIDYwLFxuICBtYXhWYWx1ZXM6IDFlNFxufTtcbnZhciBQcmVjYWxjdWxhdGVkQW5pbWF0b3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLkRlZmF1bHRzMiwgLi4ub3B0aW9ucyB9O1xuICAgIHRoaXMuYW5pbWF0b3IgPSBvcHRpb25zLmFuaW1hdG9yO1xuICB9XG4gIHByZUNhbGN1bGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuYW5pbWF0b3IuaXNSZWFkeSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgZGVsdGE6IGRlbHRhMiB9ID0gdGhpcy5vcHRpb25zO1xuICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgd2hpbGUgKCF0aGlzLmFuaW1hdG9yLmlzRmluaXNoZWQoKSAmJiB0aGlzLnZhbHVlcy5sZW5ndGggPCB0aGlzLm9wdGlvbnMubWF4VmFsdWVzKSB7XG4gICAgICBsZXQgdmFsdWUgPSB0aGlzLmFuaW1hdG9yLm5leHQodGhpcy5vcHRpb25zLmRlbHRhKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0gdmFsdWU7XG4gICAgICAgIGNvbnN0IGNvcHkgPSB7IC4uLm9iamVjdCB9O1xuICAgICAgICB2YWx1ZSA9IGNvcHk7XG4gICAgICB9XG4gICAgICB0aGlzLnZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy50b3RhbFRpbWUgPSB0aGlzLnZhbHVlcy5sZW5ndGggKiBkZWx0YTI7XG4gIH1cbiAgaW5kZXhGb3JUaW1lKHRpbWUzKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMudmFsdWVzLmxlbmd0aCAtIDEsIE1hdGgucm91bmQodGhpcy52YWx1ZXMubGVuZ3RoICogKHRpbWUzIC8gdGhpcy50b3RhbFRpbWUpKSAtIDEpKTtcbiAgfVxuICBzZXRGcm9tKHZhbHVlKSB7XG4gICAgdGhpcy5hbmltYXRvci5zZXRGcm9tKHZhbHVlKTtcbiAgICB0aGlzLnByZUNhbGN1bGF0ZSgpO1xuICB9XG4gIHNldFRvKGVuZCkge1xuICAgIHRoaXMuYW5pbWF0b3Iuc2V0VG8oZW5kKTtcbiAgICB0aGlzLnByZUNhbGN1bGF0ZSgpO1xuICB9XG4gIGlzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzICE9PSB2b2lkIDAgJiYgdGhpcy52YWx1ZXMubGVuZ3RoID4gMCAmJiB0aGlzLnRvdGFsVGltZSA+IDA7XG4gIH1cbiAgbmV4dChkZWx0YTIpIHtcbiAgICB0aGlzLmN1cnJlbnRUaW1lICs9IGRlbHRhMjtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXhGb3JUaW1lKHRoaXMuY3VycmVudFRpbWUpO1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1tpbmRleF07XG4gIH1cbiAgaXNGaW5pc2hlZCgpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbFRpbWUgPT09IDAgfHwgdGhpcy5jdXJyZW50VGltZSA+PSB0aGlzLnRvdGFsVGltZTtcbiAgfVxuICBnZXQgZW5kVmFsdWUoKSB7XG4gICAgdGhpcy5wcmVDYWxjdWxhdGUoKTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXhGb3JUaW1lKHRoaXMudG90YWxUaW1lKTtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXMubGVuZ3RoID4gMCA/IHRoaXMudmFsdWVzW2luZGV4XSA6IHRoaXMuYW5pbWF0b3IubmV4dCgwKTtcbiAgfVxufTtcblxuLy8gc3JjL2FuaW1hdGlvbi9BbmltYXRvcnMvQmV6aWVyQW5pbWF0b3IudHNcbnZhciBCZXppZXI7XG4oZnVuY3Rpb24oQmV6aWVyMikge1xuICBCZXppZXIyW1wiTGluZWFyXCJdID0gXCJsaW5lYXJcIjtcbiAgQmV6aWVyMltcIkVhc2VcIl0gPSBcImVhc2VcIjtcbiAgQmV6aWVyMltcIkVhc2VJblwiXSA9IFwiZWFzZS1pblwiO1xuICBCZXppZXIyW1wiRWFzZU91dFwiXSA9IFwiZWFzZS1vdXRcIjtcbiAgQmV6aWVyMltcIkVhc2VJbk91dFwiXSA9IFwiZWFzZS1pbi1vdXRcIjtcbn0pKEJlemllciB8fCAoQmV6aWVyID0ge30pKTtcbnZhciBCZXppZXJEZWZhdWx0cyA9IHtcbiAgY3VydmU6IEJlemllci5FYXNlLFxuICBkdXJhdGlvbjogMVxufTtcbmZ1bmN0aW9uIGNvbnRyb2xQb2ludHNGb3JDdXJ2ZShjdXJ2ZSkge1xuICBzd2l0Y2ggKGN1cnZlKSB7XG4gICAgY2FzZSBCZXppZXIuTGluZWFyOlxuICAgICAgcmV0dXJuIFswLCAwLCAxLCAxXTtcbiAgICBjYXNlIEJlemllci5FYXNlOlxuICAgICAgcmV0dXJuIFswLjI1LCAwLjEsIDAuMjUsIDFdO1xuICAgIGNhc2UgQmV6aWVyLkVhc2VJbjpcbiAgICAgIHJldHVybiBbMC40MiwgMCwgMSwgMV07XG4gICAgY2FzZSBCZXppZXIuRWFzZU91dDpcbiAgICAgIHJldHVybiBbMCwgMCwgMC41OCwgMV07XG4gICAgY2FzZSBCZXppZXIuRWFzZUluT3V0OlxuICAgICAgcmV0dXJuIFswLjQyLCAwLCAwLjU4LCAxXTtcbiAgfVxufVxudmFyIEJlemllckFuaW1hdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBpbnRlcnBvbGF0aW9uKSB7XG4gICAgdGhpcy5pbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbjtcbiAgICB0aGlzLnByb2dyZXNzID0gMDtcbiAgICB0aGlzLm5leHQgPSAoZGVsdGEyKSA9PiB7XG4gICAgICBjb25zdCB7IGR1cmF0aW9uIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICB0aGlzLnByb2dyZXNzICs9IGRlbHRhMiAvIGR1cmF0aW9uO1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnVuaXRCZXppZXIuc29sdmUodGhpcy5wcm9ncmVzcywgdGhpcy5zb2x2ZUVwc2lsb24oZHVyYXRpb24pKTtcbiAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMuaW50ZXJwb2xhdG9yKHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG4gICAgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLkJlemllckRlZmF1bHRzLCAuLi5vcHRpb25zIH07XG4gICAgbGV0IGNvbnRyb2xQb2ludHM7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuY3VydmUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnRyb2xQb2ludHMgPSBjb250cm9sUG9pbnRzRm9yQ3VydmUodGhpcy5vcHRpb25zLmN1cnZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udHJvbFBvaW50cyA9IHRoaXMub3B0aW9ucy5jdXJ2ZTtcbiAgICB9XG4gICAgY29uc3QgW3AxeCwgcDF5LCBwMngsIHAyeV0gPSBjb250cm9sUG9pbnRzO1xuICAgIHRoaXMudW5pdEJlemllciA9IG5ldyBVbml0QmV6aWVyKFBvaW50KHAxeCwgcDF5KSwgUG9pbnQocDJ4LCBwMnkpKTtcbiAgfVxuICBzZXRGcm9tKHZhbHVlKSB7XG4gICAgdGhpcy5jdXJyZW50ID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVJbnRlcnBvbGF0b3IoKTtcbiAgfVxuICBzZXRUbyh2YWx1ZSkge1xuICAgIHRoaXMuZGVzdGluYXRpb24gPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZUludGVycG9sYXRvcigpO1xuICB9XG4gIGlzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJwb2xhdG9yICE9PSB2b2lkIDA7XG4gIH1cbiAgdXBkYXRlSW50ZXJwb2xhdG9yKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQgPT09IHZvaWQgMCB8fCB0aGlzLmRlc3RpbmF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pbnRlcnBvbGF0b3IgPSB0aGlzLmludGVycG9sYXRpb24uaW50ZXJwb2xhdGUodGhpcy5jdXJyZW50LCB0aGlzLmRlc3RpbmF0aW9uKTtcbiAgfVxuICBpc0ZpbmlzaGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb2dyZXNzID49IDE7XG4gIH1cbiAgc29sdmVFcHNpbG9uKGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIDEgLyAoMjAwICogZHVyYXRpb24pO1xuICB9XG59O1xudmFyIFVuaXRCZXppZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHBvaW50MSwgcG9pbnQyKSB7XG4gICAgdGhpcy5jID0gUG9pbnQubXVsdGlwbHkocG9pbnQxLCAzKTtcbiAgICB0aGlzLmIgPSBQb2ludC5zdWJ0cmFjdChQb2ludC5tdWx0aXBseShQb2ludC5zdWJ0cmFjdChwb2ludDIsIHBvaW50MSksIDMpLCB0aGlzLmMpO1xuICAgIHRoaXMuYSA9IFBvaW50LnN1YnRyYWN0KFBvaW50LnN1YnRyYWN0KFBvaW50KDEsIDEpLCB0aGlzLmMpLCB0aGlzLmIpO1xuICB9XG4gIHNvbHZlKHgsIGVwc2lsb24yKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FtcGxlWSh0aGlzLnNvbHZlRm9yVCh4LCBlcHNpbG9uMikpO1xuICB9XG4gIHNhbXBsZVgodCkge1xuICAgIHJldHVybiAoKHRoaXMuYS54ICogdCArIHRoaXMuYi54KSAqIHQgKyB0aGlzLmMueCkgKiB0O1xuICB9XG4gIHNhbXBsZVkodCkge1xuICAgIHJldHVybiAoKHRoaXMuYS55ICogdCArIHRoaXMuYi55KSAqIHQgKyB0aGlzLmMueSkgKiB0O1xuICB9XG4gIHNhbXBsZURlcml2YXRpdmVYKHQpIHtcbiAgICByZXR1cm4gKDMgKiB0aGlzLmEueCAqIHQgKyAyICogdGhpcy5iLngpICogdCArIHRoaXMuYy54O1xuICB9XG4gIHNvbHZlRm9yVCh4LCBlcHNpbG9uMikge1xuICAgIGxldCB0MCwgdDEsIHQyLCB4MiwgZDIsIGk7XG4gICAgdDIgPSB4O1xuICAgIGZvciAoaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICAgIHgyID0gdGhpcy5zYW1wbGVYKHQyKSAtIHg7XG4gICAgICBpZiAoTWF0aC5hYnMoeDIpIDwgZXBzaWxvbjIpXG4gICAgICAgIHJldHVybiB0MjtcbiAgICAgIGQyID0gdGhpcy5zYW1wbGVEZXJpdmF0aXZlWCh0Mik7XG4gICAgICBpZiAoTWF0aC5hYnMoZDIpIDwgZXBzaWxvbjIpXG4gICAgICAgIGJyZWFrO1xuICAgICAgdDIgPSB0MiAtIHgyIC8gZDI7XG4gICAgfVxuICAgIHQwID0gMDtcbiAgICB0MSA9IDE7XG4gICAgdDIgPSB4O1xuICAgIGlmICh0MiA8IHQwKVxuICAgICAgcmV0dXJuIHQwO1xuICAgIGlmICh0MiA+IHQxKVxuICAgICAgcmV0dXJuIHQxO1xuICAgIHdoaWxlICh0MCA8IHQxKSB7XG4gICAgICB4MiA9IHRoaXMuc2FtcGxlWCh0Mik7XG4gICAgICBpZiAoTWF0aC5hYnMoeDIgLSB4KSA8IGVwc2lsb24yKVxuICAgICAgICByZXR1cm4gdDI7XG4gICAgICBpZiAoeCA+IHgyKVxuICAgICAgICB0MCA9IHQyO1xuICAgICAgZWxzZVxuICAgICAgICB0MSA9IHQyO1xuICAgICAgdDIgPSAodDEgLSB0MCkgKiAwLjUgKyB0MDtcbiAgICB9XG4gICAgcmV0dXJuIHQyO1xuICB9XG59O1xuXG4vLyBzcmMvYW5pbWF0aW9uL0ZyYW1lckFuaW1hdGlvbi50c1xudmFyIERlZmF1bHREZXByZWNhdGVkQW5pbWF0aW9uT3B0aW9ucyA9IHtcbiAgcHJlY2FsY3VsYXRlOiBmYWxzZSxcbiAgY29sb3JNb2RlbDogQ29sb3JNaXhNb2RlbFR5cGUuSFVTTFxufTtcbnZhciBGcmFtZXJBbmltYXRpb24gPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHRhcmdldCwgZnJvbSwgdG8sIGFuaW1hdG9yQ2xhc3MsIG9wdGlvbnMsIGRyaXZlckNsYXNzID0gTWFpbkxvb3BBbmltYXRpb25Ecml2ZXIpIHtcbiAgICB0aGlzLnBsYXlTdGF0ZVNvdXJjZSA9IFwiaWRsZVwiO1xuICAgIHRoaXMucmVhZHlQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdGhpcy5yZXNldEZpbmlzaGVkUHJvbWlzZSgpO1xuICAgIGNvbnN0IGRlcHJlY2F0ZWRBbmltYXRpb25PcHRpb25zID0geyAuLi5EZWZhdWx0RGVwcmVjYXRlZEFuaW1hdGlvbk9wdGlvbnMgfTtcbiAgICBjb25zdCBhbmltYXRvck9wdGlvbnMgPSB7fTtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgT2JqZWN0LmFzc2lnbihkZXByZWNhdGVkQW5pbWF0aW9uT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICBPYmplY3QuYXNzaWduKGFuaW1hdG9yT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGxldCBpbnRlcnBvbGF0aW9uO1xuICAgIGlmIChkZXByZWNhdGVkQW5pbWF0aW9uT3B0aW9ucy5jdXN0b21JbnRlcnBvbGF0aW9uKSB7XG4gICAgICBpbnRlcnBvbGF0aW9uID0gZGVwcmVjYXRlZEFuaW1hdGlvbk9wdGlvbnMuY3VzdG9tSW50ZXJwb2xhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJwb2xhdGlvbiA9IG5ldyBWYWx1ZUludGVycG9sYXRpb24ob3B0aW9ucyk7XG4gICAgfVxuICAgIGxldCBhbmltYXRvcjtcbiAgICBpZiAoIWFuaW1hdG9yQ2xhc3MpIHtcbiAgICAgIGFuaW1hdG9yID0gbmV3IEJlemllckFuaW1hdG9yKHt9LCBpbnRlcnBvbGF0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5pbWF0b3IgPSBuZXcgYW5pbWF0b3JDbGFzcyhhbmltYXRvck9wdGlvbnMsIGludGVycG9sYXRpb24pO1xuICAgIH1cbiAgICBpZiAoZGVwcmVjYXRlZEFuaW1hdGlvbk9wdGlvbnMucHJlY2FsY3VsYXRlKSB7XG4gICAgICBhbmltYXRvciA9IG5ldyBQcmVjYWxjdWxhdGVkQW5pbWF0b3IoeyBhbmltYXRvciB9KTtcbiAgICB9XG4gICAgYW5pbWF0b3Iuc2V0RnJvbShmcm9tKTtcbiAgICBhbmltYXRvci5zZXRUbyh0byk7XG4gICAgY29uc3QgdXBkYXRlQ2FsbGJhY2sgPSAodmFsdWUpID0+IHtcbiAgICAgIEZyYW1lckFuaW1hdGlvbi5kcml2ZXJDYWxsYmFja0hhbmRsZXIodGFyZ2V0LCB2YWx1ZSk7XG4gICAgfTtcbiAgICBjb25zdCBmaW5pc2hlZENhbGxiYWNrID0gKGlzRmluaXNoZWQpID0+IHtcbiAgICAgIGlmIChpc0ZpbmlzaGVkKSB7XG4gICAgICAgIEZyYW1lckFuaW1hdGlvbi5kcml2ZXJDYWxsYmFja0hhbmRsZXIodGFyZ2V0LCB0byk7XG4gICAgICAgIGlmICh0aGlzLnBsYXlTdGF0ZVNvdXJjZSA9PT0gXCJydW5uaW5nXCIpIHtcbiAgICAgICAgICB0aGlzLnBsYXlTdGF0ZVZhbHVlID0gXCJmaW5pc2hlZFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmRyaXZlciA9IG5ldyBkcml2ZXJDbGFzcyhhbmltYXRvciwgdXBkYXRlQ2FsbGJhY2ssIGZpbmlzaGVkQ2FsbGJhY2spO1xuICB9XG4gIHN0YXRpYyBkcml2ZXJDYWxsYmFja0hhbmRsZXIodGFyZ2V0LCB2YWx1ZSkge1xuICAgIGlmIChpc0FuaW1hdGFibGUyKHRhcmdldCkgfHwgaXNNb3Rpb25WYWx1ZTIodGFyZ2V0KSkge1xuICAgICAgdGFyZ2V0LnNldCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRhcmdldE9iamVjdCA9IHRhcmdldDtcbiAgICAgIEFuaW1hdGFibGUudHJhbnNhY3Rpb24oKHVwZGF0ZSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGtleTYgaW4gdGFyZ2V0T2JqZWN0KSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0VmFsdWUgPSB0YXJnZXRPYmplY3Rba2V5Nl07XG4gICAgICAgICAgaWYgKGlzQW5pbWF0YWJsZTIodGFyZ2V0VmFsdWUpKSB7XG4gICAgICAgICAgICB1cGRhdGUodGFyZ2V0VmFsdWUsIHZhbHVlW2tleTZdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0T2JqZWN0W2tleTZdID0gdmFsdWVba2V5Nl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0IHBsYXlTdGF0ZVZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXlTdGF0ZVNvdXJjZTtcbiAgfVxuICBzZXQgcGxheVN0YXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMucGxheVN0YXRlU291cmNlKSB7XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5wbGF5U3RhdGVTb3VyY2UgPSB2YWx1ZTtcbiAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgY2FzZSBcImlkbGVcIjpcbiAgICAgICAgICBpZiAob2xkVmFsdWUgPT09IFwicnVubmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLm9uY2FuY2VsICYmIHRoaXMub25jYW5jZWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5yZWFkeVJlc29sdmUgJiYgdGhpcy5yZWFkeVJlc29sdmUoKTtcbiAgICAgICAgICB0aGlzLnJlc2V0UmVhZHlQcm9taXNlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmaW5pc2hlZFwiOlxuICAgICAgICAgIGlmIChvbGRWYWx1ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkJhZCBzdGF0ZSB0cmFuc2l0aW9uXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub25maW5pc2ggJiYgdGhpcy5vbmZpbmlzaCgpO1xuICAgICAgICAgIHRoaXMuZmluaXNoZWRSZXNvbHZlICYmIHRoaXMuZmluaXNoZWRSZXNvbHZlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJydW5uaW5nXCI6XG4gICAgICAgICAgdGhpcy5yZXNldFJlYWR5UHJvbWlzZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG9sZFZhbHVlID09PSBcImZpbmlzaGVkXCIpIHtcbiAgICAgICAgdGhpcy5yZXNldEZpbmlzaGVkUHJvbWlzZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSBcImZpbmlzaGVkXCIpIHtcbiAgICAgICAgdGhpcy5wbGF5U3RhdGVWYWx1ZSA9IFwiaWRsZVwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgcGxheVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXlTdGF0ZVZhbHVlO1xuICB9XG4gIHJlc2V0UmVhZHlQcm9taXNlKCkge1xuICAgIHRoaXMucmVhZHlSZXNvbHZlID0gbnVsbDtcbiAgICB0aGlzLnJlYWR5UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVhZHlSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgfVxuICBnZXQgcmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZHlQcm9taXNlO1xuICB9XG4gIHJlc2V0RmluaXNoZWRQcm9taXNlKCkge1xuICAgIHRoaXMuZmluaXNoZWRSZXNvbHZlID0gbnVsbDtcbiAgICB0aGlzLmZpbmlzaGVkUmVqZWN0ID0gbnVsbDtcbiAgICB0aGlzLmZpbmlzaGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuZmluaXNoZWRSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMuZmluaXNoZWRSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgdGhpcy5maW5pc2hlZFByb21pc2UuY2F0Y2goKHJlYXNvbikgPT4ge1xuICAgIH0pO1xuICB9XG4gIGdldCBmaW5pc2hlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hlZFByb21pc2U7XG4gIH1cbiAgcGxheSgpIHtcbiAgICB0aGlzLnBsYXlTdGF0ZVZhbHVlID0gXCJydW5uaW5nXCI7XG4gICAgdGhpcy5kcml2ZXIucGxheSgpO1xuICB9XG4gIGNhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5wbGF5U3RhdGVWYWx1ZSAhPT0gXCJydW5uaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kcml2ZXIuY2FuY2VsKCk7XG4gICAgaWYgKHRoaXMucGxheVN0YXRlICE9PSBcImlkbGVcIikge1xuICAgICAgY29uc3QgcmVhc29uID0gXCJBYm9ydEVycm9yXCI7XG4gICAgICB0aGlzLmZpbmlzaGVkUmVqZWN0ICYmIHRoaXMuZmluaXNoZWRSZWplY3QocmVhc29uKTtcbiAgICB9XG4gICAgdGhpcy5wbGF5U3RhdGVWYWx1ZSA9IFwiaWRsZVwiO1xuICB9XG4gIGZpbmlzaCgpIHtcbiAgICBpZiAodGhpcy5wbGF5U3RhdGVTb3VyY2UgPT09IFwicnVubmluZ1wiKSB7XG4gICAgICB0aGlzLnBsYXlTdGF0ZVZhbHVlID0gXCJmaW5pc2hlZFwiO1xuICAgICAgdGhpcy5kcml2ZXIuZmluaXNoKCk7XG4gICAgfVxuICB9XG4gIGlzRmluaXNoZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheVN0YXRlVmFsdWUgPT09IFwiZmluaXNoZWRcIjtcbiAgfVxufTtcblxuLy8gc3JjL2FuaW1hdGlvbi9hbmltYXRlLnRzXG5mdW5jdGlvbiBkZXByZWNhdGVkQW5pbWF0ZShmcm9tLCB0bywgYW5pbWF0b3IsIG9wdGlvbnMpIHtcbiAgZGVwcmVjYXRpb25XYXJuaW5nKFwiYW5pbWF0ZSgpXCIsIFwiMi4wLjBcIiwgXCJ0aGUgbmV3IGFuaW1hdGlvbiBBUEkgKGh0dHBzOi8vd3d3LmZyYW1lci5jb20vYXBpL2FuaW1hdGlvbi8pXCIpO1xuICBjb25zdCB0YXJnZXQgPSBmcm9tO1xuICBsZXQgZnJvbVZhbHVlO1xuICBpZiAoaXNBbmltYXRhYmxlMihmcm9tKSB8fCBpc01vdGlvblZhbHVlMihmcm9tKSkge1xuICAgIGZyb21WYWx1ZSA9IGZyb20uZ2V0KCk7XG4gIH0gZWxzZSB7XG4gICAgZnJvbVZhbHVlID0gQW5pbWF0YWJsZS5vYmplY3RUb1ZhbHVlcyhmcm9tKTtcbiAgfVxuICBjb25zdCBhbmltYXRpb24gPSBuZXcgRnJhbWVyQW5pbWF0aW9uKHRhcmdldCwgZnJvbVZhbHVlLCB0bywgYW5pbWF0b3IsIG9wdGlvbnMpO1xuICBhbmltYXRpb24ucGxheSgpO1xuICByZXR1cm4gYW5pbWF0aW9uO1xufVxuZnVuY3Rpb24gYW5pbWF0ZTMoZnJvbSwgdG8sIGFuaW1hdG9yT3JUcmFuc2l0aW9uLCBvcHRpb25zKSB7XG4gIHJldHVybiBpc0FuaW1hdGFibGUyKGZyb20pID8gZGVwcmVjYXRlZEFuaW1hdGUoZnJvbSwgdG8sIGFuaW1hdG9yT3JUcmFuc2l0aW9uLCBvcHRpb25zKSA6IGFuaW1hdGUyKGZyb20sIHRvLCBhbmltYXRvck9yVHJhbnNpdGlvbik7XG59XG4oZnVuY3Rpb24oYW5pbWF0ZTQpIHtcbiAgZnVuY3Rpb24gc3ByaW5nMihmcm9tLCB0bywgb3B0aW9ucykge1xuICAgIHJldHVybiBhbmltYXRlNChmcm9tLCB0bywgU3ByaW5nQW5pbWF0b3IsIG9wdGlvbnMpO1xuICB9XG4gIGFuaW1hdGU0LnNwcmluZyA9IHNwcmluZzI7XG4gIGZ1bmN0aW9uIGJlemllcihmcm9tLCB0bywgb3B0aW9ucykge1xuICAgIHJldHVybiBhbmltYXRlNChmcm9tLCB0bywgQmV6aWVyQW5pbWF0b3IsIG9wdGlvbnMpO1xuICB9XG4gIGFuaW1hdGU0LmJlemllciA9IGJlemllcjtcbiAgZnVuY3Rpb24gbGluZWFyMihmcm9tLCB0bywgb3B0aW9ucykge1xuICAgIHJldHVybiBhbmltYXRlNC5iZXppZXIoZnJvbSwgdG8sIHsgLi4ub3B0aW9ucywgY3VydmU6IEJlemllci5MaW5lYXIgfSk7XG4gIH1cbiAgYW5pbWF0ZTQubGluZWFyID0gbGluZWFyMjtcbiAgZnVuY3Rpb24gZWFzZShmcm9tLCB0bywgb3B0aW9ucykge1xuICAgIHJldHVybiBhbmltYXRlNC5iZXppZXIoZnJvbSwgdG8sIHsgLi4ub3B0aW9ucywgY3VydmU6IEJlemllci5FYXNlIH0pO1xuICB9XG4gIGFuaW1hdGU0LmVhc2UgPSBlYXNlO1xuICBmdW5jdGlvbiBlYXNlSW4yKGZyb20sIHRvLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGFuaW1hdGU0LmJlemllcihmcm9tLCB0bywgeyAuLi5vcHRpb25zLCBjdXJ2ZTogQmV6aWVyLkVhc2VJbiB9KTtcbiAgfVxuICBhbmltYXRlNC5lYXNlSW4gPSBlYXNlSW4yO1xuICBmdW5jdGlvbiBlYXNlT3V0Mihmcm9tLCB0bywgb3B0aW9ucykge1xuICAgIHJldHVybiBhbmltYXRlNC5iZXppZXIoZnJvbSwgdG8sIHsgLi4ub3B0aW9ucywgY3VydmU6IEJlemllci5FYXNlT3V0IH0pO1xuICB9XG4gIGFuaW1hdGU0LmVhc2VPdXQgPSBlYXNlT3V0MjtcbiAgZnVuY3Rpb24gZWFzZUluT3V0Mihmcm9tLCB0bywgb3B0aW9ucykge1xuICAgIHJldHVybiBhbmltYXRlNC5iZXppZXIoZnJvbSwgdG8sIHsgLi4ub3B0aW9ucywgY3VydmU6IEJlemllci5FYXNlSW5PdXQgfSk7XG4gIH1cbiAgYW5pbWF0ZTQuZWFzZUluT3V0ID0gZWFzZUluT3V0Mjtcbn0pKGFuaW1hdGUzIHx8IChhbmltYXRlMyA9IHt9KSk7XG5cbi8vIHNyYy9yZW5kZXIvdXRpbHMvZ2V0Q29uZmlnRnJvbVVSTC50c1xuZnVuY3Rpb24gZ2V0Q29uZmlnRnJvbVByZXZpZXdVUkwod2luZG93VVJMU3RyaW5nID0gc2FmZVdpbmRvdy5sb2NhdGlvbi5ocmVmKSB7XG4gIGlmICghd2luZG93VVJMU3RyaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBnZXRDb25maWdGcm9tVVJMKCkgY2FsbGVkIHdpdGhvdXQgdXJsIGFyZ3VtZW50IChsb2NhdGlvbi5ocmVmID0gXCIke3NhZmVXaW5kb3cubG9jYXRpb24uaHJlZn1cIilgKTtcbiAgfVxuICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMKHdpbmRvd1VSTFN0cmluZykuc2VhcmNoUGFyYW1zO1xuICBjb25zdCBpbWFnZUJhc2VVUkwgPSBwYXJhbXMuZ2V0KFwiaW1hZ2VCYXNlVVJMXCIpIHx8IFwiXCI7XG4gIGNvbnN0IHByb2plY3RVUkwgPSBwYXJhbXMuZ2V0KFwicHJvamVjdFVSTFwiKSB8fCBcIlwiO1xuICBjb25zdCBzaG93Q29uc29sZSA9IHBhcmFtcy5nZXQoXCJjb25zb2xlXCIpID09PSBcIjFcIjtcbiAgY29uc3QgZGlzYWJsZURldmljZSA9IHBhcmFtcy5nZXQoXCJkZXZpY2VcIikgPT09IFwiMFwiO1xuICByZXR1cm4geyBpbWFnZUJhc2VVUkwsIHByb2plY3RVUkwsIHNob3dDb25zb2xlLCBkaXNhYmxlRGV2aWNlIH07XG59XG5mdW5jdGlvbiBnZXRDb25maWdGcm9tVmVrdGVyVVJMKHdpbmRvd1VSTFN0cmluZyA9IHNhZmVXaW5kb3cubG9jYXRpb24uaHJlZikge1xuICBpZiAoIXdpbmRvd1VSTFN0cmluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihgZ2V0Q29uZmlnRnJvbVVSTCgpIGNhbGxlZCB3aXRob3V0IHVybCBhcmd1bWVudCAobG9jYXRpb24uaHJlZiA9IFwiJHtzYWZlV2luZG93LmxvY2F0aW9uLmhyZWZ9XCIpYCk7XG4gIH1cbiAgY29uc3QgaGFzaDIgPSBkZWNvZGVVUklDb21wb25lbnQobmV3IFVSTCh3aW5kb3dVUkxTdHJpbmcpLmhhc2guc2xpY2UoMSkpO1xuICBjb25zdCBbZG9jdW1lbnRVUkwsIGltYWdlQmFzZVVSTCwgcHJvamVjdFVSTF0gPSBoYXNoMi5zcGxpdChcIiMmI1wiKTtcbiAgcmV0dXJuIHsgZG9jdW1lbnRVUkwsIGltYWdlQmFzZVVSTCwgcHJvamVjdFVSTCB9O1xufVxuXG4vLyBzcmMvcmVuZGVyL2Fzc2V0UmVzb2x2ZXIvc2VydmVyVVJMLnRzXG5mdW5jdGlvbiBwYXJzZVVSTCh1cmwsIGJhc2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdHlwZW9mIGJhc2UgPT09IFwidW5kZWZpbmVkXCIgPyBuZXcgVVJMKHVybCkgOiBuZXcgVVJMKHVybCwgYmFzZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG52YXIgZmxhdHRlbiA9IChhcnJheXMpID0+IFtdLmNvbmNhdC5hcHBseShbXSwgYXJyYXlzKTtcbmZ1bmN0aW9uIGpvaW5QYXRocyhwYXRocykge1xuICBsZXQgcmVzID0gXCJcIjtcbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgaWYgKCFwYXRoKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKHJlcy5sZW5ndGggPiAwICYmICFyZXMuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICByZXMgKz0gXCIvXCI7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICByZXMgKz0gam9pblBhdGhzKHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHBhdGgpLnJlcGxhY2UoLyUyRi9nLCBcIi9cIik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBzZXJ2ZXJVUkwoLi4ucGF0aHMpIHtcbiAgY29uc3Qgbm90RW1wdHlQYXRocyA9IGZsYXR0ZW4ocGF0aHMpLmZpbHRlcihCb29sZWFuKTtcbiAgaWYgKG5vdEVtcHR5UGF0aHMubGVuZ3RoID09PSAxICYmIHBhcnNlVVJMKG5vdEVtcHR5UGF0aHNbMF0pKSB7XG4gICAgcmV0dXJuIG5vdEVtcHR5UGF0aHNbMF07XG4gIH1cbiAgY29uc3QgcGF0aCA9IGpvaW5QYXRocyhwYXRocyk7XG4gIGNvbnN0IHJlc29sdmVkQXNzZXQgPSBydW50aW1lLmFzc2V0UmVzb2x2ZXIocGF0aCwge1xuICAgIGlzRnJhbWVyUmVzb3VyY2VVUkw6IHRydWUsXG4gICAgaXNFeHBvcnQ6IFJlbmRlclRhcmdldC5jdXJyZW50KCkgPT09IFJlbmRlclRhcmdldC5leHBvcnRcbiAgfSk7XG4gIHJldHVybiByZXNvbHZlZEFzc2V0IHx8IFwiXCI7XG59XG5cbi8vIHNyYy91dGlscy9pbnRlcm5hbElkLnRzXG52YXIga2V5cyA9IG5ldyBNYXAoKTtcbnZhciBJbnRlcm5hbElEID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihpZCkge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLl9saW5rID0gbnVsbDtcbiAgICB0aGlzLl91cmxsaW5rID0gbnVsbDtcbiAgfVxuICBhZGQoc3RyKSB7XG4gICAgcmV0dXJuIEludGVybmFsSUQuZm9yS2V5KHRoaXMuaWQgKyBzdHIpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmlkO1xuICB9XG4gIGdldCBsaW5rKCkge1xuICAgIGNvbnN0IHJlcyA9IHRoaXMuX2xpbms7XG4gICAgaWYgKHJlcylcbiAgICAgIHJldHVybiByZXM7XG4gICAgcmV0dXJuIHRoaXMuX2xpbmsgPSBcIiNcIiArIHRoaXMuaWQ7XG4gIH1cbiAgZ2V0IHVybExpbmsoKSB7XG4gICAgY29uc3QgcmVzID0gdGhpcy5fdXJsbGluaztcbiAgICBpZiAocmVzKVxuICAgICAgcmV0dXJuIHJlcztcbiAgICByZXR1cm4gdGhpcy5fdXJsbGluayA9IFwidXJsKCNcIiArIHRoaXMuaWQgKyBcIilcIjtcbiAgfVxuICBzdGF0aWMgZm9yS2V5KGtleTYpIHtcbiAgICBsZXQgcmVzID0ga2V5cy5nZXQoa2V5Nik7XG4gICAgaWYgKHJlcylcbiAgICAgIHJldHVybiByZXM7XG4gICAgcmVzID0gbmV3IEludGVybmFsSUQoXCJhXCIgKyAoMWUzICsga2V5cy5zaXplKSArIFwielwiKTtcbiAgICBrZXlzLnNldChrZXk2LCByZXMpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbn07XG5cbi8vIHNyYy9yZW5kZXIvdXRpbHMvZWxlbWVudFByb3BlcnRpZXNGb3JHcmFkaWVudC50c1xuZnVuY3Rpb24gZWxlbWVudFByb3BlcnRpZXNGb3JMaW5lYXJHcmFkaWVudChncmFkaWVudCwgaWQpIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogYGlkJHtpZH1nJHtMaW5lYXJHcmFkaWVudC5oYXNoKGdyYWRpZW50KX1gLFxuICAgIGFuZ2xlOiBncmFkaWVudC5hbmdsZSAtIDkwLFxuICAgIHN0b3BzOiBncmFkaWVudENvbG9yU3RvcHMoZ3JhZGllbnQpLm1hcCgoc3RvcCkgPT4gKHtcbiAgICAgIGNvbG9yOiBzdG9wLnZhbHVlLFxuICAgICAgYWxwaGE6IENvbnZlcnRDb2xvci5nZXRBbHBoYShzdG9wLnZhbHVlKSAqIGdyYWRpZW50LmFscGhhLFxuICAgICAgcG9zaXRpb246IHN0b3AucG9zaXRpb25cbiAgICB9KSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRQcm9wZXJ0aWVzRm9yUmFkaWFsR3JhZGllbnQoZ3JhZGllbnQsIGlkKSB7XG4gIHJldHVybiB7XG4gICAgaWQ6IGBpZCR7aWR9ZyR7UmFkaWFsR3JhZGllbnQuaGFzaChncmFkaWVudCl9YCxcbiAgICB3aWR0aEZhY3RvcjogZ3JhZGllbnQud2lkdGhGYWN0b3IsXG4gICAgaGVpZ2h0RmFjdG9yOiBncmFkaWVudC5oZWlnaHRGYWN0b3IsXG4gICAgY2VudGVyQW5jaG9yWDogZ3JhZGllbnQuY2VudGVyQW5jaG9yWCxcbiAgICBjZW50ZXJBbmNob3JZOiBncmFkaWVudC5jZW50ZXJBbmNob3JZLFxuICAgIHN0b3BzOiBncmFkaWVudENvbG9yU3RvcHMoZ3JhZGllbnQpLm1hcCgoc3RvcCkgPT4gKHtcbiAgICAgIGNvbG9yOiBzdG9wLnZhbHVlLFxuICAgICAgYWxwaGE6IENvbnZlcnRDb2xvci5nZXRBbHBoYShzdG9wLnZhbHVlKSAqIGdyYWRpZW50LmFscGhhLFxuICAgICAgcG9zaXRpb246IHN0b3AucG9zaXRpb25cbiAgICB9KSlcbiAgfTtcbn1cblxuLy8gc3JjL3JlbmRlci91dGlscy9kb20udHNcbnZhciBmcmFtZUZyb21FbGVtZW50ID0gKGVsZW1lbnQpID0+IHtcbiAgY29uc3QgZnJhbWUyID0gUmVjdC5mcm9tUmVjdChlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgZnJhbWUyLnggPSBmcmFtZTIueCArIHNhZmVXaW5kb3cuc2Nyb2xsWDtcbiAgZnJhbWUyLnkgPSBmcmFtZTIueSArIHNhZmVXaW5kb3cuc2Nyb2xsWTtcbiAgcmV0dXJuIGZyYW1lMjtcbn07XG52YXIgZnJhbWVGcm9tRWxlbWVudHMgPSAoZWxlbWVudHMpID0+IHtcbiAgcmV0dXJuIFJlY3QubWVyZ2UoLi4uZWxlbWVudHMubWFwKGZyYW1lRnJvbUVsZW1lbnQpKTtcbn07XG52YXIgY29udmVydFRvUGFnZUZyYW1lID0gKGZyYW1lMiwgZWxlbWVudCkgPT4ge1xuICBjb25zdCBwb2ludCA9IGNvbnZlcnRUb1BhZ2VQb2ludChmcmFtZTIsIGVsZW1lbnQpO1xuICByZXR1cm4ge1xuICAgIHg6IHBvaW50LngsXG4gICAgeTogcG9pbnQueSxcbiAgICB3aWR0aDogZnJhbWUyLndpZHRoLFxuICAgIGhlaWdodDogZnJhbWUyLmhlaWdodFxuICB9O1xufTtcbnZhciBjb252ZXJ0RnJvbVBhZ2VGcmFtZSA9IChmcmFtZTIsIGVsZW1lbnQpID0+IHtcbiAgY29uc3QgcG9pbnQgPSBjb252ZXJ0RnJvbVBhZ2VQb2ludChmcmFtZTIsIGVsZW1lbnQpO1xuICByZXR1cm4ge1xuICAgIHg6IHBvaW50LngsXG4gICAgeTogcG9pbnQueSxcbiAgICB3aWR0aDogZnJhbWUyLndpZHRoLFxuICAgIGhlaWdodDogZnJhbWUyLmhlaWdodFxuICB9O1xufTtcbnZhciBnZXRQYWdlRnJhbWUgPSAoZWxlbWVudCkgPT4ge1xuICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LmxlZnQgKyBzYWZlV2luZG93LnNjcm9sbFgsXG4gICAgeTogcmVjdC50b3AgKyBzYWZlV2luZG93LnNjcm9sbFksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufTtcbnZhciBmcm9tRXZlbnRGb3JQYWdlID0gKGV2ZW50KSA9PiB7XG4gIHJldHVybiB7XG4gICAgeDogZXZlbnQucGFnZVgsXG4gICAgeTogZXZlbnQucGFnZVlcbiAgfTtcbn07XG52YXIgZnJvbUV2ZW50Rm9yQ2xpZW50ID0gKGV2ZW50KSA9PiB7XG4gIHJldHVybiB7XG4gICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICB5OiBldmVudC5jbGllbnRZXG4gIH07XG59O1xudmFyIGNvbnZlcnRUb1BhZ2VQb2ludCA9IChwb2ludCwgZWxlbWVudCkgPT4ge1xuICBjb25zdCBmcmFtZTIgPSBnZXRQYWdlRnJhbWUoZWxlbWVudCk7XG4gIHJldHVybiB7XG4gICAgeDogcG9pbnQueCArIGZyYW1lMi54LFxuICAgIHk6IHBvaW50LnkgKyBmcmFtZTIueVxuICB9O1xufTtcbnZhciBjb252ZXJ0RnJvbVBhZ2VQb2ludCA9IChwb2ludCwgZWxlbWVudCkgPT4ge1xuICBjb25zdCBmcmFtZTIgPSBnZXRQYWdlRnJhbWUoZWxlbWVudCk7XG4gIHJldHVybiB7XG4gICAgeDogcG9pbnQueCAtIGZyYW1lMi54LFxuICAgIHk6IHBvaW50LnkgLSBmcmFtZTIueVxuICB9O1xufTtcbnZhciBkaXNwYXRjaEtleURvd25FdmVudCA9IChrZXlDb2RlLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3Qga2V5Ym9hcmRFdmVudCA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5ZG93blwiLCB7XG4gICAgYnViYmxlczogdHJ1ZSxcbiAgICBrZXlDb2RlLFxuICAgIC4uLm9wdGlvbnNcbiAgfSk7XG4gIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICBpZiAoYWN0aXZlRWxlbWVudCkge1xuICAgIGFjdGl2ZUVsZW1lbnQuZGlzcGF0Y2hFdmVudChrZXlib2FyZEV2ZW50KTtcbiAgfVxufTtcbnZhciBET00gPSB7XG4gIGZyYW1lRnJvbUVsZW1lbnQsXG4gIGZyYW1lRnJvbUVsZW1lbnRzLFxuICBjb252ZXJ0VG9QYWdlRnJhbWUsXG4gIGNvbnZlcnRGcm9tUGFnZUZyYW1lLFxuICBnZXRQYWdlRnJhbWUsXG4gIGZyb21FdmVudEZvclBhZ2UsXG4gIGZyb21FdmVudEZvckNsaWVudCxcbiAgY29udmVydFRvUGFnZVBvaW50LFxuICBjb252ZXJ0RnJvbVBhZ2VQb2ludFxufTtcblxuLy8gc3JjL3JlbmRlci90cmFpdHMvU2hhcGUudHNcbnZhciBrZXk0ID0gXCJjYWxjdWxhdGVkUGF0aHNcIjtcbmZ1bmN0aW9uIHdpdGhTaGFwZSh0YXJnZXQpIHtcbiAgcmV0dXJuIGtleTQgaW4gdGFyZ2V0O1xufVxuXG4vLyBzcmMvcmVuZGVyL3V0aWxzL2dyYWRpZW50Rm9yU2hhcGUudHN4XG5mdW5jdGlvbiBncmFkaWVudEZvclNoYXBlKG5vZGVJZCwgbm9kZSkge1xuICBpZiAoTGluZWFyR3JhZGllbnQuaXNMaW5lYXJHcmFkaWVudChub2RlLmZpbGwpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRQcm9wZXJ0aWVzRm9yTGluZWFyR3JhZGllbnQobm9kZS5maWxsLCBub2RlSWQpO1xuICB9XG4gIGlmIChSYWRpYWxHcmFkaWVudC5pc1JhZGlhbEdyYWRpZW50KG5vZGUuZmlsbCkpIHtcbiAgICByZXR1cm4gZWxlbWVudFByb3BlcnRpZXNGb3JSYWRpYWxHcmFkaWVudChub2RlLmZpbGwsIG5vZGVJZCk7XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gc3JjL3JlbmRlci91dGlscy90aHJvdHRsZS50c1xuZnVuY3Rpb24gdGhyb3R0bGUoZm4sIHRpbWUzKSB7XG4gIGxldCBwcmV2aW91cyA9IDA7XG4gIGxldCB0aW1lb3V0O1xuICBjb25zdCBsYXRlciA9ICguLi5hcmdzKSA9PiB7XG4gICAgcHJldmlvdXMgPSBEYXRlLm5vdygpO1xuICAgIHRpbWVvdXQgPSB2b2lkIDA7XG4gICAgZm4oLi4uYXJncyk7XG4gIH07XG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgcmVtYWluaW5nID0gdGltZTMgLSAobm93IC0gcHJldmlvdXMpO1xuICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB0aW1lMykge1xuICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgc2FmZVdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgIGZuKC4uLmFyZ3MpO1xuICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQpIHtcbiAgICAgIHRpbWVvdXQgPSBzYWZlV2luZG93LnNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZywgLi4uYXJncyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyAuLi9hcHAvYXNzZXRzL3NyYy9hc3NldFJlZmVyZW5jZS50c1xudmFyIG1lZGlhVHlwZSA9IFwiZnJhbWVyL2Fzc2V0LXJlZmVyZW5jZSxcIjtcbmZ1bmN0aW9uIGlzQXNzZXRSZWZlcmVuY2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnN0YXJ0c1dpdGgoYGRhdGE6JHttZWRpYVR5cGV9YCk7XG59XG5cbi8vIHNyYy9yZW5kZXIvdXRpbHMvaW1hZ2VVcmxGb3JBc3NldC50c1xuZnVuY3Rpb24gaW1hZ2VVcmxGb3JBc3NldChhc3NldCwgc2l6ZTIpIHtcbiAgdmFyIF9hO1xuICBpZiAoL15cXHcrOi8udGVzdChhc3NldCkgJiYgIWlzQXNzZXRSZWZlcmVuY2UoYXNzZXQpKVxuICAgIHJldHVybiBhc3NldDtcbiAgaWYgKHR5cGVvZiBzaXplMiAhPT0gXCJudW1iZXJcIilcbiAgICBzaXplMiA9IHZvaWQgMDtcbiAgZWxzZSBpZiAoc2l6ZTIgPD0gNTEyKVxuICAgIHNpemUyID0gNTEyO1xuICBlbHNlIGlmIChzaXplMiA8PSAxMDI0KVxuICAgIHNpemUyID0gMTAyNDtcbiAgZWxzZSBpZiAoc2l6ZTIgPD0gMjA0OClcbiAgICBzaXplMiA9IDIwNDg7XG4gIGVsc2VcbiAgICBzaXplMiA9IDQwOTY7XG4gIGNvbnN0IGlzRXhwb3J0ID0gUmVuZGVyVGFyZ2V0LmN1cnJlbnQoKSA9PT0gUmVuZGVyVGFyZ2V0LmV4cG9ydDtcbiAgcmV0dXJuIChfYSA9IHJ1bnRpbWUuYXNzZXRSZXNvbHZlcihhc3NldCwgeyBzaXplOiBzaXplMiwgaXNFeHBvcnQgfSkpICE9IG51bGwgPyBfYSA6IFwiXCI7XG59XG5cbi8vIHNyYy9yZW5kZXIvdXRpbHMvaW1hZ2VQYXR0ZXJuUHJvcHNGb3JGaWxsLnRzeFxuZnVuY3Rpb24gaW1hZ2VQYXR0ZXJuUHJvcHNGb3JGaWxsKGZpbGwsIGZyYW1lMiwgaWQpIHtcbiAgZmlsbCA9IEFuaW1hdGFibGUuZ2V0KGZpbGwsIFwiIzA5RlwiKTtcbiAgaWYgKCFCYWNrZ3JvdW5kSW1hZ2UuaXNJbWFnZU9iamVjdChmaWxsKSlcbiAgICByZXR1cm4gdm9pZCAwO1xuICBpZiAoIWZpbGwucGl4ZWxXaWR0aCB8fCAhZmlsbC5waXhlbEhlaWdodClcbiAgICByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBpbWFnZVdpZHRoID0gZmlsbC5waXhlbFdpZHRoO1xuICBjb25zdCBpbWFnZUhlaWdodCA9IGZpbGwucGl4ZWxIZWlnaHQ7XG4gIGxldCB0cmFuc2Zvcm0yO1xuICBjb25zdCB7IGZpdCB9ID0gZmlsbDtcbiAgaWYgKGZpdCA9PT0gXCJmaWxsXCIgfHwgZml0ID09PSBcImZpdFwiIHx8ICFmaXQpIHtcbiAgICBsZXQgc2NhbGVYID0gMTtcbiAgICBsZXQgc2NhbGVZID0gMTtcbiAgICBsZXQgb2Zmc2V0WCA9IDA7XG4gICAgbGV0IG9mZnNldFkgPSAwO1xuICAgIGNvbnN0IGltYWdlUmF0aW8gPSBpbWFnZVdpZHRoIC8gaW1hZ2VIZWlnaHQ7XG4gICAgY29uc3QgcmVhbFdpZHRoID0gZnJhbWUyLmhlaWdodCAqIGltYWdlUmF0aW87XG4gICAgY29uc3QgcmVhbEhlaWdodCA9IGZyYW1lMi53aWR0aCAvIGltYWdlUmF0aW87XG4gICAgY29uc3QgdmFsaWRTY2FsZVggPSByZWFsV2lkdGggLyBmcmFtZTIud2lkdGg7XG4gICAgY29uc3QgdmFsaWRTY2FsZVkgPSByZWFsSGVpZ2h0IC8gZnJhbWUyLmhlaWdodDtcbiAgICBpZiAoZml0ID09PSBcImZpbGxcIiB8fCAhZml0ID8gdmFsaWRTY2FsZVkgPiB2YWxpZFNjYWxlWCA6IHZhbGlkU2NhbGVZIDwgdmFsaWRTY2FsZVgpIHtcbiAgICAgIHNjYWxlWSA9IHZhbGlkU2NhbGVZO1xuICAgICAgb2Zmc2V0WSA9ICgxIC0gdmFsaWRTY2FsZVkpIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGVYID0gdmFsaWRTY2FsZVg7XG4gICAgICBvZmZzZXRYID0gKDEgLSB2YWxpZFNjYWxlWCkgLyAyO1xuICAgIH1cbiAgICB0cmFuc2Zvcm0yID0gYHRyYW5zbGF0ZSgke29mZnNldFh9LCAke29mZnNldFl9KSBzY2FsZSgke3NjYWxlWH0sICR7c2NhbGVZfSlgO1xuICB9XG4gIGNvbnN0IGltYWdlSWQgPSBgaWQke2lkfWcke1wiLWZpbGxJbWFnZVwifWA7XG4gIHJldHVybiB7IGlkOiBpbWFnZUlkLCBwYXRoOiBmaWxsLnNyYywgdHJhbnNmb3JtOiB0cmFuc2Zvcm0yIH07XG59XG5cbi8vIHNyYy9yZW5kZXIvY29tcG9uZW50TG9hZGVyL2RlZmluaXRpb24udHNcbmZ1bmN0aW9uIGlzRGVzaWduRGVmaW5pdGlvbihkKSB7XG4gIHJldHVybiBkLnR5cGUgPT09IFwibWFzdGVyXCI7XG59XG5mdW5jdGlvbiBpc092ZXJyaWRlKGQpIHtcbiAgcmV0dXJuIGQudHlwZSA9PT0gXCJvdmVycmlkZVwiO1xufVxuZnVuY3Rpb24gaXNSZWFjdERlZmluaXRpb24oZCkge1xuICByZXR1cm4gZC50eXBlICE9PSBcIm1hc3RlclwiO1xufVxuXG4vLyBzcmMvcmVuZGVyL2NvbXBvbmVudExvYWRlci9wYWNrYWdlLnRzXG52YXIgbG9jYWxQYWNrYWdlRmFsbGJhY2tJZGVudGlmaWVyID0gXCJ8bG9jYWx8XCI7XG5cbi8vIHNyYy9yZW5kZXIvdXRpbHMvYW5ub3RhdGVUeXBlT25TdHJpbmdpZnkudHNcbmZ1bmN0aW9uIGFubm90YXRlVHlwZU9uU3RyaW5naWZ5KGN0b3IsIHR5cGVOYW1lKSB7XG4gIGNvbnN0IGV4aXN0aW5nVG9KU09OID0gY3Rvci5wcm90b3R5cGUudG9KU09OO1xuICBjdG9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBiYXNlID0gZXhpc3RpbmdUb0pTT04gPyBleGlzdGluZ1RvSlNPTi5hcHBseSh0aGlzKSA6IHRoaXM7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGJhc2UsIHsgX190eXBlX186IHR5cGVOYW1lIH0pO1xuICB9O1xuICByZXR1cm4gY3Rvcjtcbn1cbmZ1bmN0aW9uIGlzT2ZBbm5vdGF0ZWRUeXBlKG9iamVjdCwgdHlwZU5hbWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX190eXBlX18gJiYgb2JqZWN0Ll9fdHlwZV9fID09PSB0eXBlTmFtZTtcbn1cblxuLy8gc3JjL3JlbmRlci90eXBlcy9QYXRoU2VnbWVudC50c1xudmFyIFBhdGhTZWdtZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHRoaXMuX19jbGFzcyA9IFwiUGF0aFNlZ21lbnRcIjtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5oYW5kbGVNaXJyb3JpbmcgPSBcInN0cmFpZ2h0XCI7XG4gICAgdGhpcy5oYW5kbGVPdXRYID0gMDtcbiAgICB0aGlzLmhhbmRsZU91dFkgPSAwO1xuICAgIHRoaXMuaGFuZGxlSW5YID0gMDtcbiAgICB0aGlzLmhhbmRsZUluWSA9IDA7XG4gICAgdGhpcy5yYWRpdXMgPSAwO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIG1lcmdlKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpLCB0aGlzLCB2YWx1ZSk7XG4gIH1cbn07XG5QYXRoU2VnbWVudC5kaXNwbGF5TmFtZSA9IFwiV2l0aENsYXNzRGlzY3JpbWluYXRvck1peGluKFBhdGhTZWdtZW50KVwiO1xuUGF0aFNlZ21lbnQucHJvdG90eXBlLl9fY2xhc3MgPSBcIlBhdGhTZWdtZW50XCI7XG4oZnVuY3Rpb24oUGF0aFNlZ21lbnQyKSB7XG4gIFBhdGhTZWdtZW50Mi5wb2ludCA9IChwYXRoU2VnbWVudCkgPT4ge1xuICAgIHJldHVybiB7IHg6IHBhdGhTZWdtZW50LngsIHk6IHBhdGhTZWdtZW50LnkgfTtcbiAgfTtcbiAgUGF0aFNlZ21lbnQyLmhhbmRsZU91dCA9IChwYXRoU2VnbWVudCkgPT4ge1xuICAgIHJldHVybiB7IHg6IHBhdGhTZWdtZW50LmhhbmRsZU91dFgsIHk6IHBhdGhTZWdtZW50LmhhbmRsZU91dFkgfTtcbiAgfTtcbiAgUGF0aFNlZ21lbnQyLmhhbmRsZUluID0gKHBhdGhTZWdtZW50KSA9PiB7XG4gICAgcmV0dXJuIHsgeDogcGF0aFNlZ21lbnQuaGFuZGxlSW5YLCB5OiBwYXRoU2VnbWVudC5oYW5kbGVJblkgfTtcbiAgfTtcbiAgUGF0aFNlZ21lbnQyLmNhbGN1bGF0ZWRIYW5kbGVPdXQgPSAocGF0aFNlZ21lbnQpID0+IHtcbiAgICBzd2l0Y2ggKHBhdGhTZWdtZW50LmhhbmRsZU1pcnJvcmluZykge1xuICAgICAgY2FzZSBcInN5bW1ldHJpY1wiOlxuICAgICAgY2FzZSBcImRpc2Nvbm5lY3RlZFwiOlxuICAgICAgY2FzZSBcImFzeW1tZXRyaWNcIjpcbiAgICAgICAgcmV0dXJuIFBvaW50LmFkZChQYXRoU2VnbWVudDIucG9pbnQocGF0aFNlZ21lbnQpLCBQYXRoU2VnbWVudDIuaGFuZGxlT3V0KHBhdGhTZWdtZW50KSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geyB4OiBwYXRoU2VnbWVudC54LCB5OiBwYXRoU2VnbWVudC55IH07XG4gICAgfVxuICB9O1xuICBQYXRoU2VnbWVudDIuY2FsY3VsYXRlZEhhbmRsZUluID0gKHBhdGhTZWdtZW50KSA9PiB7XG4gICAgc3dpdGNoIChwYXRoU2VnbWVudC5oYW5kbGVNaXJyb3JpbmcpIHtcbiAgICAgIGNhc2UgXCJzeW1tZXRyaWNcIjpcbiAgICAgICAgcmV0dXJuIFBvaW50LnN1YnRyYWN0KFBhdGhTZWdtZW50Mi5wb2ludChwYXRoU2VnbWVudCksIFBhdGhTZWdtZW50Mi5oYW5kbGVPdXQocGF0aFNlZ21lbnQpKTtcbiAgICAgIGNhc2UgXCJkaXNjb25uZWN0ZWRcIjpcbiAgICAgIGNhc2UgXCJhc3ltbWV0cmljXCI6XG4gICAgICAgIHJldHVybiBQb2ludC5hZGQoUGF0aFNlZ21lbnQyLnBvaW50KHBhdGhTZWdtZW50KSwgUGF0aFNlZ21lbnQyLmhhbmRsZUluKHBhdGhTZWdtZW50KSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gUGF0aFNlZ21lbnQyLnBvaW50KHBhdGhTZWdtZW50KTtcbiAgICB9XG4gIH07XG4gIFBhdGhTZWdtZW50Mi5jdXJ2ZURlZmF1bHQgPSAocG9pbnRzLCBpbmRleCkgPT4ge1xuICAgIGlmIChwb2ludHMubGVuZ3RoID4gMikge1xuICAgICAgbGV0IHBvaW50QmVmb3JlO1xuICAgICAgbGV0IHBvaW50QWZ0ZXI7XG4gICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgcG9pbnRCZWZvcmUgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9pbnRCZWZvcmUgPSBwb2ludHNbaW5kZXggLSAxXTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCA9PT0gcG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgcG9pbnRBZnRlciA9IHBvaW50c1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvaW50QWZ0ZXIgPSBwb2ludHNbaW5kZXggKyAxXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlbHRhMiA9IFBvaW50LnN1YnRyYWN0KFBhdGhTZWdtZW50Mi5wb2ludChwb2ludEFmdGVyKSwgUGF0aFNlZ21lbnQyLnBvaW50KHBvaW50QmVmb3JlKSk7XG4gICAgICByZXR1cm4geyB4OiBkZWx0YTIueCAvIDQsIHk6IGRlbHRhMi55IC8gNCB9O1xuICAgIH1cbiAgICByZXR1cm4geyB4OiAxMCwgeTogMTAgfTtcbiAgfTtcbn0pKFBhdGhTZWdtZW50IHx8IChQYXRoU2VnbWVudCA9IHt9KSk7XG5cbi8vIHNyYy9yZW5kZXIvdHJhaXRzL1BhdGgudHNcbnZhciBrZXk1ID0gXCJwYXRoU2VnbWVudHNcIjtcbmZ1bmN0aW9uIHdpdGhQYXRoKHRhcmdldCkge1xuICByZXR1cm4ga2V5NSBpbiB0YXJnZXQ7XG59XG52YXIgcGF0aERlZmF1bHRzID0ge1xuICBwYXRoU2VnbWVudHM6IFtdLFxuICBwYXRoQ2xvc2VkOiBmYWxzZVxufTtcbmZ1bmN0aW9uIHRvU1ZHUGF0aCh3aXRoUGF0aHMsIHRyYW5zbGF0ZSA9IHsgeDogMCwgeTogMCB9LCBjYW52YXNNb2RlID0gUmVuZGVyVGFyZ2V0LmNhbnZhcykge1xuICBsZXQgcGF0aEVsZW1lbnRzID0gW107XG4gIGxldCBwYXRocyA9IFtdO1xuICBpZiAoQXJyYXkuaXNBcnJheSh3aXRoUGF0aHMpKSB7XG4gICAgcGF0aHMgPSB3aXRoUGF0aHM7XG4gIH0gZWxzZSB7XG4gICAgcGF0aHMgPSBbd2l0aFBhdGhzXTtcbiAgfVxuICBwYXRocy5mb3JFYWNoKChwYXRoLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHsgcGF0aENsb3NlZCwgcGF0aFNlZ21lbnRzIH0gPSBwYXRoO1xuICAgIGNvbnN0IHNlZ21lbnRDb3VudCA9IHBhdGhTZWdtZW50cy5sZW5ndGg7XG4gICAgaWYgKHNlZ21lbnRDb3VudCA9PT0gMClcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHNlZ21lbnQgPSBwYXRoU2VnbWVudHNbaV07XG4gICAgICBsZXQgbmV4dFNlZ21lbnQ7XG4gICAgICBsZXQgcHJldlNlZ21lbnQ7XG4gICAgICBjb25zdCBpc0ZpcnN0U2VnbWVudCA9IGkgPT09IDA7XG4gICAgICBjb25zdCBpc0xhc3RTZWdtZW50ID0gaSA9PT0gc2VnbWVudENvdW50IC0gMTtcbiAgICAgIGlmICghaXNMYXN0U2VnbWVudCkge1xuICAgICAgICBuZXh0U2VnbWVudCA9IHBhdGhTZWdtZW50c1tpICsgMV07XG4gICAgICB9IGVsc2UgaWYgKHBhdGhDbG9zZWQpIHtcbiAgICAgICAgbmV4dFNlZ21lbnQgPSBwYXRoU2VnbWVudHNbMF07XG4gICAgICB9XG4gICAgICBpZiAoIWlzRmlyc3RTZWdtZW50KSB7XG4gICAgICAgIHByZXZTZWdtZW50ID0gcGF0aFNlZ21lbnRzW2kgLSAxXTtcbiAgICAgIH0gZWxzZSBpZiAocGF0aENsb3NlZCkge1xuICAgICAgICBwcmV2U2VnbWVudCA9IHBhdGhTZWdtZW50c1tzZWdtZW50Q291bnQgLSAxXTtcbiAgICAgIH1cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHBhdGhFbGVtZW50cy5wdXNoKFwiTVwiKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldlNlZ21lbnQgJiYgaXNTdHJhaWdodEN1cnZlKHByZXZTZWdtZW50LCBzZWdtZW50KSkge1xuICAgICAgICBwYXRoRWxlbWVudHMucHVzaChcIkxcIik7XG4gICAgICB9XG4gICAgICBwYXRoRWxlbWVudHMucHVzaChzZWdtZW50LnggKyB0cmFuc2xhdGUueCwgc2VnbWVudC55ICsgdHJhbnNsYXRlLnkpO1xuICAgICAgaWYgKG5leHRTZWdtZW50ICYmICFpc1N0cmFpZ2h0Q3VydmUoc2VnbWVudCwgbmV4dFNlZ21lbnQpKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZU91dCA9IFBhdGhTZWdtZW50LmNhbGN1bGF0ZWRIYW5kbGVPdXQoc2VnbWVudCk7XG4gICAgICAgIGNvbnN0IGhhbmRsZUluID0gUGF0aFNlZ21lbnQuY2FsY3VsYXRlZEhhbmRsZUluKG5leHRTZWdtZW50KTtcbiAgICAgICAgcGF0aEVsZW1lbnRzLnB1c2goXCJDXCIsIGhhbmRsZU91dC54ICsgdHJhbnNsYXRlLngsIGhhbmRsZU91dC55ICsgdHJhbnNsYXRlLnksIGhhbmRsZUluLnggKyB0cmFuc2xhdGUueCwgaGFuZGxlSW4ueSArIHRyYW5zbGF0ZS55KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xhc3RTZWdtZW50ICYmIG5leHRTZWdtZW50KSB7XG4gICAgICAgIGlmIChpc1N0cmFpZ2h0Q3VydmUoc2VnbWVudCwgbmV4dFNlZ21lbnQpKSB7XG4gICAgICAgICAgcGF0aEVsZW1lbnRzLnB1c2goXCJaXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGhFbGVtZW50cy5wdXNoKG5leHRTZWdtZW50LnggKyB0cmFuc2xhdGUueCwgbmV4dFNlZ21lbnQueSArIHRyYW5zbGF0ZS55LCBcIlpcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpZiAoY2FudmFzTW9kZSA9PT0gUmVuZGVyVGFyZ2V0LmV4cG9ydCB8fCBjYW52YXNNb2RlID09PSBSZW5kZXJUYXJnZXQucHJldmlldykge1xuICAgIHBhdGhFbGVtZW50cyA9IHBhdGhFbGVtZW50cy5tYXAoKHZhbHVlKSA9PiBpc0Zpbml0ZU51bWJlcih2YWx1ZSkgPyByb3VuZGVkTnVtYmVyU3RyaW5nKHZhbHVlLCAzKSA6IHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcGF0aEVsZW1lbnRzLmpvaW4oXCIgXCIpO1xufVxuZnVuY3Rpb24gaXNTdHJhaWdodEN1cnZlKGZyb21TZWdtZW50LCB0b1NlZ21lbnQpIHtcbiAgY29uc3QgZnJvbVN0cmFpZ2h0ID0gZnJvbVNlZ21lbnQuaGFuZGxlTWlycm9yaW5nID09PSBcInN0cmFpZ2h0XCIgfHwgZnJvbVNlZ21lbnQuaGFuZGxlT3V0WCA9PT0gMCAmJiBmcm9tU2VnbWVudC5oYW5kbGVPdXRZID09PSAwO1xuICBjb25zdCB0b1N0cmFpZ2h0ID0gdG9TZWdtZW50LmhhbmRsZU1pcnJvcmluZyA9PT0gXCJzdHJhaWdodFwiIHx8IHRvU2VnbWVudC5oYW5kbGVJblggPT09IDAgJiYgdG9TZWdtZW50LmhhbmRsZUluWSA9PT0gMDtcbiAgcmV0dXJuIGZyb21TdHJhaWdodCAmJiB0b1N0cmFpZ2h0O1xufVxuXG4vLyBzcmMvcmVuZGVyL3R5cGVzL1NpemUudHNcbmZ1bmN0aW9uIFNpemUod2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0IH07XG59XG4oZnVuY3Rpb24oU2l6ZTIpIHtcbiAgU2l6ZTIuZXF1YWxzID0gKHNpemVBLCBzaXplQikgPT4ge1xuICAgIGlmIChzaXplQSA9PT0gc2l6ZUIpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIXNpemVBIHx8ICFzaXplQilcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gc2l6ZUEud2lkdGggPT09IHNpemVCLndpZHRoICYmIHNpemVBLmhlaWdodCA9PT0gc2l6ZUIuaGVpZ2h0O1xuICB9O1xuICBTaXplMi51cGRhdGUgPSAoZnJvbVNpemUsIHRvU2l6ZSwga2VlcEFzcGVjdFJhdGlvID0gZmFsc2UpID0+IHtcbiAgICBsZXQgeyB3aWR0aCwgaGVpZ2h0IH0gPSBmcm9tU2l6ZTtcbiAgICBjb25zdCBzaXplUmF0aW8gPSB3aWR0aCAvIGhlaWdodDtcbiAgICB3aWR0aCA9IHRvU2l6ZS53aWR0aCAhPT0gdm9pZCAwID8gdG9TaXplLndpZHRoIDogd2lkdGg7XG4gICAgaGVpZ2h0ID0gdG9TaXplLmhlaWdodCAhPT0gdm9pZCAwID8gdG9TaXplLmhlaWdodCA6IGhlaWdodDtcbiAgICBpZiAoa2VlcEFzcGVjdFJhdGlvKSB7XG4gICAgICBpZiAodG9TaXplLndpZHRoID09PSB2b2lkIDAgJiYgdG9TaXplLmhlaWdodCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHdpZHRoID0gdG9TaXplLmhlaWdodCAqIHNpemVSYXRpbztcbiAgICAgIH1cbiAgICAgIGlmICh0b1NpemUud2lkdGggIT09IHZvaWQgMCAmJiB0b1NpemUuaGVpZ2h0ID09PSB2b2lkIDAgJiYgc2l6ZVJhdGlvICE9PSAwKSB7XG4gICAgICAgIGhlaWdodCA9IHRvU2l6ZS53aWR0aCAvIHNpemVSYXRpbztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCB9O1xuICB9O1xuICBmdW5jdGlvbiBzdWJ0cmFjdChzaXplQSwgc2l6ZUIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IE1hdGgubWF4KDAsIHNpemVBLndpZHRoIC0gc2l6ZUIud2lkdGgpLFxuICAgICAgaGVpZ2h0OiBNYXRoLm1heCgwLCBzaXplQS5oZWlnaHQgLSBzaXplQi5oZWlnaHQpXG4gICAgfTtcbiAgfVxuICBTaXplMi5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuICBTaXplMi56ZXJvID0gU2l6ZTIoMCwgMCk7XG4gIFNpemUyLmlzWmVybyA9IGZ1bmN0aW9uKHNpemUyKSB7XG4gICAgcmV0dXJuIHNpemUyID09PSBTaXplMi56ZXJvIHx8IHNpemUyLndpZHRoID09PSAwICYmIHNpemUyLmhlaWdodCA9PT0gMDtcbiAgfTtcbiAgU2l6ZTIuZGVmYXVsdElmWmVybyA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHNpemUyKSB7XG4gICAgaWYgKFNpemUyLmlzWmVybyhzaXplMikpIHtcbiAgICAgIHJldHVybiBTaXplMih3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemUyO1xuICB9O1xufSkoU2l6ZSB8fCAoU2l6ZSA9IHt9KSk7XG5cbi8vIHNyYy9yZW5kZXIvdHlwZXMvTGluZS50c1xuZnVuY3Rpb24gTGluZShhMiwgYjIpIHtcbiAgcmV0dXJuIHsgYTogYTIsIGI6IGIyIH07XG59XG4oZnVuY3Rpb24oTGluZTIpIHtcbiAgZnVuY3Rpb24gaW50ZXJzZWN0aW9uKGxpbmVBLCBsaW5lQikge1xuICAgIGNvbnN0IHgxID0gbGluZUEuYS54O1xuICAgIGNvbnN0IHkxID0gbGluZUEuYS55O1xuICAgIGNvbnN0IHgyID0gbGluZUEuYi54O1xuICAgIGNvbnN0IHkyID0gbGluZUEuYi55O1xuICAgIGNvbnN0IHgzID0gbGluZUIuYS54O1xuICAgIGNvbnN0IHkzID0gbGluZUIuYS55O1xuICAgIGNvbnN0IHg0ID0gbGluZUIuYi54O1xuICAgIGNvbnN0IHk0ID0gbGluZUIuYi55O1xuICAgIGNvbnN0IGQgPSAoeDEgLSB4MikgKiAoeTMgLSB5NCkgLSAoeTEgLSB5MikgKiAoeDMgLSB4NCk7XG4gICAgaWYgKGQgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB4aSA9ICgoeDMgLSB4NCkgKiAoeDEgKiB5MiAtIHkxICogeDIpIC0gKHgxIC0geDIpICogKHgzICogeTQgLSB5MyAqIHg0KSkgLyBkO1xuICAgIGNvbnN0IHlpID0gKCh5MyAtIHk0KSAqICh4MSAqIHkyIC0geTEgKiB4MikgLSAoeTEgLSB5MikgKiAoeDMgKiB5NCAtIHkzICogeDQpKSAvIGQ7XG4gICAgcmV0dXJuIHsgeDogeGksIHk6IHlpIH07XG4gIH1cbiAgTGluZTIuaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICBMaW5lMi5pc09ydGhvZ29uYWwgPSAobGluZSkgPT4ge1xuICAgIHJldHVybiBsaW5lLmEueCA9PT0gbGluZS5iLnggfHwgbGluZS5hLnkgPT09IGxpbmUuYi55O1xuICB9O1xuICBMaW5lMi5wZXJwZW5kaWN1bGFyID0gKGxpbmUsIHBvaW50T25MaW5lKSA9PiB7XG4gICAgY29uc3QgZGVsdGFYID0gbGluZS5hLnggLSBsaW5lLmIueDtcbiAgICBjb25zdCBkZWx0YVkgPSBsaW5lLmEueSAtIGxpbmUuYi55O1xuICAgIGNvbnN0IHBvaW50QiA9IFBvaW50KHBvaW50T25MaW5lLnggLSBkZWx0YVksIHBvaW50T25MaW5lLnkgKyBkZWx0YVgpO1xuICAgIHJldHVybiBMaW5lMihwb2ludEIsIHBvaW50T25MaW5lKTtcbiAgfTtcbiAgZnVuY3Rpb24gcHJvamVjdFBvaW50KGxpbmUsIHBvaW50KSB7XG4gICAgY29uc3QgcGVycCA9IExpbmUyLnBlcnBlbmRpY3VsYXIobGluZSwgcG9pbnQpO1xuICAgIHJldHVybiBpbnRlcnNlY3Rpb24obGluZSwgcGVycCk7XG4gIH1cbiAgTGluZTIucHJvamVjdFBvaW50ID0gcHJvamVjdFBvaW50O1xufSkoTGluZSB8fCAoTGluZSA9IHt9KSk7XG5cbi8vIHNyYy9yZW5kZXIvcHJlc2VudGF0aW9uL0ltYWdlLnRzeFxuaW1wb3J0IHtcbiAgY3JlYXRlRWxlbWVudCBhcyBjcmVhdGVFbGVtZW50Mzdcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWY5IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgSW1hZ2UyID0gZm9yd2FyZFJlZjkoZnVuY3Rpb24gSW1hZ2UzKHByb3BzLCByZWYpIHtcbiAgY29uc3QgeyBiYWNrZ3JvdW5kLCBjaGlsZHJlbiwgLi4ucmVzdCB9ID0gcHJvcHM7XG4gIGNvbnN0IHN0eWxlID0geyAuLi5yZXN0LnN0eWxlIH07XG4gIGlmIChiYWNrZ3JvdW5kKSB7XG4gICAgZGVsZXRlIHN0eWxlLmJhY2tncm91bmQ7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MzcobW90aW9uLmRpdiwge1xuICAgIC4uLnJlc3QsXG4gICAgc3R5bGUsXG4gICAgcmVmXG4gIH0sIGJhY2tncm91bmQgJiYgYmFja2dyb3VuZC5zcmMgPyAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDM3KEJhY2tncm91bmRJbWFnZUNvbXBvbmVudCwge1xuICAgIGltYWdlOiBiYWNrZ3JvdW5kXG4gIH0pIDogbnVsbCwgY2hpbGRyZW4pO1xufSk7XG5cbi8vIHNyYy9yZW5kZXIvcHJlc2VudGF0aW9uL1NWRy50c3hcbmltcG9ydCB7XG4gIEZyYWdtZW50IGFzIEZyYWdtZW50NyxcbiAgY3JlYXRlRWxlbWVudCBhcyBjcmVhdGVFbGVtZW50MzksXG4gIGNyZWF0ZVJlZiBhcyBjcmVhdGVSZWYzLFxuICB1c2VSZWYgYXMgdXNlUmVmMjJcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9yZW5kZXIvcHJlc2VudGF0aW9uL0ltYWdlUGF0dGVybkVsZW1lbnQudHN4XG5pbXBvcnQge1xuICBDb21wb25lbnQgYXMgQ29tcG9uZW50MTQsXG4gIGNyZWF0ZUVsZW1lbnQgYXMgY3JlYXRlRWxlbWVudDM4XG59IGZyb20gXCJyZWFjdFwiO1xudmFyIEltYWdlUGF0dGVybkVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIENvbXBvbmVudDE0IHtcbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgaWQsIHBhdGgsIHRyYW5zZm9ybTogdHJhbnNmb3JtMiB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB4bGlua0hyZWYgPSBpbWFnZVVybEZvckFzc2V0KHBhdGgpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDM4KFwicGF0dGVyblwiLCB7XG4gICAgICBpZCxcbiAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICBwYXR0ZXJuQ29udGVudFVuaXRzOiBcIm9iamVjdEJvdW5kaW5nQm94XCJcbiAgICB9LCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDM4KFwiaW1hZ2VcIiwge1xuICAgICAga2V5OiB4bGlua0hyZWYsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIGhlaWdodDogMSxcbiAgICAgIHhsaW5rSHJlZixcbiAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IFwibm9uZVwiLFxuICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0yXG4gICAgfSkpO1xuICB9XG59O1xuXG4vLyBzcmMvcmVuZGVyL3ByZXNlbnRhdGlvbi9TVkcudHN4XG5mdW5jdGlvbiBTVkcocHJvcHMpIHtcbiAgY29uc3QgcGFyZW50U2l6ZSA9IHVzZVBhcmVudFNpemUoKTtcbiAgY29uc3QgbGF5b3V0SWQgPSB1c2VMYXlvdXRJZDIocHJvcHMpO1xuICBjb25zdCBsYXlvdXRSZWYgPSB1c2VSZWYyMihudWxsKTtcbiAgdXNlTWVhc3VyZUxheW91dChwcm9wcywgbGF5b3V0UmVmKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MzkoU1ZHQ29tcG9uZW50LCB7XG4gICAgLi4ucHJvcHMsXG4gICAgaW5uZXJSZWY6IGxheW91dFJlZixcbiAgICBwYXJlbnRTaXplLFxuICAgIGxheW91dElkXG4gIH0pO1xufVxuZnVuY3Rpb24gc2l6ZVNWRyhjb250YWluZXIsIHByb3BzKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IGRpdiA9IGNvbnRhaW5lci5jdXJyZW50O1xuICBpZiAoIWRpdilcbiAgICByZXR1cm47XG4gIGNvbnN0IHsgd2l0aEV4dGVybmFsTGF5b3V0LCBwYXJlbnRTaXplIH0gPSBwcm9wcztcbiAgY29uc3QgY2FuVXNlQ2FsY3VsYXRlZE9uQ2FudmFzU2l6ZSA9ICF3aXRoRXh0ZXJuYWxMYXlvdXQgJiYgY29uc3RyYWludHNFbmFibGVkKHByb3BzKSAmJiBwYXJlbnRTaXplICE9PSBQYXJlbnRTaXplU3RhdGUuRGlzYWJsZWQgJiYgcGFyZW50U2l6ZSAhPT0gUGFyZW50U2l6ZVN0YXRlLkRpc2FibGVkRm9yQ3VycmVudExldmVsO1xuICBpZiAoY2FuVXNlQ2FsY3VsYXRlZE9uQ2FudmFzU2l6ZSlcbiAgICByZXR1cm47XG4gIGNvbnN0IHN2ZyA9IGRpdi5maXJzdEVsZW1lbnRDaGlsZDtcbiAgaWYgKCFzdmcgfHwgIShzdmcgaW5zdGFuY2VvZiBTVkdTVkdFbGVtZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7IGludHJpbnNpY1dpZHRoLCBpbnRyaW5zaWNIZWlnaHQsIF9jb25zdHJhaW50cyB9ID0gcHJvcHM7XG4gIGlmICgoKF9hID0gc3ZnLnZpZXdCb3guYmFzZVZhbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLndpZHRoKSA9PT0gMCAmJiAoKF9iID0gc3ZnLnZpZXdCb3guYmFzZVZhbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmhlaWdodCkgPT09IDAgJiYgaXNGaW5pdGVOdW1iZXIoaW50cmluc2ljV2lkdGgpICYmIGlzRmluaXRlTnVtYmVyKGludHJpbnNpY0hlaWdodCkpIHtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBgMCAwICR7aW50cmluc2ljV2lkdGh9ICR7aW50cmluc2ljSGVpZ2h0fWApO1xuICB9XG4gIGlmIChfY29uc3RyYWludHMgJiYgX2NvbnN0cmFpbnRzLmFzcGVjdFJhdGlvKSB7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcInByZXNlcnZlQXNwZWN0UmF0aW9cIiwgXCJcIik7XG4gIH0gZWxzZSB7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcInByZXNlcnZlQXNwZWN0UmF0aW9cIiwgXCJub25lXCIpO1xuICB9XG4gIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjEwMCVcIik7XG4gIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIxMDAlXCIpO1xufVxudmFyIF9TVkdDb21wb25lbnQgPSBjbGFzcyBleHRlbmRzIExheWVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNyZWF0ZVJlZjMoKTtcbiAgICB0aGlzLnN2Z0VsZW1lbnQgPSBjcmVhdGVSZWYzKCk7XG4gIH1cbiAgc3RhdGljIGZyYW1lKHByb3BzKSB7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZVJlY3QocHJvcHMsIHByb3BzLnBhcmVudFNpemUgfHwgUGFyZW50U2l6ZVN0YXRlLlVua25vd24pO1xuICB9XG4gIGdldFByZWZpeGVkU1ZHKHN2ZywgaWQpIHtcbiAgICBpZiAodGhpcy5wcmV2aW91c2x5UHJlZml4ZWRTVkcgJiYgc3ZnID09PSB0aGlzLnByZXZpb3VzbHlQcmVmaXhlZFNWRy5zdmcgJiYgaWQgPT09IHRoaXMucHJldmlvdXNseVByZWZpeGVkU1ZHLmlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmV2aW91c2x5UHJlZml4ZWRTVkdSZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHByZWZpeGVkU1ZHID0gcHJlZml4SWRzSW5TVkcoc3ZnLCBpZCk7XG4gICAgdGhpcy5wcmV2aW91c2x5UHJlZml4ZWRTVkdSZXN1bHQgPSBwcmVmaXhlZFNWRztcbiAgICB0aGlzLnByZXZpb3VzbHlQcmVmaXhlZFNWRyA9IHsgc3ZnLCBpZCB9O1xuICAgIHJldHVybiBwcmVmaXhlZFNWRztcbiAgfVxuICBnZXQgZnJhbWUoKSB7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZVJlY3QodGhpcy5wcm9wcywgdGhpcy5wcm9wcy5wYXJlbnRTaXplIHx8IFBhcmVudFNpemVTdGF0ZS5Vbmtub3duKTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBzaXplU1ZHKHRoaXMuY29udGFpbmVyLCB0aGlzLnByb3BzKTtcbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgc3VwZXIuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcyk7XG4gICAgY29uc3QgeyBmaWxsIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChCYWNrZ3JvdW5kSW1hZ2UuaXNJbWFnZU9iamVjdChmaWxsKSAmJiBCYWNrZ3JvdW5kSW1hZ2UuaXNJbWFnZU9iamVjdChwcmV2UHJvcHMuZmlsbCkgJiYgZmlsbC5zcmMgIT09IHByZXZQcm9wcy5maWxsLnNyYykge1xuICAgICAgcmVzZXRTZXRTdHlsZSh0aGlzLnN2Z0VsZW1lbnQuY3VycmVudCwgXCJmaWxsXCIsIG51bGwsIGZhbHNlKTtcbiAgICB9XG4gICAgc2l6ZVNWRyh0aGlzLmNvbnRhaW5lciwgdGhpcy5wcm9wcyk7XG4gIH1cbiAgY29sbGVjdExheW91dChzdHlsZSwgaW5uZXJTdHlsZSkge1xuICAgIGlmICh0aGlzLnByb3BzLndpdGhFeHRlcm5hbExheW91dCkge1xuICAgICAgaW5uZXJTdHlsZS53aWR0aCA9IGlubmVyU3R5bGUuaGVpZ2h0ID0gXCJpbmhlcml0XCI7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZyYW1lMiA9IHRoaXMuZnJhbWU7XG4gICAgY29uc3QgeyByb3RhdGlvbiwgaW50cmluc2ljV2lkdGgsIGludHJpbnNpY0hlaWdodCwgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCByb3RhdGUgPSBBbmltYXRhYmxlLmdldE51bWJlcihyb3RhdGlvbik7XG4gICAgc3R5bGUub3BhY2l0eSA9IGlzRmluaXRlTnVtYmVyKHRoaXMucHJvcHMub3BhY2l0eSkgPyB0aGlzLnByb3BzLm9wYWNpdHkgOiAxO1xuICAgIGlmIChSZW5kZXJUYXJnZXQuaGFzUmVzdHJpY3Rpb25zKCkgJiYgZnJhbWUyKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHN0eWxlLCB7XG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke2ZyYW1lMi54fXB4LCAke2ZyYW1lMi55fXB4KSByb3RhdGUoJHtyb3RhdGUudG9GaXhlZCg0KX1kZWcpYCxcbiAgICAgICAgd2lkdGg6IGAke2ZyYW1lMi53aWR0aH1weGAsXG4gICAgICAgIGhlaWdodDogYCR7ZnJhbWUyLmhlaWdodH1weGBcbiAgICAgIH0pO1xuICAgICAgaWYgKGNvbnN0cmFpbnRzRW5hYmxlZCh0aGlzLnByb3BzKSkge1xuICAgICAgICBzdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHhGYWN0b3IgPSBmcmFtZTIud2lkdGggLyAoaW50cmluc2ljV2lkdGggfHwgMSk7XG4gICAgICBjb25zdCB5RmFjdG9yID0gZnJhbWUyLmhlaWdodCAvIChpbnRyaW5zaWNIZWlnaHQgfHwgMSk7XG4gICAgICBpbm5lclN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IFwidG9wIGxlZnRcIjtcbiAgICAgIGNvbnN0IHsgem9vbSwgdGFyZ2V0IH0gPSBSZW5kZXJFbnZpcm9ubWVudDtcbiAgICAgIGlmICh0YXJnZXQgPT09IFJlbmRlclRhcmdldC5leHBvcnQpIHtcbiAgICAgICAgY29uc3Qgem9vbUZhY3RvciA9IHpvb20gPiAxID8gem9vbSA6IDE7XG4gICAgICAgIGlubmVyU3R5bGUudHJhbnNmb3JtID0gYHNjYWxlKCR7eEZhY3RvciAqIHpvb21GYWN0b3J9LCAke3lGYWN0b3IgKiB6b29tRmFjdG9yfSlgO1xuICAgICAgICBpbm5lclN0eWxlLnpvb20gPSAxIC8gem9vbUZhY3RvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlubmVyU3R5bGUudHJhbnNmb3JtID0gYHNjYWxlKCR7eEZhY3Rvcn0sICR7eUZhY3Rvcn0pYDtcbiAgICAgIH1cbiAgICAgIGlmIChpbnRyaW5zaWNXaWR0aCAmJiBpbnRyaW5zaWNIZWlnaHQpIHtcbiAgICAgICAgaW5uZXJTdHlsZS53aWR0aCA9IGludHJpbnNpY1dpZHRoO1xuICAgICAgICBpbm5lclN0eWxlLmhlaWdodCA9IGludHJpbnNpY0hlaWdodDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20gfSA9IHRoaXMucHJvcHM7XG4gICAgICBPYmplY3QuYXNzaWduKHN0eWxlLCB7XG4gICAgICAgIGxlZnQsXG4gICAgICAgIHJpZ2h0LFxuICAgICAgICB0b3AsXG4gICAgICAgIGJvdHRvbSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgcm90YXRlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5hc3NpZ24oaW5uZXJTdHlsZSwge1xuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChzYWZlV2luZG93W1wicGVyZlwiXSlcbiAgICAgIHNhZmVXaW5kb3dbXCJwZXJmXCJdLm5vZGVSZW5kZXIoKTtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIHZpc2libGUsXG4gICAgICBzdHlsZSxcbiAgICAgIGZpbGwsXG4gICAgICBzdmcsXG4gICAgICBpbnRyaW5zaWNIZWlnaHQsXG4gICAgICBpbnRyaW5zaWNXaWR0aCxcbiAgICAgIGxheW91dElkLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICAgdmFyaWFudHMsXG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgd2l0aEV4dGVybmFsTGF5b3V0LFxuICAgICAgaW5uZXJSZWZcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIXdpdGhFeHRlcm5hbExheW91dCAmJiAoIXZpc2libGUgfHwgIWlkKSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGlkZW50aWZpZXIgPSAoX2EgPSBpZCAhPSBudWxsID8gaWQgOiBsYXlvdXRJZCkgIT0gbnVsbCA/IF9hIDogXCJzdmdcIjtcbiAgICBpbmplY3RDb21wb25lbnRDU1NSdWxlcygpO1xuICAgIGNvbnN0IGZyYW1lMiA9IHRoaXMuZnJhbWU7XG4gICAgY29uc3Qgc2l6ZTIgPSBmcmFtZTIgfHwgeyB3aWR0aDogaW50cmluc2ljV2lkdGggfHwgMTAwLCBoZWlnaHQ6IGludHJpbnNpY0hlaWdodCB8fCAxMDAgfTtcbiAgICBjb25zdCBvdXRlclN0eWxlID0geyAuLi5zdHlsZSwgaW1hZ2VSZW5kZXJpbmc6IFwicGl4ZWxhdGVkXCIgfTtcbiAgICBjb25zdCBpbm5lclN0eWxlID0ge307XG4gICAgdGhpcy5jb2xsZWN0TGF5b3V0KG91dGVyU3R5bGUsIGlubmVyU3R5bGUpO1xuICAgIGNvbGxlY3RPcGFjaXR5RnJvbVByb3BzKHRoaXMucHJvcHMsIG91dGVyU3R5bGUpO1xuICAgIGNvbGxlY3RGaWx0ZXJzRnJvbVByb3BzKHRoaXMucHJvcHMsIG91dGVyU3R5bGUpO1xuICAgIExheWVyLmFwcGx5V2lsbENoYW5nZSh0aGlzLnByb3BzLCBvdXRlclN0eWxlLCBmYWxzZSk7XG4gICAgbGV0IGZpbGxFbGVtZW50ID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIGZpbGwgPT09IFwic3RyaW5nXCIgfHwgQ29sb3IuaXNDb2xvck9iamVjdChmaWxsKSkge1xuICAgICAgY29uc3QgZmlsbENvbG9yID0gQ29sb3IuaXNDb2xvck9iamVjdChmaWxsKSA/IGZpbGwuaW5pdGlhbFZhbHVlIHx8IENvbG9yLnRvUmdiU3RyaW5nKGZpbGwpIDogZmlsbDtcbiAgICAgIG91dGVyU3R5bGUuZmlsbCA9IGZpbGxDb2xvcjtcbiAgICAgIG91dGVyU3R5bGUuY29sb3IgPSBmaWxsQ29sb3I7XG4gICAgfSBlbHNlIGlmIChMaW5lYXJHcmFkaWVudC5pc0xpbmVhckdyYWRpZW50KGZpbGwpKSB7XG4gICAgICBjb25zdCBncmFkaWVudCA9IGZpbGw7XG4gICAgICBjb25zdCBncmFkaWVudElkID0gYCR7ZW5jb2RlVVJJKGlkIHx8IFwiXCIpfWcke0xpbmVhckdyYWRpZW50Lmhhc2goZ3JhZGllbnQpfWA7XG4gICAgICBvdXRlclN0eWxlLmZpbGwgPSBgdXJsKCMke2dyYWRpZW50SWR9KWA7XG4gICAgICBjb25zdCBlbGVtZW50UHJvcGVydGllcyA9IGVsZW1lbnRQcm9wZXJ0aWVzRm9yTGluZWFyR3JhZGllbnQoZ3JhZGllbnQsIGlkZW50aWZpZXIpO1xuICAgICAgZmlsbEVsZW1lbnQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDM5KFwic3ZnXCIsIHtcbiAgICAgICAgcmVmOiB0aGlzLnN2Z0VsZW1lbnQsXG4gICAgICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgc3R5bGU6IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiB9XG4gICAgICB9LCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDM5KFwibGluZWFyR3JhZGllbnRcIiwge1xuICAgICAgICBpZDogZ3JhZGllbnRJZCxcbiAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm06IGByb3RhdGUoJHtlbGVtZW50UHJvcGVydGllcy5hbmdsZX0sIDAuNSwgMC41KWBcbiAgICAgIH0sIGVsZW1lbnRQcm9wZXJ0aWVzLnN0b3BzLm1hcCgoc3RvcCwgaWR4KSA9PiB7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDM5KFwic3RvcFwiLCB7XG4gICAgICAgICAga2V5OiBpZHgsXG4gICAgICAgICAgb2Zmc2V0OiBzdG9wLnBvc2l0aW9uLFxuICAgICAgICAgIHN0b3BDb2xvcjogc3RvcC5jb2xvcixcbiAgICAgICAgICBzdG9wT3BhY2l0eTogc3RvcC5hbHBoYVxuICAgICAgICB9KTtcbiAgICAgIH0pKSk7XG4gICAgfSBlbHNlIGlmIChSYWRpYWxHcmFkaWVudC5pc1JhZGlhbEdyYWRpZW50KGZpbGwpKSB7XG4gICAgICBjb25zdCBncmFkaWVudCA9IGZpbGw7XG4gICAgICBjb25zdCBncmFkaWVudElkID0gYCR7ZW5jb2RlVVJJKGlkIHx8IFwiXCIpfWcke1JhZGlhbEdyYWRpZW50Lmhhc2goZ3JhZGllbnQpfWA7XG4gICAgICBvdXRlclN0eWxlLmZpbGwgPSBgdXJsKCMke2dyYWRpZW50SWR9KWA7XG4gICAgICBjb25zdCBlbGVtZW50UHJvcGVydGllcyA9IGVsZW1lbnRQcm9wZXJ0aWVzRm9yUmFkaWFsR3JhZGllbnQoZ3JhZGllbnQsIGlkZW50aWZpZXIpO1xuICAgICAgZmlsbEVsZW1lbnQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDM5KFwic3ZnXCIsIHtcbiAgICAgICAgcmVmOiB0aGlzLnN2Z0VsZW1lbnQsXG4gICAgICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgc3R5bGU6IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiB9XG4gICAgICB9LCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDM5KFwicmFkaWFsR3JhZGllbnRcIiwge1xuICAgICAgICBpZDogZ3JhZGllbnRJZCxcbiAgICAgICAgY3k6IGdyYWRpZW50LmNlbnRlckFuY2hvclksXG4gICAgICAgIGN4OiBncmFkaWVudC5jZW50ZXJBbmNob3JYLFxuICAgICAgICByOiBncmFkaWVudC53aWR0aEZhY3RvclxuICAgICAgfSwgZWxlbWVudFByb3BlcnRpZXMuc3RvcHMubWFwKChzdG9wLCBpZHgpID0+IHtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50MzkoXCJzdG9wXCIsIHtcbiAgICAgICAgICBrZXk6IGlkeCxcbiAgICAgICAgICBvZmZzZXQ6IHN0b3AucG9zaXRpb24sXG4gICAgICAgICAgc3RvcENvbG9yOiBzdG9wLmNvbG9yLFxuICAgICAgICAgIHN0b3BPcGFjaXR5OiBzdG9wLmFscGhhXG4gICAgICAgIH0pO1xuICAgICAgfSkpKTtcbiAgICB9IGVsc2UgaWYgKEJhY2tncm91bmRJbWFnZS5pc0ltYWdlT2JqZWN0KGZpbGwpKSB7XG4gICAgICBjb25zdCBpbWFnZVBhdHRlcm4gPSBpbWFnZVBhdHRlcm5Qcm9wc0ZvckZpbGwoZmlsbCwgc2l6ZTIsIGlkZW50aWZpZXIpO1xuICAgICAgaWYgKGltYWdlUGF0dGVybikge1xuICAgICAgICBvdXRlclN0eWxlLmZpbGwgPSBgdXJsKCMke2ltYWdlUGF0dGVybi5pZH0pYDtcbiAgICAgICAgZmlsbEVsZW1lbnQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDM5KFwic3ZnXCIsIHtcbiAgICAgICAgICByZWY6IHRoaXMuc3ZnRWxlbWVudCxcbiAgICAgICAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgICAgICAgIHhtbG5zWGxpbms6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICAgIHN0eWxlOiB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIgfVxuICAgICAgICB9LCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDM5KFwiZGVmc1wiLCBudWxsLCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDM5KEltYWdlUGF0dGVybkVsZW1lbnQsIHtcbiAgICAgICAgICAuLi5pbWFnZVBhdHRlcm5cbiAgICAgICAgfSkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGF0YVByb3BzID0ge1xuICAgICAgXCJkYXRhLWZyYW1lci1jb21wb25lbnQtdHlwZVwiOiBcIlNWR1wiXG4gICAgfTtcbiAgICBjb25zdCBoYXNUcmFuc2Zvcm1UZW1wbGF0ZSA9ICFmcmFtZTI7XG4gICAgaWYgKGhhc1RyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGRhdGFQcm9wcywgbGF5b3V0SGludERhdGFQcm9wc0ZvckNlbnRlcih0aGlzLnByb3BzLmNlbnRlcikpO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQzOShGcmFnbWVudDcsIG51bGwsIGZpbGxFbGVtZW50LCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDM5KFwiZGl2XCIsIHtcbiAgICAgIGtleTogQmFja2dyb3VuZEltYWdlLmlzSW1hZ2VPYmplY3QoZmlsbCkgPyBmaWxsLnNyYyA6IFwiXCIsXG4gICAgICBjbGFzc05hbWU6IFwic3ZnQ29udGFpbmVyXCIsXG4gICAgICBzdHlsZTogaW5uZXJTdHlsZSxcbiAgICAgIHJlZjogdGhpcy5jb250YWluZXIsXG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogeyBfX2h0bWw6IHRoaXMuZ2V0UHJlZml4ZWRTVkcoc3ZnLCBpZGVudGlmaWVyKSB9XG4gICAgfSkpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDM5KG1vdGlvbi5kaXYsIHtcbiAgICAgIC4uLmRhdGFQcm9wcyxcbiAgICAgIGxheW91dElkLFxuICAgICAgdHJhbnNmb3JtVGVtcGxhdGU6IGhhc1RyYW5zZm9ybVRlbXBsYXRlID8gdHJhbnNmb3JtVGVtcGxhdGUodGhpcy5wcm9wcy5jZW50ZXIpIDogdm9pZCAwLFxuICAgICAgaWQsXG4gICAgICByZWY6IGlubmVyUmVmLFxuICAgICAgc3R5bGU6IG91dGVyU3R5bGUsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICB2YXJpYW50cyxcbiAgICAgIHRyYW5zaXRpb25cbiAgICB9LCBjb250ZW50KTtcbiAgfVxufTtcbnZhciBTVkdDb21wb25lbnQgPSBfU1ZHQ29tcG9uZW50O1xuU1ZHQ29tcG9uZW50LnN1cHBvcnRzQ29uc3RyYWludHMgPSB0cnVlO1xuU1ZHQ29tcG9uZW50LmRlZmF1bHRTVkdQcm9wcyA9IHtcbiAgbGVmdDogdm9pZCAwLFxuICByaWdodDogdm9pZCAwLFxuICB0b3A6IHZvaWQgMCxcbiAgYm90dG9tOiB2b2lkIDAsXG4gIHN0eWxlOiB2b2lkIDAsXG4gIF9jb25zdHJhaW50czoge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgYXNwZWN0UmF0aW86IG51bGxcbiAgfSxcbiAgcGFyZW50U2l6ZTogUGFyZW50U2l6ZVN0YXRlLlVua25vd24sXG4gIHJvdGF0aW9uOiAwLFxuICB2aXNpYmxlOiB0cnVlLFxuICBzdmc6IFwiXCIsXG4gIHNoYWRvd3M6IFtdXG59O1xuU1ZHQ29tcG9uZW50LmRlZmF1bHRQcm9wcyA9IHtcbiAgLi4uTGF5ZXIuZGVmYXVsdFByb3BzLFxuICAuLi5fU1ZHQ29tcG9uZW50LmRlZmF1bHRTVkdQcm9wc1xufTtcbmZ1bmN0aW9uIHByZWZpeElkc0luU1ZHKHN2ZywgcHJlZml4KSB7XG4gIGNvbnN0IGRvbVBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBkb2MgPSBkb21QYXJzZXIucGFyc2VGcm9tU3RyaW5nKHN2ZywgXCJpbWFnZS9zdmcreG1sXCIpO1xuICAgIGNvbnN0IGVsID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3ZnXCIpWzBdO1xuICAgIGlmICghZWwpXG4gICAgICByZXR1cm4gc3ZnO1xuICAgIGNvbnN0IHNhbml0aXplZFByZWZpeCA9IHNhbml0aXplU3RyaW5nKHByZWZpeCk7XG4gICAgcmVjdXJzaXZlbHlQcmVmaXhJZChlbCwgc2FuaXRpemVkUHJlZml4KTtcbiAgICByZXR1cm4gZWwub3V0ZXJIVE1MO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgU1ZHOiAke2Vycm9yfWApO1xuICB9XG59XG5mdW5jdGlvbiBzYW5pdGl6ZVN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXmEtejAtOVxcLV86Ll18XlteYS16XSsvZ2ksIFwiXCIpO1xufVxuZnVuY3Rpb24gcmVjdXJzaXZlbHlQcmVmaXhJZChlbCwgcHJlZml4KSB7XG4gIHByZWZpeElkKGVsLCBwcmVmaXgpO1xuICBjb25zdCBjaGlsZE5vZGVzID0gQXJyYXkuZnJvbShlbC5jaGlsZHJlbik7XG4gIGNoaWxkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgIHJlY3Vyc2l2ZWx5UHJlZml4SWQobm9kZSwgcHJlZml4KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwcmVmaXhJZChlbCwgcHJlZml4KSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBlbC5nZXRBdHRyaWJ1dGVOYW1lcygpO1xuICBhdHRyaWJ1dGVzLmZvckVhY2goKGF0dHIpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGVsLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChhdHRyID09PSBcImlkXCIpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyLCBgJHtwcmVmaXh9XyR7dmFsdWV9YCk7XG4gICAgfVxuICAgIGlmIChhdHRyID09PSBcImhyZWZcIiB8fCBhdHRyID09PSBcInhsaW5rOmhyZWZcIikge1xuICAgICAgY29uc3QgW2Jhc2UsIGZyYWdtZW50SWRlbnRpZmllcl0gPSB2YWx1ZS5zcGxpdChcIiNcIik7XG4gICAgICBpZiAoYmFzZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsIGAjJHtwcmVmaXh9XyR7ZnJhZ21lbnRJZGVudGlmaWVyfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBVUkxfUkVGID0gXCJ1cmwoI1wiO1xuICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhVUkxfUkVGKSkge1xuICAgICAgY29uc3QgcHJlZml4ZWRWYWx1ZSA9IHZhbHVlLnJlcGxhY2UoVVJMX1JFRiwgYCR7VVJMX1JFRn0ke3ByZWZpeH1fYCk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgcHJlZml4ZWRWYWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL3JlbmRlci9wcmVzZW50YXRpb24vVGV4dC50c3hcbmltcG9ydCB7XG4gIGNyZWF0ZUVsZW1lbnQgYXMgY3JlYXRlRWxlbWVudDQwXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlUmVmIGFzIHVzZVJlZjIzLCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MjIgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3JlbmRlci9mb250cy9mb250cy50c1xuZnVuY3Rpb24gY29udmVydFRvT2JqZWN0KGRlc2NyaXB0b3JzKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoZGVzY3JpcHRvcnMubWFwKChkZXNjcmlwdG9yKSA9PiBbXG4gICAgZGVzY3JpcHRvclswXSxcbiAgICBPYmplY3QuZnJvbUVudHJpZXMoZGVzY3JpcHRvclsxXS5tYXAoKG1lbWJlcikgPT4gW1xuICAgICAgbWVtYmVyWzBdLFxuICAgICAge1xuICAgICAgICBzZWxlY3RvcjogbWVtYmVyWzFdLFxuICAgICAgICB3ZWlnaHQ6IG1lbWJlclsyXVxuICAgICAgfVxuICAgIF0pKVxuICBdKSk7XG59XG52YXIgc2FmZUZvbnRzID0ge1xuICBBcmlhbDoge1xuICAgIFJlZ3VsYXI6IHsgc2VsZWN0b3I6IFwiQXJpYWxcIiwgd2VpZ2h0OiB2b2lkIDAgfSxcbiAgICBCbGFjazogeyBzZWxlY3RvcjogXCJBcmlhbC1CbGFja1wiLCB3ZWlnaHQ6IHZvaWQgMCB9LFxuICAgIE5hcnJvdzogeyBzZWxlY3RvcjogXCJBcmlhbCBOYXJyb3dcIiwgd2VpZ2h0OiB2b2lkIDAgfSxcbiAgICBcIlJvdW5kZWQgQm9sZFwiOiB7IHNlbGVjdG9yOiBcIkFyaWFsIFJvdW5kZWQgTVQgQm9sZFwiLCB3ZWlnaHQ6IHZvaWQgMCB9XG4gIH0sXG4gIEF2ZW5pcjoge1xuICAgIEJvb2s6IHsgc2VsZWN0b3I6IFwiQXZlbmlyXCIsIHdlaWdodDogdm9pZCAwIH0sXG4gICAgTGlnaHQ6IHsgc2VsZWN0b3I6IFwiQXZlbmlyLUxpZ2h0XCIsIHdlaWdodDogdm9pZCAwIH0sXG4gICAgTWVkaXVtOiB7IHNlbGVjdG9yOiBcIkF2ZW5pci1NZWRpdW1cIiwgd2VpZ2h0OiB2b2lkIDAgfSxcbiAgICBIZWF2eTogeyBzZWxlY3RvcjogXCJBdmVuaXItSGVhdnlcIiwgd2VpZ2h0OiB2b2lkIDAgfSxcbiAgICBCbGFjazogeyBzZWxlY3RvcjogXCJBdmVuaXItQmxhY2tcIiwgd2VpZ2h0OiB2b2lkIDAgfVxuICB9LFxuICBcIkF2ZW5pciBOZXh0XCI6IHtcbiAgICBSZWd1bGFyOiB7IHNlbGVjdG9yOiBcIkF2ZW5pciBOZXh0XCIsIHdlaWdodDogdm9pZCAwIH0sXG4gICAgXCJVbHRyYSBMaWdodFwiOiB7IHNlbGVjdG9yOiBcIkF2ZW5pck5leHQtVWx0cmFMaWdodFwiLCB3ZWlnaHQ6IHZvaWQgMCB9LFxuICAgIE1lZGl1bTogeyBzZWxlY3RvcjogXCJBdmVuaXJOZXh0LU1lZGl1bVwiLCB3ZWlnaHQ6IHZvaWQgMCB9LFxuICAgIFwiRGVtaSBCb2xkXCI6IHsgc2VsZWN0b3I6IFwiQXZlbmlyTmV4dC1EZW1pQm9sZFwiLCB3ZWlnaHQ6IHZvaWQgMCB9LFxuICAgIEhlYXZ5OiB7IHNlbGVjdG9yOiBcIkF2ZW5pck5leHQtSGVhdnlcIiwgd2VpZ2h0OiB2b2lkIDAgfVxuICB9LFxuICBcIkF2ZW5pciBOZXh0IENvbmRlbnNlZFwiOiB7XG4gICAgUmVndWxhcjogeyBzZWxlY3RvcjogXCJBdmVuaXIgTmV4dCBDb25kZW5zZWRcIiwgd2VpZ2h0OiB2b2lkIDAgfSxcbiAgICBcIlVsdHJhIExpZ2h0XCI6IHsgc2VsZWN0b3I6IFwiQXZlbmlyTmV4dENvbmRlbnNlZC1VbHRyYUxpZ2h0XCIsIHdlaWdodDogdm9pZCAwIH0sXG4gICAgTWVkaXVtOiB7IHNlbGVjdG9yOiBcIkF2ZW5pck5leHRDb25kZW5zZWQtTWVkaXVtXCIsIHdlaWdodDogdm9pZCAwIH0sXG4gICAgXCJEZW1pIEJvbGRcIjogeyBzZWxlY3RvcjogXCJBdmVuaXJOZXh0Q29uZGVuc2VkLURlbWlCb2xkXCIsIHdlaWdodDogdm9pZCAwIH0sXG4gICAgSGVhdnk6IHsgc2VsZWN0b3I6IFwiQXZlbmlyTmV4dENvbmRlbnNlZC1IZWF2eVwiLCB3ZWlnaHQ6IHZvaWQgMCB9XG4gIH0sXG4gIEJhc2tlcnZpbGxlOiB7XG4gICAgUmVndWxhcjogeyBzZWxlY3RvcjogXCJCYXNrZXJ2aWxsZVwiLCB3ZWlnaHQ6IHZvaWQgMCB9LFxuICAgIFwiU2VtaSBCb2xkXCI6IHsgc2VsZWN0b3I6IFwiQmFza2VydmlsbGUtU2VtaUJvbGRcIiwgd2VpZ2h0OiB2b2lkIDAgfVxuICB9LFxuICBcIkJvZG9uaSA3MlwiOiB7XG4gICAgQm9vazogeyBzZWxlY3RvcjogXCJCb2RvbmkgNzJcIiwgd2VpZ2h0OiB2b2lkIDAgfSxcbiAgICBPbGRzdHlsZTogeyBzZWxlY3RvcjogXCJCb2RvbmkgNzIgT2xkc3R5bGVcIiwgd2VpZ2h0OiB2b2lkIDAgfSxcbiAgICBTbWFsbGNhcHM6IHsgc2VsZWN0b3I6IFwiQm9kb25pIDcyIFNtYWxsY2Fwc1wiLCB3ZWlnaHQ6IHZvaWQgMCB9XG4gIH0sXG4gIENvdXJpZXI6IHsgUmVndWxhcjogeyBzZWxlY3RvcjogXCJDb3VyaWVyXCIsIHdlaWdodDogdm9pZCAwIH0gfSxcbiAgXCJDb3VyaWVyIE5ld1wiOiB7IFJlZ3VsYXI6IHsgc2VsZWN0b3I6IFwiQ291cmllciBOZXdcIiwgd2VpZ2h0OiB2b2lkIDAgfSB9LFxuICBGdXR1cmE6IHtcbiAgICBNZWRpdW06IHsgc2VsZWN0b3I6IFwiRnV0dXJhXCIsIHdlaWdodDogdm9pZCAwIH0sXG4gICAgQ29uZGVuc2VkOiB7IHNlbGVjdG9yOiBcIkZ1dHVyYS1Db25kZW5zZWRNZWRpdW1cIiwgd2VpZ2h0OiB2b2lkIDAgfSxcbiAgICBcIkNvbmRlbnNlZCBFeHRyYUJvbGRcIjogeyBzZWxlY3RvcjogXCJGdXR1cmEtQ29uZGVuc2VkRXh0cmFCb2xkXCIsIHdlaWdodDogdm9pZCAwIH1cbiAgfSxcbiAgR2VvcmdpYTogeyBSZWd1bGFyOiB7IHNlbGVjdG9yOiBcIkdlb3JnaWFcIiwgd2VpZ2h0OiB2b2lkIDAgfSB9LFxuICBcIkdpbGwgU2Fuc1wiOiB7XG4gICAgUmVndWxhcjogeyBzZWxlY3RvcjogXCJHaWxsIFNhbnNcIiwgd2VpZ2h0OiB2b2lkIDAgfSxcbiAgICBMaWdodDogeyBzZWxlY3RvcjogXCJHaWxsU2Fucy1MaWdodFwiLCB3ZWlnaHQ6IHZvaWQgMCB9LFxuICAgIFNlbWlCb2xkOiB7IHNlbGVjdG9yOiBcIkdpbGxTYW5zLVNlbWlCb2xkXCIsIHdlaWdodDogdm9pZCAwIH0sXG4gICAgVWx0cmFCb2xkOiB7IHNlbGVjdG9yOiBcIkdpbGxTYW5zLVVsdHJhQm9sZFwiLCB3ZWlnaHQ6IHZvaWQgMCB9XG4gIH0sXG4gIEhlbHZldGljYToge1xuICAgIFJlZ3VsYXI6IHsgc2VsZWN0b3I6IFwiSGVsdmV0aWNhXCIsIHdlaWdodDogdm9pZCAwIH0sXG4gICAgTGlnaHQ6IHsgc2VsZWN0b3I6IFwiSGVsdmV0aWNhLUxpZ2h0XCIsIHdlaWdodDogdm9pZCAwIH0sXG4gICAgQm9sZDogeyBzZWxlY3RvcjogXCJIZWx2ZXRpY2EtQm9sZFwiLCB3ZWlnaHQ6IHZvaWQgMCB9LFxuICAgIE9ibGlxdWU6IHsgc2VsZWN0b3I6IFwiSGVsdmV0aWNhLU9ibGlxdWVcIiwgd2VpZ2h0OiB2b2lkIDAgfSxcbiAgICBcIkxpZ2h0IE9ibGlxdWVcIjogeyBzZWxlY3RvcjogXCJIZWx2ZXRpY2EtTGlnaHRPYmxpcXVlXCIsIHdlaWdodDogdm9pZCAwIH0sXG4gICAgXCJCb2xkIE9ibGlxdWVcIjogeyBzZWxlY3RvcjogXCJIZWx2ZXRpY2EtQm9sZE9ibGlxdWVcIiwgd2VpZ2h0OiB2b2lkIDAgfVxuICB9LFxuICBcIkhlbHZldGljYSBOZXVlXCI6IHtcbiAgICBSZWd1bGFyOiB7IHNlbGVjdG9yOiBcIkhlbHZldGljYSBOZXVlXCIsIHdlaWdodDogdm9pZCAwIH0sXG4gICAgVWx0cmFMaWdodDogeyBzZWxlY3RvcjogXCJIZWx2ZXRpY2FOZXVlLVVsdHJhTGlnaHRcIiwgd2VpZ2h0OiB2b2lkIDAgfSxcbiAgICBUaGluOiB7IHNlbGVjdG9yOiBcIkhlbHZldGljYU5ldWUtVGhpblwiLCB3ZWlnaHQ6IHZvaWQgMCB9LFxuICAgIExpZ2h0OiB7IHNlbGVjdG9yOiBcIkhlbHZldGljYU5ldWUtTGlnaHRcIiwgd2VpZ2h0OiB2b2lkIDAgfSxcbiAgICBNZWRpdW06IHsgc2VsZWN0b3I6IFwiSGVsdmV0aWNhTmV1ZS1NZWRpdW1cIiwgd2VpZ2h0OiB2b2lkIDAgfSxcbiAgICBCb2xkOiB7IHNlbGVjdG9yOiBcIkhlbHZldGljYU5ldWUtQm9sZFwiLCB3ZWlnaHQ6IHZvaWQgMCB9LFxuICAgIEl0YWxpYzogeyBzZWxlY3RvcjogXCJIZWx2ZXRpY2FOZXVlLUl0YWxpY1wiLCB3ZWlnaHQ6IHZvaWQgMCB9LFxuICAgIFwiVWx0cmFMaWdodCBJdGFsaWNcIjogeyBzZWxlY3RvcjogXCJIZWx2ZXRpY2FOZXVlLVVsdHJhTGlnaHRJdGFsaWNcIiwgd2VpZ2h0OiB2b2lkIDAgfSxcbiAgICBcIlRoaW4gSXRhbGljXCI6IHsgc2VsZWN0b3I6IFwiSGVsdmV0aWNhTmV1ZS1UaGluSXRhbGljXCIsIHdlaWdodDogdm9pZCAwIH0sXG4gICAgXCJMaWdodCBJdGFsaWNcIjogeyBzZWxlY3RvcjogXCJIZWx2ZXRpY2FOZXVlLUxpZ2h0SXRhbGljXCIsIHdlaWdodDogdm9pZCAwIH0sXG4gICAgXCJNZWRpdW0gSXRhbGljXCI6IHsgc2VsZWN0b3I6IFwiSGVsdmV0aWNhTmV1ZS1NZWRpdW1JdGFsaWNcIiwgd2VpZ2h0OiB2b2lkIDAgfSxcbiAgICBcIkJvbGQgSXRhbGljXCI6IHsgc2VsZWN0b3I6IFwiSGVsdmV0aWNhTmV1ZS1Cb2xkSXRhbGljXCIsIHdlaWdodDogdm9pZCAwIH0sXG4gICAgXCJDb25kZW5zZWQgQm9sZFwiOiB7IHNlbGVjdG9yOiBcIkhlbHZldGljYU5ldWUtQ29uZGVuc2VkQm9sZFwiLCB3ZWlnaHQ6IHZvaWQgMCB9LFxuICAgIFwiQ29uZGVuc2VkIEJsYWNrXCI6IHsgc2VsZWN0b3I6IFwiSGVsdmV0aWNhTmV1ZS1Db25kZW5zZWRCbGFja1wiLCB3ZWlnaHQ6IHZvaWQgMCB9XG4gIH0sXG4gIFwiSG9lZmxlciBUZXh0XCI6IHsgUmVndWxhcjogeyBzZWxlY3RvcjogXCJIb2VmbGVyIFRleHRcIiwgd2VpZ2h0OiB2b2lkIDAgfSB9LFxuICBJbXBhY3Q6IHsgUmVndWxhcjogeyBzZWxlY3RvcjogXCJJbXBhY3RcIiwgd2VpZ2h0OiB2b2lkIDAgfSB9LFxuICBcIkx1Y2lkYSBHcmFuZGVcIjogeyBSZWd1bGFyOiB7IHNlbGVjdG9yOiBcIkx1Y2lkYSBHcmFuZGVcIiwgd2VpZ2h0OiB2b2lkIDAgfSB9LFxuICBNZW5sbzogeyBSZWd1bGFyOiB7IHNlbGVjdG9yOiBcIk1lbmxvXCIsIHdlaWdodDogdm9pZCAwIH0gfSxcbiAgTW9uYWNvOiB7IFJlZ3VsYXI6IHsgc2VsZWN0b3I6IFwiTW9uYWNvXCIsIHdlaWdodDogdm9pZCAwIH0gfSxcbiAgT3B0aW1hOiB7XG4gICAgUmVndWxhcjogeyBzZWxlY3RvcjogXCJPcHRpbWFcIiwgd2VpZ2h0OiB2b2lkIDAgfSxcbiAgICBFeHRyYUJsYWNrOiB7IHNlbGVjdG9yOiBcIk9wdGltYS1FeHRyYUJsYWNrXCIsIHdlaWdodDogdm9pZCAwIH1cbiAgfSxcbiAgUGFsYXRpbm86IHsgUmVndWxhcjogeyBzZWxlY3RvcjogXCJQYWxhdGlub1wiLCB3ZWlnaHQ6IHZvaWQgMCB9IH0sXG4gIFwiU0YgUHJvIERpc3BsYXlcIjoge1xuICAgIFJlZ3VsYXI6IHsgc2VsZWN0b3I6IFwiX19TRi1VSS1EaXNwbGF5LVJlZ3VsYXJfX1wiLCB3ZWlnaHQ6IDQwMCB9LFxuICAgIFVsdHJhbGlnaHQ6IHsgc2VsZWN0b3I6IFwiX19TRi1VSS1EaXNwbGF5LVVsdHJhbGlnaHRfX1wiLCB3ZWlnaHQ6IDEwMCB9LFxuICAgIFRoaW46IHsgc2VsZWN0b3I6IFwiX19TRi1VSS1EaXNwbGF5LVRoaW5fX1wiLCB3ZWlnaHQ6IDIwMCB9LFxuICAgIExpZ2h0OiB7IHNlbGVjdG9yOiBcIl9fU0YtVUktRGlzcGxheS1MaWdodF9fXCIsIHdlaWdodDogMzAwIH0sXG4gICAgTWVkaXVtOiB7IHNlbGVjdG9yOiBcIl9fU0YtVUktRGlzcGxheS1NZWRpdW1fX1wiLCB3ZWlnaHQ6IDUwMCB9LFxuICAgIFNlbWlib2xkOiB7IHNlbGVjdG9yOiBcIl9fU0YtVUktRGlzcGxheS1TZW1pYm9sZF9fXCIsIHdlaWdodDogNjAwIH0sXG4gICAgQm9sZDogeyBzZWxlY3RvcjogXCJfX1NGLVVJLURpc3BsYXktQm9sZF9fXCIsIHdlaWdodDogNzAwIH0sXG4gICAgSGVhdnk6IHsgc2VsZWN0b3I6IFwiX19TRi1VSS1EaXNwbGF5LUhlYXZ5X19cIiwgd2VpZ2h0OiA4MDAgfSxcbiAgICBCbGFjazogeyBzZWxlY3RvcjogXCJfX1NGLVVJLURpc3BsYXktQmxhY2tfX1wiLCB3ZWlnaHQ6IDkwMCB9LFxuICAgIEl0YWxpYzogeyBzZWxlY3RvcjogXCJfX1NGLVVJLURpc3BsYXktSXRhbGljX19cIiwgd2VpZ2h0OiA0MDAgfSxcbiAgICBcIlVsdHJhbGlnaHQgSXRhbGljXCI6IHsgc2VsZWN0b3I6IFwiX19TRi1VSS1EaXNwbGF5LVVsdHJhbGlnaHQtSXRhbGljX19cIiwgd2VpZ2h0OiAxMDAgfSxcbiAgICBcIlRoaW4gSXRhbGljXCI6IHsgc2VsZWN0b3I6IFwiX19TRi1VSS1EaXNwbGF5LVRoaW4tSXRhbGljX19cIiwgd2VpZ2h0OiAyMDAgfSxcbiAgICBcIkxpZ2h0IEl0YWxpY1wiOiB7IHNlbGVjdG9yOiBcIl9fU0YtVUktRGlzcGxheS1MaWdodC1JdGFsaWNfX1wiLCB3ZWlnaHQ6IDMwMCB9LFxuICAgIFwiTWVkaXVtIEl0YWxpY1wiOiB7IHNlbGVjdG9yOiBcIl9fU0YtVUktRGlzcGxheS1NZWRpdW0tSXRhbGljX19cIiwgd2VpZ2h0OiA1MDAgfSxcbiAgICBcIlNlbWlib2xkIEl0YWxpY1wiOiB7IHNlbGVjdG9yOiBcIl9fU0YtVUktRGlzcGxheS1TZW1pYm9sZC1JdGFsaWNfX1wiLCB3ZWlnaHQ6IDYwMCB9LFxuICAgIFwiQm9sZCBJdGFsaWNcIjogeyBzZWxlY3RvcjogXCJfX1NGLVVJLURpc3BsYXktQm9sZC1JdGFsaWNfX1wiLCB3ZWlnaHQ6IDcwMCB9LFxuICAgIFwiSGVhdnkgSXRhbGljXCI6IHsgc2VsZWN0b3I6IFwiX19TRi1VSS1EaXNwbGF5LUhlYXZ5LUl0YWxpY19fXCIsIHdlaWdodDogODAwIH0sXG4gICAgXCJCbGFjayBJdGFsaWNcIjogeyBzZWxlY3RvcjogXCJfX1NGLVVJLURpc3BsYXktQmxhY2stSXRhbGljX19cIiwgd2VpZ2h0OiA5MDAgfVxuICB9LFxuICBcIlNGIFBybyBEaXNwbGF5IENvbmRlbnNlZFwiOiB7XG4gICAgUmVndWxhcjogeyBzZWxlY3RvcjogXCJfX1NGLVVJLURpc3BsYXktQ29uZGVuc2VkLVJlZ3VsYXJfX1wiLCB3ZWlnaHQ6IDQwMCB9LFxuICAgIFVsdHJhbGlnaHQ6IHsgc2VsZWN0b3I6IFwiX19TRi1VSS1EaXNwbGF5LUNvbmRlbnNlZC1VbHRyYWxpZ2h0X19cIiwgd2VpZ2h0OiAxMDAgfSxcbiAgICBUaGluOiB7IHNlbGVjdG9yOiBcIl9fU0YtVUktRGlzcGxheS1Db25kZW5zZWQtVGhpbl9fXCIsIHdlaWdodDogMjAwIH0sXG4gICAgTGlnaHQ6IHsgc2VsZWN0b3I6IFwiX19TRi1VSS1EaXNwbGF5LUNvbmRlbnNlZC1MaWdodF9fXCIsIHdlaWdodDogMzAwIH0sXG4gICAgTWVkaXVtOiB7IHNlbGVjdG9yOiBcIl9fU0YtVUktRGlzcGxheS1Db25kZW5zZWQtTWVkaXVtX19cIiwgd2VpZ2h0OiA1MDAgfSxcbiAgICBTZW1pYm9sZDogeyBzZWxlY3RvcjogXCJfX1NGLVVJLURpc3BsYXktQ29uZGVuc2VkLVNlbWlib2xkX19cIiwgd2VpZ2h0OiA2MDAgfSxcbiAgICBCb2xkOiB7IHNlbGVjdG9yOiBcIl9fU0YtVUktRGlzcGxheS1Db25kZW5zZWQtQm9sZF9fXCIsIHdlaWdodDogNzAwIH0sXG4gICAgSGVhdnk6IHsgc2VsZWN0b3I6IFwiX19TRi1VSS1EaXNwbGF5LUNvbmRlbnNlZC1IZWF2eV9fXCIsIHdlaWdodDogODAwIH0sXG4gICAgQmxhY2s6IHsgc2VsZWN0b3I6IFwiX19TRi1VSS1EaXNwbGF5LUNvbmRlbnNlZC1CbGFja19fXCIsIHdlaWdodDogOTAwIH1cbiAgfSxcbiAgXCJTRiBQcm8gVGV4dFwiOiB7XG4gICAgUmVndWxhcjogeyBzZWxlY3RvcjogXCJfX1NGLVVJLVRleHQtUmVndWxhcl9fXCIsIHdlaWdodDogNDAwIH0sXG4gICAgTGlnaHQ6IHsgc2VsZWN0b3I6IFwiX19TRi1VSS1UZXh0LUxpZ2h0X19cIiwgd2VpZ2h0OiAyMDAgfSxcbiAgICBNZWRpdW06IHsgc2VsZWN0b3I6IFwiX19TRi1VSS1UZXh0LU1lZGl1bV9fXCIsIHdlaWdodDogNTAwIH0sXG4gICAgU2VtaWJvbGQ6IHsgc2VsZWN0b3I6IFwiX19TRi1VSS1UZXh0LVNlbWlib2xkX19cIiwgd2VpZ2h0OiA2MDAgfSxcbiAgICBCb2xkOiB7IHNlbGVjdG9yOiBcIl9fU0YtVUktVGV4dC1Cb2xkX19cIiwgd2VpZ2h0OiA3MDAgfSxcbiAgICBIZWF2eTogeyBzZWxlY3RvcjogXCJfX1NGLVVJLVRleHQtSGVhdnlfX1wiLCB3ZWlnaHQ6IDgwMCB9LFxuICAgIEl0YWxpYzogeyBzZWxlY3RvcjogXCJfX1NGLVVJLVRleHQtSXRhbGljX19cIiwgd2VpZ2h0OiA0MDAgfSxcbiAgICBcIkxpZ2h0IEl0YWxpY1wiOiB7IHNlbGVjdG9yOiBcIl9fU0YtVUktVGV4dC1MaWdodC1JdGFsaWNfX1wiLCB3ZWlnaHQ6IDIwMCB9LFxuICAgIFwiTWVkaXVtIEl0YWxpY1wiOiB7IHNlbGVjdG9yOiBcIl9fU0YtVUktVGV4dC1NZWRpdW0tSXRhbGljX19cIiwgd2VpZ2h0OiA1MDAgfSxcbiAgICBcIlNlbWlib2xkIEl0YWxpY1wiOiB7IHNlbGVjdG9yOiBcIl9fU0YtVUktVGV4dC1TZW1pYm9sZC1JdGFsaWNfX1wiLCB3ZWlnaHQ6IDYwMCB9LFxuICAgIFwiQm9sZCBJdGFsaWNcIjogeyBzZWxlY3RvcjogXCJfX1NGLVVJLVRleHQtQm9sZC1JdGFsaWNfX1wiLCB3ZWlnaHQ6IDcwMCB9LFxuICAgIFwiSGVhdnkgSXRhbGljXCI6IHsgc2VsZWN0b3I6IFwiX19TRi1VSS1UZXh0LUhlYXZ5LUl0YWxpY19fXCIsIHdlaWdodDogODAwIH1cbiAgfSxcbiAgXCJTRiBQcm8gVGV4dCBDb25kZW5zZWRcIjoge1xuICAgIFJlZ3VsYXI6IHsgc2VsZWN0b3I6IFwiX19TRi1VSS1UZXh0LUNvbmRlbnNlZC1SZWd1bGFyX19cIiwgd2VpZ2h0OiA0MDAgfSxcbiAgICBMaWdodDogeyBzZWxlY3RvcjogXCJfX1NGLVVJLVRleHQtQ29uZGVuc2VkLUxpZ2h0X19cIiwgd2VpZ2h0OiAyMDAgfSxcbiAgICBNZWRpdW06IHsgc2VsZWN0b3I6IFwiX19TRi1VSS1UZXh0LUNvbmRlbnNlZC1NZWRpdW1fX1wiLCB3ZWlnaHQ6IDUwMCB9LFxuICAgIFNlbWlib2xkOiB7IHNlbGVjdG9yOiBcIl9fU0YtVUktVGV4dC1Db25kZW5zZWQtU2VtaWJvbGRfX1wiLCB3ZWlnaHQ6IDYwMCB9LFxuICAgIEJvbGQ6IHsgc2VsZWN0b3I6IFwiX19TRi1VSS1UZXh0LUNvbmRlbnNlZC1Cb2xkX19cIiwgd2VpZ2h0OiA3MDAgfSxcbiAgICBIZWF2eTogeyBzZWxlY3RvcjogXCJfX1NGLVVJLVRleHQtQ29uZGVuc2VkLUhlYXZ5X19cIiwgd2VpZ2h0OiA4MDAgfVxuICB9LFxuICBUYWhvbWE6IHsgUmVndWxhcjogeyBzZWxlY3RvcjogXCJUYWhvbWFcIiwgd2VpZ2h0OiB2b2lkIDAgfSB9LFxuICBUaW1lczogeyBSZWd1bGFyOiB7IHNlbGVjdG9yOiBcIlRpbWVzXCIsIHdlaWdodDogdm9pZCAwIH0gfSxcbiAgXCJUaW1lcyBOZXcgUm9tYW5cIjogeyBSZWd1bGFyOiB7IHNlbGVjdG9yOiBcIlRpbWVzIE5ldyBSb21hblwiLCB3ZWlnaHQ6IHZvaWQgMCB9IH0sXG4gIFRyZWJ1Y2hldDogeyBSZWd1bGFyOiB7IHNlbGVjdG9yOiBcIlRyZWJ1Y2hldCBNU1wiLCB3ZWlnaHQ6IHZvaWQgMCB9IH0sXG4gIFZlcmRhbmE6IHsgUmVndWxhcjogeyBzZWxlY3RvcjogXCJWZXJkYW5hXCIsIHdlaWdodDogdm9pZCAwIH0gfVxufTtcbnZhciB0eXBlZmFjZUFsaWFzZXMgPSB7XG4gIFwiX19TRi1Db21wYWN0LURpc3BsYXktUmVndWxhcl9fXCI6IFwiU0ZDb21wYWN0RGlzcGxheS1SZWd1bGFyfC5TRkNvbXBhY3REaXNwbGF5LVJlZ3VsYXJcIixcbiAgXCJfX1NGLUNvbXBhY3QtRGlzcGxheS1VbHRyYWxpZ2h0X19cIjogXCJTRkNvbXBhY3REaXNwbGF5LVVsdHJhbGlnaHR8LlNGQ29tcGFjdERpc3BsYXktVWx0cmFsaWdodFwiLFxuICBcIl9fU0YtQ29tcGFjdC1EaXNwbGF5LVRoaW5fX1wiOiBcIlNGQ29tcGFjdERpc3BsYXktVGhpbnwuU0ZDb21wYWN0RGlzcGxheS1UaGluXCIsXG4gIFwiX19TRi1Db21wYWN0LURpc3BsYXktTGlnaHRfX1wiOiBcIlNGQ29tcGFjdERpc3BsYXktTGlnaHR8LlNGQ29tcGFjdERpc3BsYXktTGlnaHRcIixcbiAgXCJfX1NGLUNvbXBhY3QtRGlzcGxheS1NZWRpdW1fX1wiOiBcIlNGQ29tcGFjdERpc3BsYXktTWVkaXVtfC5TRkNvbXBhY3REaXNwbGF5LU1lZGl1bVwiLFxuICBcIl9fU0YtQ29tcGFjdC1EaXNwbGF5LVNlbWlib2xkX19cIjogXCJTRkNvbXBhY3REaXNwbGF5LVNlbWlib2xkfC5TRkNvbXBhY3REaXNwbGF5LVNlbWlib2xkXCIsXG4gIFwiX19TRi1Db21wYWN0LURpc3BsYXktSGVhdnlfX1wiOiBcIlNGQ29tcGFjdERpc3BsYXktSGVhdnl8LlNGQ29tcGFjdERpc3BsYXktSGVhdnlcIixcbiAgXCJfX1NGLUNvbXBhY3QtRGlzcGxheS1CbGFja19fXCI6IFwiU0ZDb21wYWN0RGlzcGxheS1CbGFja3wuU0ZDb21wYWN0RGlzcGxheS1CbGFja1wiLFxuICBcIl9fU0YtQ29tcGFjdC1EaXNwbGF5LUJvbGRfX1wiOiBcIlNGQ29tcGFjdERpc3BsYXktQm9sZHwuU0ZDb21wYWN0RGlzcGxheS1Cb2xkXCIsXG4gIFwiX19TRi1VSS1UZXh0LVJlZ3VsYXJfX1wiOiBcIi5TRk5TVGV4dHxTRlByb1RleHQtUmVndWxhcnxTRlVJVGV4dC1SZWd1bGFyfC5TRlVJVGV4dFwiLFxuICBcIl9fU0YtVUktVGV4dC1MaWdodF9fXCI6IFwiLlNGTlNUZXh0LUxpZ2h0fFNGUHJvVGV4dC1MaWdodHxTRlVJVGV4dC1MaWdodHwuU0ZVSVRleHQtTGlnaHRcIixcbiAgXCJfX1NGLVVJLVRleHQtTWVkaXVtX19cIjogXCIuU0ZOU1RleHQtTWVkaXVtfFNGUHJvVGV4dC1NZWRpdW18U0ZVSVRleHQtTWVkaXVtfC5TRlVJVGV4dC1NZWRpdW1cIixcbiAgXCJfX1NGLVVJLVRleHQtU2VtaWJvbGRfX1wiOiBcIi5TRk5TVGV4dC1TZW1pYm9sZHxTRlByb1RleHQtU2VtaWJvbGR8U0ZVSVRleHQtU2VtaWJvbGR8LlNGVUlUZXh0LVNlbWlib2xkXCIsXG4gIFwiX19TRi1VSS1UZXh0LUJvbGRfX1wiOiBcIi5TRk5TVGV4dC1Cb2xkfFNGUHJvVGV4dC1Cb2xkfFNGVUlUZXh0LUJvbGR8LlNGVUlUZXh0LUJvbGRcIixcbiAgXCJfX1NGLVVJLVRleHQtSGVhdnlfX1wiOiBcIi5TRk5TVGV4dC1IZWF2eXxTRlByb1RleHQtSGVhdnl8LlNGVUlUZXh0LUhlYXZ5XCIsXG4gIFwiX19TRi1VSS1UZXh0LUl0YWxpY19fXCI6IFwiLlNGTlNUZXh0LUl0YWxpY3xTRlByb1RleHQtSXRhbGljfFNGVUlUZXh0LUl0YWxpY3wuU0ZVSVRleHQtSXRhbGljXCIsXG4gIFwiX19TRi1VSS1UZXh0LUxpZ2h0LUl0YWxpY19fXCI6IFwiLlNGTlNUZXh0LUxpZ2h0SXRhbGljfFNGUHJvVGV4dC1MaWdodEl0YWxpY3xTRlVJVGV4dC1MaWdodEl0YWxpY3wuU0ZVSVRleHQtTGlnaHRJdGFsaWNcIixcbiAgXCJfX1NGLVVJLVRleHQtTWVkaXVtLUl0YWxpY19fXCI6IFwiLlNGTlNUZXh0LU1lZGl1bUl0YWxpY3xTRlByb1RleHQtTWVkaXVtSXRhbGljfFNGVUlUZXh0LU1lZGl1bUl0YWxpY3wuU0ZVSVRleHQtTWVkaXVtSXRhbGljXCIsXG4gIFwiX19TRi1VSS1UZXh0LVNlbWlib2xkLUl0YWxpY19fXCI6IFwiLlNGTlNUZXh0LVNlbWlib2xkSXRhbGljfFNGUHJvVGV4dC1TZW1pYm9sZEl0YWxpY3xTRlVJVGV4dC1TZW1pYm9sZEl0YWxpY3wuU0ZVSVRleHQtU2VtaWJvbGRJdGFsaWNcIixcbiAgXCJfX1NGLVVJLVRleHQtQm9sZC1JdGFsaWNfX1wiOiBcIi5TRk5TVGV4dC1Cb2xkSXRhbGljfFNGUHJvVGV4dC1Cb2xkSXRhbGljfFNGVUlUZXh0LUJvbGRJdGFsaWN8LlNGVUlUZXh0LUJvbGRJdGFsaWNcIixcbiAgXCJfX1NGLVVJLVRleHQtSGVhdnktSXRhbGljX19cIjogXCIuU0ZOU1RleHQtSGVhdnlJdGFsaWN8U0ZQcm9UZXh0LUhlYXZ5SXRhbGljfC5TRlVJVGV4dC1IZWF2eUl0YWxpY1wiLFxuICBcIl9fU0YtQ29tcGFjdC1UZXh0LVJlZ3VsYXJfX1wiOiBcIlNGQ29tcGFjdFRleHQtUmVndWxhcnwuU0ZDb21wYWN0VGV4dC1SZWd1bGFyXCIsXG4gIFwiX19TRi1Db21wYWN0LVRleHQtTGlnaHRfX1wiOiBcIlNGQ29tcGFjdFRleHQtTGlnaHR8LlNGQ29tcGFjdFRleHQtTGlnaHRcIixcbiAgXCJfX1NGLUNvbXBhY3QtVGV4dC1NZWRpdW1fX1wiOiBcIlNGQ29tcGFjdFRleHQtTWVkaXVtfC5TRkNvbXBhY3RUZXh0LU1lZGl1bVwiLFxuICBcIl9fU0YtQ29tcGFjdC1UZXh0LVNlbWlib2xkX19cIjogXCJTRkNvbXBhY3RUZXh0LVNlbWlib2xkfC5TRkNvbXBhY3RUZXh0LVNlbWlib2xkXCIsXG4gIFwiX19TRi1Db21wYWN0LVRleHQtQm9sZF9fXCI6IFwiU0ZDb21wYWN0VGV4dC1Cb2xkfC5TRkNvbXBhY3RUZXh0LUJvbGRcIixcbiAgXCJfX1NGLUNvbXBhY3QtVGV4dC1IZWF2eV9fXCI6IFwiU0ZDb21wYWN0VGV4dC1IZWF2eXwuU0ZDb21wYWN0VGV4dC1IZWF2eVwiLFxuICBcIl9fU0YtQ29tcGFjdC1UZXh0LUl0YWxpY19fXCI6IFwiU0ZDb21wYWN0VGV4dC1JdGFsaWN8LlNGQ29tcGFjdFRleHQtSXRhbGljXCIsXG4gIFwiX19TRi1Db21wYWN0LVRleHQtTGlnaHQtSXRhbGljX19cIjogXCJTRkNvbXBhY3RUZXh0LUxpZ2h0SXRhbGljfC5TRkNvbXBhY3RUZXh0LUxpZ2h0SXRhbGljXCIsXG4gIFwiX19TRi1Db21wYWN0LVRleHQtTWVkaXVtLUl0YWxpY19fXCI6IFwiU0ZDb21wYWN0VGV4dC1NZWRpdW1JdGFsaWN8LlNGQ29tcGFjdFRleHQtTWVkaXVtSXRhbGljXCIsXG4gIFwiX19TRi1Db21wYWN0LVRleHQtU2VtaWJvbGQtSXRhbGljX19cIjogXCJTRkNvbXBhY3RUZXh0LVNlbWlib2xkSXRhbGljfC5TRkNvbXBhY3RUZXh0LVNlbWlib2xkSXRhbGljXCIsXG4gIFwiX19TRi1Db21wYWN0LVRleHQtQm9sZC1JdGFsaWNfX1wiOiBcIlNGQ29tcGFjdFRleHQtQm9sZEl0YWxpY3wuU0ZDb21wYWN0VGV4dC1Cb2xkSXRhbGljXCIsXG4gIFwiX19TRi1Db21wYWN0LVRleHQtSGVhdnktSXRhbGljX19cIjogXCJTRkNvbXBhY3RUZXh0LUhlYXZ5SXRhbGljfC5TRkNvbXBhY3RUZXh0LUhlYXZ5SXRhbGljXCIsXG4gIFwiX19TRi1VSS1EaXNwbGF5LUNvbmRlbnNlZC1SZWd1bGFyX19cIjogXCIuU0ZOU0Rpc3BsYXlDb25kZW5zZWQtUmVndWxhcnxTRlVJRGlzcGxheUNvbmRlbnNlZC1SZWd1bGFyfC5TRlVJRGlzcGxheUNvbmRlbnNlZC1SZWd1bGFyXCIsXG4gIFwiX19TRi1VSS1EaXNwbGF5LUNvbmRlbnNlZC1VbHRyYWxpZ2h0X19cIjogXCIuU0ZOU0Rpc3BsYXlDb25kZW5zZWQtVWx0cmFsaWdodHxTRlVJRGlzcGxheUNvbmRlbnNlZC1VbHRyYWxpZ2h0fC5TRlVJRGlzcGxheUNvbmRlbnNlZC1VbHRyYWxpZ2h0XCIsXG4gIFwiX19TRi1VSS1EaXNwbGF5LUNvbmRlbnNlZC1UaGluX19cIjogXCIuU0ZOU0Rpc3BsYXlDb25kZW5zZWQtVGhpbnxTRlVJRGlzcGxheUNvbmRlbnNlZC1UaGlufC5TRlVJRGlzcGxheUNvbmRlbnNlZC1UaGluXCIsXG4gIFwiX19TRi1VSS1EaXNwbGF5LUNvbmRlbnNlZC1MaWdodF9fXCI6IFwiLlNGTlNEaXNwbGF5Q29uZGVuc2VkLUxpZ2h0fFNGVUlEaXNwbGF5Q29uZGVuc2VkLUxpZ2h0fC5TRlVJRGlzcGxheUNvbmRlbnNlZC1MaWdodFwiLFxuICBcIl9fU0YtVUktRGlzcGxheS1Db25kZW5zZWQtTWVkaXVtX19cIjogXCIuU0ZOU0Rpc3BsYXlDb25kZW5zZWQtTWVkaXVtfFNGVUlEaXNwbGF5Q29uZGVuc2VkLU1lZGl1bXwuU0ZVSURpc3BsYXlDb25kZW5zZWQtTWVkaXVtXCIsXG4gIFwiX19TRi1VSS1EaXNwbGF5LUNvbmRlbnNlZC1TZW1pYm9sZF9fXCI6IFwiLlNGTlNEaXNwbGF5Q29uZGVuc2VkLVNlbWlib2xkfFNGVUlEaXNwbGF5Q29uZGVuc2VkLVNlbWlib2xkfC5TRlVJRGlzcGxheUNvbmRlbnNlZC1TZW1pYm9sZFwiLFxuICBcIl9fU0YtVUktRGlzcGxheS1Db25kZW5zZWQtQm9sZF9fXCI6IFwiLlNGTlNEaXNwbGF5Q29uZGVuc2VkLUJvbGR8U0ZVSURpc3BsYXlDb25kZW5zZWQtQm9sZHwuU0ZVSURpc3BsYXlDb25kZW5zZWQtQm9sZFwiLFxuICBcIl9fU0YtVUktRGlzcGxheS1Db25kZW5zZWQtSGVhdnlfX1wiOiBcIi5TRk5TRGlzcGxheUNvbmRlbnNlZC1IZWF2eXxTRlVJRGlzcGxheUNvbmRlbnNlZC1IZWF2eXwuU0ZVSURpc3BsYXlDb25kZW5zZWQtSGVhdnlcIixcbiAgXCJfX1NGLVVJLURpc3BsYXktQ29uZGVuc2VkLUJsYWNrX19cIjogXCIuU0ZOU0Rpc3BsYXlDb25kZW5zZWQtQmxhY2t8LlNGVUlEaXNwbGF5Q29uZGVuc2VkLUJsYWNrXCIsXG4gIFwiX19TRi1VSS1EaXNwbGF5LVJlZ3VsYXJfX1wiOiBcIi5TRk5TRGlzcGxheXxTRlByb0Rpc3BsYXktUmVndWxhcnxTRlVJRGlzcGxheS1SZWd1bGFyfC5TRlVJRGlzcGxheVwiLFxuICBcIl9fU0YtVUktRGlzcGxheS1VbHRyYWxpZ2h0X19cIjogXCIuU0ZOU0Rpc3BsYXktVWx0cmFsaWdodHxTRlByb0Rpc3BsYXktVWx0cmFsaWdodHxTRlVJRGlzcGxheS1VbHRyYWxpZ2h0fC5TRlVJRGlzcGxheS1VbHRyYWxpZ2h0XCIsXG4gIFwiX19TRi1VSS1EaXNwbGF5LVRoaW5fX1wiOiBcIi5TRk5TRGlzcGxheS1UaGlufFNGUHJvRGlzcGxheS1UaGlufFNGVUlEaXNwbGF5LVRoaW58LlNGVUlEaXNwbGF5LVRoaW5cIixcbiAgXCJfX1NGLVVJLURpc3BsYXktTGlnaHRfX1wiOiBcIi5TRk5TRGlzcGxheS1MaWdodHxTRlByb0Rpc3BsYXktTGlnaHR8U0ZVSURpc3BsYXktTGlnaHR8LlNGVUlEaXNwbGF5LUxpZ2h0XCIsXG4gIFwiX19TRi1VSS1EaXNwbGF5LU1lZGl1bV9fXCI6IFwiLlNGTlNEaXNwbGF5LU1lZGl1bXxTRlByb0Rpc3BsYXktTWVkaXVtfFNGVUlEaXNwbGF5LU1lZGl1bXwuU0ZVSURpc3BsYXktTWVkaXVtXCIsXG4gIFwiX19TRi1VSS1EaXNwbGF5LVNlbWlib2xkX19cIjogXCIuU0ZOU0Rpc3BsYXktU2VtaWJvbGR8U0ZQcm9EaXNwbGF5LVNlbWlib2xkfFNGVUlEaXNwbGF5LVNlbWlib2xkfC5TRlVJRGlzcGxheS1TZW1pYm9sZFwiLFxuICBcIl9fU0YtVUktRGlzcGxheS1Cb2xkX19cIjogXCIuU0ZOU0Rpc3BsYXktQm9sZHxTRlByb0Rpc3BsYXktQm9sZHxTRlVJRGlzcGxheS1Cb2xkfC5TRlVJRGlzcGxheS1Cb2xkXCIsXG4gIFwiX19TRi1VSS1EaXNwbGF5LUhlYXZ5X19cIjogXCIuU0ZOU0Rpc3BsYXktSGVhdnl8U0ZQcm9EaXNwbGF5LUhlYXZ5fFNGVUlEaXNwbGF5LUhlYXZ5fC5TRlVJRGlzcGxheS1IZWF2eVwiLFxuICBcIl9fU0YtVUktRGlzcGxheS1CbGFja19fXCI6IFwiLlNGTlNEaXNwbGF5LUJsYWNrfFNGUHJvRGlzcGxheS1CbGFja3wuU0ZVSURpc3BsYXktQmxhY2tcIixcbiAgXCJfX1NGLVVJLURpc3BsYXktSXRhbGljX19cIjogXCIuU0ZOU0Rpc3BsYXktSXRhbGljfFNGUHJvRGlzcGxheS1JdGFsaWN8U0ZVSURpc3BsYXktSXRhbGljXCIsXG4gIFwiX19TRi1VSS1EaXNwbGF5LVVsdHJhbGlnaHQtSXRhbGljX19cIjogXCIuU0ZOU0Rpc3BsYXktVWx0cmFsaWdodEl0YWxpY3xTRlByb0Rpc3BsYXktVWx0cmFsaWdodEl0YWxpY3xTRlVJRGlzcGxheS1VbHRyYWxpZ2h0SXRhbGljfC5TRlVJRGlzcGxheS1VbHRyYWxpZ2h0SXRhbGljXCIsXG4gIFwiX19TRi1VSS1EaXNwbGF5LVRoaW4tSXRhbGljX19cIjogXCIuU0ZOU0Rpc3BsYXktVGhpbkl0YWxpY3xTRlByb0Rpc3BsYXktVGhpbkl0YWxpY3xTRlVJRGlzcGxheS1UaGluSXRhbGljfC5TRlVJRGlzcGxheS1UaGluSXRhbGljXCIsXG4gIFwiX19TRi1VSS1EaXNwbGF5LUxpZ2h0LUl0YWxpY19fXCI6IFwiLlNGTlNEaXNwbGF5LUxpZ2h0SXRhbGljfFNGUHJvRGlzcGxheS1MaWdodEl0YWxpY3xTRlVJRGlzcGxheS1MaWdodEl0YWxpY3wuU0ZVSURpc3BsYXktTGlnaHRJdGFsaWNcIixcbiAgXCJfX1NGLVVJLURpc3BsYXktTWVkaXVtLUl0YWxpY19fXCI6IFwiLlNGTlNEaXNwbGF5LU1lZGl1bUl0YWxpY3xTRlByb0Rpc3BsYXktTWVkaXVtSXRhbGljfFNGVUlEaXNwbGF5LU1lZGl1bUl0YWxpY3wuU0ZVSURpc3BsYXktTWVkaXVtSXRhbGljXCIsXG4gIFwiX19TRi1VSS1EaXNwbGF5LVNlbWlib2xkLUl0YWxpY19fXCI6IFwiLlNGTlNEaXNwbGF5LVNlbWlib2xkSXRhbGljfFNGUHJvRGlzcGxheS1TZW1pYm9sZEl0YWxpY3xTRlVJRGlzcGxheS1TZW1pYm9sZEl0YWxpY3wuU0ZVSURpc3BsYXktU2VtaWJvbGRJdGFsaWNcIixcbiAgXCJfX1NGLVVJLURpc3BsYXktQm9sZC1JdGFsaWNfX1wiOiBcIi5TRk5TRGlzcGxheS1Cb2xkSXRhbGljfFNGUHJvRGlzcGxheS1Cb2xkSXRhbGljfFNGVUlEaXNwbGF5LUJvbGRJdGFsaWN8LlNGVUlEaXNwbGF5LUJvbGRJdGFsaWNcIixcbiAgXCJfX1NGLVVJLURpc3BsYXktSGVhdnktSXRhbGljX19cIjogXCIuU0ZOU0Rpc3BsYXktSGVhdnlJdGFsaWN8U0ZQcm9EaXNwbGF5LUhlYXZ5SXRhbGljfFNGVUlEaXNwbGF5LUhlYXZ5SXRhbGljfC5TRlVJRGlzcGxheS1IZWF2eUl0YWxpY1wiLFxuICBcIl9fU0YtVUktRGlzcGxheS1CbGFjay1JdGFsaWNfX1wiOiBcIi5TRk5TRGlzcGxheS1CbGFja0l0YWxpY3xTRlByb0Rpc3BsYXktQmxhY2tJdGFsaWN8LlNGVUlEaXNwbGF5LUJsYWNrSXRhbGljXCIsXG4gIFwiX19TRi1VSS1UZXh0LUNvbmRlbnNlZC1SZWd1bGFyX19cIjogXCIuU0ZOU1RleHRDb25kZW5zZWQtUmVndWxhcnxTRlVJVGV4dENvbmRlbnNlZC1SZWd1bGFyfC5TRlVJVGV4dENvbmRlbnNlZC1SZWd1bGFyXCIsXG4gIFwiX19TRi1VSS1UZXh0LUNvbmRlbnNlZC1MaWdodF9fXCI6IFwiLlNGTlNUZXh0Q29uZGVuc2VkLUxpZ2h0fFNGVUlUZXh0Q29uZGVuc2VkLUxpZ2h0fC5TRlVJVGV4dENvbmRlbnNlZC1MaWdodFwiLFxuICBcIl9fU0YtVUktVGV4dC1Db25kZW5zZWQtTWVkaXVtX19cIjogXCIuU0ZOU1RleHRDb25kZW5zZWQtTWVkaXVtfFNGVUlUZXh0Q29uZGVuc2VkLU1lZGl1bXwuU0ZVSVRleHRDb25kZW5zZWQtTWVkaXVtXCIsXG4gIFwiX19TRi1VSS1UZXh0LUNvbmRlbnNlZC1TZW1pYm9sZF9fXCI6IFwiLlNGTlNUZXh0Q29uZGVuc2VkLVNlbWlib2xkfFNGVUlUZXh0Q29uZGVuc2VkLVNlbWlib2xkfC5TRlVJVGV4dENvbmRlbnNlZC1TZW1pYm9sZFwiLFxuICBcIl9fU0YtVUktVGV4dC1Db25kZW5zZWQtQm9sZF9fXCI6IFwiLlNGTlNUZXh0Q29uZGVuc2VkLUJvbGR8U0ZVSVRleHRDb25kZW5zZWQtQm9sZHwuU0ZVSVRleHRDb25kZW5zZWQtQm9sZFwiLFxuICBcIl9fU0YtVUktVGV4dC1Db25kZW5zZWQtSGVhdnlfX1wiOiBcIi5TRk5TVGV4dENvbmRlbnNlZC1IZWF2eXwuU0ZVSVRleHRDb25kZW5zZWQtSGVhdnlcIixcbiAgXCJfX1NGLUNvbXBhY3QtUm91bmRlZC1SZWd1bGFyX19cIjogXCJTRkNvbXBhY3RSb3VuZGVkLVJlZ3VsYXJ8LlNGQ29tcGFjdFJvdW5kZWQtUmVndWxhclwiLFxuICBcIl9fU0YtQ29tcGFjdC1Sb3VuZGVkLVVsdHJhbGlnaHRfX1wiOiBcIlNGQ29tcGFjdFJvdW5kZWQtVWx0cmFsaWdodHwuU0ZDb21wYWN0Um91bmRlZC1VbHRyYWxpZ2h0XCIsXG4gIFwiX19TRi1Db21wYWN0LVJvdW5kZWQtVGhpbl9fXCI6IFwiU0ZDb21wYWN0Um91bmRlZC1UaGlufC5TRkNvbXBhY3RSb3VuZGVkLVRoaW5cIixcbiAgXCJfX1NGLUNvbXBhY3QtUm91bmRlZC1MaWdodF9fXCI6IFwiU0ZDb21wYWN0Um91bmRlZC1MaWdodHwuU0ZDb21wYWN0Um91bmRlZC1MaWdodFwiLFxuICBcIl9fU0YtQ29tcGFjdC1Sb3VuZGVkLU1lZGl1bV9fXCI6IFwiU0ZDb21wYWN0Um91bmRlZC1NZWRpdW18LlNGQ29tcGFjdFJvdW5kZWQtTWVkaXVtXCIsXG4gIFwiX19TRi1Db21wYWN0LVJvdW5kZWQtU2VtaWJvbGRfX1wiOiBcIlNGQ29tcGFjdFJvdW5kZWQtU2VtaWJvbGR8LlNGQ29tcGFjdFJvdW5kZWQtU2VtaWJvbGRcIixcbiAgXCJfX1NGLUNvbXBhY3QtUm91bmRlZC1Cb2xkX19cIjogXCJTRkNvbXBhY3RSb3VuZGVkLUJvbGR8LlNGQ29tcGFjdFJvdW5kZWQtQm9sZFwiLFxuICBcIl9fU0YtQ29tcGFjdC1Sb3VuZGVkLUhlYXZ5X19cIjogXCJTRkNvbXBhY3RSb3VuZGVkLUhlYXZ5fC5TRkNvbXBhY3RSb3VuZGVkLUhlYXZ5XCIsXG4gIFwiX19TRi1Db21wYWN0LVJvdW5kZWQtQmxhY2tfX1wiOiBcIlNGQ29tcGFjdFJvdW5kZWQtQmxhY2t8LlNGQ29tcGFjdFJvdW5kZWQtQmxhY2tcIlxufTtcbnZhciB0eXBlZmFjZXMgPSB0eXBlb2Ygc2FmZVdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzYWZlV2luZG93W1wiU3lzdGVtVHlwZWZhY2VEZXNjcmlwdG9yc1wiXSAhPT0gdm9pZCAwID8gY29udmVydFRvT2JqZWN0KHNhZmVXaW5kb3dbXCJTeXN0ZW1UeXBlZmFjZURlc2NyaXB0b3JzXCJdKSA6IHNhZmVGb250cztcbnZhciBkZWZhdWx0Rm9udFNlbGVjdG9yID0gdHlwZW9mIHNhZmVXaW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHNhZmVXaW5kb3dbXCJTeXN0ZW1UeXBlZmFjZURlZmF1bHRTZWxlY3RvclwiXSA9PT0gXCJzdHJpbmdcIiA/IHNhZmVXaW5kb3dbXCJTeXN0ZW1UeXBlZmFjZURlZmF1bHRTZWxlY3RvclwiXSA6IFwiSW50ZXJcIjtcblxuLy8gc3JjL3JlbmRlci9mb250cy90eXBlcy50c1xudmFyIFR5cGVmYWNlU291cmNlTmFtZXM7XG4oZnVuY3Rpb24oVHlwZWZhY2VTb3VyY2VOYW1lczIpIHtcbiAgVHlwZWZhY2VTb3VyY2VOYW1lczJbXCJHb29nbGVcIl0gPSBcImdvb2dsZVwiO1xuICBUeXBlZmFjZVNvdXJjZU5hbWVzMltcIkxvY2FsXCJdID0gXCJsb2NhbFwiO1xuICBUeXBlZmFjZVNvdXJjZU5hbWVzMltcIkN1c3RvbVwiXSA9IFwiY3VzdG9tXCI7XG59KShUeXBlZmFjZVNvdXJjZU5hbWVzIHx8IChUeXBlZmFjZVNvdXJjZU5hbWVzID0ge30pKTtcblxuLy8gc3JjL3JlbmRlci9mb250cy9Hb29nbGVGb250U291cmNlLnRzXG52YXIgZ29vZ2xlRm9udFNlbGVjdG9yUHJlZml4ID0gXCJHRjtcIjtcbnZhciBHb29nbGVGb250U291cmNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5hbWUgPSBUeXBlZmFjZVNvdXJjZU5hbWVzLkdvb2dsZTtcbiAgICB0aGlzLnR5cGVmYWNlcyA9IFtdO1xuICAgIHRoaXMuYnlGYW1pbHkgPSBuZXcgTWFwKCk7XG4gIH1cbiAgZ2V0VHlwZWZhY2VCeUZhbWlseShmYW1pbHkpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMuYnlGYW1pbHkuZ2V0KGZhbWlseSkpICE9IG51bGwgPyBfYSA6IG51bGw7XG4gIH1cbiAgcGFyc2VTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIGlmICghc2VsZWN0b3Iuc3RhcnRzV2l0aChnb29nbGVGb250U2VsZWN0b3JQcmVmaXgpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgdG9rZW5zID0gc2VsZWN0b3Iuc3BsaXQoXCItXCIpO1xuICAgIGlmICh0b2tlbnMubGVuZ3RoICE9PSAyKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgZmFtaWx5ID0gdG9rZW5zWzBdLnJlcGxhY2UoZ29vZ2xlRm9udFNlbGVjdG9yUHJlZml4LCBcIlwiKTtcbiAgICBjb25zdCB2YXJpYW50ID0gdG9rZW5zWzFdO1xuICAgIHJldHVybiB7IGZhbWlseSwgdmFyaWFudCwgc291cmNlOiB0aGlzLm5hbWUgfTtcbiAgfVxuICBjcmVhdGVUeXBlZmFjZShmYW1pbHkpIHtcbiAgICBjb25zdCB0eXBlZmFjZSA9IHsgZmFtaWx5LCBmb250czogW10sIHNvdXJjZTogdGhpcy5uYW1lIH07XG4gICAgdGhpcy5hZGRUeXBlZmFjZSh0eXBlZmFjZSk7XG4gICAgcmV0dXJuIHR5cGVmYWNlO1xuICB9XG4gIGFkZFR5cGVmYWNlKHR5cGVmYWNlKSB7XG4gICAgdGhpcy50eXBlZmFjZXMucHVzaCh0eXBlZmFjZSk7XG4gICAgdGhpcy5ieUZhbWlseS5zZXQodHlwZWZhY2UuZmFtaWx5LCB0eXBlZmFjZSk7XG4gIH1cbiAgaW1wb3J0Rm9udHMod2ViRm9udHMpIHtcbiAgICBsZXQgZm9udExvY2F0b3JzID0gW107XG4gICAgd2ViRm9udHMuZm9yRWFjaCgod2ViRm9udCkgPT4ge1xuICAgICAgY29uc3QgbG9jYXRvcnMgPSB3ZWJGb250LnZhcmlhbnRzLm1hcCgodmFyaWFudCkgPT4gKHtcbiAgICAgICAgc291cmNlOiB0aGlzLm5hbWUsXG4gICAgICAgIHZhcmlhbnQsXG4gICAgICAgIGZhbWlseTogd2ViRm9udC5mYW1pbHksXG4gICAgICAgIGZpbGU6IHdlYkZvbnQuZmlsZXNbdmFyaWFudF0ucmVwbGFjZShcImh0dHA6Ly9cIiwgXCJodHRwczovL1wiKVxuICAgICAgfSkpO1xuICAgICAgZm9udExvY2F0b3JzID0gZm9udExvY2F0b3JzLmNvbmNhdChsb2NhdG9ycyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvbnRMb2NhdG9ycztcbiAgfVxufTtcblxuLy8gc3JjL3JlbmRlci9mb250cy9Mb2NhbEZvbnRTb3VyY2UudHNcbnZhciBzeXN0ZW1UeXBlZmFjZU5hbWUgPSBcIlN5c3RlbSBEZWZhdWx0XCI7XG52YXIgTG9jYWxGb250U291cmNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5hbWUgPSBUeXBlZmFjZVNvdXJjZU5hbWVzLkxvY2FsO1xuICAgIHRoaXMudHlwZWZhY2VzID0gW107XG4gICAgdGhpcy5ieUZhbWlseSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnR5cGVmYWNlQWxpYXNCeVNlbGVjdG9yID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudHlwZWZhY2VBbGlhc2VzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuaW50ZXJUeXBlZmFjZVNlbGVjdG9ycyA9IG5ldyBTZXQoKTtcbiAgfVxuICBnZXRUeXBlZmFjZUJ5RmFtaWx5KGZhbWlseSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5ieUZhbWlseS5nZXQoZmFtaWx5KSkgIT0gbnVsbCA/IF9hIDogbnVsbDtcbiAgfVxuICBjcmVhdGVUeXBlZmFjZShmYW1pbHkpIHtcbiAgICBjb25zdCB0eXBlZmFjZSA9IHsgZmFtaWx5LCBmb250czogW10sIHNvdXJjZTogdGhpcy5uYW1lIH07XG4gICAgdGhpcy5hZGRUeXBlZmFjZSh0eXBlZmFjZSk7XG4gICAgcmV0dXJuIHR5cGVmYWNlO1xuICB9XG4gIGFkZFR5cGVmYWNlKHR5cGVmYWNlKSB7XG4gICAgdGhpcy50eXBlZmFjZXMucHVzaCh0eXBlZmFjZSk7XG4gICAgdGhpcy5ieUZhbWlseS5zZXQodHlwZWZhY2UuZmFtaWx5LCB0eXBlZmFjZSk7XG4gIH1cbiAgaW1wb3J0Rm9udHMoKSB7XG4gICAgY29uc3QgZm9udHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZhbWlseSBvZiBPYmplY3Qua2V5cyh0eXBlZmFjZXMpKSB7XG4gICAgICBjb25zdCBtZW1iZXJzID0gdHlwZWZhY2VzW2ZhbWlseV07XG4gICAgICBpZiAoIW1lbWJlcnMpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdHlwZWZhY2UgPSB0aGlzLmNyZWF0ZVR5cGVmYWNlKGZhbWlseSk7XG4gICAgICBmb3IgKGNvbnN0IHZhcmlhbnQgb2YgT2JqZWN0LmtleXMobWVtYmVycykpIHtcbiAgICAgICAgY29uc3QgbWVtYmVyID0gbWVtYmVyc1t2YXJpYW50XTtcbiAgICAgICAgaWYgKCFtZW1iZXIpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0b3IsIHdlaWdodCB9ID0gbWVtYmVyO1xuICAgICAgICBjb25zdCBmb250ID0ge1xuICAgICAgICAgIHZhcmlhbnQsXG4gICAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgICAgd2VpZ2h0LFxuICAgICAgICAgIHR5cGVmYWNlLFxuICAgICAgICAgIHN0YXR1czogXCJsb2FkZWRcIlxuICAgICAgICB9O1xuICAgICAgICB0eXBlZmFjZS5mb250cy5wdXNoKGZvbnQpO1xuICAgICAgfVxuICAgICAgZm9udHMucHVzaCguLi50eXBlZmFjZS5mb250cyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2tleTYsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0eXBlZmFjZUFsaWFzZXMpKSB7XG4gICAgICB0aGlzLmFkZFR5cGVmYWNlQWxpYXMoa2V5NiwgdmFsdWUpO1xuICAgIH1cbiAgICBjb25zdCB7IHR5cGVmYWNlOiBzeXN0ZW1UeXBlZmFjZSwgYWxpYXNlcyB9ID0gdGhpcy5nZXRTeXN0ZW1UeXBlZmFjZSgpO1xuICAgIHRoaXMuYWRkVHlwZWZhY2Uoc3lzdGVtVHlwZWZhY2UpO1xuICAgIGZvciAoY29uc3QgW2tleTYsIHZhbHVlXSBvZiBhbGlhc2VzKSB7XG4gICAgICB0aGlzLmFkZFR5cGVmYWNlQWxpYXMoa2V5NiwgdmFsdWUpO1xuICAgIH1cbiAgICBmb250cy5wdXNoKC4uLnN5c3RlbVR5cGVmYWNlLmZvbnRzKTtcbiAgICBjb25zdCBpbnRlclR5cGVmYWNlID0gdGhpcy5pbXBvcnRJbnRlclR5cGVmYWNlKCk7XG4gICAgZm9udHMucHVzaCguLi5pbnRlclR5cGVmYWNlLmZvbnRzKTtcbiAgICByZXR1cm4gZm9udHM7XG4gIH1cbiAgaW1wb3J0SW50ZXJUeXBlZmFjZSgpIHtcbiAgICBjb25zdCBpbnRlciA9IFtcbiAgICAgIFtcIlJlZ3VsYXJcIiwgXCJJbnRlclwiLCB2b2lkIDBdLFxuICAgICAgW1wiVGhpblwiLCBcIkludGVyLVRoaW5cIiwgMTAwXSxcbiAgICAgIFtcIkV4dHJhIExpZ2h0XCIsIFwiSW50ZXItRXh0cmFMaWdodFwiLCAyMDBdLFxuICAgICAgW1wiTGlnaHRcIiwgXCJJbnRlci1MaWdodFwiLCAzMDBdLFxuICAgICAgW1wiTWVkaXVtXCIsIFwiSW50ZXItTWVkaXVtXCIsIDUwMF0sXG4gICAgICBbXCJTZW1pYm9sZFwiLCBcIkludGVyLVNlbWlCb2xkXCIsIDYwMF0sXG4gICAgICBbXCJCb2xkXCIsIFwiSW50ZXItQm9sZFwiLCA3MDBdLFxuICAgICAgW1wiRXh0cmEgQm9sZFwiLCBcIkludGVyLUV4dHJhQm9sZFwiLCA4MDBdLFxuICAgICAgW1wiQmxhY2tcIiwgXCJJbnRlci1CbGFja1wiLCA5MDBdLFxuICAgICAgW1wiVGhpbiBJdGFsaWNcIiwgXCJJbnRlci1UaGluSXRhbGljXCIsIDEwMF0sXG4gICAgICBbXCJFeHRyYSBMaWdodCBJdGFsaWNcIiwgXCJJbnRlci1FeHRyYUxpZ2h0SXRhbGljXCIsIDMwMF0sXG4gICAgICBbXCJMaWdodCBJdGFsaWNcIiwgXCJJbnRlci1MaWdodEl0YWxpY1wiLCAzMDBdLFxuICAgICAgW1wiSXRhbGljXCIsIFwiSW50ZXItSXRhbGljXCIsIHZvaWQgMF0sXG4gICAgICBbXCJNZWRpdW0gSXRhbGljXCIsIFwiSW50ZXItTWVkaXVtSXRhbGljXCIsIDUwMF0sXG4gICAgICBbXCJTZW1pYm9sZCBJdGFsaWNcIiwgXCJJbnRlci1TZW1pQm9sZEl0YWxpY1wiLCA2MDBdLFxuICAgICAgW1wiQm9sZCBJdGFsaWNcIiwgXCJJbnRlci1Cb2xkSXRhbGljXCIsIDcwMF0sXG4gICAgICBbXCJFeHRyYSBCb2xkIEl0YWxpY1wiLCBcIkludGVyLUV4dHJhQm9sZEl0YWxpY1wiLCA4MDBdLFxuICAgICAgW1wiQmxhY2sgSXRhbGljXCIsIFwiSW50ZXItQmxhY2tJdGFsaWNcIiwgOTAwXVxuICAgIF07XG4gICAgY29uc3QgdHlwZWZhY2UgPSB0aGlzLmNyZWF0ZVR5cGVmYWNlKFwiSW50ZXJcIik7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBpbnRlcikge1xuICAgICAgY29uc3QgW3ZhcmlhbnQsIHNlbGVjdG9yLCB3ZWlnaHRdID0gZW50cnk7XG4gICAgICBjb25zdCBmb250ID0ge1xuICAgICAgICB2YXJpYW50LFxuICAgICAgICBzZWxlY3RvcixcbiAgICAgICAgd2VpZ2h0LFxuICAgICAgICB0eXBlZmFjZSxcbiAgICAgICAgc3R5bGU6IC9pdGFsaWMvaS50ZXN0KHNlbGVjdG9yKSA/IFwiaXRhbGljXCIgOiB2b2lkIDBcbiAgICAgIH07XG4gICAgICB0eXBlZmFjZS5mb250cy5wdXNoKGZvbnQpO1xuICAgIH1cbiAgICB0eXBlZmFjZS5mb250cy5mb3JFYWNoKCh0KSA9PiB0aGlzLmludGVyVHlwZWZhY2VTZWxlY3RvcnMuYWRkKHQuc2VsZWN0b3IpKTtcbiAgICByZXR1cm4gdHlwZWZhY2U7XG4gIH1cbiAgYWRkVHlwZWZhY2VBbGlhcyhrZXk2LCB2YWx1ZSkge1xuICAgIHRoaXMudHlwZWZhY2VBbGlhc2VzLnNldChrZXk2LCB2YWx1ZSk7XG4gICAgdGhpcy50eXBlZmFjZUFsaWFzQnlTZWxlY3Rvci5zZXQodmFsdWUsIGtleTYpO1xuICB9XG4gIGdldFN5c3RlbVR5cGVmYWNlKCkge1xuICAgIGNvbnN0IGZvbnRGYW1pbGllcyA9IHRoaXMud29ya2Fyb3VuZENocm9tZTgxYW5kODIoXCJzeXN0ZW0tdWl8LWFwcGxlLXN5c3RlbXxCbGlua01hY1N5c3RlbUZvbnR8U2Vnb2UgVUl8Um9ib3RvfE94eWdlbnxVYnVudHV8Q2FudGFyZWxsfEZpcmEgU2Fuc3xEcm9pZCBTYW5zfEhlbHZldGljYSBOZXVlfHNhbnMtc2VyaWZcIik7XG4gICAgY29uc3QgdHlwZWZhY2UgPSB7IGZhbWlseTogc3lzdGVtVHlwZWZhY2VOYW1lLCBmb250czogW10sIHNvdXJjZTogdGhpcy5uYW1lIH07XG4gICAgY29uc3QgYWxpYXNlcyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCB3ZWlnaHRzID0gWzQwMCwgMTAwLCAyMDAsIDMwMCwgNTAwLCA2MDAsIDcwMCwgODAwLCA5MDBdO1xuICAgIGNvbnN0IHN0eWxlcyA9IFtcIm5vcm1hbFwiLCBcIml0YWxpY1wiXTtcbiAgICBmb3IgKGNvbnN0IHN0eWxlIG9mIHN0eWxlcykge1xuICAgICAgZm9yIChjb25zdCB3ZWlnaHQgb2Ygd2VpZ2h0cykge1xuICAgICAgICBjb25zdCB2YXJpYW50ID0gY3JlYXRlVmFyaWFudE5hbWUod2VpZ2h0LCBzdHlsZSk7XG4gICAgICAgIGNvbnN0IGFsaWFzID0gYF9fU3lzdGVtRGVmYXVsdC0ke3dlaWdodH0tJHtzdHlsZX1fX2A7XG4gICAgICAgIGNvbnN0IGZvbnQgPSB7XG4gICAgICAgICAgdmFyaWFudCxcbiAgICAgICAgICBzZWxlY3RvcjogYWxpYXMsXG4gICAgICAgICAgc3R5bGU6IHN0eWxlID09PSBcIm5vcm1hbFwiID8gdm9pZCAwIDogc3R5bGUsXG4gICAgICAgICAgd2VpZ2h0OiB3ZWlnaHQgPT09IDQwMCA/IHZvaWQgMCA6IHdlaWdodCxcbiAgICAgICAgICB0eXBlZmFjZSxcbiAgICAgICAgICBzdGF0dXM6IFwibG9hZGVkXCJcbiAgICAgICAgfTtcbiAgICAgICAgdHlwZWZhY2UuZm9udHMucHVzaChmb250KTtcbiAgICAgICAgYWxpYXNlcy5zZXQoYWxpYXMsIGZvbnRGYW1pbGllcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGVmYWNlLCBhbGlhc2VzIH07XG4gIH1cbiAgZ2V0VHlwZWZhY2VBbGlhc0J5U2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlZmFjZUFsaWFzQnlTZWxlY3Rvci5nZXQoc2VsZWN0b3IpIHx8IG51bGw7XG4gIH1cbiAgZ2V0VHlwZWZhY2VTZWxlY3RvckJ5QWxpYXMoYWxpYXMpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlZmFjZUFsaWFzZXMuZ2V0KGFsaWFzKSB8fCBudWxsO1xuICB9XG4gIGlzVHlwZWZhY2VBbGlhcyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXl9fLipfXyQvKSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB3b3JrYXJvdW5kQ2hyb21lODFhbmQ4MihzKSB7XG4gICAgY29uc3QgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICBpZiAoIXVzZXJBZ2VudC5pbmNsdWRlcyhcIk1hYyBPUyBYIDEwXzE1XCIpKVxuICAgICAgcmV0dXJuIHM7XG4gICAgaWYgKCF1c2VyQWdlbnQuaW5jbHVkZXMoXCJDaHJvbWUvODFcIikgJiYgIXVzZXJBZ2VudC5pbmNsdWRlcyhcIkNocm9tZS84MlwiKSlcbiAgICAgIHJldHVybiBzO1xuICAgIHJldHVybiBgSW50ZXJ8JHtzfWA7XG4gIH1cbn07XG52YXIgZm9udFdlaWdodE5hbWVzID0ge1xuICBcIjEwMFwiOiBcIlRoaW5cIixcbiAgXCIyMDBcIjogXCJFeHRyYSBMaWdodFwiLFxuICBcIjMwMFwiOiBcIkxpZ2h0XCIsXG4gIFwiNDAwXCI6IFwiTm9ybWFsXCIsXG4gIFwiNTAwXCI6IFwiTWVkaXVtXCIsXG4gIFwiNjAwXCI6IFwiU2VtaSBCb2xkXCIsXG4gIFwiNzAwXCI6IFwiQm9sZFwiLFxuICBcIjgwMFwiOiBcIkV4dHJhIEJvbGRcIixcbiAgXCI5MDBcIjogXCJCbGFja1wiXG59O1xuZnVuY3Rpb24gY3JlYXRlVmFyaWFudE5hbWUod2VpZ2h0LCBzdHlsZSkge1xuICBjb25zdCBmcmllbmRseVN0eWxlID0gc3R5bGUgPT09IFwibm9ybWFsXCIgPyBcIlJlZ3VsYXJcIiA6IFwiSXRhbGljXCI7XG4gIGlmICh3ZWlnaHQgPT09IDQwMCkge1xuICAgIHJldHVybiBmcmllbmRseVN0eWxlO1xuICB9XG4gIGlmIChzdHlsZSAhPT0gXCJub3JtYWxcIikge1xuICAgIHJldHVybiBgJHtmb250V2VpZ2h0TmFtZXNbd2VpZ2h0XX0gJHtmcmllbmRseVN0eWxlfWA7XG4gIH1cbiAgcmV0dXJuIGAke2ZvbnRXZWlnaHROYW1lc1t3ZWlnaHRdfWA7XG59XG5cbi8vIHNyYy9yZW5kZXIvZm9udHMvdXRpbHMudHNcbmZ1bmN0aW9uIHBhcnNlVmFyaWFudCh2YXJpYW50KSB7XG4gIGlmICh2YXJpYW50ID09PSBcInJlZ3VsYXJcIilcbiAgICByZXR1cm4geyBzdHlsZTogXCJub3JtYWxcIiwgd2VpZ2h0OiA0MDAgfTtcbiAgY29uc3QgcmVzID0gLyhbMC05XSopKFthLXpdKikvLmV4ZWModmFyaWFudCk7XG4gIGlmICghcmVzKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCB3ZWlnaHQgPSBwYXJzZUludChyZXNbMV0gfHwgXCI0MDBcIik7XG4gIGNvbnN0IHN0eWxlID0gcmVzWzJdIHx8IFwibm9ybWFsXCI7XG4gIHJldHVybiB7IHdlaWdodCwgc3R5bGUgfTtcbn1cblxuLy8gc3JjL3JlbmRlci9mb250cy9DdXN0b21Gb250U291cmNlLnRzXG52YXIgY3VzdG9tRm9udFNlbGVjdG9yUHJlZml4ID0gXCJDVVNUT007XCI7XG5mdW5jdGlvbiBnZXRDdXN0b21Gb250TmFtZShmaWxlTmFtZSwgcHJvcGVydGllcykge1xuICBpZiAoIXByb3BlcnRpZXMpXG4gICAgcmV0dXJuIGZpbGVOYW1lLnN1YnN0cmluZygwLCBmaWxlTmFtZS5sYXN0SW5kZXhPZihcIi5cIikpO1xuICBjb25zdCBmb250RmFtaWx5ID0gcHJvcGVydGllcy5mb250LnByZWZlcnJlZEZhbWlseSA9PT0gXCJcIiA/IHByb3BlcnRpZXMuZm9udC5mb250RmFtaWx5IDogcHJvcGVydGllcy5mb250LnByZWZlcnJlZEZhbWlseTtcbiAgY29uc3QgdmFyaWFudCA9IHByb3BlcnRpZXMuZm9udC5wcmVmZXJyZWRTdWJGYW1pbHkgPT09IFwiXCIgPyBwcm9wZXJ0aWVzLmZvbnQuZm9udFN1YkZhbWlseSA6IHByb3BlcnRpZXMuZm9udC5wcmVmZXJyZWRTdWJGYW1pbHk7XG4gIHJldHVybiBgJHtmb250RmFtaWx5fSAke3ZhcmlhbnR9YDtcbn1cbnZhciBDdXN0b21Gb250U291cmNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5hbWUgPSBUeXBlZmFjZVNvdXJjZU5hbWVzLkN1c3RvbTtcbiAgICB0aGlzLnR5cGVmYWNlcyA9IFtdO1xuICAgIHRoaXMuYnlGYW1pbHkgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5hc3NldHNCeUZhbWlseSA9IG5ldyBNYXAoKTtcbiAgfVxuICBpbXBvcnRGb250cyhhc3NldHMpIHtcbiAgICB0aGlzLnR5cGVmYWNlcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuYnlGYW1pbHkuY2xlYXIoKTtcbiAgICB0aGlzLmFzc2V0c0J5RmFtaWx5LmNsZWFyKCk7XG4gICAgY29uc3QgZm9udHMgPSBbXTtcbiAgICBhc3NldHMuZm9yRWFjaCgoYXNzZXQpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghdGhpcy5pc1ZhbGlkQ3VzdG9tRm9udEFzc2V0KGFzc2V0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBmb250TmFtZSA9IGdldEN1c3RvbUZvbnROYW1lKGFzc2V0Lm5hbWUsIGFzc2V0LnByb3BlcnRpZXMpO1xuICAgICAgY29uc3QgdHlwZWZhY2UgPSB0aGlzLmNyZWF0ZVR5cGVmYWNlKGZvbnROYW1lKTtcbiAgICAgIGNvbnN0IGZvbnQgPSB7XG4gICAgICAgIHR5cGVmYWNlLFxuICAgICAgICBzZWxlY3RvcjogYCR7Y3VzdG9tRm9udFNlbGVjdG9yUHJlZml4fSR7Zm9udE5hbWV9YCxcbiAgICAgICAgdmFyaWFudDogdGhpcy5pbmZlclZhcmlhbnROYW1lKGZvbnROYW1lKSxcbiAgICAgICAgcG9zdHNjcmlwdE5hbWU6IChfYSA9IGFzc2V0LnByb3BlcnRpZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5mb250LnBvc3RzY3JpcHROYW1lLFxuICAgICAgICBmaWxlOiBhc3NldC51cmxcbiAgICAgIH07XG4gICAgICB0eXBlZmFjZS5mb250cy5wdXNoKGZvbnQpO1xuICAgICAgdHlwZWZhY2Uub3duZXIgPSBhc3NldC5vd25lclR5cGUgPT09IFwidGVhbVwiID8gXCJ0ZWFtXCIgOiBcInByb2plY3RcIjtcbiAgICAgIHRoaXMuYXNzZXRzQnlGYW1pbHkuc2V0KGZvbnROYW1lLCBhc3NldCk7XG4gICAgICBmb250cy5wdXNoKC4uLnR5cGVmYWNlLmZvbnRzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm9udHM7XG4gIH1cbiAgaXNWYWxpZEN1c3RvbUZvbnRBc3NldChhc3NldCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIGFzc2V0Lm1pbWVUeXBlLnN0YXJ0c1dpdGgoXCJmb250L1wiKSAmJiBhc3NldC5wcm9wZXJ0aWVzICYmIFwiZm9udFwiIGluIGFzc2V0LnByb3BlcnRpZXMgJiYgKChfYSA9IGFzc2V0LnByb3BlcnRpZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5raW5kKSA9PT0gXCJmb250XCIgJiYgXCJmb250RmFtaWx5XCIgaW4gKChfYiA9IGFzc2V0LnByb3BlcnRpZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5mb250KTtcbiAgfVxuICBpbmZlclZhcmlhbnROYW1lKGZhbWlseSkge1xuICAgIGNvbnN0IHBvc3NpYmxlVmFsdWVzID0gW1xuICAgICAgXCJ0aGluXCIsXG4gICAgICBcInVsdHJhIGxpZ2h0XCIsXG4gICAgICBcImV4dHJhIGxpZ2h0XCIsXG4gICAgICBcImxpZ2h0XCIsXG4gICAgICBcIm5vcm1hbFwiLFxuICAgICAgXCJtZWRpdW1cIixcbiAgICAgIFwic2VtaSBib2xkXCIsXG4gICAgICBcImJvbGRcIixcbiAgICAgIFwiZXh0cmEgYm9sZFwiLFxuICAgICAgXCJibGFja1wiXG4gICAgXTtcbiAgICBjb25zdCBwb3NzaWJsZVZhbHVlc1dpdGhJdGFsaWNzID0gWy4uLnBvc3NpYmxlVmFsdWVzLm1hcCgodmFsdWUpID0+IGAke3ZhbHVlfSBpdGFsaWNgKSwgLi4ucG9zc2libGVWYWx1ZXNdO1xuICAgIGNvbnN0IGxvd2VyQ2FzZUZhbWlseSA9IGZhbWlseS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHRva2VucyA9IFsuLi5sb3dlckNhc2VGYW1pbHkuc3BsaXQoXCIgXCIpLCAuLi5sb3dlckNhc2VGYW1pbHkuc3BsaXQoXCItXCIpLCAuLi5sb3dlckNhc2VGYW1pbHkuc3BsaXQoXCJfXCIpXTtcbiAgICBjb25zdCBmb3VuZFRva2VuID0gcG9zc2libGVWYWx1ZXNXaXRoSXRhbGljcy5maW5kKCh2YWx1ZSkgPT4gdG9rZW5zLmluY2x1ZGVzKHZhbHVlKSB8fCB0b2tlbnMuaW5jbHVkZXModmFsdWUucmVwbGFjZSgvXFxzKy9nLCBcIlwiKSkpO1xuICAgIGlmIChmb3VuZFRva2VuKVxuICAgICAgcmV0dXJuIGZvdW5kVG9rZW4ucmVwbGFjZSgvKF5cXHd8XFxzXFx3KS9nLCAoY2hhcikgPT4gY2hhci50b1VwcGVyQ2FzZSgpKTtcbiAgICByZXR1cm4gXCJSZWd1bGFyXCI7XG4gIH1cbiAgY3JlYXRlVHlwZWZhY2UoZmFtaWx5KSB7XG4gICAgY29uc3QgZXhpc3RpbmdUeXBlZmFjZSA9IHRoaXMuYnlGYW1pbHkuZ2V0KGZhbWlseSk7XG4gICAgaWYgKGV4aXN0aW5nVHlwZWZhY2UpXG4gICAgICByZXR1cm4gZXhpc3RpbmdUeXBlZmFjZTtcbiAgICBjb25zdCB0eXBlZmFjZSA9IHtcbiAgICAgIHNvdXJjZTogdGhpcy5uYW1lLFxuICAgICAgZmFtaWx5LFxuICAgICAgZm9udHM6IFtdXG4gICAgfTtcbiAgICB0aGlzLmFkZFR5cGVmYWNlKHR5cGVmYWNlKTtcbiAgICByZXR1cm4gdHlwZWZhY2U7XG4gIH1cbiAgYWRkVHlwZWZhY2UodHlwZWZhY2UpIHtcbiAgICB0aGlzLnR5cGVmYWNlcy5wdXNoKHR5cGVmYWNlKTtcbiAgICB0aGlzLmJ5RmFtaWx5LnNldCh0eXBlZmFjZS5mYW1pbHksIHR5cGVmYWNlKTtcbiAgfVxuICBwYXJzZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgaWYgKCFzZWxlY3Rvci5zdGFydHNXaXRoKGN1c3RvbUZvbnRTZWxlY3RvclByZWZpeCkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB0b2tlbnMgPSBzZWxlY3Rvci5zcGxpdChjdXN0b21Gb250U2VsZWN0b3JQcmVmaXgpO1xuICAgIGNvbnN0IGxvY2F0b3IgPSB7IHNvdXJjZTogXCJjdXN0b21cIiwgZmFtaWx5OiB0b2tlbnNbMV0gfTtcbiAgICByZXR1cm4gbG9jYXRvcjtcbiAgfVxuICBnZXRGb250QnlTZWxlY3RvcihzZWxlY3RvciwgY3JlYXRlRm9udCA9IHRydWUpIHtcbiAgICBjb25zdCBsb2NhdG9yID0gdGhpcy5wYXJzZVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICBpZiAoIWxvY2F0b3IpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoIWNyZWF0ZUZvbnQgJiYgIXRoaXMuYnlGYW1pbHkuZ2V0KGxvY2F0b3IuZmFtaWx5KSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLmdldFR5cGVmYWNlQnlGYW1pbHkobG9jYXRvci5mYW1pbHkpLmZvbnRzWzBdO1xuICB9XG4gIGdldFR5cGVmYWNlQnlGYW1pbHkoZmFtaWx5KSB7XG4gICAgY29uc3QgZm91bmRUeXBlZmFjZSA9IHRoaXMuYnlGYW1pbHkuZ2V0KGZhbWlseSk7XG4gICAgaWYgKGZvdW5kVHlwZWZhY2UpXG4gICAgICByZXR1cm4gZm91bmRUeXBlZmFjZTtcbiAgICBjb25zdCB0eXBlZmFjZSA9IHtcbiAgICAgIHNvdXJjZTogXCJjdXN0b21cIixcbiAgICAgIGZhbWlseSxcbiAgICAgIGZvbnRzOiBbXVxuICAgIH07XG4gICAgdHlwZWZhY2UuZm9udHMucHVzaCh7XG4gICAgICBzZWxlY3RvcjogYCR7Y3VzdG9tRm9udFNlbGVjdG9yUHJlZml4fSR7ZmFtaWx5fWAsXG4gICAgICB2YXJpYW50OiB0aGlzLmluZmVyVmFyaWFudE5hbWUoZmFtaWx5KSxcbiAgICAgIHR5cGVmYWNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHR5cGVmYWNlO1xuICB9XG59O1xuXG4vLyBzcmMvcmVuZGVyL2ZvbnRzL2xvYWRGb250LnRzXG52YXIgaW1wb3J0X2ZvbnRmYWNlb2JzZXJ2ZXIgPSBfX3RvTW9kdWxlKHJlcXVpcmVfZm9udGZhY2VvYnNlcnZlcl9zdGFuZGFsb25lKCkpO1xudmFyIEZPTlRfTE9BRElOR19USU1FT1VUID0gNWUzO1xudmFyIE1BWF9SRVRSSUVTID0gMztcbnZhciBGb250TG9hZGluZ0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIkZvbnRMb2FkaW5nRXJyb3JcIjtcbiAgfVxufTtcbnZhciBmb250UmVxdWVzdHMgPSBuZXcgTWFwKCk7XG52YXIgZm9udFJlYWR5UHJvbWlzZXMgPSBuZXcgTWFwKCk7XG52YXIgbG9hZEZvbnQgPSAoZGF0YSwgZG9jKSA9PiBsb2FkRm9udFdpdGhSZXRyaWVzKGRhdGEsIGRvYyk7XG5hc3luYyBmdW5jdGlvbiBsb2FkRm9udFdpdGhSZXRyaWVzKGRhdGEsIGRvYywgYXR0ZW1wdCA9IDApIHtcbiAgY29uc3QgeyBmYW1pbHksIHVybCB9ID0gZGF0YTtcbiAgY29uc3Qgd2VpZ2h0ID0gZGF0YS53ZWlnaHQgfHwgNTAwO1xuICBjb25zdCBzdHlsZSA9IGRhdGEuc3R5bGUgfHwgXCJub3JtYWxcIjtcbiAgY29uc3QgcmVxdWVzdElkID0gYCR7ZmFtaWx5fS0ke3N0eWxlfS0ke3dlaWdodH0tJHt1cmx9YDtcbiAgaWYgKCFmb250UmVxdWVzdHMuaGFzKHJlcXVlc3RJZCkgfHwgYXR0ZW1wdCA+IDApIHtcbiAgICBjb25zdCBmb250RmFjZSA9IG5ldyBGb250RmFjZShmYW1pbHksIGB1cmwoJHt1cmx9KWAsIHtcbiAgICAgIHdlaWdodDogd2VpZ2h0ID09IG51bGwgPyB2b2lkIDAgOiB3ZWlnaHQudG9TdHJpbmcoKSxcbiAgICAgIHN0eWxlXG4gICAgfSk7XG4gICAgY29uc3QgcmVhZHlQcm9taXNlID0gZm9udEZhY2UubG9hZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgZG9jLmZvbnRzLmFkZChmb250RmFjZSk7XG4gICAgICByZXR1cm4gaXNGb250UmVhZHkoZmFtaWx5LCBzdHlsZSwgd2VpZ2h0KTtcbiAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgaWYgKGUubmFtZSAhPT0gXCJOZXR3b3JrRXJyb3JcIikge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgaWYgKGF0dGVtcHQgPCBNQVhfUkVUUklFUykge1xuICAgICAgICByZXR1cm4gbG9hZEZvbnRXaXRoUmV0cmllcyhkYXRhLCBkb2MsIGF0dGVtcHQgKyAxKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBGb250TG9hZGluZ0Vycm9yKGBGb250IGxvYWRpbmcgZmFpbGVkIGFmdGVyICR7YXR0ZW1wdH0gcmV0cmllcyBkdWUgdG8gbmV0d29yayBlcnJvcmApO1xuICAgIH0pO1xuICAgIGZvbnRSZXF1ZXN0cy5zZXQocmVxdWVzdElkLCByZWFkeVByb21pc2UpO1xuICB9XG4gIGF3YWl0IGZvbnRSZXF1ZXN0cy5nZXQocmVxdWVzdElkKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGlzRm9udFJlYWR5KGZhbWlseSwgc3R5bGUsIHdlaWdodCkge1xuICBjb25zdCByZWFkeVByb21pc2VJZCA9IGAke2ZhbWlseX0tJHtzdHlsZX0tJHt3ZWlnaHR9YDtcbiAgaWYgKCFmb250UmVhZHlQcm9taXNlcy5oYXMocmVhZHlQcm9taXNlSWQpKSB7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgaW1wb3J0X2ZvbnRmYWNlb2JzZXJ2ZXIuZGVmYXVsdChmYW1pbHksIHtcbiAgICAgIHN0eWxlLFxuICAgICAgd2VpZ2h0XG4gICAgfSk7XG4gICAgY29uc3QgcmVhZHlQcm9taXNlID0gb2JzZXJ2ZXIubG9hZChudWxsLCBGT05UX0xPQURJTkdfVElNRU9VVCk7XG4gICAgZm9udFJlYWR5UHJvbWlzZXMuc2V0KHJlYWR5UHJvbWlzZUlkLCByZWFkeVByb21pc2UpO1xuICB9XG4gIHRyeSB7XG4gICAgYXdhaXQgZm9udFJlYWR5UHJvbWlzZXMuZ2V0KHJlYWR5UHJvbWlzZUlkKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBGb250TG9hZGluZ0Vycm9yKGBGYWlsZWQgdG8gY2hlY2sgaWYgZm9udCBpcyByZWFkeSAoJHtGT05UX0xPQURJTkdfVElNRU9VVH1tcyB0aW1lb3V0IGV4Y2VlZGVkKWApO1xuICB9XG59XG5cbi8vIHNyYy9yZW5kZXIvZm9udHMvZm9udFN0b3JlLnRzXG52YXIgTG9hZEZvbnRSZXN1bHQ7XG4oZnVuY3Rpb24oTG9hZEZvbnRSZXN1bHQyKSB7XG4gIExvYWRGb250UmVzdWx0MltMb2FkRm9udFJlc3VsdDJbXCJBbHJlYWR5TG9hZGVkXCJdID0gMF0gPSBcIkFscmVhZHlMb2FkZWRcIjtcbiAgTG9hZEZvbnRSZXN1bHQyW0xvYWRGb250UmVzdWx0MltcIkxvYWRlZFwiXSA9IDFdID0gXCJMb2FkZWRcIjtcbn0pKExvYWRGb250UmVzdWx0IHx8IChMb2FkRm9udFJlc3VsdCA9IHt9KSk7XG52YXIgRm9udFN0b3JlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmJ5U2VsZWN0b3IgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5sb2FkZWRTZWxlY3RvcnMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5jcmVhdGVHb29nbGVGb250ID0gKGxvY2F0b3IpID0+IHtcbiAgICAgIGNvbnN0IHsgc291cmNlLCBmYW1pbHksIHZhcmlhbnQsIGZpbGUgfSA9IGxvY2F0b3I7XG4gICAgICBsZXQgdHlwZWZhY2UgPSB0aGlzLmdldFR5cGVmYWNlKGxvY2F0b3IpO1xuICAgICAgaWYgKCF0eXBlZmFjZSkge1xuICAgICAgICB0eXBlZmFjZSA9IHRoaXNbc291cmNlXS5jcmVhdGVUeXBlZmFjZShmYW1pbHkpO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFyaWFudEluZm8gPSBwYXJzZVZhcmlhbnQodmFyaWFudCkgfHwge307XG4gICAgICBjb25zdCB7IHdlaWdodCwgc3R5bGUgfSA9IHZhcmlhbnRJbmZvO1xuICAgICAgY29uc3Qgc2VsZWN0b3IgPSBgR0Y7JHtmYW1pbHl9LSR7dmFyaWFudH1gO1xuICAgICAgY29uc3QgZm9udCA9IHtcbiAgICAgICAgdHlwZWZhY2UsXG4gICAgICAgIHZhcmlhbnQsXG4gICAgICAgIHNlbGVjdG9yLFxuICAgICAgICB3ZWlnaHQsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICBmaWxlXG4gICAgICB9O1xuICAgICAgdHlwZWZhY2UuZm9udHMucHVzaChmb250KTtcbiAgICAgIHJldHVybiBmb250O1xuICAgIH07XG4gICAgdGhpcy5sb2NhbCA9IG5ldyBMb2NhbEZvbnRTb3VyY2UoKTtcbiAgICB0aGlzLmdvb2dsZSA9IG5ldyBHb29nbGVGb250U291cmNlKCk7XG4gICAgdGhpcy5jdXN0b20gPSBuZXcgQ3VzdG9tRm9udFNvdXJjZSgpO1xuICAgIHRoaXMuYnlTZWxlY3RvciA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmltcG9ydExvY2FsRm9udHMoKTtcbiAgICB0aGlzLmRlZmF1bHRGb250ID0gdGhpcy5nZXRGb250QnlTZWxlY3RvcihkZWZhdWx0Rm9udFNlbGVjdG9yKTtcbiAgICBpZiAodGhpcy5kZWZhdWx0Rm9udCkge1xuICAgICAgdGhpcy5sb2FkRm9udCh0aGlzLmRlZmF1bHRGb250KTtcbiAgICB9XG4gIH1cbiAgYWRkRm9udChmb250KSB7XG4gICAgdGhpcy5ieVNlbGVjdG9yLnNldChmb250LnNlbGVjdG9yLCBmb250KTtcbiAgfVxuICBnZXRBdmFpbGFibGVGb250cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmJ5U2VsZWN0b3IudmFsdWVzKCkpO1xuICB9XG4gIGltcG9ydExvY2FsRm9udHMoKSB7XG4gICAgdGhpcy5sb2NhbC5pbXBvcnRGb250cygpLmZvckVhY2goKGZvbnQpID0+IHtcbiAgICAgIHRoaXMuYWRkRm9udChmb250KTtcbiAgICAgIGlmICghdGhpcy5sb2NhbC5pbnRlclR5cGVmYWNlU2VsZWN0b3JzLmhhcyhmb250LnNlbGVjdG9yKSkge1xuICAgICAgICB0aGlzLmxvYWRGb250KGZvbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGltcG9ydEdvb2dsZUZvbnRzKCkge1xuICAgIGlmICghdGhpcy5nZXRHb29nbGVGb250c0xpc3RQcm9taXNlKSB7XG4gICAgICB0aGlzLmdldEdvb2dsZUZvbnRzTGlzdFByb21pc2UgPSBydW50aW1lLmZldGNoR29vZ2xlRm9udHNMaXN0KCk7XG4gICAgICBjb25zdCBnb29nbGVGb250cyA9IGF3YWl0IHRoaXMuZ2V0R29vZ2xlRm9udHNMaXN0UHJvbWlzZTtcbiAgICAgIHRoaXMuZ29vZ2xlLmltcG9ydEZvbnRzKGdvb2dsZUZvbnRzKS5mb3JFYWNoKChsb2NhdG9yKSA9PiB7XG4gICAgICAgIGNvbnN0IGZvbnQgPSB0aGlzLmNyZWF0ZUdvb2dsZUZvbnQobG9jYXRvcik7XG4gICAgICAgIHRoaXMuYWRkRm9udChmb250KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRHb29nbGVGb250c0xpc3RQcm9taXNlO1xuICB9XG4gIGltcG9ydEN1c3RvbUZvbnRzKGFzc2V0cykge1xuICAgIHRoaXMuYnlTZWxlY3Rvci5mb3JFYWNoKChfLCBrZXk2KSA9PiB7XG4gICAgICBpZiAoa2V5Ni5zdGFydHNXaXRoKGN1c3RvbUZvbnRTZWxlY3RvclByZWZpeCkpIHtcbiAgICAgICAgdGhpcy5ieVNlbGVjdG9yLmRlbGV0ZShrZXk2KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmN1c3RvbS5pbXBvcnRGb250cyhhc3NldHMpLmZvckVhY2goKGZvbnQpID0+IHRoaXMuYWRkRm9udChmb250KSk7XG4gIH1cbiAgZ2V0VHlwZWZhY2UoaW5mbykge1xuICAgIGNvbnN0IHR5cGVmYWNlID0gdGhpc1tpbmZvLnNvdXJjZV0uZ2V0VHlwZWZhY2VCeUZhbWlseShpbmZvLmZhbWlseSk7XG4gICAgcmV0dXJuIHR5cGVmYWNlO1xuICB9XG4gIGdldEZvbnRCeVNlbGVjdG9yKHNlbGVjdG9yLCBjcmVhdGVGb250ID0gdHJ1ZSkge1xuICAgIGlmIChzZWxlY3Rvci5zdGFydHNXaXRoKGN1c3RvbUZvbnRTZWxlY3RvclByZWZpeCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1c3RvbS5nZXRGb250QnlTZWxlY3RvcihzZWxlY3RvciwgY3JlYXRlRm9udCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJ5U2VsZWN0b3IuZ2V0KHNlbGVjdG9yKSB8fCBudWxsO1xuICB9XG4gIGdldERyYWZ0UHJvcGVydGllc0J5U2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICBjb25zdCBmb250ID0gdGhpcy5nZXRGb250QnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgaWYgKGZvbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0eWxlOiBmb250LnN0eWxlLFxuICAgICAgICB3ZWlnaHQ6IGZvbnQud2VpZ2h0LFxuICAgICAgICB2YXJpYW50OiBmb250LnZhcmlhbnQsXG4gICAgICAgIGZhbWlseTogZm9udC50eXBlZmFjZS5mYW1pbHksXG4gICAgICAgIHNvdXJjZTogZm9udC50eXBlZmFjZS5zb3VyY2VcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGxvY2F0b3IgPSB0aGlzLmdvb2dsZS5wYXJzZVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICBpZiAobG9jYXRvcikge1xuICAgICAgY29uc3QgZm9udFZhcmlhbnQgPSBwYXJzZVZhcmlhbnQobG9jYXRvci52YXJpYW50KTtcbiAgICAgIGlmIChmb250VmFyaWFudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0eWxlOiBmb250VmFyaWFudC5zdHlsZSxcbiAgICAgICAgICB3ZWlnaHQ6IGZvbnRWYXJpYW50LndlaWdodCxcbiAgICAgICAgICB2YXJpYW50OiBsb2NhdG9yLnZhcmlhbnQsXG4gICAgICAgICAgZmFtaWx5OiBsb2NhdG9yLmZhbWlseSxcbiAgICAgICAgICBzb3VyY2U6IFR5cGVmYWNlU291cmNlTmFtZXMuR29vZ2xlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlzU2VsZWN0b3JMb2FkZWQoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkZWRTZWxlY3RvcnMuaGFzKHNlbGVjdG9yKTtcbiAgfVxuICBhc3luYyBsb2FkVHlwZWZhY2UodHlwZWZhY2UpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbCh0eXBlZmFjZS5mb250cy5tYXAoKGYpID0+IHRoaXMubG9hZEZvbnQoZikpKTtcbiAgfVxuICBhc3luYyBsb2FkRm9udChmb250KSB7XG4gICAgaWYgKHRoaXMuaXNTZWxlY3RvckxvYWRlZChmb250LnNlbGVjdG9yKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChmb250LnR5cGVmYWNlLnNvdXJjZSA9PT0gVHlwZWZhY2VTb3VyY2VOYW1lcy5Mb2NhbCkge1xuICAgICAgaWYgKHRoaXMubG9jYWwuaW50ZXJUeXBlZmFjZVNlbGVjdG9ycy5oYXMoZm9udC5zZWxlY3RvcikgJiYgdHJ1ZSkge1xuICAgICAgICBhd2FpdCBpc0ZvbnRSZWFkeShmb250LnR5cGVmYWNlLmZhbWlseSwgZm9udC5zdHlsZSwgZm9udC53ZWlnaHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2FkZWRTZWxlY3RvcnMuYWRkKGZvbnQuc2VsZWN0b3IpO1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmICghZm9udC5maWxlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoYFVuYWJsZSB0byBsb2FkIGZvbnQ6ICR7Zm9udC5zZWxlY3Rvcn1gKTtcbiAgICB9XG4gICAgYXdhaXQgbG9hZEZvbnQoe1xuICAgICAgZmFtaWx5OiBmb250LnR5cGVmYWNlLmZhbWlseSxcbiAgICAgIHVybDogZm9udC5maWxlLFxuICAgICAgd2VpZ2h0OiBmb250LndlaWdodCxcbiAgICAgIHN0eWxlOiBmb250LnN0eWxlXG4gICAgfSwgZG9jdW1lbnQpO1xuICAgIHRoaXMubG9hZGVkU2VsZWN0b3JzLmFkZChmb250LnNlbGVjdG9yKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBhc3luYyBsb2FkV2ViRm9udHNGcm9tU2VsZWN0b3JzKHNlbGVjdG9ycykge1xuICAgIGlmIChzZWxlY3RvcnMuc29tZSgocykgPT4gcy5zdGFydHNXaXRoKGdvb2dsZUZvbnRTZWxlY3RvclByZWZpeCkpKSB7XG4gICAgICBhd2FpdCB0aGlzLmltcG9ydEdvb2dsZUZvbnRzKCk7XG4gICAgfVxuICAgIGNvbnN0IGZvbnRzID0gc2VsZWN0b3JzLm1hcCgocykgPT4gdGhpcy5ieVNlbGVjdG9yLmdldChzKSkuZmlsdGVyKChmKSA9PiAhIWYpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbFNldHRsZWQoZm9udHMubWFwKChmKSA9PiB0aGlzLmxvYWRGb250KGYpKSk7XG4gIH1cbn07XG52YXIgZm9udFN0b3JlID0gbmV3IEZvbnRTdG9yZSgpO1xuUHJvbWlzZS5hbGxTZXR0bGVkID0gUHJvbWlzZS5hbGxTZXR0bGVkIHx8ICgocHJvbWlzZXMpID0+IFByb21pc2UuYWxsKHByb21pc2VzLm1hcCgocCkgPT4gcC50aGVuKCh2KSA9PiAoeyBzdGF0dXM6IFwiZnVsZmlsbGVkXCIsIHZhbHVlOiB2IH0pKS5jYXRjaCgoZSkgPT4gKHsgc3RhdHVzOiBcInJlamVjdGVkXCIsIHJlYXNvbjogZSB9KSkpKSk7XG5cbi8vIHNyYy9yZW5kZXIvdXRpbHMvaXNTaGFsbG93RXF1YWxBcnJheS50c1xuZnVuY3Rpb24gaXNTaGFsbG93RXF1YWxBcnJheShhMiwgYjIpIHtcbiAgcmV0dXJuIGEyLmxlbmd0aCA9PT0gYjIubGVuZ3RoICYmIGEyLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBiMltpXSk7XG59XG5cbi8vIHNyYy9yZW5kZXIvcHJlc2VudGF0aW9uL1RleHQudHN4XG5mdW5jdGlvbiBUZXh0KHByb3BzKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgcGFyZW50U2l6ZSA9IHVzZVBhcmVudFNpemUoKTtcbiAgY29uc3QgbGF5b3V0SWQgPSB1c2VMYXlvdXRJZDIocHJvcHMpO1xuICBjb25zdCBsYXlvdXRSZWYgPSB1c2VSZWYyMyhudWxsKTtcbiAgdXNlTWVhc3VyZUxheW91dChwcm9wcywgbGF5b3V0UmVmKTtcbiAgY29uc3QgeyBmb250cywgX19mcm9tQ2FudmFzQ29tcG9uZW50IH0gPSBwcm9wcztcbiAgY29uc3QgcHJldkZvbnRzUmVmID0gdXNlUmVmMjMoW10pO1xuICBjb25zdCBmb250c0RpZENoYW5nZSA9ICFpc1NoYWxsb3dFcXVhbEFycmF5KChfYSA9IHByZXZGb250c1JlZi5jdXJyZW50KSAhPSBudWxsID8gX2EgOiBbXSwgZm9udHMgIT0gbnVsbCA/IGZvbnRzIDogW10pO1xuICBwcmV2Rm9udHNSZWYuY3VycmVudCA9IGZvbnRzO1xuICB1c2VFZmZlY3QyMigoKSA9PiB7XG4gICAgaWYgKCFmb250c0RpZENoYW5nZSB8fCAhZm9udHMpXG4gICAgICByZXR1cm47XG4gICAgZm9udFN0b3JlLmxvYWRXZWJGb250c0Zyb21TZWxlY3RvcnMoZm9udHMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgIGlmICghX19mcm9tQ2FudmFzQ29tcG9uZW50IHx8ICFsYXlvdXRSZWYuY3VycmVudCB8fCBSZW5kZXJUYXJnZXQuY3VycmVudCgpICE9PSBSZW5kZXJUYXJnZXQuY2FudmFzKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBkaWRMb2FkTmV3Rm9udHMgPSByZXN1bHRzLnNvbWUoKHJlc3VsdCkgPT4gcmVzdWx0LnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIiAmJiByZXN1bHQudmFsdWUgPT09IExvYWRGb250UmVzdWx0LkxvYWRlZCk7XG4gICAgICBpZiAoIWRpZExvYWROZXdGb250cylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbWVhc3VyZUNsb3Nlc3RDb21wb25lbnRDb250YWluZXIobGF5b3V0UmVmLmN1cnJlbnQpO1xuICAgIH0pO1xuICB9LCBbZm9udHNdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50NDAoVGV4dENvbXBvbmVudCwge1xuICAgIC4uLnByb3BzLFxuICAgIGlubmVyUmVmOiBsYXlvdXRSZWYsXG4gICAgbGF5b3V0SWQsXG4gICAgcGFyZW50U2l6ZVxuICB9KTtcbn1cbnZhciBfVGV4dENvbXBvbmVudCA9IGNsYXNzIGV4dGVuZHMgTGF5ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMucmVuZGVyTWFpbiA9IChpbkNvZGVDb21wb25lbnQpID0+IHtcbiAgICAgIGlmIChzYWZlV2luZG93W1wicGVyZlwiXSlcbiAgICAgICAgc2FmZVdpbmRvd1tcInBlcmZcIl0ubm9kZVJlbmRlcigpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBmb250LFxuICAgICAgICB2aXNpYmxlLFxuICAgICAgICBhbGlnbm1lbnQsXG4gICAgICAgIHdpbGxDaGFuZ2VUcmFuc2Zvcm0sXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIGlkLFxuICAgICAgICBsYXlvdXRJZCxcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICB0cmFuc2l0aW9uLFxuICAgICAgICB2YXJpYW50cyxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgaW5uZXJSZWYsXG4gICAgICAgIF9fZnJvbUNhbnZhc0NvbXBvbmVudCxcbiAgICAgICAgd2lkdGhUeXBlLFxuICAgICAgICBoZWlnaHRUeXBlLFxuICAgICAgICBfdXNlc0RPTVJlY3QsXG4gICAgICAgIGF1dG9TaXplLFxuICAgICAgICBzdHlsZTogc3R5bGVQcm9wXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IGZyYW1lMiA9IHRoaXMuZnJhbWU7XG4gICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpbmplY3RDb21wb25lbnRDU1NSdWxlcygpO1xuICAgICAgY29uc3QgaXNIaWRkZW4yID0gdGhpcy5wcm9wcy5pc0VkaXRhYmxlICYmIHRoaXMucHJvcHMuZW52aXJvbm1lbnQoKSA9PT0gUmVuZGVyVGFyZ2V0LmNhbnZhcztcbiAgICAgIGNvbnN0IGp1c3RpZnlDb250ZW50ID0gY29udmVydFZlcnRpY2FsQWxpZ25tZW50KHRoaXMucHJvcHMudmVydGljYWxBbGlnbm1lbnQpO1xuICAgICAgY29uc3Qgc3R5bGUgPSB7XG4gICAgICAgIG91dGxpbmU6IFwibm9uZVwiLFxuICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICAgICAganVzdGlmeUNvbnRlbnQsXG4gICAgICAgIG9wYWNpdHk6IGlzSGlkZGVuMiA/IDAgOiBvcGFjaXR5LFxuICAgICAgICBmbGV4U2hyaW5rOiAwXG4gICAgICB9O1xuICAgICAgY29uc3QgZGF0YVByb3BzID0ge1xuICAgICAgICBcImRhdGEtZnJhbWVyLWNvbXBvbmVudC10eXBlXCI6IFwiVGV4dFwiLFxuICAgICAgICBcImRhdGEtZnJhbWVyLW5hbWVcIjogbmFtZVxuICAgICAgfTtcbiAgICAgIGlmIChhdXRvU2l6ZSkge1xuICAgICAgICBkYXRhUHJvcHNbXCJkYXRhLWZyYW1lci1jb21wb25lbnQtdGV4dC1hdXRvc2l6ZWRcIl0gPSBcInRydWVcIjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29sbGVjdExheW91dChzdHlsZSwgaW5Db2RlQ29tcG9uZW50KTtcbiAgICAgIGNvbGxlY3RGaWx0ZXJzRnJvbVByb3BzKHRoaXMucHJvcHMsIHN0eWxlKTtcbiAgICAgIGNvbGxlY3RUZXh0U2hhZG93c0ZvclByb3BzKHRoaXMucHJvcHMsIHN0eWxlKTtcbiAgICAgIGlmIChzdHlsZS5vcGFjaXR5ID09PSAxIHx8IHN0eWxlLm9wYWNpdHkgPT09IHZvaWQgMCkge1xuICAgICAgICBkZWxldGUgc3R5bGUub3BhY2l0eTtcbiAgICAgIH1cbiAgICAgIGlmICh3aWxsQ2hhbmdlVHJhbnNmb3JtKSB7XG4gICAgICAgIGZvcmNlTGF5ZXJCYWNraW5nV2l0aENTU1Byb3BlcnRpZXMoc3R5bGUpO1xuICAgICAgfVxuICAgICAgbGV0IHJhd0hUTUwgPSB0aGlzLnByb3BzLnJhd0hUTUw7XG4gICAgICBjb25zdCB0ZXh0ID0gdGhpcy5nZXRPdmVycmlkZVRleHQoKSB8fCB0aGlzLnByb3BzLnRleHQ7XG4gICAgICBpZiAoaXNTdHJpbmcyKHRleHQpKSB7XG4gICAgICAgIGlmIChyYXdIVE1MKSB7XG4gICAgICAgICAgcmF3SFRNTCA9IHJlcGxhY2VEcmFmdEhUTUxXaXRoVGV4dChyYXdIVE1MLCB0ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByYXdIVE1MID0gYDxwIHN0eWxlPVwiZm9udDogJHtmb250fVwiPiR7dGV4dH08L3A+YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHJvcHMuc3R5bGUpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZSwgdGhpcy5wcm9wcy5zdHlsZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBpc0RPTUxheW91dEF1dG9TaXplZCA9IF91c2VzRE9NUmVjdCAmJiAod2lkdGhUeXBlID09PSBEaW1lbnNpb25UeXBlLkF1dG8gfHwgaGVpZ2h0VHlwZSA9PT0gRGltZW5zaW9uVHlwZS5BdXRvKTtcbiAgICAgIGNvbnN0IGhhc1RyYW5zZm9ybVRlbXBsYXRlID0gIWZyYW1lMiB8fCAhUmVuZGVyVGFyZ2V0Lmhhc1Jlc3RyaWN0aW9ucygpIHx8IF9fZnJvbUNhbnZhc0NvbXBvbmVudCB8fCBpc0RPTUxheW91dEF1dG9TaXplZDtcbiAgICAgIGlmIChoYXNUcmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKGRhdGFQcm9wcywgbGF5b3V0SGludERhdGFQcm9wc0ZvckNlbnRlcih0aGlzLnByb3BzLmNlbnRlcikpO1xuICAgICAgfVxuICAgICAgaWYgKHJhd0hUTUwpIHtcbiAgICAgICAgc3R5bGUudGV4dEFsaWduID0gYWxpZ25tZW50O1xuICAgICAgICBzdHlsZS5saW5lSGVpZ2h0ID0gXCIxcHhcIjtcbiAgICAgICAgc3R5bGUuZm9udFNpemUgPSBcIjBweFwiO1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQ0MChtb3Rpb24uZGl2LCB7XG4gICAgICAgICAgbGF5b3V0SWQsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgLi4uZGF0YVByb3BzLFxuICAgICAgICAgIHN0eWxlOiB7IC4uLnN0eWxlLCAuLi5zdHlsZVByb3AgfSxcbiAgICAgICAgICB0cmFuc2Zvcm1UZW1wbGF0ZTogaGFzVHJhbnNmb3JtVGVtcGxhdGUgPyB0cmFuc2Zvcm1UZW1wbGF0ZSh0aGlzLnByb3BzLmNlbnRlcikgOiB2b2lkIDAsXG4gICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiByYXdIVE1MIH0sXG4gICAgICAgICAgXCJkYXRhLWNlbnRlclwiOiB0aGlzLnByb3BzLmNlbnRlcixcbiAgICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgICAgdHJhbnNpdGlvbixcbiAgICAgICAgICB2YXJpYW50cyxcbiAgICAgICAgICByZWY6IGlubmVyUmVmXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2V0IGZyYW1lKCkge1xuICAgIHJldHVybiBjYWxjdWxhdGVSZWN0KHRoaXMucHJvcHMsIHRoaXMucHJvcHMucGFyZW50U2l6ZSB8fCBQYXJlbnRTaXplU3RhdGUuVW5rbm93biwgZmFsc2UpO1xuICB9XG4gIGdldE92ZXJyaWRlVGV4dCgpIHtcbiAgICBjb25zdCB7IF9mb3J3YXJkZWRPdmVycmlkZUlkLCBfZm9yd2FyZGVkT3ZlcnJpZGVzLCBpZCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBmb3J3YXJkZWRPdmVycmlkZUlkID0gX2ZvcndhcmRlZE92ZXJyaWRlSWQgIT0gbnVsbCA/IF9mb3J3YXJkZWRPdmVycmlkZUlkIDogaWQ7XG4gICAgaWYgKGZvcndhcmRlZE92ZXJyaWRlSWQgJiYgX2ZvcndhcmRlZE92ZXJyaWRlcykge1xuICAgICAgY29uc3QgdGV4dCA9IF9mb3J3YXJkZWRPdmVycmlkZXNbZm9yd2FyZGVkT3ZlcnJpZGVJZF07XG4gICAgICBpZiAoaXNTdHJpbmcyKHRleHQpKSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50NDAoQ29tcG9uZW50Q29udGFpbmVyQ29udGV4dC5Db25zdW1lciwgbnVsbCwgdGhpcy5yZW5kZXJNYWluKTtcbiAgfVxuICBjb2xsZWN0TGF5b3V0KHN0eWxlLCBpbkNvZGVDb21wb25lbnQpIHtcbiAgICBpZiAodGhpcy5wcm9wcy53aXRoRXh0ZXJuYWxMYXlvdXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZnJhbWUyID0gdGhpcy5mcmFtZTtcbiAgICBjb25zdCB7XG4gICAgICByb3RhdGlvbixcbiAgICAgIGF1dG9TaXplLFxuICAgICAgcG9zaXRpb25TdGlja3ksXG4gICAgICBwb3NpdGlvblN0aWNreVRvcCxcbiAgICAgIHBvc2l0aW9uU3RpY2t5UmlnaHQsXG4gICAgICBwb3NpdGlvblN0aWNreUJvdHRvbSxcbiAgICAgIHBvc2l0aW9uU3RpY2t5TGVmdCxcbiAgICAgIHdpZHRoOiBleHRlcm5hbFdpZHRoLFxuICAgICAgaGVpZ2h0OiBleHRlcm5hbEhlaWdodCxcbiAgICAgIF91c2VzRE9NUmVjdFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHJvdGF0ZSA9IEFuaW1hdGFibGUuZ2V0TnVtYmVyKHJvdGF0aW9uKTtcbiAgICBjb25zdCBpc0RPTUxheW91dEF1dG9TaXplZCA9IF91c2VzRE9NUmVjdCAmJiAoZXh0ZXJuYWxXaWR0aCA9PT0gXCJhdXRvXCIgfHwgZXh0ZXJuYWxIZWlnaHQgPT09IFwiYXV0b1wiKTtcbiAgICBpZiAoZnJhbWUyICYmICFpc0RPTUxheW91dEF1dG9TaXplZCAmJiBSZW5kZXJUYXJnZXQuaGFzUmVzdHJpY3Rpb25zKCkpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3R5bGUsIHtcbiAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7ZnJhbWUyLnh9cHgsICR7ZnJhbWUyLnl9cHgpIHJvdGF0ZSgke3JvdGF0ZS50b0ZpeGVkKDQpfWRlZylgLFxuICAgICAgICB3aWR0aDogYXV0b1NpemUgPyBcImF1dG9cIiA6IGAke2ZyYW1lMi53aWR0aH1weGAsXG4gICAgICAgIG1pbldpZHRoOiBgJHtmcmFtZTIud2lkdGh9cHhgLFxuICAgICAgICBoZWlnaHQ6IGAke2ZyYW1lMi5oZWlnaHR9cHhgXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20gfSA9IHRoaXMucHJvcHM7XG4gICAgICBsZXQgd2lkdGg7XG4gICAgICBsZXQgaGVpZ2h0O1xuICAgICAgaWYgKGF1dG9TaXplKSB7XG4gICAgICAgIHdpZHRoID0gXCJhdXRvXCI7XG4gICAgICAgIGhlaWdodCA9IFwiYXV0b1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFpc0Zpbml0ZU51bWJlcihsZWZ0KSB8fCAhaXNGaW5pdGVOdW1iZXIocmlnaHQpKSB7XG4gICAgICAgICAgd2lkdGggPSBleHRlcm5hbFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNGaW5pdGVOdW1iZXIodG9wKSB8fCAhaXNGaW5pdGVOdW1iZXIoYm90dG9tKSkge1xuICAgICAgICAgIGhlaWdodCA9IGV4dGVybmFsSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBPYmplY3QuYXNzaWduKHN0eWxlLCB7XG4gICAgICAgIGxlZnQsXG4gICAgICAgIHJpZ2h0LFxuICAgICAgICB0b3AsXG4gICAgICAgIGJvdHRvbSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgcm90YXRlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBvc2l0aW9uU3RpY2t5KSB7XG4gICAgICBjb25zdCBvbkNhbnZhcyA9IFJlbmRlclRhcmdldC5jdXJyZW50KCkgPT09IFJlbmRlclRhcmdldC5jYW52YXM7XG4gICAgICBpZiAoIW9uQ2FudmFzIHx8IGluQ29kZUNvbXBvbmVudCkge1xuICAgICAgICBzdHlsZS5wb3NpdGlvbiA9IFwic3RpY2t5XCI7XG4gICAgICAgIHN0eWxlLndpbGxDaGFuZ2UgPSBcInRyYW5zZm9ybVwiO1xuICAgICAgICBzdHlsZS56SW5kZXggPSAxO1xuICAgICAgICBzdHlsZS50b3AgPSBwb3NpdGlvblN0aWNreVRvcDtcbiAgICAgICAgc3R5bGUucmlnaHQgPSBwb3NpdGlvblN0aWNreVJpZ2h0O1xuICAgICAgICBzdHlsZS5ib3R0b20gPSBwb3NpdGlvblN0aWNreUJvdHRvbTtcbiAgICAgICAgc3R5bGUubGVmdCA9IHBvc2l0aW9uU3RpY2t5TGVmdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIgVGV4dENvbXBvbmVudCA9IF9UZXh0Q29tcG9uZW50O1xuVGV4dENvbXBvbmVudC5zdXBwb3J0c0NvbnN0cmFpbnRzID0gdHJ1ZTtcblRleHRDb21wb25lbnQuZGVmYXVsdFRleHRQcm9wcyA9IHtcbiAgb3BhY2l0eTogdm9pZCAwLFxuICBsZWZ0OiB2b2lkIDAsXG4gIHJpZ2h0OiB2b2lkIDAsXG4gIHRvcDogdm9pZCAwLFxuICBib3R0b206IHZvaWQgMCxcbiAgX2NvbnN0cmFpbnRzOiB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBhc3BlY3RSYXRpbzogbnVsbFxuICB9LFxuICByb3RhdGlvbjogMCxcbiAgdmlzaWJsZTogdHJ1ZSxcbiAgYWxpZ25tZW50OiB2b2lkIDAsXG4gIHZlcnRpY2FsQWxpZ25tZW50OiBcInRvcFwiLFxuICBzaGFkb3dzOiBbXSxcbiAgZm9udDogXCIxNnB4IFwiICsgZGV2aWNlRm9udCgpXG59O1xuVGV4dENvbXBvbmVudC5kZWZhdWx0UHJvcHMgPSB7XG4gIC4uLkxheWVyLmRlZmF1bHRQcm9wcyxcbiAgLi4uX1RleHRDb21wb25lbnQuZGVmYXVsdFRleHRQcm9wcyxcbiAgaXNFZGl0YWJsZTogZmFsc2UsXG4gIGVudmlyb25tZW50OiBSZW5kZXJUYXJnZXQuY3VycmVudCxcbiAgd2l0aEV4dGVybmFsTGF5b3V0OiBmYWxzZVxufTtcbnZhciB0ZXh0Q29udGVudFJlZ2V4ID0gLyg8c3BhbiBbXj5dKz4pLio8XFwvc3Bhbj4vcztcbmZ1bmN0aW9uIHJlcGxhY2VEcmFmdEhUTUxXaXRoVGV4dChyYXdIVE1MLCB0ZXh0KSB7XG4gIHJldHVybiByYXdIVE1MLnJlcGxhY2UodGV4dENvbnRlbnRSZWdleCwgKF8sIHNwYW4pID0+IHNwYW4gKyB0ZXh0ICsgXCI8L3NwYW4+XCIpO1xufVxuZnVuY3Rpb24gY29udmVydFZlcnRpY2FsQWxpZ25tZW50KHZlcnRpY2FsQWxpZ25tZW50KSB7XG4gIHN3aXRjaCAodmVydGljYWxBbGlnbm1lbnQpIHtcbiAgICBjYXNlIFwidG9wXCI6XG4gICAgICByZXR1cm4gXCJmbGV4LXN0YXJ0XCI7XG4gICAgY2FzZSBcImNlbnRlclwiOlxuICAgICAgcmV0dXJuIFwiY2VudGVyXCI7XG4gICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgcmV0dXJuIFwiZmxleC1lbmRcIjtcbiAgfVxufVxuXG4vLyBzcmMvcmVuZGVyL3ByZXNlbnRhdGlvbi9WZWN0b3IudHN4XG5pbXBvcnQge1xuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQ0M1xufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3JlbmRlci91dGlscy90cmFuc2Zvcm1TdHJpbmcudHNcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0cmluZyh0cmFuc2Zvcm0yKSB7XG4gIGlmICh0cmFuc2Zvcm0yID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IHsgeCwgeSwgcm90YXRpb24sIHdpZHRoLCBoZWlnaHQgfSA9IHRyYW5zZm9ybTI7XG4gIGxldCByZXN1bHQ7XG4gIGlmICh4ICE9PSAwIHx8IHkgIT09IDApIHtcbiAgICByZXN1bHQgPSBgdHJhbnNsYXRlKCR7cm91bmRlZE51bWJlclN0cmluZyh4LCAzKX0gJHtyb3VuZGVkTnVtYmVyU3RyaW5nKHksIDMpfSlgO1xuICB9XG4gIGlmIChyb3RhdGlvbiAhPT0gMCkge1xuICAgIGNvbnN0IHJvdW5kZWRSb3RhdGlvbiA9IHJvdW5kZWROdW1iZXJTdHJpbmcocm90YXRpb24sIDQpO1xuICAgIGNvbnN0IHJvdW5kZWRXaWR0aCA9IHJvdW5kZWROdW1iZXJTdHJpbmcod2lkdGggLyAyLCAzKTtcbiAgICBjb25zdCByb3VuZGVkSGVpZ2h0ID0gcm91bmRlZE51bWJlclN0cmluZyhoZWlnaHQgLyAyLCAzKTtcbiAgICBjb25zdCByb3RhdGlvblN0cmluZyA9IGByb3RhdGUoJHtyb3VuZGVkUm90YXRpb259ICR7cm91bmRlZFdpZHRofSAke3JvdW5kZWRIZWlnaHR9KWA7XG4gICAgcmVzdWx0ID0gcmVzdWx0ID8gYCR7cmVzdWx0fSAke3JvdGF0aW9uU3RyaW5nfWAgOiByb3RhdGlvblN0cmluZztcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvcmVuZGVyL3ByZXNlbnRhdGlvbi9TVkdSb290LnRzeFxuaW1wb3J0IHtcbiAgQ29tcG9uZW50IGFzIENvbXBvbmVudDE1LFxuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQ0MVxufSBmcm9tIFwicmVhY3RcIjtcbnZhciBTVkdSb290ID0gY2xhc3MgZXh0ZW5kcyBDb21wb25lbnQxNSB7XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBmcmFtZTogZnJhbWUyIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZnJhbWUyO1xuICAgIGNvbnN0IGZ4ID0gTWF0aC5mbG9vcihmcmFtZTIueCk7XG4gICAgY29uc3QgZnkgPSBNYXRoLmZsb29yKGZyYW1lMi55KTtcbiAgICBjb25zdCBzdmdTdHlsZSA9IHtcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICB3aWR0aDogTWF0aC5jZWlsKHdpZHRoKSxcbiAgICAgIGhlaWdodDogTWF0aC5jZWlsKGhlaWdodCksXG4gICAgICBvdmVyZmxvdzogXCJ2aXNpYmxlXCIsXG4gICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtmeH1weCwgJHtmeX1weClgXG4gICAgfTtcbiAgICBMYXllci5hcHBseVdpbGxDaGFuZ2UodGhpcy5wcm9wcywgc3ZnU3R5bGUsIGZhbHNlKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQ0MShcInN2Z1wiLCB7XG4gICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICAgIHhtbG5zWGxpbms6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICAgICAgc3R5bGU6IHN2Z1N0eWxlXG4gICAgfSwgY2hpbGRyZW4pO1xuICB9XG59O1xuXG4vLyBzcmMvcmVuZGVyL3ByZXNlbnRhdGlvbi9HcmFkaWVudEVsZW1lbnQudHN4XG5pbXBvcnQge1xuICBDb21wb25lbnQgYXMgQ29tcG9uZW50MTYsXG4gIGNyZWF0ZUVsZW1lbnQgYXMgY3JlYXRlRWxlbWVudDQyXG59IGZyb20gXCJyZWFjdFwiO1xudmFyIExpbmVhckdyYWRpZW50RWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgQ29tcG9uZW50MTYge1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBpZCwgYW5nbGUsIHN0b3BzIH0gPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDQyKFwibGluZWFyR3JhZGllbnRcIiwge1xuICAgICAgaWQsXG4gICAgICBncmFkaWVudFRyYW5zZm9ybTogYHJvdGF0ZSgke2FuZ2xlfSwgMC41LCAwLjUpYFxuICAgIH0sIHN0b3BzLm1hcCgoc3RvcCwgaWR4KSA9PiB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQ0MihcInN0b3BcIiwge1xuICAgICAgICBrZXk6IGlkeCxcbiAgICAgICAgb2Zmc2V0OiBzdG9wLnBvc2l0aW9uLFxuICAgICAgICBzdG9wQ29sb3I6IHN0b3AuY29sb3IsXG4gICAgICAgIHN0b3BPcGFjaXR5OiBzdG9wLmFscGhhXG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH1cbn07XG52YXIgUmFkaWFsR3JhZGllbnRFbGVtZW50ID0gY2xhc3MgZXh0ZW5kcyBDb21wb25lbnQxNiB7XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGNlbnRlckFuY2hvclgsIGNlbnRlckFuY2hvclksIGlkLCB3aWR0aEZhY3RvciwgaGVpZ2h0RmFjdG9yLCBzdG9wcyB9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQ0MihcInJhZGlhbEdyYWRpZW50XCIsIHtcbiAgICAgIGlkLFxuICAgICAgY3k6IGNlbnRlckFuY2hvclksXG4gICAgICBjeDogY2VudGVyQW5jaG9yWCxcbiAgICAgIHI6IHdpZHRoRmFjdG9yLFxuICAgICAgZ3JhZGllbnRUcmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtjZW50ZXJBbmNob3JYfSwgJHtjZW50ZXJBbmNob3JZfSkgc2NhbGUoMSAke2hlaWdodEZhY3RvciAvIHdpZHRoRmFjdG9yfSkgdHJhbnNsYXRlKC0ke2NlbnRlckFuY2hvclh9LCAtJHtjZW50ZXJBbmNob3JZfSlgXG4gICAgfSwgc3RvcHMubWFwKChzdG9wLCBpZHgpID0+IHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDQyKFwic3RvcFwiLCB7XG4gICAgICAgIGtleTogaWR4LFxuICAgICAgICBvZmZzZXQ6IHN0b3AucG9zaXRpb24sXG4gICAgICAgIHN0b3BDb2xvcjogc3RvcC5jb2xvcixcbiAgICAgICAgc3RvcE9wYWNpdHk6IHN0b3AuYWxwaGFcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgfVxufTtcblxuLy8gc3JjL3JlbmRlci91dGlscy9jcmVhdGVUcmFuc2Zvcm1WYWx1ZXMudHNcbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybVZhbHVlcyhiYXNlVHJhbnNmb3JtLCBtb2RlKSB7XG4gIGxldCB7IHgsIHkgfSA9IGJhc2VUcmFuc2Zvcm07XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgcm90YXRpb24gfSA9IGJhc2VUcmFuc2Zvcm07XG4gIGlmIChtb2RlID09PSBcInJlc2V0WFlLZWVwRnJhY3Rpb25cIikge1xuICAgIHggPSB4IC0gTWF0aC5mbG9vcih4KTtcbiAgICB5ID0geSAtIE1hdGguZmxvb3IoeSk7XG4gIH0gZWxzZSBpZiAobW9kZSA9PT0gXCJyZXNldFhZXCIpIHtcbiAgICB4ID0gMDtcbiAgICB5ID0gMDtcbiAgfVxuICByZXR1cm4geyB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByb3RhdGlvbiB9O1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtTW9kZShpc1Jvb3RWZWN0b3JOb2RlLCBpbmNsdWRlVHJhbnNmb3JtKSB7XG4gIGlmIChpbmNsdWRlVHJhbnNmb3JtICE9PSB2b2lkIDApIHtcbiAgICBpZiAoaW5jbHVkZVRyYW5zZm9ybSkge1xuICAgICAgcmV0dXJuIFwiYXNJc1wiO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoIWlzUm9vdFZlY3Rvck5vZGUpIHtcbiAgICAgIHJldHVybiBcImFzSXNcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGlzUm9vdFZlY3Rvck5vZGUpIHtcbiAgICByZXR1cm4gXCJyZXNldFhZS2VlcEZyYWN0aW9uXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwicmVzZXRYWVwiO1xuICB9XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1WYWx1ZXMyKHJlY3QsIHJvdGF0aW9uLCBpc1Jvb3RWZWN0b3JOb2RlLCBpbmNsdWRlVHJhbnNmb3JtKSB7XG4gIGNvbnN0IHRyYW5zZm9ybU1vZGUgPSBnZXRUcmFuc2Zvcm1Nb2RlKGlzUm9vdFZlY3Rvck5vZGUsIGluY2x1ZGVUcmFuc2Zvcm0pO1xuICBjb25zdCBiYXNlVHJhbnNmb3JtID0geyAuLi5yZWN0LCByb3RhdGlvbiB9O1xuICBjb25zdCB0cmFuc2Zvcm0yID0gY3JlYXRlVHJhbnNmb3JtVmFsdWVzKGJhc2VUcmFuc2Zvcm0sIHRyYW5zZm9ybU1vZGUpO1xuICByZXR1cm4gdHJhbnNmb3JtMjtcbn1cblxuLy8gc3JjL3JlbmRlci90eXBlcy9zdmdFbGVtZW50QXR0cmlidXRlRGVmYXVsdHMudHNcbnZhciBzdmdFbGVtZW50QXR0cmlidXRlRGVmYXVsdHMgPSB7XG4gIHN0cm9rZTogXCJub25lXCIsXG4gIHN0cm9rZVdpZHRoOiAxLFxuICBzdHJva2VMaW5lY2FwOiBcImJ1dHRcIixcbiAgc3Ryb2tlTGluZWpvaW46IFwibWl0ZXJcIixcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogNCxcbiAgc3Ryb2tlRGFzaGFycmF5OiBcIjBcIixcbiAgc3Ryb2tlRGFzaG9mZnNldDogMCxcbiAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgZmlsbDogXCJibGFja1wiLFxuICBmaWxsUnVsZTogXCJub256ZXJvXCIsXG4gIGZpbGxPcGFjaXR5OiAxXG59O1xuXG4vLyBzcmMvcmVuZGVyL3ByZXNlbnRhdGlvbi9WZWN0b3IudHN4XG52YXIgX1ZlY3RvciA9IGNsYXNzIGV4dGVuZHMgTGF5ZXIge1xuICByZW5kZXIoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoc2FmZVdpbmRvd1tcInBlcmZcIl0pXG4gICAgICBzYWZlV2luZG93W1wicGVyZlwiXS5ub2RlUmVuZGVyKCk7XG4gICAgY29uc3Qge1xuICAgICAgb3BhY2l0eSxcbiAgICAgIGNhbGN1bGF0ZWRQYXRoLFxuICAgICAgZCxcbiAgICAgIGluc2lkZVN0cm9rZSxcbiAgICAgIHNoYXBlSWQsXG4gICAgICBzdHJva2VFbmFibGVkLFxuICAgICAgc3Ryb2tlQ2xpcElkLFxuICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICBpZEF0dHJpYnV0ZSxcbiAgICAgIHJlY3QsXG4gICAgICBzaGFkb3dzLFxuICAgICAgc3Ryb2tlQWxwaGEsXG4gICAgICBuYW1lLFxuICAgICAgaW5jbHVkZVRyYW5zZm9ybSxcbiAgICAgIGlzUm9vdFZlY3Rvck5vZGUsXG4gICAgICByb3RhdGlvbixcbiAgICAgIGlkLFxuICAgICAgbGluZUNhcCxcbiAgICAgIGxpbmVKb2luLFxuICAgICAgc3Ryb2tlQ29sb3IsXG4gICAgICBzdHJva2VNaXRlckxpbWl0LFxuICAgICAgc3Ryb2tlRGFzaEFycmF5LFxuICAgICAgc3Ryb2tlRGFzaE9mZnNldCxcbiAgICAgIGZpbGwsXG4gICAgICB2YXJpYW50cyxcbiAgICAgIHRyYW5zaXRpb25cbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIWlkIHx8ICFzaGFwZUlkIHx8ICFzdHJva2VDbGlwSWQpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCByb3RhdGUgPSAoX2IgPSAoX2EgPSB0aGlzLnByb3BzLnJvdGF0ZSkgIT0gbnVsbCA/IF9hIDogcm90YXRpb24pICE9IG51bGwgPyBfYiA6IDA7XG4gICAgY29uc3QgeyB0YXJnZXQgfSA9IFJlbmRlckVudmlyb25tZW50O1xuICAgIGNvbnN0IHRyYW5zZm9ybTIgPSB0cmFuc2Zvcm1WYWx1ZXMyKHJlY3QsIHJvdGF0ZSwgaXNSb290VmVjdG9yTm9kZSwgaW5jbHVkZVRyYW5zZm9ybSk7XG4gICAgbGV0IHZlY3RvckZpbGw7XG4gICAgbGV0IGZpbGxBbHBoYSA9IDA7XG4gICAgbGV0IGltYWdlUGF0dGVybjtcbiAgICBsZXQgbGluZWFyR3JhZGllbnQ7XG4gICAgbGV0IHJhZGlhbEdyYWRpZW50O1xuICAgIGlmICh0eXBlb2YgZmlsbCA9PT0gXCJzdHJpbmdcIiB8fCBDb2xvci5pc0NvbG9yT2JqZWN0KGZpbGwpKSB7XG4gICAgICBjb25zdCBmaWxsQ29sb3IgPSBDb2xvci5pc0NvbG9yT2JqZWN0KGZpbGwpID8gZmlsbC5pbml0aWFsVmFsdWUgfHwgQ29sb3IudG9SZ2JTdHJpbmcoZmlsbCkgOiBmaWxsO1xuICAgICAgaWYgKGZpbGxDb2xvciAhPT0gXCJ0cmFuc3BhcmVudFwiKSB7XG4gICAgICAgIHZlY3RvckZpbGwgPSBmaWxsQ29sb3I7XG4gICAgICAgIGZpbGxBbHBoYSA9IENvbnZlcnRDb2xvci5nZXRBbHBoYSh2ZWN0b3JGaWxsKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKExpbmVhckdyYWRpZW50LmlzTGluZWFyR3JhZGllbnQoZmlsbCkpIHtcbiAgICAgIGxpbmVhckdyYWRpZW50ID0gZWxlbWVudFByb3BlcnRpZXNGb3JMaW5lYXJHcmFkaWVudChmaWxsLCBpZCk7XG4gICAgICB2ZWN0b3JGaWxsID0gYHVybCgjJHtsaW5lYXJHcmFkaWVudC5pZH0pYDtcbiAgICAgIGZpbGxBbHBoYSA9IDE7XG4gICAgfSBlbHNlIGlmIChSYWRpYWxHcmFkaWVudC5pc1JhZGlhbEdyYWRpZW50KGZpbGwpKSB7XG4gICAgICByYWRpYWxHcmFkaWVudCA9IGVsZW1lbnRQcm9wZXJ0aWVzRm9yUmFkaWFsR3JhZGllbnQoZmlsbCwgaWQpO1xuICAgICAgdmVjdG9yRmlsbCA9IGB1cmwoIyR7cmFkaWFsR3JhZGllbnQuaWR9KWA7XG4gICAgICBmaWxsQWxwaGEgPSAxO1xuICAgIH0gZWxzZSBpZiAoQmFja2dyb3VuZEltYWdlLmlzSW1hZ2VPYmplY3QoZmlsbCkpIHtcbiAgICAgIGltYWdlUGF0dGVybiA9IGltYWdlUGF0dGVyblByb3BzRm9yRmlsbChmaWxsLCB0cmFuc2Zvcm0yLCBpZCk7XG4gICAgICBpZiAoaW1hZ2VQYXR0ZXJuKSB7XG4gICAgICAgIHZlY3RvckZpbGwgPSBgdXJsKCMke2ltYWdlUGF0dGVybi5pZH0pYDtcbiAgICAgICAgZmlsbEFscGhhID0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZlY3RvckZpbGwgPT09IHN2Z0VsZW1lbnRBdHRyaWJ1dGVEZWZhdWx0cy5maWxsKSB7XG4gICAgICB2ZWN0b3JGaWxsID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAodmVjdG9yRmlsbCA9PT0gdm9pZCAwKSB7XG4gICAgICB2ZWN0b3JGaWxsID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgIH1cbiAgICBjb25zdCBmaWxsRW5hYmxlZCA9IHZlY3RvckZpbGwgIT09IHZvaWQgMCAmJiB2ZWN0b3JGaWxsICE9PSBcInRyYW5zcGFyZW50XCIgJiYgZmlsbEFscGhhICE9PSAwO1xuICAgIGlmICghZmlsbEVuYWJsZWQgJiYgIXN0cm9rZUVuYWJsZWQpIHtcbiAgICAgIGZpbGxBbHBoYSA9IDE7XG4gICAgfVxuICAgIGxldCBtYWluRWxlbWVudDtcbiAgICBsZXQgc3Ryb2tlQ2xpcFBhdGggPSBudWxsO1xuICAgIGxldCBzaGFwZVJlZmVyZW5jZSA9IG51bGw7XG4gICAgbGV0IHN0cm9rZUVsZW1lbnQgPSBudWxsO1xuICAgIGxldCBwYXRoVHJhbnNsYXRlO1xuICAgIGxldCBlbGVtZW50VHJhbnNmb3JtO1xuICAgIGNvbnN0IHRyYW5zbGF0ZVBhdGhzID0gdGFyZ2V0ID09PSBSZW5kZXJUYXJnZXQuZXhwb3J0O1xuICAgIGlmICh0cmFuc2Zvcm0yLnJvdGF0aW9uID09PSAwICYmIHRyYW5zbGF0ZVBhdGhzKSB7XG4gICAgICBwYXRoVHJhbnNsYXRlID0gdHJhbnNmb3JtMjtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aFRyYW5zbGF0ZSA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgZWxlbWVudFRyYW5zZm9ybSA9IHRyYW5zZm9ybVN0cmluZyh0cmFuc2Zvcm0yKTtcbiAgICB9XG4gICAgY29uc3QgcGF0aEF0dHJpYnV0ZXMgPSB7XG4gICAgICBkOiBkICE9IG51bGwgPyBkIDogdG9TVkdQYXRoKGNhbGN1bGF0ZWRQYXRoLCBwYXRoVHJhbnNsYXRlLCB0YXJnZXQpLFxuICAgICAgdHJhbnNmb3JtOiBlbGVtZW50VHJhbnNmb3JtXG4gICAgfTtcbiAgICBjb25zdCBzdmdTdHJva2VBdHRyaWJ1dGVzID0ge307XG4gICAgaWYgKHN0cm9rZUVuYWJsZWQgJiYgc3Ryb2tlV2lkdGggIT09IDApIHtcbiAgICAgIHN2Z1N0cm9rZUF0dHJpYnV0ZXMuc3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICAgIHN2Z1N0cm9rZUF0dHJpYnV0ZXMuc3Ryb2tlID0gc3Ryb2tlQ29sb3I7XG4gICAgICBzdmdTdHJva2VBdHRyaWJ1dGVzLnN0cm9rZUxpbmVjYXAgPSBsaW5lQ2FwO1xuICAgICAgc3ZnU3Ryb2tlQXR0cmlidXRlcy5zdHJva2VMaW5lam9pbiA9IGxpbmVKb2luO1xuICAgICAgaWYgKGxpbmVKb2luID09PSBcIm1pdGVyXCIpIHtcbiAgICAgICAgc3ZnU3Ryb2tlQXR0cmlidXRlcy5zdHJva2VNaXRlcmxpbWl0ID0gc3Ryb2tlTWl0ZXJMaW1pdDtcbiAgICAgIH1cbiAgICAgIHN2Z1N0cm9rZUF0dHJpYnV0ZXMuc3Ryb2tlRGFzaGFycmF5ID0gc3Ryb2tlRGFzaEFycmF5O1xuICAgICAgaWYgKHN0cm9rZURhc2hPZmZzZXQgIT09IDApIHtcbiAgICAgICAgc3ZnU3Ryb2tlQXR0cmlidXRlcy5zdHJva2VEYXNob2Zmc2V0ID0gc3Ryb2tlRGFzaE9mZnNldDtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXk2IGluIHN2Z0VsZW1lbnRBdHRyaWJ1dGVEZWZhdWx0cykge1xuICAgICAgaWYgKHN2Z1N0cm9rZUF0dHJpYnV0ZXNba2V5Nl0gPT09IHN2Z0VsZW1lbnRBdHRyaWJ1dGVEZWZhdWx0c1trZXk2XSkge1xuICAgICAgICBzdmdTdHJva2VBdHRyaWJ1dGVzW2tleTZdID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbnRlcm5hbFNoYXBlSWQgPSBJbnRlcm5hbElELmZvcktleShzaGFwZUlkKTtcbiAgICBjb25zdCBpbnRlcm5hbFN0cm9rZUNsaXBJZCA9IEludGVybmFsSUQuZm9yS2V5KHN0cm9rZUNsaXBJZCk7XG4gICAgY29uc3Qgc2hhZG93ID0gc2hhZG93Rm9yU2hhcGUoc2hhZG93cywgcmVjdCwgaW50ZXJuYWxTaGFwZUlkLCBmaWxsQWxwaGEsIHN0cm9rZUFscGhhLCBzdHJva2VXaWR0aCwgaW50ZXJuYWxTdHJva2VDbGlwSWQsIHN2Z1N0cm9rZUF0dHJpYnV0ZXMpO1xuICAgIGNvbnN0IGN1cnJlbnROYW1lID0gdGFyZ2V0ID09PSBSZW5kZXJUYXJnZXQucHJldmlldyA/IG5hbWUgfHwgdm9pZCAwIDogdm9pZCAwO1xuICAgIGlmIChzaGFkb3cuaW5zZXRFbGVtZW50ICE9PSBudWxsIHx8IHNoYWRvdy5vdXRzZXRFbGVtZW50ICE9PSBudWxsIHx8IGluc2lkZVN0cm9rZSkge1xuICAgICAgcGF0aEF0dHJpYnV0ZXMuaWQgPSBpbnRlcm5hbFNoYXBlSWQuaWQ7XG4gICAgICBzaGFwZVJlZmVyZW5jZSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50NDMobW90aW9uLnBhdGgsIHtcbiAgICAgICAgLi4ueyAuLi5wYXRoQXR0cmlidXRlcyB9LFxuICAgICAgICB2YXJpYW50cyxcbiAgICAgICAgdHJhbnNpdGlvblxuICAgICAgfSk7XG4gICAgICBpZiAoc2hhZG93Lm5lZWRzU3Ryb2tlQ2xpcCB8fCBpbnNpZGVTdHJva2UpIHtcbiAgICAgICAgc3Ryb2tlQ2xpcFBhdGggPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDQzKFwiY2xpcFBhdGhcIiwge1xuICAgICAgICAgIGlkOiBpbnRlcm5hbFN0cm9rZUNsaXBJZC5pZFxuICAgICAgICB9LCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDQzKFwidXNlXCIsIHtcbiAgICAgICAgICB4bGlua0hyZWY6IGludGVybmFsU2hhcGVJZC5saW5rXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaGFkb3cuaW5zZXRFbGVtZW50ICE9PSBudWxsICYmIHN0cm9rZUVuYWJsZWQgJiYgc3Ryb2tlV2lkdGggJiYgc3Ryb2tlV2lkdGggPiAwKSB7XG4gICAgICAgIG1haW5FbGVtZW50ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQ0MyhcInVzZVwiLCB7XG4gICAgICAgICAgeGxpbmtIcmVmOiBpbnRlcm5hbFNoYXBlSWQubGluayxcbiAgICAgICAgICBmaWxsOiB2ZWN0b3JGaWxsLFxuICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IFwiMFwiLFxuICAgICAgICAgIG5hbWU6IGN1cnJlbnROYW1lXG4gICAgICAgIH0pO1xuICAgICAgICBzdHJva2VFbGVtZW50ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQ0MyhcInVzZVwiLCB7XG4gICAgICAgICAgeGxpbmtIcmVmOiBpbnRlcm5hbFNoYXBlSWQubGluayxcbiAgICAgICAgICBjbGlwUGF0aDogaW50ZXJuYWxTdHJva2VDbGlwSWQudXJsTGluayxcbiAgICAgICAgICBmaWxsOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgLi4uc3ZnU3Ryb2tlQXR0cmlidXRlcyxcbiAgICAgICAgICBzdHJva2VXaWR0aFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1haW5FbGVtZW50ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQ0MyhcInVzZVwiLCB7XG4gICAgICAgICAgeGxpbmtIcmVmOiBpbnRlcm5hbFNoYXBlSWQubGluayxcbiAgICAgICAgICBmaWxsOiB2ZWN0b3JGaWxsLFxuICAgICAgICAgIGNsaXBQYXRoOiBpbnRlcm5hbFN0cm9rZUNsaXBJZC51cmxMaW5rLFxuICAgICAgICAgIC4uLnN2Z1N0cm9rZUF0dHJpYnV0ZXMsXG4gICAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgbmFtZTogY3VycmVudE5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGhBdHRyaWJ1dGVzLmlkID0gaWRBdHRyaWJ1dGU7XG4gICAgICBtYWluRWxlbWVudCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50NDMobW90aW9uLnBhdGgsIHtcbiAgICAgICAgLi4ue1xuICAgICAgICAgIC4uLnBhdGhBdHRyaWJ1dGVzLFxuICAgICAgICAgIGZpbGw6IHZlY3RvckZpbGwsXG4gICAgICAgICAgLi4uc3ZnU3Ryb2tlQXR0cmlidXRlc1xuICAgICAgICB9LFxuICAgICAgICBuYW1lOiBjdXJyZW50TmFtZSxcbiAgICAgICAgdmFyaWFudHMsXG4gICAgICAgIHRyYW5zaXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBpbWFnZVBhdHRlcm5FbGVtZW50ID0gaW1hZ2VQYXR0ZXJuID8gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQ0MyhJbWFnZVBhdHRlcm5FbGVtZW50LCB7XG4gICAgICAuLi5pbWFnZVBhdHRlcm5cbiAgICB9KSA6IHZvaWQgMDtcbiAgICBsZXQgZ3JhZGllbnQ7XG4gICAgaWYgKGxpbmVhckdyYWRpZW50KSB7XG4gICAgICBncmFkaWVudCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50NDMoTGluZWFyR3JhZGllbnRFbGVtZW50LCB7XG4gICAgICAgIC4uLmxpbmVhckdyYWRpZW50XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHJhZGlhbEdyYWRpZW50KSB7XG4gICAgICBncmFkaWVudCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50NDMoUmFkaWFsR3JhZGllbnRFbGVtZW50LCB7XG4gICAgICAgIC4uLnJhZGlhbEdyYWRpZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGRlZnMgPSBudWxsO1xuICAgIGlmIChzaGFwZVJlZmVyZW5jZSB8fCBzdHJva2VDbGlwUGF0aCB8fCBzaGFkb3cuZGVmaW5pdGlvbiAmJiBzaGFkb3cuZGVmaW5pdGlvbi5sZW5ndGggfHwgZ3JhZGllbnQgfHwgaW1hZ2VQYXR0ZXJuRWxlbWVudCkge1xuICAgICAgZGVmcyA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50NDMoXCJkZWZzXCIsIG51bGwsIHNoYXBlUmVmZXJlbmNlLCBzdHJva2VDbGlwUGF0aCwgc2hhZG93LmRlZmluaXRpb24sIGdyYWRpZW50LCBpbWFnZVBhdHRlcm5FbGVtZW50KTtcbiAgICB9XG4gICAgY29uc3Qgb3BhY2l0eVZhbHVlID0gb3BhY2l0eSAhPSBudWxsID8gb3BhY2l0eSA6IHZhcmlhbnRzID8gMSA6IHZvaWQgMDtcbiAgICBpZiAoZGVmcyA9PT0gbnVsbCAmJiBzaGFkb3cub3V0c2V0RWxlbWVudCA9PT0gbnVsbCAmJiBzaGFkb3cuaW5zZXRFbGVtZW50ID09PSBudWxsICYmIHN0cm9rZUVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgIG1haW5FbGVtZW50ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQ0Myhtb3Rpb24ucGF0aCwge1xuICAgICAgICAuLi57XG4gICAgICAgICAgLi4ucGF0aEF0dHJpYnV0ZXMsXG4gICAgICAgICAgZmlsbDogdmVjdG9yRmlsbCxcbiAgICAgICAgICAuLi5zdmdTdHJva2VBdHRyaWJ1dGVzXG4gICAgICAgIH0sXG4gICAgICAgIG9wYWNpdHk6IG9wYWNpdHlWYWx1ZSxcbiAgICAgICAgdmFyaWFudHMsXG4gICAgICAgIHRyYW5zaXRpb24sXG4gICAgICAgIG5hbWU6IGN1cnJlbnROYW1lXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlckVsZW1lbnQobWFpbkVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJFbGVtZW50KC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50NDMobW90aW9uLmcsIHtcbiAgICAgICAgb3BhY2l0eTogb3BhY2l0eVZhbHVlLFxuICAgICAgICB2YXJpYW50cyxcbiAgICAgICAgdHJhbnNpdGlvblxuICAgICAgfSwgZGVmcywgc2hhZG93Lm91dHNldEVsZW1lbnQsIG1haW5FbGVtZW50LCBzaGFkb3cuaW5zZXRFbGVtZW50LCBzdHJva2VFbGVtZW50KSk7XG4gICAgfVxuICB9XG4gIHJlbmRlckVsZW1lbnQoZWxlbWVudCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyBpc1Jvb3RWZWN0b3JOb2RlLCB3aWR0aCwgaGVpZ2h0LCByZWN0LCB3aWxsQ2hhbmdlVHJhbnNmb3JtIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGZyYW1lMiA9IChfYiA9IChfYSA9IHRoaXMucHJvcHMuZnJhbWUpICE9IG51bGwgPyBfYSA6IHJlY3QpICE9IG51bGwgPyBfYiA6IHsgeDogMCwgeTogMCwgd2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDAgfTtcbiAgICBpZiAoIWlzUm9vdFZlY3Rvck5vZGUpXG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQ0MyhTVkdSb290LCB7XG4gICAgICAuLi57IGZyYW1lOiBmcmFtZTIsIHdpZHRoLCBoZWlnaHQsIHdpbGxDaGFuZ2VUcmFuc2Zvcm0gfVxuICAgIH0sIGVsZW1lbnQpO1xuICB9XG59O1xudmFyIFZlY3RvciA9IF9WZWN0b3I7XG5WZWN0b3IuZGVmYXVsdFZlY3RvclByb3BzID0ge1xuICBpc1Jvb3RWZWN0b3JOb2RlOiBmYWxzZSxcbiAgbmFtZTogbnVsbCxcbiAgaW5jbHVkZVRyYW5zZm9ybTogdm9pZCAwLFxuICBkZWZhdWx0RmlsbENvbG9yOiB2b2lkIDAsXG4gIGRlZmF1bHRTdHJva2VDb2xvcjogdm9pZCAwLFxuICBkZWZhdWx0U3Ryb2tlV2lkdGg6IHZvaWQgMCxcbiAgZGVmYXVsdFN0cm9rZUFsaWdubWVudDogXCJjZW50ZXJcIixcbiAgd2lkdGg6IDEwMCxcbiAgaGVpZ2h0OiAxMDAsXG4gIHJvdGF0aW9uOiAwLFxuICByb3RhdGU6IHZvaWQgMCxcbiAgZnJhbWU6IHZvaWQgMCxcbiAgb3BhY2l0eTogdm9pZCAwLFxuICBjYWxjdWxhdGVkUGF0aDogW10sXG4gIGQ6IHZvaWQgMCxcbiAgc2hhcGVJZDogdm9pZCAwLFxuICBpbnNpZGVTdHJva2U6IGZhbHNlLFxuICBzdHJva2VFbmFibGVkOiB0cnVlLFxuICBzdHJva2VDbGlwSWQ6IHZvaWQgMCxcbiAgc3Ryb2tlV2lkdGg6IHZvaWQgMCxcbiAgaWRBdHRyaWJ1dGU6IHZvaWQgMCxcbiAgdHJhbnNpdGlvbjogdm9pZCAwLFxuICBzaGFkb3dzOiBbXSxcbiAgc3Ryb2tlQWxwaGE6IDEsXG4gIHJlY3Q6IHsgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9LFxuICBsaW5lQ2FwOiBcImJ1dHRcIixcbiAgc3Ryb2tlQ29sb3I6IFwiIzBBRlwiLFxuICBsaW5lSm9pbjogXCJtaXRlclwiLFxuICBzdHJva2VNaXRlckxpbWl0OiA0LFxuICBzdHJva2VEYXNoQXJyYXk6IFwiMFwiLFxuICBzdHJva2VEYXNoT2Zmc2V0OiAwLFxuICBmaWxsOiBcInJnYmEoMCwxNzAsMjU1LDAuNSlcIlxufTtcblZlY3Rvci5kZWZhdWx0UHJvcHMgPSB7XG4gIC4uLkxheWVyLmRlZmF1bHRQcm9wcyxcbiAgLi4uX1ZlY3Rvci5kZWZhdWx0VmVjdG9yUHJvcHNcbn07XG5cbi8vIHNyYy9yZW5kZXIvcHJlc2VudGF0aW9uL1ZlY3Rvckdyb3VwLnRzeFxuaW1wb3J0IHtcbiAgY3JlYXRlRWxlbWVudCBhcyBjcmVhdGVFbGVtZW50NDRcbn0gZnJvbSBcInJlYWN0XCI7XG52YXIgX1ZlY3Rvckdyb3VwID0gY2xhc3MgZXh0ZW5kcyBMYXllciB7XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoc2FmZVdpbmRvd1tcInBlcmZcIl0pXG4gICAgICBzYWZlV2luZG93W1wicGVyZlwiXS5ub2RlUmVuZGVyKCk7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBuYW1lOiBuYW1lUHJvcCxcbiAgICAgIG9wYWNpdHksXG4gICAgICB2aXNpYmxlLFxuICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgIGRlZmF1bHROYW1lLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBpbmNsdWRlVHJhbnNmb3JtLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgaXNSb290VmVjdG9yTm9kZVxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmICghdmlzaWJsZSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSBSZW5kZXJFbnZpcm9ubWVudDtcbiAgICBjb25zdCByZWN0ID0geyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH07XG4gICAgY29uc3QgdHJhbnNmb3JtMiA9IHRyYW5zZm9ybVZhbHVlczIocmVjdCwgcm90YXRpb24sIGlzUm9vdFZlY3Rvck5vZGUsIGluY2x1ZGVUcmFuc2Zvcm0pO1xuICAgIGNvbnN0IGFkZE5hbWVzID0gdGFyZ2V0ID09PSBSZW5kZXJUYXJnZXQucHJldmlldztcbiAgICBsZXQgbmFtZSA9IHZvaWQgMDtcbiAgICBpZiAoYWRkTmFtZXMpIHtcbiAgICAgIGlmICh0YXJnZXROYW1lKSB7XG4gICAgICAgIG5hbWUgPSB0YXJnZXROYW1lO1xuICAgICAgfSBlbHNlIGlmIChuYW1lUHJvcCkge1xuICAgICAgICBuYW1lID0gbmFtZVByb3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lID0gZGVmYXVsdE5hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbmRlckVsZW1lbnQoLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQ0NChcImdcIiwge1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1TdHJpbmcodHJhbnNmb3JtMiksXG4gICAgICAuLi57IGlkLCBuYW1lLCBvcGFjaXR5IH1cbiAgICB9LCBjaGlsZHJlbikpO1xuICB9XG4gIHJlbmRlckVsZW1lbnQoZWxlbWVudCkge1xuICAgIGNvbnN0IHsgaXNSb290VmVjdG9yTm9kZSwgd2lkdGgsIGhlaWdodCwgZnJhbWU6IGZyYW1lMiwgd2lsbENoYW5nZVRyYW5zZm9ybSB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIWlzUm9vdFZlY3Rvck5vZGUpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQ0NChTVkdSb290LCB7XG4gICAgICAuLi57IGZyYW1lOiBmcmFtZTIsIHdpZHRoLCBoZWlnaHQsIHdpbGxDaGFuZ2VUcmFuc2Zvcm0gfVxuICAgIH0sIGVsZW1lbnQpO1xuICB9XG59O1xudmFyIFZlY3Rvckdyb3VwID0gX1ZlY3Rvckdyb3VwO1xuVmVjdG9yR3JvdXAuZGVmYXVsdFZlY3Rvckdyb3VwUHJvcHMgPSB7XG4gIG5hbWU6IHZvaWQgMCxcbiAgb3BhY2l0eTogdm9pZCAwLFxuICB2aXNpYmxlOiB0cnVlLFxuICB4OiAwLFxuICB5OiAwLFxuICByb3RhdGlvbjogMCxcbiAgd2lkdGg6IDEwMCxcbiAgaGVpZ2h0OiAxMDAsXG4gIHRhcmdldE5hbWU6IHZvaWQgMCxcbiAgZGVmYXVsdE5hbWU6IFwiXCIsXG4gIGlzUm9vdFZlY3Rvck5vZGU6IGZhbHNlLFxuICBpbmNsdWRlVHJhbnNmb3JtOiB2b2lkIDAsXG4gIGZyYW1lOiB7IHg6IDAsIHk6IDAsIHdpZHRoOiAxMDAsIGhlaWdodDogMTAwIH1cbn07XG5WZWN0b3JHcm91cC5kZWZhdWx0UHJvcHMgPSB7XG4gIC4uLkxheWVyLmRlZmF1bHRQcm9wcyxcbiAgLi4uX1ZlY3Rvckdyb3VwLmRlZmF1bHRWZWN0b3JHcm91cFByb3BzXG59O1xuXG4vLyBzcmMvcmVuZGVyL3ByZXNlbnRhdGlvbi9EZXByZWNhdGVkQ29tcG9uZW50Q29udGFpbmVyLnRzeFxuaW1wb3J0IHtcbiAgQ2hpbGRyZW4gYXMgQ2hpbGRyZW4xMSxcbiAgY2xvbmVFbGVtZW50IGFzIGNsb25lRWxlbWVudDksXG4gIGNyZWF0ZUVsZW1lbnQgYXMgY3JlYXRlRWxlbWVudDQ1XG59IGZyb20gXCJyZWFjdFwiO1xudmFyIF9EZXByZWNhdGVkQ29tcG9uZW50Q29udGFpbmVyID0gY2xhc3MgZXh0ZW5kcyBMYXllciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zdGF0ZSA9IHt9O1xuICB9XG4gIGNvbXBvbmVudERpZENhdGNoKGVycm9yLCBpbmZvKSB7XG4gICAgbGV0IHN0YWNrID0gaW5mby5jb21wb25lbnRTdGFjay5zcGxpdChcIlxcblwiKS5maWx0ZXIoKGxpbmUpID0+IGxpbmUubGVuZ3RoICE9PSAwKTtcbiAgICBsZXQgY3VycmVudEluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2Ygc3RhY2spIHtcbiAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoYCAgICBpbiAke3RoaXMuY29uc3RydWN0b3IubmFtZX1gKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRJbmRleCsrO1xuICAgIH1cbiAgICBzdGFjayA9IHN0YWNrLnNsaWNlKDAsIGN1cnJlbnRJbmRleCk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBsYXN0RXJyb3I6IHtcbiAgICAgICAgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIG5hbWU6IGVycm9yLm5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIGNvbXBvbmVudFN0YWNrOiBzdGFja1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJlbmRlckVycm9yUGxhY2Vob2xkZXIoZmlsZSwgZXJyb3IpIHtcbiAgICBjb25zdCB7IFJlbmRlclBsYWNlaG9sZGVyIH0gPSBydW50aW1lO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDQ1KEZyYW1lV2l0aE1vdGlvbiwge1xuICAgICAgLi4udGhpcy5wcm9wcyxcbiAgICAgIGJhY2tncm91bmQ6IG51bGxcbiAgICB9LCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDQ1KFJlbmRlclBsYWNlaG9sZGVyLCB7XG4gICAgICBlcnJvcjogeyBlcnJvciwgZmlsZSB9XG4gICAgfSkpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmIChzYWZlV2luZG93W1wicGVyZlwiXSlcbiAgICAgIHNhZmVXaW5kb3dbXCJwZXJmXCJdLm5vZGVSZW5kZXIoKTtcbiAgICBsZXQgeyBjaGlsZHJlbiB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGNvbXBvbmVudElkZW50aWZpZXIsIGlubmVyUmVmIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgbGFzdEVycm9yOiBlcnJvciB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBub0NoaWxkcmVuID0gIWNoaWxkcmVuIHx8IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmZpbHRlcigoYzIpID0+IGMyKS5sZW5ndGggPT09IDA7XG4gICAgaWYgKG5vQ2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGVycm9yQ29tcG9uZW50ID0gcnVudGltZS5jb21wb25lbnRMb2FkZXIuZXJyb3JGb3JJZGVudGlmaWVyKGNvbXBvbmVudElkZW50aWZpZXIpO1xuICAgICAgaWYgKGVycm9yQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckVycm9yUGxhY2Vob2xkZXIoZXJyb3JDb21wb25lbnQuZmlsZSwgZXJyb3JDb21wb25lbnQuZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXJyb3IgJiYgZXJyb3IuY2hpbGRyZW4gPT09IGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBjb21wb25lbnQgPSBydW50aW1lLmNvbXBvbmVudExvYWRlci5jb21wb25lbnRGb3JJZGVudGlmaWVyKGNvbXBvbmVudElkZW50aWZpZXIpO1xuICAgICAgY29uc3QgZmlsZSA9IGNvbXBvbmVudCA/IGNvbXBvbmVudC5maWxlIDogXCI/Pz9cIjtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlckVycm9yUGxhY2Vob2xkZXIoZmlsZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICAgIChfYiA9IChfYSA9IHNhZmVXaW5kb3cpW1wiX19jaGVja0NvbXBvbmVudEJ1ZGdldF9fXCJdKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgbGV0IGZyYW1lUHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmIChSZW5kZXJUYXJnZXQuY3VycmVudCgpICE9PSBSZW5kZXJUYXJnZXQuY2FudmFzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxlZnQsXG4gICAgICAgIHJpZ2h0LFxuICAgICAgICB0b3AsXG4gICAgICAgIGJvdHRvbSxcbiAgICAgICAgY2VudGVyLFxuICAgICAgICBjZW50ZXJYLFxuICAgICAgICBjZW50ZXJZLFxuICAgICAgICBhc3BlY3RSYXRpbyxcbiAgICAgICAgcGFyZW50U2l6ZSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIHZpc2libGUsXG4gICAgICAgIF9jb25zdHJhaW50cyxcbiAgICAgICAgX2luaXRpYWxTdHlsZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcG9zaXRpb25TdGlja3ksXG4gICAgICAgIHBvc2l0aW9uU3RpY2t5VG9wLFxuICAgICAgICBwb3NpdGlvblN0aWNreVJpZ2h0LFxuICAgICAgICBwb3NpdGlvblN0aWNreUJvdHRvbSxcbiAgICAgICAgcG9zaXRpb25TdGlja3lMZWZ0LFxuICAgICAgICBjb21wb25lbnRJZGVudGlmaWVyOiBvcmlnaW5hbENvbXBvbmVudElkZW50aWZpZXIsXG4gICAgICAgIGNoaWxkcmVuOiBvcmlnaW5hbENoaWxkcmVuLFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgZHVwbGljYXRlZEZyb20sXG4gICAgICAgIHdpZHRoVHlwZSxcbiAgICAgICAgaGVpZ2h0VHlwZSxcbiAgICAgICAgLi4uY2hpbGRQcm9wc1xuICAgICAgfSA9IGZyYW1lUHJvcHM7XG4gICAgICBjaGlsZHJlbiA9IENoaWxkcmVuMTEubWFwKG9yaWdpbmFsQ2hpbGRyZW4sIChjaGlsZCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICBpZiAoIWlzUmVhY3RDaGlsZChjaGlsZCkgfHwgIWlzUmVhY3RFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUGFnZU9yU2Nyb2xsKG9yaWdpbmFsQ29tcG9uZW50SWRlbnRpZmllcikpIHtcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQ0NShMYXlvdXRHcm91cENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgIHZhbHVlOiAoX2EyID0gdGhpcy5wcm9wcy5fX2xheW91dElkKSAhPSBudWxsID8gX2EyIDogbnVsbFxuICAgICAgICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50NDUoQW5pbWF0ZVNoYXJlZExheW91dCwgbnVsbCwgLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQ0NShBdXRvbWF0aWNMYXlvdXRJZHMsIHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgfSwgY2xvbmVFbGVtZW50OShjaGlsZCwgY2hpbGRQcm9wcykpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lRWxlbWVudDkoY2hpbGQsIGNoaWxkUHJvcHMpO1xuICAgICAgfSk7XG4gICAgICBmcmFtZVByb3BzID0ge1xuICAgICAgICBzdHlsZSxcbiAgICAgICAgX2NvbnN0cmFpbnRzLFxuICAgICAgICBfaW5pdGlhbFN0eWxlLFxuICAgICAgICBsZWZ0LFxuICAgICAgICByaWdodCxcbiAgICAgICAgdG9wLFxuICAgICAgICBib3R0b20sXG4gICAgICAgIGNlbnRlcixcbiAgICAgICAgY2VudGVyWCxcbiAgICAgICAgY2VudGVyWSxcbiAgICAgICAgYXNwZWN0UmF0aW8sXG4gICAgICAgIHBhcmVudFNpemUsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICB2aXNpYmxlLFxuICAgICAgICBuYW1lLFxuICAgICAgICBkdXBsaWNhdGVkRnJvbSxcbiAgICAgICAgaWQ6IGZyYW1lUHJvcHMuaWQsXG4gICAgICAgIGxheW91dElkOiB0aGlzLnByb3BzLl9fbGF5b3V0SWQsXG4gICAgICAgIHdpZHRoVHlwZSxcbiAgICAgICAgaGVpZ2h0VHlwZSxcbiAgICAgICAgcG9zaXRpb25TdGlja3ksXG4gICAgICAgIHBvc2l0aW9uU3RpY2t5VG9wLFxuICAgICAgICBwb3NpdGlvblN0aWNreVJpZ2h0LFxuICAgICAgICBwb3NpdGlvblN0aWNreUJvdHRvbSxcbiAgICAgICAgcG9zaXRpb25TdGlja3lMZWZ0XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQ0NShDb21wb25lbnRDb250YWluZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50NDUoRnJhbWVXaXRoTW90aW9uLCB7XG4gICAgICBcImRhdGEtZnJhbWVyLWNvbXBvbmVudC1jb250YWluZXJcIjogdHJ1ZSxcbiAgICAgIGJhY2tncm91bmQ6IG51bGwsXG4gICAgICBvdmVyZmxvdzogXCJ2aXNpYmxlXCIsXG4gICAgICByZWY6IGlubmVyUmVmLFxuICAgICAgLi4uZnJhbWVQcm9wc1xuICAgIH0sIGNoaWxkcmVuKSk7XG4gIH1cbn07XG52YXIgRGVwcmVjYXRlZENvbXBvbmVudENvbnRhaW5lciA9IF9EZXByZWNhdGVkQ29tcG9uZW50Q29udGFpbmVyO1xuRGVwcmVjYXRlZENvbXBvbmVudENvbnRhaW5lci5zdXBwb3J0c0NvbnN0cmFpbnRzID0gdHJ1ZTtcbkRlcHJlY2F0ZWRDb21wb25lbnRDb250YWluZXIuZGVmYXVsdENvbXBvbmVudENvbnRhaW5lclByb3BzID0ge1xuICBzdHlsZToge30sXG4gIHZpc2libGU6IHRydWUsXG4gIGNvbXBvbmVudElkZW50aWZpZXI6IFwiXCJcbn07XG5EZXByZWNhdGVkQ29tcG9uZW50Q29udGFpbmVyLmRlZmF1bHRQcm9wcyA9IHtcbiAgLi4uTGF5ZXIuZGVmYXVsdFByb3BzLFxuICAuLi5fRGVwcmVjYXRlZENvbXBvbmVudENvbnRhaW5lci5kZWZhdWx0Q29tcG9uZW50Q29udGFpbmVyUHJvcHNcbn07XG5EZXByZWNhdGVkQ29tcG9uZW50Q29udGFpbmVyLmNvbnRleHRUeXBlID0gQ29tcG9uZW50Q29udGFpbmVyQ29udGV4dDtcbmZ1bmN0aW9uIGlzUGFnZU9yU2Nyb2xsKGlkZW50aWZpZXIpIHtcbiAgaWYgKCFpZGVudGlmaWVyKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGlkZW50aWZpZXIgPT09IFwiZnJhbWVyL1BhZ2VcIilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKGlkZW50aWZpZXIgPT09IFwiZnJhbWVyL1Njcm9sbFwiKVxuICAgIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNyYy9yZW5kZXIvcHJlc2VudGF0aW9uL1ByZXNlbnRhdGlvblRyZWUudHNcbmZ1bmN0aW9uIGNvbnZlcnRQcmVzZW50YXRpb25UcmVlKG5vZGUsIGNvbnZlcnRlciwgY29tcG9uZW50RGVmaW5pdGlvblByb3ZpZGVyLCBnZXRDYWNoZWROb2RlLCBza2lwQ29kZUNvbXBvbmVudFByb3BzQ2FjaGUgPSBmYWxzZSkge1xuICBjb25zdCBjYWNoZWROb2RlID0gZ2V0Q2FjaGVkTm9kZSAmJiBnZXRDYWNoZWROb2RlKG5vZGUpO1xuICBpZiAoY2FjaGVkTm9kZSlcbiAgICByZXR1cm4gY2FjaGVkTm9kZTtcbiAgbGV0IGNoaWxkcmVuO1xuICBpZiAoaXNDb2RlQ29tcG9uZW50Q29udGFpbmVyUHJlc2VudGF0aW9uKG5vZGUpKSB7XG4gICAgY2hpbGRyZW4gPSBjb252ZXJ0Q29kZUNvbXBvbmVudENvbnRhaW5lcihjb21wb25lbnREZWZpbml0aW9uUHJvdmlkZXIsIG5vZGUsIGNvbnZlcnRlciwgZ2V0Q2FjaGVkTm9kZSwgc2tpcENvZGVDb21wb25lbnRQcm9wc0NhY2hlKTtcbiAgfSBlbHNlIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcCgobikgPT4gY29udmVydFByZXNlbnRhdGlvblRyZWUobiwgY29udmVydGVyLCBjb21wb25lbnREZWZpbml0aW9uUHJvdmlkZXIsIGdldENhY2hlZE5vZGUsIHNraXBDb2RlQ29tcG9uZW50UHJvcHNDYWNoZSkpO1xuICB9XG4gIHJldHVybiBjb252ZXJ0ZXIobm9kZSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gaXNDb2RlQ29tcG9uZW50Q29udGFpbmVyUHJlc2VudGF0aW9uKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlLmNvZGVDb21wb25lbnRJZGVudGlmaWVyO1xufVxuZnVuY3Rpb24gY29udmVydENvZGVDb21wb25lbnRDb250YWluZXIoY29tcG9uZW50RGVmaW5pdGlvblByb3ZpZGVyLCBub2RlLCBjb252ZXJ0ZXIsIGdldENhY2hlZE5vZGUsIHNraXBDb2RlQ29tcG9uZW50UHJvcHNDYWNoZSA9IGZhbHNlKSB7XG4gIGNvbnN0IGNvZGVDb21wb25lbnRDaGlsZHJlbiA9IG5vZGUuZ2V0Q29tcG9uZW50Q2hpbGRyZW4gPyBub2RlLmdldENvbXBvbmVudENoaWxkcmVuKGNvbXBvbmVudERlZmluaXRpb25Qcm92aWRlcikgOiBbXTtcbiAgY29uc3QgY29kZUNvbXBvbmVudFNsb3RzID0gbm9kZS5nZXRDb21wb25lbnRTbG90Q2hpbGRyZW4gPyBub2RlLmdldENvbXBvbmVudFNsb3RDaGlsZHJlbihjb21wb25lbnREZWZpbml0aW9uUHJvdmlkZXIpIDoge307XG4gIGxldCBjb2RlQ29tcG9uZW50UHJlc2VudGF0aW9uO1xuICBjb25zdCBwcm9wcyA9IG5vZGUuZ2V0Q29kZUNvbXBvbmVudFByb3BzID8gbm9kZS5nZXRDb2RlQ29tcG9uZW50UHJvcHMoY29tcG9uZW50RGVmaW5pdGlvblByb3ZpZGVyLCB7IHNraXBDYWNoZTogc2tpcENvZGVDb21wb25lbnRQcm9wc0NhY2hlIH0pIDogdm9pZCAwO1xuICBpZiAobm9kZS5jYWNoZS5jb2RlQ29tcG9uZW50UHJlc2VudGF0aW9uKSB7XG4gICAgY29kZUNvbXBvbmVudFByZXNlbnRhdGlvbiA9IG5vZGUuY2FjaGUuY29kZUNvbXBvbmVudFByZXNlbnRhdGlvbjtcbiAgICBpZiAoIWlzU2hhbGxvd0VxdWFsQXJyYXkoY29kZUNvbXBvbmVudFByZXNlbnRhdGlvbi5jaGlsZHJlbiwgY29kZUNvbXBvbmVudENoaWxkcmVuKSkge1xuICAgICAgY29kZUNvbXBvbmVudFByZXNlbnRhdGlvbi5jYWNoZS5yZWFjdEVsZW1lbnQgPSBudWxsO1xuICAgICAgY29kZUNvbXBvbmVudFByZXNlbnRhdGlvbi5jaGlsZHJlbiA9IGNvZGVDb21wb25lbnRDaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKCFpc0VxdWFsKGNvZGVDb21wb25lbnRQcmVzZW50YXRpb24ucHJvcHMsIHByb3BzKSkge1xuICAgICAgY29kZUNvbXBvbmVudFByZXNlbnRhdGlvbi5jYWNoZS5yZWFjdEVsZW1lbnQgPSBudWxsO1xuICAgICAgY29kZUNvbXBvbmVudFByZXNlbnRhdGlvbi5jYWNoZS5wcm9wcyA9IG51bGw7XG4gICAgICBjb2RlQ29tcG9uZW50UHJlc2VudGF0aW9uLnByb3BzID0gcHJvcHM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHsgaWQ6IGNvbnRhaW5lcklkLCBjb2RlQ29tcG9uZW50SWRlbnRpZmllcjogaWRlbnRpZmllciwgY29kZUNvbXBvbmVudFBhY2thZ2VWZXJzaW9uIH0gPSBub2RlO1xuICAgIG5vZGUuY2FjaGUuY29kZUNvbXBvbmVudFByZXNlbnRhdGlvbiA9IGNvZGVDb21wb25lbnRQcmVzZW50YXRpb24gPSBuZXcgQ29kZUNvbXBvbmVudFByZXNlbnRhdGlvbihjb250YWluZXJJZCArIGlkZW50aWZpZXIsIGlkZW50aWZpZXIsIGNvZGVDb21wb25lbnRQYWNrYWdlVmVyc2lvbiwgcHJvcHMsIGNvZGVDb21wb25lbnRDaGlsZHJlbik7XG4gIH1cbiAgY29kZUNvbXBvbmVudFByZXNlbnRhdGlvbi5wcm9wcy5wbGFjZWhvbGRlcnMgPSBub2RlLmNhY2hlLnBsYWNlaG9sZGVycztcbiAgY29uc3Qgc2xvdEtleXMgPSBPYmplY3Qua2V5cyhjb2RlQ29tcG9uZW50U2xvdHMpO1xuICBpZiAoc2xvdEtleXMubGVuZ3RoKSB7XG4gICAgY29kZUNvbXBvbmVudFByZXNlbnRhdGlvbi5wcm9wcyA9IHsgLi4uY29kZUNvbXBvbmVudFByZXNlbnRhdGlvbi5wcm9wcyB9O1xuICAgIGNvZGVDb21wb25lbnRQcmVzZW50YXRpb24ucHJvcHMuX19zbG90S2V5cyA9IHNsb3RLZXlzO1xuICAgIGZvciAoY29uc3Qgc2xvdEtleSBvZiBzbG90S2V5cykge1xuICAgICAgY29uc3Qgc2xvdENoaWxkcmVuID0gY29kZUNvbXBvbmVudFNsb3RzW3Nsb3RLZXldLm1hcCgoY2hpbGQpID0+IGNvbnZlcnRQcmVzZW50YXRpb25UcmVlKGNoaWxkLCBjb252ZXJ0ZXIsIGNvbXBvbmVudERlZmluaXRpb25Qcm92aWRlciwgZ2V0Q2FjaGVkTm9kZSwgc2tpcENvZGVDb21wb25lbnRQcm9wc0NhY2hlKSk7XG4gICAgICBjb2RlQ29tcG9uZW50UHJlc2VudGF0aW9uLnByb3BzW3Nsb3RLZXldID0gc2xvdENoaWxkcmVuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW1xuICAgIGNvbnZlcnRlcihjb2RlQ29tcG9uZW50UHJlc2VudGF0aW9uLCBjb2RlQ29tcG9uZW50UHJlc2VudGF0aW9uLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGNvbnZlcnRQcmVzZW50YXRpb25UcmVlKGNoaWxkLCBjb252ZXJ0ZXIsIGNvbXBvbmVudERlZmluaXRpb25Qcm92aWRlciwgZ2V0Q2FjaGVkTm9kZSwgc2tpcENvZGVDb21wb25lbnRQcm9wc0NhY2hlKSkpXG4gIF07XG59XG52YXIgQ29kZUNvbXBvbmVudFByZXNlbnRhdGlvbiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoaWQsIGNvbXBvbmVudElkZW50aWZpZXIsIHBhY2thZ2VWZXJzaW9uLCBwcm9wcywgY2hpbGRyZW4sIGNvZGVPdmVycmlkZUlkZW50aWZpZXIpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5jb21wb25lbnRJZGVudGlmaWVyID0gY29tcG9uZW50SWRlbnRpZmllcjtcbiAgICB0aGlzLnBhY2thZ2VWZXJzaW9uID0gcGFja2FnZVZlcnNpb247XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB0aGlzLmNvZGVPdmVycmlkZUlkZW50aWZpZXIgPSBjb2RlT3ZlcnJpZGVJZGVudGlmaWVyO1xuICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgfVxuICBnZXRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5wcm9wcyxcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAga2V5OiB0aGlzLmlkXG4gICAgfTtcbiAgfVxuICByZWN0KHBhcmVudFNpemUpIHtcbiAgICByZXR1cm4geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gIH1cbn07XG5cbi8vIHNyYy9jb21wb25lbnRzL3VzZU5hdmlnYXRpb24udHNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDI2IH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VOYXZpZ2F0aW9uKCkge1xuICByZXR1cm4gdXNlQ29udGV4dDI2KE5hdmlnYXRpb25Db250ZXh0KTtcbn1cblxuLy8gc3JjL3JlbmRlci9zdHlsZS9nZXRDU1NUZXh0Q29sb3JGcm9tU3R5bGUudHNcbmZ1bmN0aW9uIF9nZXRDU1NUZXh0Q29sb3JGcm9tU3R5bGUoY3NzKSB7XG4gIGxldCBjb2xvcjI7XG4gIGlmICh0eXBlb2YgY3NzW1wid2Via2l0VGV4dEZpbGxDb2xvclwiXSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbG9yMiA9IGNzc1tcIndlYmtpdFRleHRGaWxsQ29sb3JcIl07XG4gIH1cbiAgaWYgKHR5cGVvZiBjc3MuV2Via2l0VGV4dEZpbGxDb2xvciA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbG9yMiA9IGNzcy5XZWJraXRUZXh0RmlsbENvbG9yO1xuICB9XG4gIGlmICh0eXBlb2YgY3NzLmNvbG9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29sb3IyID0gY3NzLmNvbG9yO1xuICB9XG4gIGlmIChjb2xvcjIpIHtcbiAgICByZXR1cm4gQ29udmVydENvbG9yLnRvUmdiU3RyaW5nKGNvbG9yMik7XG4gIH1cbn1cblxuLy8gc3JjL3JlbmRlci9EZXNpZ25Db21wb25lbnRXcmFwcGVyLnRzeFxuaW1wb3J0IHtcbiAgQ29tcG9uZW50IGFzIENvbXBvbmVudDE4LFxuICBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxNyxcbiAgY3JlYXRlRWxlbWVudCBhcyBjcmVhdGVFbGVtZW50NDgsXG4gIGlzVmFsaWRFbGVtZW50IGFzIGlzVmFsaWRFbGVtZW50M1xufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2RlcHJlY2F0ZWQvV2l0aE92ZXJyaWRlLnRzeFxuaW1wb3J0IHtcbiAgY3JlYXRlRWxlbWVudCBhcyBjcmVhdGVFbGVtZW50NDdcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyOCB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvZGVwcmVjYXRlZC9EYXRhT2JzZXJ2ZXIudHN4XG5pbXBvcnQge1xuICBDb21wb25lbnQgYXMgQ29tcG9uZW50MTcsXG4gIGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDE2LFxuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQ0NixcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0Mjdcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9kYXRhL0RhdGEudHNcbmZ1bmN0aW9uIERhdGEoaW5pdGlhbCA9IHt9KSB7XG4gIGNvbnN0IGRhdGEgPSBPYnNlcnZhYmxlT2JqZWN0KGluaXRpYWwsIGZhbHNlLCBmYWxzZSk7XG4gIERhdGEuYWRkRGF0YShkYXRhKTtcbiAgcmV0dXJuIGRhdGE7XG59XG4oZnVuY3Rpb24oRGF0YTIpIHtcbiAgRGF0YTIuX3N0b3JlcyA9IFtdO1xuICBmdW5jdGlvbiBhZGREYXRhKGRhdGEpIHtcbiAgICBEYXRhMi5fc3RvcmVzLnB1c2goZGF0YSk7XG4gIH1cbiAgRGF0YTIuYWRkRGF0YSA9IGFkZERhdGE7XG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIERhdGEyLl9zdG9yZXMuZm9yRWFjaCgodGFyZ2V0KSA9PiBPYnNlcnZhYmxlT2JqZWN0LnJlc2V0T2JqZWN0KHRhcmdldCkpO1xuICB9XG4gIERhdGEyLnJlc2V0ID0gcmVzZXQ7XG4gIGZ1bmN0aW9uIGFkZE9ic2VydmVyKHRhcmdldCwgb2JzZXJ2ZXIpIHtcbiAgICByZXR1cm4gT2JzZXJ2YWJsZU9iamVjdC5hZGRPYnNlcnZlcih0YXJnZXQsIG9ic2VydmVyKTtcbiAgfVxuICBEYXRhMi5hZGRPYnNlcnZlciA9IGFkZE9ic2VydmVyO1xufSkoRGF0YSB8fCAoRGF0YSA9IHt9KSk7XG5cbi8vIHNyYy9kZXByZWNhdGVkL0RhdGFPYnNlcnZlci50c3hcbnZhciBpbml0aWFsU3RhdGUgPSB7IHVwZGF0ZTogMCB9O1xudmFyIERhdGFPYnNlcnZlckNvbnRleHQgPSBjcmVhdGVDb250ZXh0MTYoaW5pdGlhbFN0YXRlKTtcbmZ1bmN0aW9uIHVzZU9ic2VydmVEYXRhKCkge1xuICB1c2VDb250ZXh0MjcoRGF0YU9ic2VydmVyQ29udGV4dCk7XG59XG52YXIgRGF0YU9ic2VydmVyID0gY2xhc3MgZXh0ZW5kcyBDb21wb25lbnQxNyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIHRoaXMudGFza0FkZGVkID0gZmFsc2U7XG4gICAgdGhpcy5mcmFtZVRhc2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgdXBkYXRlOiB0aGlzLnN0YXRlLnVwZGF0ZSArIDEgfSk7XG4gICAgICB0aGlzLnRhc2tBZGRlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy5vYnNlcnZlciA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnRhc2tBZGRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy50YXNrQWRkZWQgPSB0cnVlO1xuICAgICAgTWFpbkxvb3AuYWRkRnJhbWVUYXNrKHRoaXMuZnJhbWVUYXNrKTtcbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMub2JzZXJ2ZXJzLm1hcCgoY2FuY2VsKSA9PiBjYW5jZWwoKSk7XG4gICAgRGF0YS5yZXNldCgpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSB0aGlzLnByb3BzO1xuICAgIHRoaXMub2JzZXJ2ZXJzLm1hcCgoY2FuY2VsKSA9PiBjYW5jZWwoKSk7XG4gICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICBEYXRhLl9zdG9yZXMuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBEYXRhLmFkZE9ic2VydmVyKGQsIHRoaXMub2JzZXJ2ZXIpO1xuICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50NDYoRGF0YU9ic2VydmVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHsgLi4udGhpcy5zdGF0ZSB9XG4gICAgfSwgY2hpbGRyZW4pO1xuICB9XG59O1xuXG4vLyBzcmMvZGVwcmVjYXRlZC9jb252ZXJ0Q29sb3JQcm9wcy50c1xuZnVuY3Rpb24gY29udmVydENvbG9yT2JqZWN0KHByb3ApIHtcbiAgaWYgKHR5cGVvZiBwcm9wID09PSBcInN0cmluZ1wiIHx8IGlzTW90aW9uVmFsdWUyKHByb3ApKSB7XG4gICAgcmV0dXJuIHByb3A7XG4gIH0gZWxzZSBpZiAoTGluZWFyR3JhZGllbnQuaXNMaW5lYXJHcmFkaWVudChwcm9wKSkge1xuICAgIHJldHVybiBMaW5lYXJHcmFkaWVudC50b0NTUyhwcm9wKTtcbiAgfSBlbHNlIGlmIChSYWRpYWxHcmFkaWVudC5pc1JhZGlhbEdyYWRpZW50KHByb3ApKSB7XG4gICAgcmV0dXJuIFJhZGlhbEdyYWRpZW50LnRvQ1NTKHByb3ApO1xuICB9IGVsc2UgaWYgKENvbG9yLmlzQ29sb3JPYmplY3QocHJvcCkpIHtcbiAgICByZXR1cm4gQ29sb3IudG9SZ2JTdHJpbmcocHJvcCk7XG4gIH1cbiAgcmV0dXJuIHByb3A7XG59XG5mdW5jdGlvbiBjb252ZXJ0Q29sb3JQcm9wcyhwcm9wcykge1xuICBpZiAocHJvcHMuYmFja2dyb3VuZCB8fCBwcm9wcy5jb2xvcikge1xuICAgIGNvbnN0IGNvbnZlcnRlZCA9IE9iamVjdC5hc3NpZ24oe30sIHByb3BzKTtcbiAgICBpZiAocHJvcHMuYmFja2dyb3VuZCkge1xuICAgICAgY29udmVydGVkLmJhY2tncm91bmQgPSBjb252ZXJ0Q29sb3JPYmplY3QocHJvcHMuYmFja2dyb3VuZCk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jb2xvcikge1xuICAgICAgY29udmVydGVkLmNvbG9yID0gY29udmVydENvbG9yT2JqZWN0KHByb3BzLmNvbG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRlZDtcbiAgfVxuICByZXR1cm4gcHJvcHM7XG59XG5cbi8vIHNyYy9kZXByZWNhdGVkL1dpdGhPdmVycmlkZS50c3hcbnZhciBob2lzdE5vblJlYWN0U3RhdGljNCA9IHJlcXVpcmVfaG9pc3Rfbm9uX3JlYWN0X3N0YXRpY3NfY2pzKCk7XG5mdW5jdGlvbiBXaXRoT3ZlcnJpZGUoQ29tcG9uZW50MTksIG92ZXJyaWRlKSB7XG4gIGNvbnN0IHVzZU92ZXJyaWRlID0gdHlwZW9mIG92ZXJyaWRlID09PSBcImZ1bmN0aW9uXCIgPyAocHJvcHMpID0+IG92ZXJyaWRlKGNvbnZlcnRDb2xvclByb3BzKHByb3BzKSkgOiAoKSA9PiBjb252ZXJ0Q29sb3JQcm9wcyhvdmVycmlkZSk7XG4gIGNvbnN0IENvbXBvbmVudFdpdGhPdmVycmlkZSA9IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgdXNlQ29udGV4dDI4KERhdGFPYnNlcnZlckNvbnRleHQpO1xuICAgIGNvbnN0IG92ZXJyaWRlUHJvcHMgPSB1c2VPdmVycmlkZShwcm9wcyk7XG4gICAgY29uc3QgeyBzdHlsZSwgLi4ucmVzdCB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50NDcoQ29tcG9uZW50MTksIHtcbiAgICAgIC4uLnJlc3QsXG4gICAgICAuLi5vdmVycmlkZVByb3BzLFxuICAgICAgX2luaXRpYWxTdHlsZTogc3R5bGVcbiAgICB9KTtcbiAgfTtcbiAgaG9pc3ROb25SZWFjdFN0YXRpYzQoQ29tcG9uZW50V2l0aE92ZXJyaWRlLCBDb21wb25lbnQxOSk7XG4gIENvbXBvbmVudFdpdGhPdmVycmlkZVtcImRpc3BsYXlOYW1lXCJdID0gYFdpdGhPdmVycmlkZSgke0NvbXBvbmVudDE5LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudDE5Lm5hbWV9KWA7XG4gIHJldHVybiBDb21wb25lbnRXaXRoT3ZlcnJpZGU7XG59XG5cbi8vIHNyYy9yZW5kZXIvRGVzaWduQ29tcG9uZW50V3JhcHBlci50c3hcbnZhciBfQ2FudmFzU3RvcmUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2FudmFzID0geyBjaGlsZHJlbjogW10gfTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuaWRzID0gW107XG4gIH1cbiAgc3RhdGljIHNoYXJlZChkYXRhKSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGNvbnN0IHN0b3JlID0gbmV3IF9DYW52YXNTdG9yZSgpO1xuICAgICAgc3RvcmUuc2V0Q2FudmFzKGRhdGEpO1xuICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH1cbiAgICBpZiAoIV9DYW52YXNTdG9yZS5fX3NoYXJlZCkge1xuICAgICAgX0NhbnZhc1N0b3JlLl9fc2hhcmVkID0gbmV3IF9DYW52YXNTdG9yZSgpO1xuICAgIH1cbiAgICByZXR1cm4gX0NhbnZhc1N0b3JlLl9fc2hhcmVkO1xuICB9XG4gIHVwZGF0ZU5vZGUocHJlc2VudGF0aW9uTm9kZSkge1xuICAgIGNvbnN0IGlkID0gcHJlc2VudGF0aW9uTm9kZS5wcm9wcy5pZDtcbiAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLmNhbnZhcy5jaGlsZHJlbjtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICB0aGlzLmNhbnZhcy5jaGlsZHJlbiA9IGNoaWxkcmVuID0gW107XG4gICAgfVxuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQucHJvcHMuaWQgPT09IGlkKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgY2hpbGRyZW5baV0gPSBwcmVzZW50YXRpb25Ob2RlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgY2hpbGRyZW4ucHVzaChwcmVzZW50YXRpb25Ob2RlKTtcbiAgICB9XG4gICAgdGhpcy5zZXRDYW52YXModGhpcy5jYW52YXMpO1xuICB9XG4gIHNldENhbnZhcyhjYW52YXMpIHtcbiAgICBpZiAoIWNhbnZhcy5jaGlsZHJlbilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChsLCBhdCkgPT4ge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLmlkc1thdF07XG4gICAgICBjb25zdCBkYXRhID0gZmluZE5vZGVGb3IoY2FudmFzLCBpZCk7XG4gICAgICBsLnNldFN0YXRlKHsgZGF0YSB9KTtcbiAgICB9KTtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVyKGxpc3RlbmVyLCBpZE9yTmFtZSkge1xuICAgIHRoaXMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHRoaXMuaWRzLnB1c2goaWRPck5hbWUpO1xuICAgIHJldHVybiBmaW5kTm9kZUZvcih0aGlzLmNhbnZhcywgaWRPck5hbWUpO1xuICB9XG4gIHJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgY29uc3QgYXQgPSB0aGlzLmxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICBpZiAoYXQgPT09IC0xKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMubGlzdGVuZXJzLnNwbGljZShhdCwgMSk7XG4gICAgdGhpcy5pZHMuc3BsaWNlKGF0LCAxKTtcbiAgfVxufTtcbnZhciBDYW52YXNTdG9yZSA9IF9DYW52YXNTdG9yZTtcbkNhbnZhc1N0b3JlLl9fc2hhcmVkID0gbnVsbDtcbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHsgRnJhbWUsIFZlY3RvciwgU3RhY2ssIFZlY3Rvckdyb3VwLCBTVkcsIFRleHQsIERlcHJlY2F0ZWRDb21wb25lbnRDb250YWluZXIgfTtcbnZhciBEZXNpZ25Db21wb25lbnQgPSBjbGFzcyBleHRlbmRzIENvbXBvbmVudDE4IHtcbiAgX3R5cGVGb3JOYW1lKG5hbWUpIHtcbiAgICBjb25zdCBidWlsdEluID0gYnVpbHRJbkNvbXBvbmVudHNbbmFtZV07XG4gICAgaWYgKGJ1aWx0SW4pXG4gICAgICByZXR1cm4gYnVpbHRJbjtcbiAgICBjb25zdCBjb2RlQ29tcG9uZW50ID0gcnVudGltZS5jb21wb25lbnRMb2FkZXIuY29tcG9uZW50Rm9ySWRlbnRpZmllcihuYW1lKTtcbiAgICBpZiAoY29kZUNvbXBvbmVudCAmJiBpc1JlYWN0RGVmaW5pdGlvbihjb2RlQ29tcG9uZW50KSkge1xuICAgICAgcmV0dXJuIGNvZGVDb21wb25lbnQuY2xhc3M7XG4gICAgfVxuICAgIHJldHVybiBGcmFtZTtcbiAgfVxuICBfcmVuZGVyRGF0YShwcmVzZW50YXRpb24sIGNvbXBvbmVudFByb3BzLCB0b3BMZXZlbFByb3BzKSB7XG4gICAgc2FmZVdpbmRvd1tcIl9fY2hlY2tCdWRnZXRfX1wiXSgpO1xuICAgIGNvbnN0IHsgY29tcG9uZW50Q2xhc3MsIG5hbWUgfSA9IHByZXNlbnRhdGlvbjtcbiAgICBsZXQgeyBwcm9wcywgY2hpbGRyZW4gfSA9IHByZXNlbnRhdGlvbjtcbiAgICBwcm9wcyA9IHsgLi4ucHJvcHMsIF9jb25zdHJhaW50czogeyBlbmFibGVkOiBmYWxzZSB9IH07XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuX3R5cGVGb3JOYW1lKGNvbXBvbmVudENsYXNzKTtcbiAgICBpZiAoIXR5cGUpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAodG9wTGV2ZWxQcm9wcykge1xuICAgICAgY29uc3QgeyBzdHlsZSwgLi4ucmVzdCB9ID0gcHJvcHM7XG4gICAgICBwcm9wcyA9IHsgLi4ucmVzdCwgLi4udG9wTGV2ZWxQcm9wcywgX2luaXRpYWxTdHlsZTogc3R5bGUgfTtcbiAgICB9XG4gICAgaWYgKCFwcm9wcy5zaXplICYmIHByb3BzLl9zaXplT2ZNYXN0ZXJPbkNhbnZhcykge1xuICAgICAgaWYgKCFwcm9wcy53aWR0aCkge1xuICAgICAgICBwcm9wcy53aWR0aCA9IHByb3BzLl9zaXplT2ZNYXN0ZXJPbkNhbnZhcy53aWR0aDtcbiAgICAgIH1cbiAgICAgIGlmICghcHJvcHMuaGVpZ2h0KSB7XG4gICAgICAgIHByb3BzLmhlaWdodCA9IHByb3BzLl9zaXplT2ZNYXN0ZXJPbkNhbnZhcy5oZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuYW1lICYmIGNvbXBvbmVudFByb3BzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBpZiAoY29tcG9uZW50Q2xhc3MgPT09IFwiVGV4dFwiKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSBjb21wb25lbnRQcm9wc1tuYW1lXTtcbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICBwcm9wcyA9IHsgLi4ucHJvcHMsIHRleHQ6IGNvbXBvbmVudFByb3BzW25hbWVdIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG9yaWcgPSBwcm9wcy5iYWNrZ3JvdW5kO1xuICAgICAgICBjb25zdCBiYWNrZ3JvdW5kID0geyBzcmM6IGNvbXBvbmVudFByb3BzW25hbWVdLCBmaXQ6IG9yaWcuZml0IH07XG4gICAgICAgIHByb3BzID0geyAuLi5wcm9wcywgYmFja2dyb3VuZCB9O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjMiA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IHRoaXMuX3JlbmRlckRhdGEoY2hpbGQsIGNvbXBvbmVudFByb3BzLCB2b2lkIDApKTtcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuID8gYzIgOiBbXTtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudDQ4KHR5cGUsIHByb3BzLCBjaGlsZHJlbik7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHNhZmVXaW5kb3dbXCJfX2NoZWNrQnVkZ2V0X19cIl0oKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5zdGF0ZS5kYXRhO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNvbm5lY3QgdG8gY2FudmFzIGRhdGEgc3RvcmUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyRGF0YSh0aGlzLnN0YXRlLmRhdGEsIHRoaXMucHJvcHMsIHRoaXMucHJvcHMpO1xuICB9XG59O1xuZnVuY3Rpb24gaXNOb2RlMihpZCwgcHJlc2VudGF0aW9uKSB7XG4gIGNvbnN0IHsgbmFtZSwgcHJvcHMgfSA9IHByZXNlbnRhdGlvbjtcbiAgcmV0dXJuIHByb3BzICYmIHByb3BzLmlkID09PSBpZCB8fCBuYW1lID09PSBpZDtcbn1cbmZ1bmN0aW9uIGZpbmROb2RlRm9yKHByZXNlbnRhdGlvbiwgaWQpIHtcbiAgaWYgKCFwcmVzZW50YXRpb24pXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmIChpc05vZGUyKGlkLCBwcmVzZW50YXRpb24pKSB7XG4gICAgcmV0dXJuIHByZXNlbnRhdGlvbjtcbiAgfVxuICBjb25zdCB7IGNoaWxkcmVuIH0gPSBwcmVzZW50YXRpb247XG4gIGlmICghY2hpbGRyZW4gfHwgIWlzQXJyYXkoY2hpbGRyZW4pKVxuICAgIHJldHVybiBudWxsO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgaWYgKGlzTm9kZTIoaWQsIGNoaWxkKSkge1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZmluZE5vZGVGb3IoY2hpbGQsIGlkKTtcbiAgICBpZiAocmVzdWx0KVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlc2lnbkNvbXBvbmVudChjYW52YXNTdG9yZSwgaWQsIHByb3BlcnR5Q29udHJvbHMsIHdpZHRoID0gMjAwLCBoZWlnaHQgPSAyMDApIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gX2EgPSBjbGFzcyBleHRlbmRzIERlc2lnbkNvbXBvbmVudCB7XG4gICAgc3RhdGljIHJlY3QocHJvcHMpIHtcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnRWYWx1ZXMgPSBDb25zdHJhaW50VmFsdWVzLmZyb21Qcm9wZXJ0aWVzKHByb3BzKTtcbiAgICAgIHJldHVybiBDb25zdHJhaW50VmFsdWVzLnRvUmVjdChjb25zdHJhaW50VmFsdWVzLCBwcm9wcy5wYXJlbnRTaXplIHx8IG51bGwsIG51bGwpO1xuICAgIH1cbiAgICBzdGF0aWMgbWluU2l6ZShwcm9wcywgcGFyZW50U2l6ZSkge1xuICAgICAgY29uc3QgY29uc3RyYWludFZhbHVlcyA9IENvbnN0cmFpbnRWYWx1ZXMuZnJvbVByb3BlcnRpZXMocHJvcHMpO1xuICAgICAgcmV0dXJuIENvbnN0cmFpbnRWYWx1ZXMudG9NaW5TaXplKGNvbnN0cmFpbnRWYWx1ZXMsIHBhcmVudFNpemUgfHwgbnVsbCk7XG4gICAgfVxuICAgIHN0YXRpYyBzaXplKHByb3BzLCBwYXJlbnRTaXplLCBmcmVlU3BhY2UpIHtcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnRWYWx1ZXMgPSBDb25zdHJhaW50VmFsdWVzLmZyb21Qcm9wZXJ0aWVzKHByb3BzKTtcbiAgICAgIHJldHVybiBDb25zdHJhaW50VmFsdWVzLnRvU2l6ZShjb25zdHJhaW50VmFsdWVzLCBwYXJlbnRTaXplIHx8IG51bGwsIG51bGwsIGZyZWVTcGFjZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XG4gICAgICBjb25zdCBkYXRhID0gY2FudmFzU3RvcmUucmVnaXN0ZXJMaXN0ZW5lcih0aGlzLCBpZCk7XG4gICAgICB0aGlzLnN0YXRlID0geyBkYXRhIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgIGNvbnN0IG1heWJlUmVuZGVyV2l0aFByb3ZpZGVyID0gKHJlbmRlck5vZGUpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZUlkID0gbm9kZUlkRnJvbVN0cmluZyhpZCk7XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS5kYXRhICYmIHJlbmRlck5vZGUpIHtcbiAgICAgICAgICBzYWZlV2luZG93W1wiX19jaGVja0J1ZGdldF9fXCJdKCk7XG4gICAgICAgICAgY29uc3QgZWwgPSByZW5kZXJOb2RlKG5vZGVJZCk7XG4gICAgICAgICAgaWYgKGVsICYmIGlzVmFsaWRFbGVtZW50MyhlbCkgJiYgdHlwZW9mIGVsLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50NDgoV2l0aE92ZXJyaWRlKGVsLnR5cGUsIHRoaXMucHJvcHMpLCBlbC5wcm9wcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5yZW5kZXIoKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQ0OChSZW5kZXJOb2RlQ29udGV4dC5Db25zdW1lciwgbnVsbCwgbWF5YmVSZW5kZXJXaXRoUHJvdmlkZXIpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIGNhbnZhc1N0b3JlLnJlbW92ZUxpc3RlbmVyKHRoaXMpO1xuICAgIH1cbiAgfSwgX2EuZGlzcGxheU5hbWUgPSBgRGVzaWduQ29tcG9uZW50KCR7aWR9KWAsIF9hLnByb3BlcnR5Q29udHJvbHMgPSBwcm9wZXJ0eUNvbnRyb2xzLCBfYS5zdXBwb3J0c0NvbnN0cmFpbnRzID0gdHJ1ZSwgX2EuZGVmYXVsdFByb3BzID0ge1xuICAgIF9zaXplT2ZNYXN0ZXJPbkNhbnZhczoge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9XG4gIH0sIF9hO1xufVxudmFyIFJlbmRlck5vZGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDE3KG51bGwpO1xudmFyIFJlbmRlck5vZGVQcm92aWRlciA9IFJlbmRlck5vZGVDb250ZXh0LlByb3ZpZGVyO1xuXG4vLyBzcmMvcmVuZGVyL3V0aWxzL3dpdGhHZW5lcmF0ZWRMYXlvdXRJZC50c3hcbmltcG9ydCB7XG4gIGNyZWF0ZUVsZW1lbnQgYXMgY3JlYXRlRWxlbWVudDQ5LFxuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWYxMFxufSBmcm9tIFwicmVhY3RcIjtcbnZhciB3aXRoR2VuZXJhdGVkTGF5b3V0SWQgPSAoQ29tcG9uZW50MTkpID0+IGZvcndhcmRSZWYxMCgocHJvcHMsIHJlZikgPT4ge1xuICBjb25zdCBsYXlvdXRJZCA9IHVzZUxheW91dElkMihwcm9wcyk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDQ5KENvbXBvbmVudDE5LCB7XG4gICAgbGF5b3V0SWQsXG4gICAgLi4ucHJvcHMsXG4gICAgbGF5b3V0SWRLZXk6IHZvaWQgMCxcbiAgICBkdXBsaWNhdGVkRnJvbTogdm9pZCAwLFxuICAgIHJlZlxuICB9KTtcbn0pO1xuXG4vLyBzcmMvZGF0YS91c2VEYXRhL2luZGV4LnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MjMsIHVzZU1lbW8gYXMgdXNlTWVtbzExLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTksIGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDE4LCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyOSB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvZGF0YS91c2VEYXRhL3N0b3JlLnRzXG5mdW5jdGlvbiBiaW5kQWN0aW9uc1RvU3RvcmUoZ2V0LCBzZXQsIGFjdGlvbnMpIHtcbiAgY29uc3QgYm91bmRBY3Rpb25zID0ge307XG4gIGZvciAoY29uc3Qga2V5NiBpbiBhY3Rpb25zKSB7XG4gICAgYm91bmRBY3Rpb25zW2tleTZdID0gKGRhdGEpID0+IHNldChhY3Rpb25zW2tleTZdKGdldCgpLCBkYXRhKSk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kQWN0aW9ucztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKGluaXRpYWxTdGF0ZTIsIHVuYm91bmRBY3Rpb25zKSB7XG4gIGxldCBzdGF0ZSA9IGluaXRpYWxTdGF0ZTI7XG4gIGxldCB2ZXJzaW9uMiA9IDA7XG4gIGNvbnN0IHN1YnNjcmliZXJzID0gbmV3IFNldCgpO1xuICBjb25zdCBub3RpZnlTdWJzY3JpYmVyID0gKHN1YikgPT4gc3ViKHZlcnNpb24yKTtcbiAgY29uc3QgZ2V0ID0gKCkgPT4gc3RhdGU7XG4gIGNvbnN0IHNldCA9IChsYXRlc3RTdGF0ZSkgPT4ge1xuICAgIHZlcnNpb24yKys7XG4gICAgc3RhdGUgPSBsYXRlc3RTdGF0ZTtcbiAgICBzdWJzY3JpYmVycy5mb3JFYWNoKG5vdGlmeVN1YnNjcmliZXIpO1xuICB9O1xuICBjb25zdCBhY3Rpb25zID0gdW5ib3VuZEFjdGlvbnMgPyBiaW5kQWN0aW9uc1RvU3RvcmUoZ2V0LCBzZXQsIHVuYm91bmRBY3Rpb25zKSA6IHNldDtcbiAgcmV0dXJuIHtcbiAgICBnZXQsXG4gICAgc2V0LFxuICAgIGdldFZlcnNpb246ICgpID0+IHZlcnNpb24yLFxuICAgIGdldEFjdGlvbnM6ICgpID0+IGFjdGlvbnMsXG4gICAgc3Vic2NyaWJlOiAoc3ViKSA9PiB7XG4gICAgICBzdWJzY3JpYmVycy5hZGQoc3ViKTtcbiAgICAgIHJldHVybiAoKSA9PiBzdWJzY3JpYmVycy5kZWxldGUoc3ViKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9kYXRhL3VzZURhdGEvaW5kZXgudHNcbnZhciBkZWZhdWx0SWQgPSBTeW1ib2woXCJkZWZhdWx0XCIpO1xudmFyIERhdGFDb250ZXh0ID0gY3JlYXRlQ29udGV4dDE4KGRlZmF1bHRJZCk7XG5mdW5jdGlvbiBjcmVhdGVEYXRhKGRlZmF1bHRTdGF0ZTIsIGFjdGlvbnMpIHtcbiAgY29uc3Qgc3RvcmVzID0gbmV3IE1hcCgpO1xuICBjb25zdCB1c2VEYXRhID0gKGlkLCBpbml0aWFsU3RhdGUyKSA9PiB7XG4gICAgY29uc3QgY29udGV4dElkID0gdXNlQ29udGV4dDI5KERhdGFDb250ZXh0KTtcbiAgICBpZCA9IGlkIHx8IGNvbnRleHRJZDtcbiAgICBjb25zdCBzdG9yZSA9IHVzZU1lbW8xMSgoKSA9PiB7XG4gICAgICBpZiAoIXN0b3Jlcy5oYXMoaWQpKSB7XG4gICAgICAgIHN0b3Jlcy5zZXQoaWQsIGNyZWF0ZVN0b3JlKGluaXRpYWxTdGF0ZTIgfHwgZGVmYXVsdFN0YXRlMiwgYWN0aW9ucykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0b3Jlcy5nZXQoaWQpO1xuICAgIH0sIFtpZF0pO1xuICAgIGNvbnN0IFssIG5vdGlmeVVwZGF0ZXNdID0gdXNlU3RhdGU5KHN0b3JlLmdldFZlcnNpb24oKSk7XG4gICAgY29uc3Qgc3RvcmVWYWx1ZUF0SG9va0NhbGxUaW1lID0gdXNlTWVtbzExKCgpID0+IHN0b3JlLmdldCgpLCBbc3RvcmVdKTtcbiAgICB1c2VFZmZlY3QyMygoKSA9PiB7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN0b3JlLnN1YnNjcmliZShub3RpZnlVcGRhdGVzKTtcbiAgICAgIGlmIChzdG9yZVZhbHVlQXRIb29rQ2FsbFRpbWUgIT09IHN0b3JlLmdldCgpKVxuICAgICAgICBub3RpZnlVcGRhdGVzKHN0b3JlLmdldFZlcnNpb24oKSk7XG4gICAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gICAgfSwgW3N0b3JlLCBzdG9yZVZhbHVlQXRIb29rQ2FsbFRpbWVdKTtcbiAgICByZXR1cm4gW3N0b3JlLmdldCgpLCBzdG9yZS5nZXRBY3Rpb25zKCldO1xuICB9O1xuICByZXR1cm4gdXNlRGF0YTtcbn1cblxuLy8gc3JjL3V0aWxzL2FkZEFjdGlvbkNvbnRyb2xzLnRzXG5mdW5jdGlvbiBhZGRBY3Rpb25Db250cm9scyhhY3Rpb24sIHRpdGxlLCBjb250cm9scykge1xuICBydW50aW1lLmFkZEFjdGlvbkNvbnRyb2xzKGFjdGlvbiwgdGl0bGUsIGNvbnRyb2xzKTtcbn1cblxuLy8gc3JjL2RhdGEvUHJvcGVydHlTdG9yZS50c1xuZnVuY3Rpb24gUHJvcGVydHlTdG9yZShpbml0aWFsID0ge30sIG1ha2VBbmltYXRhYmxlcyA9IGZhbHNlKSB7XG4gIGRlcHJlY2F0aW9uV2FybmluZyhcIlByb3BlcnR5U3RvcmVcIiwgXCIxLjAuMFwiLCBcIkRhdGEoKSBvciBPYnNlcnZhYmxlT2JqZWN0KClcIik7XG4gIHJldHVybiBPYnNlcnZhYmxlT2JqZWN0KGluaXRpYWwsIG1ha2VBbmltYXRhYmxlcyk7XG59XG4oZnVuY3Rpb24oUHJvcGVydHlTdG9yZTIpIHtcbiAgZnVuY3Rpb24gYWRkT2JzZXJ2ZXIodGFyZ2V0LCBvYnNlcnZlcikge1xuICAgIHJldHVybiBPYnNlcnZhYmxlT2JqZWN0LmFkZE9ic2VydmVyKHRhcmdldCwgb2JzZXJ2ZXIpO1xuICB9XG4gIFByb3BlcnR5U3RvcmUyLmFkZE9ic2VydmVyID0gYWRkT2JzZXJ2ZXI7XG59KShQcm9wZXJ0eVN0b3JlIHx8IChQcm9wZXJ0eVN0b3JlID0ge30pKTtcblxuLy8gc3JjL3V0aWxzL25ldHdvcmsudHNcbmZ1bmN0aW9uIGxvYWRKU09OKHVybCkge1xuICByZXR1cm4gZmV0Y2godXJsLCB7IG1vZGU6IFwiY29yc1wiIH0pLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSk7XG59XG5cbi8vIHNyYy91dGlscy9pbnNwZWN0T2JqZWN0VHlwZS50c1xuZnVuY3Rpb24gaW5zcGVjdE9iamVjdFR5cGUoaXRlbSkge1xuICBsZXQgY2xhc3NOYW1lO1xuICBpZiAoKGl0ZW0uY29uc3RydWN0b3IgIT09IG51bGwgPyBpdGVtLmNvbnN0cnVjdG9yLm5hbWUgOiB2b2lkIDApICE9PSBudWxsICYmIChpdGVtLmNvbnN0cnVjdG9yICE9PSBudWxsID8gaXRlbS5jb25zdHJ1Y3Rvci5uYW1lIDogdm9pZCAwKSAhPT0gXCJPYmplY3RcIikge1xuICAgIHJldHVybiBpdGVtLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cbiAgY29uc3QgZXh0cmFjdCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVnZXggPSAvXFxbb2JqZWN0IChcXHcrKVxcXS87XG4gICAgY29uc3QgbWF0Y2ggPSByZWdleC5leGVjKHN0cik7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWF0Y2hbMV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBpZiAoaXRlbS50b1N0cmluZykge1xuICAgIGNsYXNzTmFtZSA9IGV4dHJhY3QoaXRlbS50b1N0cmluZygpKTtcbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICByZXR1cm4gY2xhc3NOYW1lO1xuICAgIH1cbiAgfVxuICBpZiAoaXRlbS5jb25zdHJ1Y3RvciAhPT0gbnVsbCA/IGl0ZW0uY29uc3RydWN0b3IudG9TdHJpbmcgOiB2b2lkIDApIHtcbiAgICBjbGFzc05hbWUgPSBleHRyYWN0KGl0ZW0uY29uc3RydWN0b3IgIT09IG51bGwgPyBpdGVtLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkgOiB2b2lkIDApO1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiBjbGFzc05hbWUucmVwbGFjZShcIkNvbnN0cnVjdG9yXCIsIFwiXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gXCJPYmplY3RcIjtcbn1cblxuLy8gc3JjL3V0aWxzL2luc3BlY3QudHNcbmZ1bmN0aW9uIGluc3BlY3QoaXRlbSwgbWF4LCBsKSB7XG4gIGlmIChtYXggPT09IHZvaWQgMCkge1xuICAgIG1heCA9IDU7XG4gIH1cbiAgaWYgKGwgPT09IHZvaWQgMCkge1xuICAgIGwgPSAwO1xuICB9XG4gIGlmIChpdGVtID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICB9XG4gIGlmIChpdGVtID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgfVxuICBpZiAoaXNGdW5jdGlvbihpdGVtLnRvSW5zcGVjdCkpIHtcbiAgICByZXR1cm4gaXRlbS50b0luc3BlY3QoKTtcbiAgfVxuICBpZiAoaXNTdHJpbmcyKGl0ZW0pKSB7XG4gICAgcmV0dXJuIGBcIiR7aXRlbX1cImA7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKGl0ZW0pKSB7XG4gICAgcmV0dXJuIGAke2l0ZW19YDtcbiAgfVxuICBpZiAoaXNGdW5jdGlvbihpdGVtKSkge1xuICAgIGxldCBjb2RlID0gaXRlbS50b1N0cmluZygpLnNsaWNlKFwiZnVuY3Rpb24gXCIubGVuZ3RoKS5yZXBsYWNlKC9cXG4vZywgXCJcIikucmVwbGFjZSgvXFxzKy9nLCBcIiBcIik7XG4gICAgY29uc3QgbGltaXQgPSA1MDtcbiAgICBpZiAoY29kZS5sZW5ndGggPiBsaW1pdCAmJiBsID4gMCkge1xuICAgICAgY29kZSA9IGAke2NvZGUuc2xpY2UoMCwgK2xpbWl0ICsgMSB8fCB2b2lkIDApLnRyaW0oKX1cXHUyMDI2IH1gO1xuICAgIH1cbiAgICByZXR1cm4gYDxGdW5jdGlvbiAke2NvZGV9PmA7XG4gIH1cbiAgaWYgKGlzQXJyYXkoaXRlbSkpIHtcbiAgICBpZiAobCA+IG1heCkge1xuICAgICAgcmV0dXJuIFwiWy4uLl1cIjtcbiAgICB9XG4gICAgcmV0dXJuIGBbJHtpdGVtLm1hcCgoaSkgPT4gaW5zcGVjdChpLCBtYXgsIChsIHx8IDApICsgMSkpLmpvaW4oXCIsIFwiKX1dYDtcbiAgfVxuICBpZiAoaXNPYmplY3QoaXRlbSkpIHtcbiAgICBsZXQgb2JqZWN0SW5mbztcbiAgICBjb25zdCBvYmplY3RUeXBlID0gaW5zcGVjdE9iamVjdFR5cGUoaXRlbSk7XG4gICAgaWYgKC9IVE1MXFx3Kz9FbGVtZW50Ly50ZXN0KG9iamVjdFR5cGUpKSB7XG4gICAgICByZXR1cm4gYDwke29iamVjdFR5cGV9PmA7XG4gICAgfVxuICAgIGlmIChsID4gbWF4KSB7XG4gICAgICBvYmplY3RJbmZvID0gXCJ7Li4ufVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpdGVtS2V5cyA9IE9iamVjdC5rZXlzKGl0ZW0pO1xuICAgICAgb2JqZWN0SW5mbyA9IGB7JHtpdGVtS2V5cy5tYXAoKGspID0+IGAke2t9OiR7aW5zcGVjdChpdGVtW2tdLCBtYXgsIChsIHx8IDApICsgMSl9YCkuam9pbihcIiwgXCIpfX1gO1xuICAgIH1cbiAgICBpZiAob2JqZWN0VHlwZSA9PT0gXCJPYmplY3RcIikge1xuICAgICAgcmV0dXJuIG9iamVjdEluZm87XG4gICAgfVxuICAgIHJldHVybiBgPCR7b2JqZWN0VHlwZX0gJHtvYmplY3RJbmZvfT5gO1xuICB9XG4gIHJldHVybiBgJHtpdGVtfWA7XG59XG5cbi8vIHNyYy91dGlscy9wcmludC50c1xuZnVuY3Rpb24gcHJpbnQoLi4uYXJncykge1xuICBjb25zdCBsaW5lID0gYXJncy5tYXAoKGFyZykgPT4ge1xuICAgIHJldHVybiBpbnNwZWN0KGFyZyk7XG4gIH0pLmpvaW4oXCIsIFwiKTtcbiAgY29uc29sZS5sb2cobGluZSk7XG59XG5cbi8vIHNyYy91dGlscy9hZGRGb250cy50c1xuZnVuY3Rpb24gYWRkRm9udHMoY29tcG9uZW50LCBmb250cykge1xuICBPYmplY3QuYXNzaWduKGNvbXBvbmVudCwgeyBmb250cyB9KTtcbn1cbmZ1bmN0aW9uIGdldEZvbnRzKGNvbXBvbmVudCkge1xuICBjb25zdCBmb250cyA9IGNvbXBvbmVudC5mb250cztcbiAgcmV0dXJuIGZvbnRzIHx8IFtdO1xufVxuXG4vLyBzcmMvdmVyc2lvbi50c1xudmFyIHZlcnNpb24gPSBcIjEuMy42XCI7XG5cbi8vIHNyYy9hbmltYXRpb24vTW90aW9uL01vdGlvblNldHVwLnRzeFxuaW1wb3J0IHtcbiAgRnJhZ21lbnQgYXMgRnJhZ21lbnQ4LFxuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQ1MFxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2FuaW1hdGlvbi9Nb3Rpb24vYXV0b1ZhbHVlSGFuZGxlcnMudHNcbnZhciBjb3JyZWN0Qm9yZGVyU2NhbGUgPSAoYXhpcykgPT4gKHtcbiAgcHJvY2VzczogKGxhdGVzdCwgeyBkZWx0YTogZGVsdGEyLCB0cmVlU2NhbGUgfSkgPT4ge1xuICAgIGlmICh0eXBlb2YgbGF0ZXN0ID09PSBcInN0cmluZ1wiKVxuICAgICAgbGF0ZXN0ID0gcGFyc2VGbG9hdChsYXRlc3QpO1xuICAgIGlmIChsYXRlc3QgPT09IDApXG4gICAgICByZXR1cm4gXCIwcHhcIjtcbiAgICBsZXQgY29ycmVjdGVkID0gTWF0aC5yb3VuZChsYXRlc3QgLyBkZWx0YTJbYXhpc10uc2NhbGUgLyB0cmVlU2NhbGVbYXhpc10pO1xuICAgIGNvcnJlY3RlZCA9IE1hdGgubWF4KGNvcnJlY3RlZCwgMSk7XG4gICAgcmV0dXJuIGNvcnJlY3RlZCArIFwicHhcIjtcbiAgfVxufSk7XG5cbi8vIHNyYy9hbmltYXRpb24vTW90aW9uL01vdGlvblNldHVwLnRzeFxuYWRkU2NhbGVDb3JyZWN0aW9uKHtcbiAgYm9yZGVyVG9wV2lkdGg6IGNvcnJlY3RCb3JkZXJTY2FsZShcInlcIiksXG4gIGJvcmRlckxlZnRXaWR0aDogY29ycmVjdEJvcmRlclNjYWxlKFwieFwiKSxcbiAgYm9yZGVyUmlnaHRXaWR0aDogY29ycmVjdEJvcmRlclNjYWxlKFwieFwiKSxcbiAgYm9yZGVyQm90dG9tV2lkdGg6IGNvcnJlY3RCb3JkZXJTY2FsZShcInlcIilcbn0pO1xuZnVuY3Rpb24gTW90aW9uU2V0dXAoeyBjaGlsZHJlbiB9KSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDUwKEZyYWdtZW50OCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuXG4vLyBzcmMvYW5pbWF0aW9uL01vdGlvbi9zdGFydEFuaW1hdGlvbi50c1xuZnVuY3Rpb24gc3RhcnRBbmltYXRpb24yKF9rZXksIHZhbHVlLCB0YXJnZXQsIHRyYW5zaXRpb24gPSB7fSkge1xuICB3YXJuT25jZShgXCJzdGFydEFuaW1hdGlvblwiIGlzIHVuc3VwcG9ydGVkLiBVc2UgXCJhbmltYXRlXCIgaW5zdGVhZDogaHR0cHM6Ly93d3cuZnJhbWVyLmNvbS9hcGkvbW90aW9uL3V0aWxpdGllcy8jYW5pbWF0ZWApO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBhbmltYXRlMih2YWx1ZSwgdGFyZ2V0LCB7XG4gICAgICAuLi50cmFuc2l0aW9uLFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4gcmVzb2x2ZSgpXG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyBzcmMvbW9kdWxlcy91c2VBZGRWYXJpYW50UHJvcHMudHNcbmltcG9ydCB7XG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMTBcbn0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VBZGRWYXJpYW50UHJvcHMoYmFzZVZhcmlhbnQsIGdlc3R1cmVWYXJpYW50LCB2YXJpYW50UHJvcHMyKSB7XG4gIHJldHVybiB1c2VDYWxsYmFjazEwKChpZCkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGlmICghdmFyaWFudFByb3BzMilcbiAgICAgIHJldHVybiB7fTtcbiAgICBpZiAoIWJhc2VWYXJpYW50KVxuICAgICAgcmV0dXJuIHt9O1xuICAgIGlmIChnZXN0dXJlVmFyaWFudCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIChfYSA9IHZhcmlhbnRQcm9wczJbYmFzZVZhcmlhbnRdKSA9PSBudWxsID8gdm9pZCAwIDogX2FbaWRdLCAoX2IgPSB2YXJpYW50UHJvcHMyW2dlc3R1cmVWYXJpYW50XSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iW2lkXSk7XG4gICAgfVxuICAgIHJldHVybiAoKF9jID0gdmFyaWFudFByb3BzMltiYXNlVmFyaWFudF0pID09IG51bGwgPyB2b2lkIDAgOiBfY1tpZF0pIHx8IHt9O1xuICB9LCBbYmFzZVZhcmlhbnQsIGdlc3R1cmVWYXJpYW50LCB2YXJpYW50UHJvcHMyXSk7XG59XG5cbi8vIHNyYy9tb2R1bGVzL3VzZVZhcmlhbnRTdGF0ZS50c1xuaW1wb3J0IHtcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2sxMSxcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDksXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzEyLFxuICB1c2VSZWYgYXMgdXNlUmVmMjRcbn0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBjcmVhdGVHZXN0dXJlVmFyaWFudCh2YXJpYW50LCB0eXBlKSB7XG4gIHJldHVybiBgJHt2YXJpYW50fS0ke3R5cGV9YDtcbn1cbmZ1bmN0aW9uIG5leHRWYXJpYW50KGFsbFZhcmlhbnRzLCBjdXJyZW50VmFyaWFudCkge1xuICBjb25zdCBpbmRleCA9IGFsbFZhcmlhbnRzLmluZGV4T2YoY3VycmVudFZhcmlhbnQpO1xuICBsZXQgbmV4dEluZGV4ID0gaW5kZXggKyAxO1xuICBpZiAobmV4dEluZGV4ID49IGFsbFZhcmlhbnRzLmxlbmd0aCkge1xuICAgIG5leHRJbmRleCA9IDA7XG4gIH1cbiAgcmV0dXJuIGFsbFZhcmlhbnRzW25leHRJbmRleF07XG59XG52YXIgVmFyaWFudFNlbGVjdG9yO1xuKGZ1bmN0aW9uKFZhcmlhbnRTZWxlY3RvcjIpIHtcbiAgVmFyaWFudFNlbGVjdG9yMltcIlZhcmlhbnRcIl0gPSBcInZcIjtcbn0pKFZhcmlhbnRTZWxlY3RvciB8fCAoVmFyaWFudFNlbGVjdG9yID0ge30pKTtcbmZ1bmN0aW9uIGdldEdlc3R1cmUoZW5hYmxlZEdlc3R1cmVzLCBpc0hvdmVyZWQsIGlzUHJlc3NlZCkge1xuICBjb25zdCB7IGhvdmVyLCBwcmVzc2VkIH0gPSBlbmFibGVkR2VzdHVyZXMgfHwge307XG4gIGlmIChwcmVzc2VkICYmIGlzUHJlc3NlZClcbiAgICByZXR1cm4gXCJwcmVzc2VkXCI7XG4gIGlmIChob3ZlciAmJiBpc0hvdmVyZWQpXG4gICAgcmV0dXJuIFwiaG92ZXJcIjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZhcmlhbnRDbGFzc05hbWUoYmFzZVZhcmlhbnQsIHZhcmlhbnRDbGFzc05hbWVzKSB7XG4gIGNvbnN0IG1hcHBlZENsYXNzTmFtZSA9IHZhcmlhbnRDbGFzc05hbWVzW2Jhc2VWYXJpYW50XTtcbiAgaWYgKG1hcHBlZENsYXNzTmFtZSlcbiAgICByZXR1cm4gbWFwcGVkQ2xhc3NOYW1lO1xuICByZXR1cm4gYGZyYW1lci0ke1ZhcmlhbnRTZWxlY3Rvci5WYXJpYW50fS0ke2Jhc2VWYXJpYW50fWA7XG59XG52YXIgQ3ljbGVWYXJpYW50U3RhdGUgPSBTeW1ib2woXCJjeWNsZVwiKTtcbmZ1bmN0aW9uIHVzZVZhcmlhbnRTdGF0ZSh7XG4gIHZhcmlhbnQsXG4gIGRlZmF1bHRWYXJpYW50OiBleHRlcm5hbERlZmF1bHRWYXJpYW50LFxuICB0cmFuc2l0aW9uczogZXh0ZXJuYWxUcmFuc2l0aW9ucyxcbiAgZW5hYmxlZEdlc3R1cmVzOiBleHRlcm5hbEVuYWJsZWRHZXN0dXJlcyxcbiAgY3ljbGVPcmRlcjogZXh0ZXJuYWxDeWNsZU9yZGVyID0gW10sXG4gIHZhcmlhbnRQcm9wczogdmFyaWFudFByb3BzMiA9IHt9LFxuICB2YXJpYW50Q2xhc3NOYW1lcyA9IHt9XG59KSB7XG4gIGNvbnN0IGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUyKCk7XG4gIGNvbnN0IGludGVybmFsU3RhdGUgPSB1c2VSZWYyNCh7XG4gICAgaXNIb3ZlcmVkOiBmYWxzZSxcbiAgICBpc1ByZXNzZWQ6IGZhbHNlLFxuICAgIGJhc2VWYXJpYW50OiB2YXJpYW50ICE9IG51bGwgPyB2YXJpYW50IDogZXh0ZXJuYWxEZWZhdWx0VmFyaWFudCxcbiAgICBnZXN0dXJlVmFyaWFudDogdm9pZCAwLFxuICAgIGRlZmF1bHRWYXJpYW50OiBleHRlcm5hbERlZmF1bHRWYXJpYW50LFxuICAgIGVuYWJsZWRHZXN0dXJlczogZXh0ZXJuYWxFbmFibGVkR2VzdHVyZXMsXG4gICAgY3ljbGVPcmRlcjogZXh0ZXJuYWxDeWNsZU9yZGVyLFxuICAgIHRyYW5zaXRpb25zOiBleHRlcm5hbFRyYW5zaXRpb25zXG4gIH0pO1xuICBjb25zdCByZXNvbHZlTmV4dFZhcmlhbnQgPSB1c2VDYWxsYmFjazExKChuZXh0QmFzZVZhcmlhbnQgPSBpbnRlcm5hbFN0YXRlLmN1cnJlbnQuZGVmYXVsdFZhcmlhbnQpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBiYXNlVmFyaWFudDogYmFzZVZhcmlhbnQyLFxuICAgICAgZ2VzdHVyZVZhcmlhbnQ6IGdlc3R1cmVWYXJpYW50MixcbiAgICAgIGlzUHJlc3NlZDogaXNQcmVzc2VkMixcbiAgICAgIGlzSG92ZXJlZDogaXNIb3ZlcmVkMixcbiAgICAgIGRlZmF1bHRWYXJpYW50OiBkZWZhdWx0VmFyaWFudDIsXG4gICAgICBlbmFibGVkR2VzdHVyZXM6IGVuYWJsZWRHZXN0dXJlczJcbiAgICB9ID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50O1xuICAgIGNvbnN0IGdlc3R1cmUgPSBnZXRHZXN0dXJlKGVuYWJsZWRHZXN0dXJlczIgPT0gbnVsbCA/IHZvaWQgMCA6IGVuYWJsZWRHZXN0dXJlczJbbmV4dEJhc2VWYXJpYW50XSwgaXNIb3ZlcmVkMiwgaXNQcmVzc2VkMik7XG4gICAgY29uc3QgbmV4dEdlc3R1cmVWYXJpYW50ID0gZ2VzdHVyZSA/IGNyZWF0ZUdlc3R1cmVWYXJpYW50KG5leHRCYXNlVmFyaWFudCwgZ2VzdHVyZSkgOiB2b2lkIDA7XG4gICAgaWYgKG5leHRCYXNlVmFyaWFudCAhPT0gYmFzZVZhcmlhbnQyIHx8IG5leHRHZXN0dXJlVmFyaWFudCAhPT0gZ2VzdHVyZVZhcmlhbnQyKSB7XG4gICAgICBpbnRlcm5hbFN0YXRlLmN1cnJlbnQuYmFzZVZhcmlhbnQgPSBuZXh0QmFzZVZhcmlhbnQgfHwgZGVmYXVsdFZhcmlhbnQyO1xuICAgICAgaW50ZXJuYWxTdGF0ZS5jdXJyZW50Lmdlc3R1cmVWYXJpYW50ID0gbmV4dEdlc3R1cmVWYXJpYW50O1xuICAgICAgZm9yY2VVcGRhdGUoKTtcbiAgICB9XG4gIH0sIFtmb3JjZVVwZGF0ZV0pO1xuICBjb25zdCBzZXRHZXN0dXJlU3RhdGUgPSB1c2VDYWxsYmFjazExKCh7IGlzSG92ZXJlZDogaXNIb3ZlcmVkMiwgaXNQcmVzc2VkOiBpc1ByZXNzZWQyIH0pID0+IHtcbiAgICBpZiAoaXNIb3ZlcmVkMiAhPT0gdm9pZCAwKVxuICAgICAgaW50ZXJuYWxTdGF0ZS5jdXJyZW50LmlzSG92ZXJlZCA9IGlzSG92ZXJlZDI7XG4gICAgaWYgKGlzUHJlc3NlZDIgIT09IHZvaWQgMClcbiAgICAgIGludGVybmFsU3RhdGUuY3VycmVudC5pc1ByZXNzZWQgPSBpc1ByZXNzZWQyO1xuICAgIHJlc29sdmVOZXh0VmFyaWFudChpbnRlcm5hbFN0YXRlLmN1cnJlbnQuYmFzZVZhcmlhbnQpO1xuICB9LCBbcmVzb2x2ZU5leHRWYXJpYW50XSk7XG4gIGNvbnN0IHNldFZhcmlhbnQgPSB1c2VDYWxsYmFjazExKChwcm9wb3NlZFZhcmlhbnQpID0+IHtcbiAgICBjb25zdCB7IGRlZmF1bHRWYXJpYW50OiBkZWZhdWx0VmFyaWFudDIsIGN5Y2xlT3JkZXIsIGJhc2VWYXJpYW50OiBiYXNlVmFyaWFudDIgfSA9IGludGVybmFsU3RhdGUuY3VycmVudDtcbiAgICBjb25zdCBuZXh0QmFzZVZhcmlhbnQgPSBwcm9wb3NlZFZhcmlhbnQgPT09IEN5Y2xlVmFyaWFudFN0YXRlID8gbmV4dFZhcmlhbnQoY3ljbGVPcmRlciB8fCBbXSwgYmFzZVZhcmlhbnQyIHx8IGRlZmF1bHRWYXJpYW50MikgOiBwcm9wb3NlZFZhcmlhbnQ7XG4gICAgcmVzb2x2ZU5leHRWYXJpYW50KG5leHRCYXNlVmFyaWFudCB8fCBkZWZhdWx0VmFyaWFudDIpO1xuICB9LCBbcmVzb2x2ZU5leHRWYXJpYW50XSk7XG4gIHVzZUxheW91dEVmZmVjdDkoKCkgPT4ge1xuICAgIGlmICh2YXJpYW50ICE9PSBpbnRlcm5hbFN0YXRlLmN1cnJlbnQuYmFzZVZhcmlhbnQpXG4gICAgICBzZXRWYXJpYW50KHZhcmlhbnQpO1xuICB9LCBbdmFyaWFudCwgc2V0VmFyaWFudF0pO1xuICBjb25zdCB7IGJhc2VWYXJpYW50IH0gPSBpbnRlcm5hbFN0YXRlLmN1cnJlbnQ7XG4gIGNvbnN0IHRyYW5zaXRpb24gPSB1c2VNZW1vMTIoKCkgPT4ge1xuICAgIGNvbnN0IHsgdHJhbnNpdGlvbnMgfSA9IGludGVybmFsU3RhdGUuY3VycmVudDtcbiAgICBpZiAoIXRyYW5zaXRpb25zKVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAoYmFzZVZhcmlhbnQpIHtcbiAgICAgIGNvbnN0IHZhcmlhbnRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbnNbYmFzZVZhcmlhbnRdO1xuICAgICAgaWYgKHZhcmlhbnRUcmFuc2l0aW9uKVxuICAgICAgICByZXR1cm4gdmFyaWFudFRyYW5zaXRpb247XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2l0aW9ucy5kZWZhdWx0O1xuICB9LCBbYmFzZVZhcmlhbnRdKTtcbiAgY29uc3QgdmFyaWFudHMgPSBbXTtcbiAgY29uc3QgeyBnZXN0dXJlVmFyaWFudCwgZGVmYXVsdFZhcmlhbnQsIGVuYWJsZWRHZXN0dXJlcywgaXNIb3ZlcmVkLCBpc1ByZXNzZWQgfSA9IGludGVybmFsU3RhdGUuY3VycmVudDtcbiAgaWYgKGJhc2VWYXJpYW50ICYmIGJhc2VWYXJpYW50ICE9PSBkZWZhdWx0VmFyaWFudClcbiAgICB2YXJpYW50cy5wdXNoKGJhc2VWYXJpYW50KTtcbiAgaWYgKGdlc3R1cmVWYXJpYW50KVxuICAgIHZhcmlhbnRzLnB1c2goZ2VzdHVyZVZhcmlhbnQpO1xuICBjb25zdCBhZGRWYXJpYW50UHJvcHMgPSB1c2VBZGRWYXJpYW50UHJvcHMoYmFzZVZhcmlhbnQsIGdlc3R1cmVWYXJpYW50LCB2YXJpYW50UHJvcHMyKTtcbiAgcmV0dXJuIHtcbiAgICB2YXJpYW50cyxcbiAgICBiYXNlVmFyaWFudCxcbiAgICBnZXN0dXJlVmFyaWFudCxcbiAgICB0cmFuc2l0aW9uLFxuICAgIHNldFZhcmlhbnQsXG4gICAgc2V0R2VzdHVyZVN0YXRlLFxuICAgIGFkZFZhcmlhbnRQcm9wcyxcbiAgICBjbGFzc05hbWVzOiBjeChjcmVhdGVWYXJpYW50Q2xhc3NOYW1lKGJhc2VWYXJpYW50LCB2YXJpYW50Q2xhc3NOYW1lcyksIGdldEdlc3R1cmUoZW5hYmxlZEdlc3R1cmVzID09IG51bGwgPyB2b2lkIDAgOiBlbmFibGVkR2VzdHVyZXNbYmFzZVZhcmlhbnRdLCBpc0hvdmVyZWQsIGlzUHJlc3NlZCkpXG4gIH07XG59XG5cbi8vIHNyYy9tb2R1bGVzL3dpdGhDU1MudHN4XG5pbXBvcnQge1xuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQ1MSxcbiAgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmMTEsXG4gIHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3QxMFxufSBmcm9tIFwicmVhY3RcIjtcbnZhciB3aXRoQ1NTID0gKENvbXBvbmVudDE5LCBlc2NhcGVkQ1NTKSA9PiBmb3J3YXJkUmVmMTEoKHByb3BzLCByZWYpID0+IHtcbiAgdXNlTGF5b3V0RWZmZWN0MTAoKCkgPT4ge1xuICAgIGNvbnN0IGNzcyA9IEFycmF5LmlzQXJyYXkoZXNjYXBlZENTUykgPyBlc2NhcGVkQ1NTIDogZXNjYXBlZENTUy5zcGxpdChcIlxcblwiKTtcbiAgICBjc3MuZm9yRWFjaCgocnVsZSkgPT4gcnVsZSAmJiBzZXREb2N1bWVudFN0eWxlcyhydWxlKSk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50NTEoQ29tcG9uZW50MTksIHtcbiAgICAuLi5wcm9wcyxcbiAgICByZWZcbiAgfSk7XG59KTtcblxuLy8gc3JjL21vZHVsZXMvQ29udGFpbmVyLnRzeFxuaW1wb3J0IHtcbiAgQ2hpbGRyZW4gYXMgQ2hpbGRyZW4xMixcbiAgY2xvbmVFbGVtZW50IGFzIGNsb25lRWxlbWVudDEwLFxuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQ1MixcbiAgaXNWYWxpZEVsZW1lbnQgYXMgaXNWYWxpZEVsZW1lbnQ0XG59IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gUHJvdmlkZXJzKHsgY2hpbGRyZW4sIGxheW91dElkLCAuLi5wcm9wcyB9KSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb25zdGFudDIoY3JlYXRlQmF0Y2hlcik7XG4gIGNvbnN0IG91dGVyTGF5b3V0SWQgPSB1c2VDb25zdGFudDIoKCkgPT4gbGF5b3V0SWQgPyBgJHtsYXlvdXRJZH0tY29udGFpbmVyYCA6IHZvaWQgMCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDUyKG1vdGlvbi5kaXYsIHtcbiAgICBsYXlvdXRJZDogb3V0ZXJMYXlvdXRJZCxcbiAgICAuLi5wcm9wc1xuICB9LCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDUyKENvbXBvbmVudENvbnRhaW5lckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9LCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDUyKFNoYXJlZExheW91dENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFxuICB9LCAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudDUyKEF1dG9tYXRpY0xheW91dElkcywge1xuICAgIGVuYWJsZWQ6IGZhbHNlXG4gIH0sIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50NTIoTGF5b3V0R3JvdXBDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGxheW91dElkICE9IG51bGwgPyBsYXlvdXRJZCA6IG51bGxcbiAgfSwgQ2hpbGRyZW4xMi5tYXAoY2hpbGRyZW4sIChjaGlsZCkgPT4ge1xuICAgIHJldHVybiBpc1ZhbGlkRWxlbWVudDQoY2hpbGQpID8gY2xvbmVFbGVtZW50MTAoY2hpbGQsIHsgbGF5b3V0SWQgfSkgOiBjaGlsZDtcbiAgfSkpKSkpKTtcbn1cbnZhciBDb250YWluZXIgPSB3aXRoR2VuZXJhdGVkTGF5b3V0SWQoUHJvdmlkZXJzKTtcblxuLy8gc3JjL21vZHVsZXMvY2FsbEVhY2gudHNcbnZhciBjYWxsRWFjaCA9ICguLi5mbnMpID0+IGZucy5mb3JFYWNoKChmbikgPT4gZm4gJiYgZm4oKSk7XG5cbi8vIHNyYy9tb2R1bGVzL3VzZU9uVmFyaWFudENoYW5nZS50c1xuaW1wb3J0IHtcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDI0LFxuICB1c2VSZWYgYXMgdXNlUmVmMjVcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9tb2R1bGVzL3VzZUlzT25GcmFtZXJDYW52YXMudHNcbmZ1bmN0aW9uIHVzZUlzT25GcmFtZXJDYW52YXMoKSB7XG4gIHJldHVybiBSZW5kZXJUYXJnZXQuY3VycmVudCgpID09PSBSZW5kZXJUYXJnZXQuY2FudmFzO1xufVxuXG4vLyBzcmMvbW9kdWxlcy91c2VPblZhcmlhbnRDaGFuZ2UudHNcbmZ1bmN0aW9uIGNhbGxiYWNrRm9yVmFyaWFudChtYXAsIHZhcmlhbnQpIHtcbiAgaWYgKG1hcFt2YXJpYW50XSlcbiAgICByZXR1cm4gbWFwW3ZhcmlhbnRdO1xuICBpZiAodmFyaWFudCBpbiBtYXApXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgcmV0dXJuIG1hcC5kZWZhdWx0O1xufVxuZnVuY3Rpb24gdXNlT25WYXJpYW50Q2hhbmdlKHZhcmlhbnQsIGNhbGxiYWNrTWFwKSB7XG4gIGNvbnN0IGlzT25GcmFtZXJDYW52YXMgPSB1c2VJc09uRnJhbWVyQ2FudmFzKCk7XG4gIGlmIChpc09uRnJhbWVyQ2FudmFzKVxuICAgIHJldHVybjtcbiAgY29uc3QgaXNJbkN1cnJlbnRUYXJnZXRSZWYgPSB1c2VSZWYyNSh0cnVlKTtcbiAgdXNlT25DdXJyZW50VGFyZ2V0Q2hhbmdlKChpc0luVGFyZ2V0KSA9PiB7XG4gICAgaWYgKCFpc0luQ3VycmVudFRhcmdldFJlZi5jdXJyZW50ICYmIGlzSW5UYXJnZXQpIHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gY2FsbGJhY2tGb3JWYXJpYW50KGNhbGxiYWNrTWFwLCB2YXJpYW50KTtcbiAgICAgIGlmIChjYWxsYmFjaylcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgaXNJbkN1cnJlbnRUYXJnZXRSZWYuY3VycmVudCA9IGlzSW5UYXJnZXQ7XG4gIH0sIFtjYWxsYmFja01hcF0pO1xuICB1c2VFZmZlY3QyNCgoKSA9PiB7XG4gICAgaWYgKGlzSW5DdXJyZW50VGFyZ2V0UmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gY2FsbGJhY2tGb3JWYXJpYW50KGNhbGxiYWNrTWFwLCB2YXJpYW50KTtcbiAgICAgIGlmIChjYWxsYmFjaylcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH0sIFt2YXJpYW50LCBjYWxsYmFja01hcF0pO1xufVxuZnVuY3Rpb24gdXNlT25BcHBlYXIoY2FsbGJhY2spIHtcbiAgdXNlT25WYXJpYW50Q2hhbmdlKFwiZGVmYXVsdFwiLCB7IGRlZmF1bHQ6IGNhbGxiYWNrIH0pO1xufVxuXG4vLyBzcmMvbW9kdWxlcy91c2VBY3RpdmVWYXJpYW50Q2FsbGJhY2sudHNcbmltcG9ydCB7XG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyNSxcbiAgdXNlUmVmIGFzIHVzZVJlZjI2XG59IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gcmVqZWN0UGVuZGluZyhwZW5kaW5nVGltZXJzLCBwZW5kaW5nUHJvbWlzZXMpIHtcbiAgcGVuZGluZ1RpbWVycy5mb3JFYWNoKCh0KSA9PiBjbGVhclRpbWVvdXQodCkpO1xuICBwZW5kaW5nVGltZXJzLmNsZWFyKCk7XG4gIHBlbmRpbmdQcm9taXNlcy5mb3JFYWNoKChyZWplY3QpID0+IHJlamVjdCAmJiByZWplY3QoXCJDYWxsYmFjayBjYW5jZWxsZWQgYnkgdmFyaWFudCBjaGFuZ2VcIikpO1xuICBwZW5kaW5nUHJvbWlzZXMuY2xlYXIoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNldCgpIHtcbiAgcmV0dXJuIG5ldyBTZXQoKTtcbn1cbmZ1bmN0aW9uIHVzZUFjdGl2ZVZhcmlhbnRDYWxsYmFjayhiYXNlVmFyaWFudCkge1xuICBjb25zdCBwZW5kaW5nUHJvbWlzZXMgPSB1c2VDb25zdGFudDIoY3JlYXRlU2V0KTtcbiAgY29uc3QgcGVuZGluZ1RpbWVycyA9IHVzZUNvbnN0YW50MihjcmVhdGVTZXQpO1xuICB1c2VPbkN1cnJlbnRUYXJnZXRDaGFuZ2UoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiByZWplY3RQZW5kaW5nKHBlbmRpbmdUaW1lcnMsIHBlbmRpbmdQcm9taXNlcyk7XG4gIH0pO1xuICB1c2VFZmZlY3QyNSgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHJlamVjdFBlbmRpbmcocGVuZGluZ1RpbWVycywgcGVuZGluZ1Byb21pc2VzKTtcbiAgfSwgW3BlbmRpbmdQcm9taXNlcywgcGVuZGluZ1RpbWVyc10pO1xuICB1c2VFZmZlY3QyNSgoKSA9PiB7XG4gICAgcmVqZWN0UGVuZGluZyhwZW5kaW5nVGltZXJzLCBwZW5kaW5nUHJvbWlzZXMpO1xuICB9LCBbYmFzZVZhcmlhbnQsIHBlbmRpbmdQcm9taXNlcywgcGVuZGluZ1RpbWVyc10pO1xuICByZXR1cm4gdXNlUmVmMjYoe1xuICAgIGFjdGl2ZVZhcmlhbnRDYWxsYmFjazogKGNhbGxiYWNrKSA9PiAoLi4uYXJncykgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgcGVuZGluZ1Byb21pc2VzLmFkZChyZWplY3QpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soLi4uYXJncykudGhlbihyZXNvbHZlKTtcbiAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGVsYXk6IGFzeW5jIChjYWxsYmFjaywgbXNEZWxheSkgPT4ge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHBlbmRpbmdUaW1lcnMuYWRkKGdsb2JhbFRoaXMuc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKHRydWUpLCBtc0RlbGF5KSkpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH0pLmN1cnJlbnQ7XG59XG5mdW5jdGlvbiB1c2VBY3RpdmVUYXJnZXRDYWxsYmFjaygpIHtcbiAgY29uc3QgdmFsdWUgPSB1c2VBY3RpdmVWYXJpYW50Q2FsbGJhY2sodm9pZCAwKTtcbiAgcmV0dXJuIHVzZVJlZjI2KHtcbiAgICBhY3RpdmVUYXJnZXRDYWxsYmFjazogdmFsdWUuYWN0aXZlVmFyaWFudENhbGxiYWNrLFxuICAgIGRlbGF5OiB2YWx1ZS5kZWxheVxuICB9KS5jdXJyZW50O1xufVxuXG4vLyBzcmMvbW9kdWxlcy91c2VOYXZpZ2F0ZS50c3hcbmltcG9ydCB7XG4gIGNyZWF0ZUVsZW1lbnQgYXMgY3JlYXRlRWxlbWVudDUzLFxuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWYxMixcbiAgbGF6eSxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDI2XG59IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gbGF6eTIoZmFjdG9yeSkge1xuICBjb25zdCBMYXp5Q29tcG9uZW50ID0gbGF6eShmYWN0b3J5KTtcbiAgbGV0IGZhY3RvcnlQcm9taXNlO1xuICBsZXQgTG9hZGVkQ29tcG9uZW50O1xuICBjb25zdCBDb21wb25lbnQxOSA9IGZvcndhcmRSZWYxMihmdW5jdGlvbiBMYXp5V2l0aFByZWxvYWQocHJvcHMsIHJlZikge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50NTMoTG9hZGVkQ29tcG9uZW50ICE9IG51bGwgPyBMb2FkZWRDb21wb25lbnQgOiBMYXp5Q29tcG9uZW50LCBPYmplY3QuYXNzaWduKHJlZiA/IHsgcmVmIH0gOiB7fSwgcHJvcHMpKTtcbiAgfSk7XG4gIENvbXBvbmVudDE5LnByZWxvYWQgPSAoKSA9PiB7XG4gICAgaWYgKCFmYWN0b3J5UHJvbWlzZSkge1xuICAgICAgZmFjdG9yeVByb21pc2UgPSBmYWN0b3J5KCkudGhlbigobW9kdWxlKSA9PiB7XG4gICAgICAgIExvYWRlZENvbXBvbmVudCA9IG1vZHVsZS5kZWZhdWx0O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmYWN0b3J5UHJvbWlzZTtcbiAgfTtcbiAgcmV0dXJuIENvbXBvbmVudDE5O1xufVxuZnVuY3Rpb24gdXNlTmF2aWdhdGUoeyBwcmVsb2FkIH0gPSB7fSkge1xuICBjb25zdCBuYXZpZ2F0aW9uID0gdXNlTmF2aWdhdGlvbigpO1xuICB1c2VFZmZlY3QyNigoKSA9PiB7XG4gICAgaWYgKCFuYXZpZ2F0aW9uKVxuICAgICAgcmV0dXJuO1xuICAgIHByZWxvYWQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZWxvYWQuZm9yRWFjaCgoY29tcG9uZW50KSA9PiBcInByZWxvYWRcIiBpbiBjb21wb25lbnQgJiYgY29tcG9uZW50LnByZWxvYWQoKSk7XG4gIH0sIFtdKTtcbiAgaWYgKCFuYXZpZ2F0aW9uKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgfTtcbiAgcmV0dXJuIGFzeW5jICh0YXJnZXQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGlmICh0YXJnZXQgPT09IFwicHJldmlvdXNcIikge1xuICAgICAgbmF2aWdhdGlvbi5nb0JhY2soKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBhcHBlYXJzRnJvbSwgYmFja2Ryb3BDb2xvciwgYW5pbWF0aW9uIH0gPSBvcHRpb25zO1xuICAgIGlmICghdGFyZ2V0KVxuICAgICAgcmV0dXJuO1xuICAgIHN3aXRjaCAob3B0aW9ucy50cmFuc2l0aW9uKSB7XG4gICAgICBjYXNlIFwiaW5zdGFudFwiOlxuICAgICAgICBuYXZpZ2F0aW9uLmluc3RhbnQodGFyZ2V0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZmFkZVwiOlxuICAgICAgICBuYXZpZ2F0aW9uLmZhZGUodGFyZ2V0LCB7IGFuaW1hdGlvbiB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicHVzaFwiOlxuICAgICAgICBuYXZpZ2F0aW9uLnB1c2godGFyZ2V0LCB7IGFwcGVhcnNGcm9tLCBhbmltYXRpb24gfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1vZGFsXCI6XG4gICAgICAgIG5hdmlnYXRpb24ubW9kYWwodGFyZ2V0LCB7IGJhY2tkcm9wQ29sb3IsIGFuaW1hdGlvbiB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwib3ZlcmxheVwiOlxuICAgICAgICBuYXZpZ2F0aW9uLm92ZXJsYXkodGFyZ2V0LCB7IGFwcGVhcnNGcm9tLCBiYWNrZHJvcENvbG9yLCBhbmltYXRpb24gfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZsaXBcIjpcbiAgICAgICAgbmF2aWdhdGlvbi5mbGlwKHRhcmdldCwgeyBhcHBlYXJzRnJvbSwgYW5pbWF0aW9uIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtYWdpY01vdGlvblwiOlxuICAgICAgICBuYXZpZ2F0aW9uLm1hZ2ljTW90aW9uKHRhcmdldCwgeyBhbmltYXRpb24gfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59XG5cbi8vIHNyYy9tb2R1bGVzL0xheW91dEdyb3VwLnRzeFxuaW1wb3J0IHtcbiAgRnJhZ21lbnQgYXMgRnJhZ21lbnQ5LFxuICBjcmVhdGVFbGVtZW50IGFzIGNyZWF0ZUVsZW1lbnQ1NFxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDMwIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgTGF5b3V0R3JvdXAgPSAoe1xuICBpZCxcbiAgY2hpbGRyZW5cbn0pID0+IHtcbiAgY29uc3QgcGFyZW50TGF5b3V0SWQgPSB1c2VDb250ZXh0MzAoTGF5b3V0R3JvdXBDb250ZXh0KTtcbiAgaWYgKCFpZClcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQ1NChGcmFnbWVudDksIG51bGwsIGNoaWxkcmVuKTtcbiAgY29uc3QgY29tYmluZWRMYXlvdXRJZCA9IHBhcmVudExheW91dElkICYmIHBhcmVudExheW91dElkICE9PSBpZCA/IGAke3BhcmVudExheW91dElkfS0ke2lkfWAgOiBpZDtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVFbGVtZW50NTQoTGF5b3V0R3JvdXBDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbWJpbmVkTGF5b3V0SWRcbiAgfSwgY2hpbGRyZW4pO1xufTtcblxuLy8gc3JjL21vZHVsZXMvdXNlSG90a2V5LnRzXG5pbXBvcnQge1xuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazEyLFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MjcsXG4gIHVzZVJlZiBhcyB1c2VSZWYyN1xufSBmcm9tIFwicmVhY3RcIjtcbnZhciBtb2RpZmllckRlZmF1bHRzID0ge1xuICBhbHRLZXk6IGZhbHNlLFxuICBjdHJsS2V5OiBmYWxzZSxcbiAgbWV0YUtleTogZmFsc2UsXG4gIHNoaWZ0S2V5OiBmYWxzZVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVNob3J0Y3V0RGVmaW5pdGlvbihzaG9ydGN1dCkge1xuICBjb25zdCBrZXlzMiA9IHNob3J0Y3V0LnNwbGl0KFwiK1wiKTtcbiAgY29uc3Qga2V5NiA9IGtleXMyLnBvcCgpO1xuICBpZiAoIWtleTYpXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgbW9kaWZpZXJzID0ge307XG4gIGZvciAoY29uc3QgbW9kaWZpZXIgb2Yga2V5czIpIHtcbiAgICBtb2RpZmllcnNbYCR7bW9kaWZpZXJ9S2V5YF0gPSB0cnVlO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4ubW9kaWZpZXJEZWZhdWx0cyxcbiAgICAuLi5tb2RpZmllcnMsXG4gICAga2V5OiBrZXk2XG4gIH07XG59XG5mdW5jdGlvbiB1c2VIb3RrZXkoc2hvcnRjdXQsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGluVGFyZ2V0ID0gdXNlUmVmMjcodHJ1ZSk7XG4gIGNvbnN0IHNob3J0Y3V0RGVmaW5pdGlvbiA9IHVzZUNvbnN0YW50MigoKSA9PiBjcmVhdGVTaG9ydGN1dERlZmluaXRpb24oc2hvcnRjdXQpKTtcbiAgdXNlT25DdXJyZW50VGFyZ2V0Q2hhbmdlKChpc0N1cnJlbnRUYXJnZXQsIGlzT3ZlcmxheWVkKSA9PiB7XG4gICAgaW5UYXJnZXQuY3VycmVudCA9IGlzQ3VycmVudFRhcmdldCAmJiAhaXNPdmVybGF5ZWQ7XG4gICAgcmV0dXJuICgpID0+IGluVGFyZ2V0LmN1cnJlbnQgPSBmYWxzZTtcbiAgfSk7XG4gIGNvbnN0IGV2ZW50SGFuZGxlciA9IHVzZUNhbGxiYWNrMTIoKGV2ZW50KSA9PiB7XG4gICAgaWYgKCFzaG9ydGN1dERlZmluaXRpb24pXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFpblRhcmdldC5jdXJyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghT2JqZWN0LmtleXMoc2hvcnRjdXREZWZpbml0aW9uKS5ldmVyeSgoa2V5NikgPT4gc2hvcnRjdXREZWZpbml0aW9uW2tleTZdID09PSBldmVudFtrZXk2XSkpXG4gICAgICByZXR1cm47XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjYWxsYmFjaygpO1xuICB9LCBbc2hvcnRjdXREZWZpbml0aW9uLCBjYWxsYmFja10pO1xuICB1c2VFZmZlY3QyNygoKSA9PiB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZlbnRIYW5kbGVyKTtcbiAgICByZXR1cm4gKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZlbnRIYW5kbGVyKTtcbiAgfSwgW2V2ZW50SGFuZGxlcl0pO1xufVxuXG4vLyBzcmMvbW9kdWxlcy91c2VHYW1lcGFkLnRzXG5pbXBvcnQge1xuICBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxOSxcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2sxMyxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MzEsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyOFxufSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIGlzRnJhbWVyR2FtZXBhZEtleWRvd25EYXRhKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUubWFwcGluZyAhPT0gdm9pZCAwO1xufVxuZnVuY3Rpb24gY3JlYXRlR2FtZXBhZFBvbGxlcigpIHtcbiAgY29uc3QgY2FsbGJhY2tzMiA9IG5ldyBTZXQoKTtcbiAgbGV0IGlzQ29ubmVjdGVkID0gZmFsc2U7XG4gIGxldCBpc1BvbGxpbmcgPSBudWxsO1xuICBsZXQgbGFzdEtleSA9IG51bGw7XG4gIGNvbnN0IHN0YXJ0UG9sbGluZyA9ICgpID0+IHtcbiAgICBjb25zdCBpbnB1dCA9IGdldEZpcnN0QXZhaWxhYmxlR2FtZXBhZElucHV0KCk7XG4gICAgaWYgKCFpbnB1dClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGdhbWVwYWQsIGtleToga2V5NiB9ID0gaW5wdXQ7XG4gICAgY29uc3QgeyBtYXBwaW5nLCBpZCB9ID0gZ2FtZXBhZDtcbiAgICBpZiAoa2V5NiAmJiBsYXN0S2V5ICE9PSBrZXk2KVxuICAgICAgY2FsbGJhY2tzMi5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soeyBrZXk6IGtleTYsIG1hcHBpbmcsIGlkIH0pKTtcbiAgICBsYXN0S2V5ID0ga2V5NjtcbiAgICBpc1BvbGxpbmcgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0YXJ0UG9sbGluZyk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZUNvbm5lY3Rpb24gPSAoKSA9PiB7XG4gICAgaWYgKGlzQ29ubmVjdGVkIHx8IGlzUG9sbGluZylcbiAgICAgIHJldHVybjtcbiAgICBzdGFydFBvbGxpbmcoKTtcbiAgICBpc0Nvbm5lY3RlZCA9IHRydWU7XG4gIH07XG4gIGNvbnN0IHN0b3BQb2xsaW5nID0gKCkgPT4ge1xuICAgIGlmICghaXNQb2xsaW5nKVxuICAgICAgcmV0dXJuO1xuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShpc1BvbGxpbmcpO1xuICAgIGlzUG9sbGluZyA9IG51bGw7XG4gIH07XG4gIGNvbnN0IGhhbmRsZURpc2Nvbm5lY3Rpb24gPSAoKSA9PiB7XG4gICAgaWYgKCFpc0Nvbm5lY3RlZClcbiAgICAgIHJldHVybjtcbiAgICBzdG9wUG9sbGluZygpO1xuICAgIGlzQ29ubmVjdGVkID0gZmFsc2U7XG4gIH07XG4gIGNvbnN0IHNldHVwQW5kU3RhcnRQb2xsaW5nID0gKCkgPT4ge1xuICAgIGlmIChpc1BvbGxpbmcpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZ2FtZXBhZCA9IGdldEZpcnN0QXZhaWxhYmxlR2FtZXBhZElucHV0KCk7XG4gICAgaWYgKCFnYW1lcGFkKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImdhbWVwYWRjb25uZWN0ZWRcIiwgaGFuZGxlQ29ubmVjdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZ2FtZXBhZGRpc2Nvbm5lY3RlZFwiLCBoYW5kbGVEaXNjb25uZWN0aW9uKTtcbiAgICBpc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgc3RhcnRQb2xsaW5nKCk7XG4gIH07XG4gIGNvbnN0IGNsZWFudXBBbmRTdG9wUG9sbGluZyA9ICgpID0+IHtcbiAgICBpZiAoIWlzUG9sbGluZylcbiAgICAgIHJldHVybjtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImdhbWVwYWRjb25uZWN0ZWRcIiwgaGFuZGxlQ29ubmVjdGlvbik7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJnYW1lcGFkZGlzY29ubmVjdGVkXCIsIGhhbmRsZURpc2Nvbm5lY3Rpb24pO1xuICAgIHN0b3BQb2xsaW5nKCk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgcmVnaXN0ZXIoY2FsbGJhY2spIHtcbiAgICAgIGlmIChjYWxsYmFja3MyLnNpemUgPT09IDApXG4gICAgICAgIHNldHVwQW5kU3RhcnRQb2xsaW5nKCk7XG4gICAgICBjYWxsYmFja3MyLmFkZChjYWxsYmFjayk7XG4gICAgfSxcbiAgICB1bnJlZ2lzdGVyKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFja3MyLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICBpZiAoY2FsbGJhY2tzMi5zaXplID09PSAwKVxuICAgICAgICBjbGVhbnVwQW5kU3RvcFBvbGxpbmcoKTtcbiAgICB9XG4gIH07XG59XG52YXIgR2FtZXBhZENvbnRleHQgPSBjcmVhdGVDb250ZXh0MTkoY3JlYXRlR2FtZXBhZFBvbGxlcigpKTtcbmZ1bmN0aW9uIGdldEZpcnN0QXZhaWxhYmxlR2FtZXBhZElucHV0KCkge1xuICBsZXQgZmlyc3RDb25uZWN0ZWRHYW1lcGFkID0gbnVsbDtcbiAgY29uc3QgZ2FtZXBhZHMgPSBuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKTtcbiAgZm9yIChjb25zdCBnYW1lcGFkIG9mIGdhbWVwYWRzKSB7XG4gICAgaWYgKCFnYW1lcGFkKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKCFmaXJzdENvbm5lY3RlZEdhbWVwYWQpIHtcbiAgICAgIGZpcnN0Q29ubmVjdGVkR2FtZXBhZCA9IGdhbWVwYWQ7XG4gICAgfVxuICAgIGNvbnN0IGF4aXMgPSBzY2FuUHJlc3NlZEF4aXMoZ2FtZXBhZCk7XG4gICAgaWYgKGF4aXMgIT09IG51bGwpXG4gICAgICByZXR1cm4geyBnYW1lcGFkLCBrZXk6IGF4aXMgfTtcbiAgICBjb25zdCBidXR0b24gPSBzY2FuUHJlc3NlZEJ1dHRvbihnYW1lcGFkKTtcbiAgICBpZiAoYnV0dG9uICE9PSBudWxsKVxuICAgICAgcmV0dXJuIHsgZ2FtZXBhZCwga2V5OiBidXR0b24gfTtcbiAgfVxuICBpZiAoZmlyc3RDb25uZWN0ZWRHYW1lcGFkKVxuICAgIHJldHVybiB7IGdhbWVwYWQ6IGZpcnN0Q29ubmVjdGVkR2FtZXBhZCwga2V5OiBudWxsIH07XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2NhblByZXNzZWRBeGlzKGdhbWVwYWQpIHtcbiAgZm9yIChjb25zdCBbaWR4LCBheGlzXSBvZiBnYW1lcGFkLmF4ZXMuZW50cmllcygpKSB7XG4gICAgaWYgKGlkeCA+IDMpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoYXhpcyA8PSAtMC41KVxuICAgICAgcmV0dXJuIGBBeGlzICR7aWR4fS1gO1xuICAgIGlmIChheGlzID4gMC41KVxuICAgICAgcmV0dXJuIGBBeGlzICR7aWR4fStgO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2NhblByZXNzZWRCdXR0b24oZ2FtZXBhZCkge1xuICBmb3IgKGNvbnN0IFtpZHgsIGJ1dHRvbl0gb2YgZ2FtZXBhZC5idXR0b25zLmVudHJpZXMoKSkge1xuICAgIGlmIChpc0J1dHRvblByZXNzZWQoYnV0dG9uKSlcbiAgICAgIHJldHVybiBgQnV0dG9uICR7aWR4fWA7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc0J1dHRvblByZXNzZWQoYnV0dG9uKSB7XG4gIHJldHVybiBidXR0b24ucHJlc3NlZCA9PT0gdHJ1ZSB8fCBidXR0b24udmFsdWUgPiAwO1xufVxuZnVuY3Rpb24gdXNlR2FtZXBhZChrZXk2LCBjYWxsYmFjaywgb3B0aW9ucyA9IHsgbWFwcGluZzogXCJzdGFuZGFyZFwiIH0pIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQzMShHYW1lcGFkQ29udGV4dCk7XG4gIGNvbnN0IG1hcHBpbmcgPSB1c2VDb25zdGFudDIoKCkgPT4gb3B0aW9ucy5tYXBwaW5nKTtcbiAgY29uc3QgY2IyID0gdXNlQ2FsbGJhY2sxMygoaW5wdXQpID0+IHtcbiAgICBpZiAoa2V5NiA9PT0gaW5wdXQua2V5ICYmIG1hcHBpbmcgPT09IGlucHV0Lm1hcHBpbmcpXG4gICAgICBjYWxsYmFjaygpO1xuICB9LCBba2V5NiwgbWFwcGluZywgY2FsbGJhY2tdKTtcbiAgdXNlT25DdXJyZW50VGFyZ2V0Q2hhbmdlKChpc0luVGFyZ2V0LCBpc092ZXJsYXllZCkgPT4ge1xuICAgIGNvbnN0IGlzQWN0aXZlID0gaXNJblRhcmdldCAmJiAhaXNPdmVybGF5ZWQ7XG4gICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICBjb250ZXh0LnJlZ2lzdGVyKGNiMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQudW5yZWdpc3RlcihjYjIpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4gY29udGV4dC51bnJlZ2lzdGVyKGNiMik7XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0MjgoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiBjb250ZXh0LnVucmVnaXN0ZXIoY2IyKTtcbiAgfSwgW2NiMiwgY29udGV4dF0pO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmlmICh1bmRlZmluZWQgPT09IFwiZnJhbWVyXCIpIHtcbiAgTWFpbkxvb3Auc3RhcnQoKTtcbn1cbmV4cG9ydCB7XG4gIEFuaW1hdGFibGUsXG4gIEFuaW1hdGVQcmVzZW5jZSxcbiAgQW5pbWF0ZVNoYXJlZExheW91dCxcbiAgQW55SW50ZXJwb2xhdGlvbixcbiAgQXV0b21hdGljTGF5b3V0SWRzLFxuICBCYWNrZ3JvdW5kSW1hZ2UsXG4gIEJlemllckFuaW1hdG9yLFxuICBCb3hTaGFkb3csXG4gIENhbnZhc1N0b3JlLFxuICBDb2xvcixcbiAgQ29sb3JGb3JtYXQsXG4gIENvbG9yTWl4TW9kZWxUeXBlLFxuICBDb21wb25lbnRDb250YWluZXJDb250ZXh0LFxuICBDb25zdHJhaW50TWFzayxcbiAgQ29uc3RyYWludFZhbHVlcyxcbiAgQ29udGFpbmVyLFxuICBDb250cm9sVHlwZSxcbiAgQ29udmVydENvbG9yLFxuICBDdXN0b21Qcm9wZXJ0aWVzLFxuICBDdXN0b21Qcm9wZXJ0aWVzQ29udGV4dCxcbiAgQ3ljbGVWYXJpYW50U3RhdGUsXG4gIERPTSxcbiAgRGF0YSxcbiAgRGF0YUNvbnRleHQsXG4gIERhdGFPYnNlcnZlcixcbiAgRGF0YU9ic2VydmVyQ29udGV4dCxcbiAgRGVwcmVjYXRlZENvbXBvbmVudENvbnRhaW5lcixcbiAgRGVwcmVjYXRlZEZyYW1lV2l0aEV2ZW50cyxcbiAgRGltZW5zaW9uVHlwZSxcbiAgRHJhZ0NvbnRyb2xzLFxuICBEcmFnZ2FibGUsXG4gIEVtcHR5U3RhdGUsXG4gIEZsYXRUcmVlLFxuICBGcmFtZSxcbiAgRnJhbWVXaXRoTW90aW9uLFxuICBGcmFtZXJBbmltYXRpb24sXG4gIEZyYW1lckV2ZW50LFxuICBGcmFtZXJFdmVudExpc3RlbmVyLFxuICBGcmFtZXJFdmVudFNlc3Npb24sXG4gIEZyYW1lclRyZWVMYXlvdXRDb250ZXh0LFxuICBHYW1lcGFkQ29udGV4dCxcbiAgSW1hZ2UyIGFzIEltYWdlLFxuICBJbnRlcm5hbElELFxuICBMYXllcixcbiAgTGF5b3V0R3JvdXAsXG4gIExheW91dEdyb3VwQ29udGV4dCxcbiAgTGF5b3V0SWRDb250ZXh0LFxuICBMYXp5TW90aW9uLFxuICBMaW5lLFxuICBMaW5lYXJHcmFkaWVudCxcbiAgTWFpbkxvb3AsXG4gIE1vdGlvbkNvbmZpZyxcbiAgTW90aW9uQ29uZmlnQ29udGV4dCxcbiAgTW90aW9uU2V0dXAsXG4gIE1vdGlvblZhbHVlLFxuICBOYXZpZ2F0ZVRvLFxuICBOYXZpZ2F0aW9uLFxuICBOYXZpZ2F0aW9uQ2FsbGJhY2tQcm92aWRlcixcbiAgTmF2aWdhdGlvbkNvbnN1bWVyLFxuICBOYXZpZ2F0aW9uVHJhbnNpdGlvblR5cGUsXG4gIE9ic2VydmFibGVPYmplY3QsXG4gIFBhZ2UsXG4gIFBhcmVudFNpemVTdGF0ZSxcbiAgUGF0aFNlZ21lbnQsXG4gIFBvaW50LFxuICBQcmVzZW5jZUNvbnRleHQsXG4gIFByb3BlcnR5U3RvcmUsXG4gIFByb3ZpZGVQYXJlbnRTaXplLFxuICBSYWRpYWxHcmFkaWVudCxcbiAgUmVjdCxcbiAgUmVuZGVyTm9kZVByb3ZpZGVyLFxuICBSZW5kZXJUYXJnZXQsXG4gIFNWRyxcbiAgU2Nyb2xsLFxuICBTaGFkb3csXG4gIFNoYXJlZExheW91dENvbnRleHQsXG4gIFNpemUsXG4gIFNwcmluZ0FuaW1hdG9yLFxuICBTdGFjayxcbiAgVGV4dCxcbiAgVHlwZWZhY2VTb3VyY2VOYW1lcyxcbiAgVmFsdWVJbnRlcnBvbGF0aW9uLFxuICBWYXJpYW50U2VsZWN0b3IsXG4gIFZlY3RvcixcbiAgVmVjdG9yR3JvdXAsXG4gIFZpc2liaWxpdHlBY3Rpb24sXG4gIFdpdGhOYXZpZ2F0b3IsXG4gIFdpdGhPdmVycmlkZSxcbiAgX2dldENTU1RleHRDb2xvckZyb21TdHlsZSxcbiAgX2luamVjdFJ1bnRpbWUsXG4gIGFkZEFjdGlvbkNvbnRyb2xzLFxuICBhZGRGb250cyxcbiAgYWRkUHJvcGVydHlDb250cm9scyxcbiAgYWRkU2NhbGVDb3JyZWN0aW9uLFxuICBhbmltYXRlMyBhcyBhbmltYXRlLFxuICBhbmltYXRlVmlzdWFsRWxlbWVudCxcbiAgYW5pbWF0aW9uQ29udHJvbHMsXG4gIGFubm90YXRlVHlwZU9uU3RyaW5naWZ5LFxuICBiYWNrZ3JvdW5kSW1hZ2VGcm9tUHJvcHMsXG4gIGNhbGN1bGF0ZVJlY3QsXG4gIGNhbGxFYWNoLFxuICBjb2xsZWN0VmlzdWFsU3R5bGVGcm9tUHJvcHMsXG4gIGNvbnN0cmFpbnRzRW5hYmxlZCxcbiAgY29udmVydFByZXNlbnRhdGlvblRyZWUsXG4gIGNyZWF0ZUJhdGNoZXIsXG4gIGNyZWF0ZUNyb3NzZmFkZXIsXG4gIGNyZWF0ZURhdGEsXG4gIGNyZWF0ZURlc2lnbkNvbXBvbmVudCxcbiAgY3JlYXRlRG9tTW90aW9uQ29tcG9uZW50LFxuICBjcmVhdGVNb3Rpb25Db21wb25lbnQsXG4gIGNzc0JhY2tncm91bmRTaXplLFxuICBjeCxcbiAgZGVib3VuY2UsXG4gIGRpc3BhdGNoS2V5RG93bkV2ZW50LFxuICBkb21BbmltYXRpb24sXG4gIGRvbU1heCxcbiAgZW52aXJvbm1lbnQsXG4gIGV4ZWN1dGVJblJlbmRlckVudmlyb25tZW50LFxuICBmaW5pdGVOdW1iZXIsXG4gIGZvbnRTdG9yZSxcbiAgZm9yY2VMYXllckJhY2tpbmdXaXRoQ1NTUHJvcGVydGllcyxcbiAgZnJhY3Rpb24sXG4gIGZyYW1lRnJvbUVsZW1lbnQsXG4gIGZyYW1lRnJvbUVsZW1lbnRzLFxuICBnZXRDb25maWdGcm9tUHJldmlld1VSTCxcbiAgZ2V0Q29uZmlnRnJvbVByZXZpZXdVUkwgYXMgZ2V0Q29uZmlnRnJvbVVSTCxcbiAgZ2V0Q29uZmlnRnJvbVZla3RlclVSTCxcbiAgZ2V0Rm9udHMsXG4gIGdldE1lYXN1cmFibGVDb2RlQ29tcG9uZW50Q2hpbGRyZW4sXG4gIGdldE1lcmdlZENvbnN0cmFpbnRzUHJvcHMsXG4gIGdldFByb3BlcnR5Q29udHJvbHMsXG4gIGdyYWRpZW50Rm9yU2hhcGUsXG4gIGltYWdlUGF0dGVyblByb3BzRm9yRmlsbCxcbiAgaW1hZ2VVcmxGb3JBc3NldCxcbiAgaXNBbmltYXRhYmxlMiBhcyBpc0FuaW1hdGFibGUsXG4gIGlzRGVzaWduRGVmaW5pdGlvbixcbiAgaXNFcXVhbCxcbiAgaXNGaW5pdGVOdW1iZXIsXG4gIGlzRnJhY3Rpb25EaW1lbnNpb24sXG4gIGlzRnJhbWVyR2FtZXBhZEtleWRvd25EYXRhLFxuICBpc0dhcEVuYWJsZWQsXG4gIGlzTW90aW9uVmFsdWUyIGFzIGlzTW90aW9uVmFsdWUsXG4gIGlzT2ZBbm5vdGF0ZWRUeXBlLFxuICBpc092ZXJyaWRlLFxuICBpc1JlYWN0RGVmaW5pdGlvbixcbiAgaXNTaGFsbG93RXF1YWxBcnJheSxcbiAgaXNTdHJhaWdodEN1cnZlLFxuICBpc1ZhbGlkTW90aW9uUHJvcCxcbiAgbGF6eTIgYXMgbGF6eSxcbiAgbG9hZEZvbnQsXG4gIGxvYWRKU09OLFxuICBsb2NhbFBhY2thZ2VGYWxsYmFja0lkZW50aWZpZXIsXG4gIGxvY2FsU2hhZG93RnJhbWUsXG4gIG0sXG4gIG1ha2VQYWRkaW5nU3RyaW5nLFxuICBtZW1vaXplLFxuICBtb3Rpb24sXG4gIG1vdGlvblZhbHVlLFxuICBwYWRkaW5nRnJvbVByb3BzLFxuICBwYXJzZVZhcmlhbnQsXG4gIHBhdGhEZWZhdWx0cyxcbiAgcHJpbnQsXG4gIHJlc29sdmVNb3Rpb25WYWx1ZSxcbiAgcm91bmRXaXRoT2Zmc2V0LFxuICByb3VuZGVkTnVtYmVyLFxuICByb3VuZGVkTnVtYmVyU3RyaW5nLFxuICBzZXJ2ZXJVUkwsXG4gIHNldEdsb2JhbFJlbmRlckVudmlyb25tZW50LFxuICBzbmFwc2hvdFZpZXdwb3J0Qm94LFxuICBzdGFydEFuaW1hdGlvbjIgYXMgc3RhcnRBbmltYXRpb24sXG4gIHN5c3RlbVR5cGVmYWNlTmFtZSxcbiAgdGhyb3R0bGUsXG4gIHRvRmxleERpcmVjdGlvbixcbiAgdG9KdXN0aWZ5T3JBbGlnbm1lbnQsXG4gIHRvU1ZHUGF0aCxcbiAgdHJhbnNmb3JtLFxuICB0cmFuc2Zvcm1TdHJpbmcsXG4gIHRyYW5zZm9ybVRlbXBsYXRlLFxuICB1c2VBY3RpdmVUYXJnZXRDYWxsYmFjayxcbiAgdXNlQWN0aXZlVmFyaWFudENhbGxiYWNrLFxuICB1c2VBZGRWYXJpYW50UHJvcHMsXG4gIHVzZUFuaW1hdGVkU3RhdGUsXG4gIHVzZUFuaW1hdGlvbixcbiAgdXNlQ3ljbGUsXG4gIHVzZUFuaW1hdGVkU3RhdGUgYXMgdXNlRGVwcmVjYXRlZEFuaW1hdGVkU3RhdGUsXG4gIHVzZUludmVydGVkU2NhbGUgYXMgdXNlRGVwcmVjYXRlZEludmVydGVkU2NhbGUsXG4gIHVzZURvbUV2ZW50LFxuICB1c2VEcmFnQ29udHJvbHMsXG4gIHVzZUVsZW1lbnRTY3JvbGwsXG4gIHVzZUdhbWVwYWQsXG4gIHVzZUhvdGtleSxcbiAgdXNlSW52ZXJ0ZWRTY2FsZSxcbiAgdXNlSXNJbkN1cnJlbnROYXZpZ2F0aW9uVGFyZ2V0LFxuICB1c2VJc09uRnJhbWVyQ2FudmFzLFxuICB1c2VJc1ByZXNlbnQsXG4gIHVzZU1lYXN1cmVMYXlvdXQsXG4gIHVzZU1vdGlvblRlbXBsYXRlLFxuICB1c2VNb3Rpb25WYWx1ZSxcbiAgdXNlTmF2aWdhdGUsXG4gIHVzZU5hdmlnYXRpb24sXG4gIHVzZU9ic2VydmVEYXRhLFxuICB1c2VPbkFwcGVhcixcbiAgdXNlT25DdXJyZW50VGFyZ2V0Q2hhbmdlLFxuICB1c2VPblZhcmlhbnRDaGFuZ2UsXG4gIHVzZVByZXNlbmNlLFxuICB1c2VSZWR1Y2VkTW90aW9uLFxuICB1c2VSZW5kZXJFbnZpcm9ubWVudCxcbiAgdXNlU3ByaW5nLFxuICB1c2VUcmFuc2Zvcm0sXG4gIHVzZVZhcmlhbnRTdGF0ZSxcbiAgdXNlVmVsb2NpdHksXG4gIHVzZVZpZXdwb3J0U2Nyb2xsLFxuICB2YWx1ZVRvRGltZW5zaW9uVHlwZSxcbiAgdmVyc2lvbixcbiAgdmlzdWFsRWxlbWVudCxcbiAgd2l0aENTUyxcbiAgd2l0aEdlbmVyYXRlZExheW91dElkLFxuICB3aXRoTWVhc3VyZWRTaXplLFxuICB3aXRoT3BhY2l0eSxcbiAgd2l0aFBhdGgsXG4gIHdpdGhTaGFwZVxufTtcbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG5cblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1Jcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJhbWVyLmRlYnVnLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/framer/build/esm/framer.debug.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Button.tsx":
/*!***********************************!*\
  !*** ./src/components/Button.tsx ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Button)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var framer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! framer */ \"(app-pages-browser)/./node_modules/framer/build/esm/framer.debug.js\");\n/* harmony import */ var framer_motion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! framer-motion */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/value/use-motion-value.mjs\");\n/* harmony import */ var _SimpleGlobalState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SimpleGlobalState */ \"(app-pages-browser)/./src/components/SimpleGlobalState.tsx\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n/**\n * @framerSupportedLayoutWidth any-prefer-fixed\n * @framerSupportedLayoutHeight auto\n */ function Button(props) {\n    _s();\n    const { text = \"Button\", variant = \"primary\", size = \"medium\", disabled = false, loading = false, fullWidth = false, externalDisabled = false, linkedForm, linkedFormId = \"\", showIcon = false, icon, iconPosition = \"left\", iconSize = 16, iconColor = \"#FFFFFF\", backgroundColor = \"#000000\", textColor = \"#FFFFFF\", borderColor = \"#000000\", hoverBackgroundColor = \"#333333\", hoverTextColor = \"#FFFFFF\", hoverBorderColor = \"#333333\", borderRadius = \"8px\", padding = \"12px 24px\", font, onClick } = props;\n    const [isHovered, setIsHovered] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Motion values for linking\n    const disabledMotion = (0,framer_motion__WEBPACK_IMPORTED_MODULE_4__.useMotionValue)(disabled || externalDisabled);\n    const formDataMotion = (0,framer_motion__WEBPACK_IMPORTED_MODULE_4__.useMotionValue)({\n        hasContent: false,\n        value: \"\"\n    });\n    const isDisabled = disabled || externalDisabled;\n    // Component linking system\n    // const { createLink } = useComponentLink({\n    //     id: componentId,\n    //     type: 'button',\n    //     data: {\n    //         disabled: isDisabled,\n    //         text,\n    //         variant,\n    //         hasContent: false // Will be updated by linked form\n    //     },\n    //     onDataUpdate: (data) => {\n    //         // Handle updates from linked form\n    //         if (data.hasContent !== undefined) {\n    //             // Update button state based on form content\n    //             console.log('Button received form update:', data)\n    //         }\n    //     }\n    // })\n    // Auto-link with form if ID is provided\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Button.useEffect\": ()=>{\n            if (linkedFormId && linkedFormId.trim() !== '') {\n                // Subscribe to form updates\n                const handleFormUpdate = {\n                    \"Button.useEffect.handleFormUpdate\": (formData)=>{\n                        // Update button state based on form data\n                        console.log('Button received form update:', formData);\n                    }\n                }[\"Button.useEffect.handleFormUpdate\"];\n                (0,_SimpleGlobalState__WEBPACK_IMPORTED_MODULE_3__.subscribeToComponent)(linkedFormId, handleFormUpdate);\n                return ({\n                    \"Button.useEffect\": ()=>{\n                        (0,_SimpleGlobalState__WEBPACK_IMPORTED_MODULE_3__.unsubscribeFromComponent)(linkedFormId, handleFormUpdate);\n                    }\n                })[\"Button.useEffect\"];\n            }\n        }\n    }[\"Button.useEffect\"], [\n        linkedFormId\n    ]);\n    // Sync with linked form if provided (legacy method)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Button.useEffect\": ()=>{\n            if (linkedForm && linkedForm.get) {\n                const formData = linkedForm.get();\n                if (formData) {\n                    disabledMotion.set(formData.disabled || false);\n                    formDataMotion.set({\n                        hasContent: formData.hasContent || false,\n                        value: formData.value || \"\"\n                    });\n                }\n            }\n        }\n    }[\"Button.useEffect\"], [\n        linkedForm,\n        disabledMotion,\n        formDataMotion\n    ]);\n    const handleClick = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"Button.useCallback[handleClick]\": ()=>{\n            if (!isDisabled && !loading && onClick) {\n                (0,react__WEBPACK_IMPORTED_MODULE_1__.startTransition)({\n                    \"Button.useCallback[handleClick]\": ()=>onClick()\n                }[\"Button.useCallback[handleClick]\"]);\n            }\n        }\n    }[\"Button.useCallback[handleClick]\"], [\n        isDisabled,\n        loading,\n        onClick\n    ]);\n    const handleMouseEnter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"Button.useCallback[handleMouseEnter]\": ()=>{\n            (0,react__WEBPACK_IMPORTED_MODULE_1__.startTransition)({\n                \"Button.useCallback[handleMouseEnter]\": ()=>setIsHovered(true)\n            }[\"Button.useCallback[handleMouseEnter]\"]);\n        }\n    }[\"Button.useCallback[handleMouseEnter]\"], []);\n    const handleMouseLeave = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"Button.useCallback[handleMouseLeave]\": ()=>{\n            (0,react__WEBPACK_IMPORTED_MODULE_1__.startTransition)({\n                \"Button.useCallback[handleMouseLeave]\": ()=>setIsHovered(false)\n            }[\"Button.useCallback[handleMouseLeave]\"]);\n        }\n    }[\"Button.useCallback[handleMouseLeave]\"], []);\n    const getVariantStyles = ()=>{\n        // Define variant-specific colors\n        const getVariantColors = ()=>{\n            switch(variant){\n                case \"primary\":\n                    return {\n                        bg: \"#000000\",\n                        text: \"#FFFFFF\",\n                        border: \"#000000\",\n                        hoverBg: \"#333333\",\n                        hoverText: \"#FFFFFF\",\n                        hoverBorder: \"#333333\"\n                    };\n                case \"secondary\":\n                    return {\n                        bg: \"#F5F5F5\",\n                        text: \"#000000\",\n                        border: \"#F5F5F5\",\n                        hoverBg: \"#E5E5E5\",\n                        hoverText: \"#000000\",\n                        hoverBorder: \"#E5E5E5\"\n                    };\n                case \"outline\":\n                    return {\n                        bg: \"transparent\",\n                        text: \"#000000\",\n                        border: \"#000000\",\n                        hoverBg: \"#000000\",\n                        hoverText: \"#FFFFFF\",\n                        hoverBorder: \"#000000\"\n                    };\n                case \"ghost\":\n                    return {\n                        bg: \"transparent\",\n                        text: \"#000000\",\n                        border: \"transparent\",\n                        hoverBg: \"#F5F5F5\",\n                        hoverText: \"#000000\",\n                        hoverBorder: \"transparent\"\n                    };\n                case \"danger\":\n                    return {\n                        bg: \"#FF4444\",\n                        text: \"#FFFFFF\",\n                        border: \"#FF4444\",\n                        hoverBg: \"#CC3333\",\n                        hoverText: \"#FFFFFF\",\n                        hoverBorder: \"#CC3333\"\n                    };\n                default:\n                    return {\n                        bg: backgroundColor,\n                        text: textColor,\n                        border: borderColor,\n                        hoverBg: hoverBackgroundColor,\n                        hoverText: hoverTextColor,\n                        hoverBorder: hoverBorderColor\n                    };\n            }\n        };\n        const colors = getVariantColors();\n        const baseStyles = {\n            backgroundColor: isDisabled ? \"#CCCCCC\" : colors.bg,\n            color: isDisabled ? \"#666666\" : colors.text,\n            border: \"1px solid \".concat(isDisabled ? \"#CCCCCC\" : colors.border)\n        };\n        if (isHovered && !isDisabled) {\n            return {\n                ...baseStyles,\n                backgroundColor: colors.hoverBg,\n                color: colors.hoverText,\n                border: \"1px solid \".concat(colors.hoverBorder)\n            };\n        }\n        return baseStyles;\n    };\n    const getSizeMultiplier = ()=>{\n        switch(size){\n            case \"small\":\n                return 0.75;\n            case \"large\":\n                return 1.25;\n            default:\n                return 1;\n        }\n    };\n    const parsePadding = ()=>{\n        const paddingValues = padding.split(' ').map((p)=>parseInt(p.replace('px', '')));\n        const [top, right, bottom, left] = paddingValues.length === 1 ? [\n            paddingValues[0],\n            paddingValues[0],\n            paddingValues[0],\n            paddingValues[0]\n        ] : paddingValues.length === 2 ? [\n            paddingValues[0],\n            paddingValues[1],\n            paddingValues[0],\n            paddingValues[1]\n        ] : paddingValues.length === 4 ? paddingValues : [\n            12,\n            24,\n            12,\n            24\n        ] // fallback\n        ;\n        const multiplier = getSizeMultiplier();\n        return {\n            paddingTop: \"\".concat(top * multiplier, \"px\"),\n            paddingRight: \"\".concat(right * multiplier, \"px\"),\n            paddingBottom: \"\".concat(bottom * multiplier, \"px\"),\n            paddingLeft: \"\".concat(left * multiplier, \"px\")\n        };\n    };\n    const variantStyles = getVariantStyles();\n    const paddingStyles = parsePadding();\n    const buttonStyles = {\n        ...paddingStyles,\n        ...variantStyles,\n        borderRadius: borderRadius,\n        width: fullWidth ? \"100%\" : \"auto\",\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        gap: \"8px\",\n        cursor: isDisabled || loading ? \"not-allowed\" : \"pointer\",\n        transition: \"all 0.2s ease\",\n        outline: \"none\",\n        ...font,\n        fontSize: (font === null || font === void 0 ? void 0 : font.fontSize) || (size === \"small\" ? \"12px\" : size === \"large\" ? \"16px\" : \"14px\"),\n        fontWeight: (font === null || font === void 0 ? void 0 : font.fontWeight) || \"500\",\n        letterSpacing: (font === null || font === void 0 ? void 0 : font.letterSpacing) || \"0\",\n        lineHeight: (font === null || font === void 0 ? void 0 : font.lineHeight) || \"1.2em\"\n    };\n    const renderIcon = ()=>{\n        if (!showIcon || !icon) return null;\n        const iconStyle = {\n            width: \"\".concat(iconSize, \"px\"),\n            height: \"\".concat(iconSize, \"px\"),\n            color: isDisabled ? \"#666666\" : iconColor,\n            display: \"flex\",\n            alignItems: \"center\",\n            justifyContent: \"center\"\n        };\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: iconStyle,\n            children: icon\n        }, void 0, false, {\n            fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/Button.tsx\",\n            lineNumber: 282,\n            columnNumber: 16\n        }, this);\n    };\n    const renderLoadingSpinner = ()=>{\n        if (!loading) return null;\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                width: \"\".concat(iconSize, \"px\"),\n                height: \"\".concat(iconSize, \"px\"),\n                border: \"2px solid transparent\",\n                borderTop: \"2px solid \".concat(isDisabled ? \"#666666\" : textColor),\n                borderRadius: \"50%\",\n                animation: \"spin 1s linear infinite\"\n            }\n        }, void 0, false, {\n            fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/Button.tsx\",\n            lineNumber: 289,\n            columnNumber: 13\n        }, this);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"style\", {\n                children: \"\\n                    @keyframes spin {\\n                        0% { transform: rotate(0deg); }\\n                        100% { transform: rotate(360deg); }\\n                    }\\n                \"\n            }, void 0, false, {\n                fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/Button.tsx\",\n                lineNumber: 304,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                style: {\n                    ...buttonStyles,\n                    ...props.style\n                },\n                onClick: handleClick,\n                onMouseEnter: handleMouseEnter,\n                onMouseLeave: handleMouseLeave,\n                disabled: isDisabled || loading,\n                type: \"button\",\n                children: [\n                    showIcon && iconPosition === \"left\" && renderIcon(),\n                    loading ? renderLoadingSpinner() : text,\n                    showIcon && iconPosition === \"right\" && renderIcon()\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/Button.tsx\",\n                lineNumber: 312,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true);\n}\n_s(Button, \"9Z0/rh1H3JzCM3+gJR0hmYHY5lg=\", false, function() {\n    return [\n        framer_motion__WEBPACK_IMPORTED_MODULE_4__.useMotionValue,\n        framer_motion__WEBPACK_IMPORTED_MODULE_4__.useMotionValue\n    ];\n});\n_c = Button;\n(0,framer__WEBPACK_IMPORTED_MODULE_2__.addPropertyControls)(Button, {\n    // === BASIC SETTINGS ===\n    text: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.String,\n        title: \"Text\",\n        defaultValue: \"Button\"\n    },\n    variant: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Enum,\n        title: \"Variant\",\n        options: [\n            \"primary\",\n            \"secondary\",\n            \"outline\",\n            \"ghost\",\n            \"danger\",\n            \"custom\"\n        ],\n        optionTitles: [\n            \"Primary\",\n            \"Secondary\",\n            \"Outline\",\n            \"Ghost\",\n            \"Danger\",\n            \"Custom\"\n        ],\n        defaultValue: \"primary\"\n    },\n    size: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Enum,\n        title: \"Size\",\n        options: [\n            \"small\",\n            \"medium\",\n            \"large\"\n        ],\n        optionTitles: [\n            \"Small\",\n            \"Medium\",\n            \"Large\"\n        ],\n        defaultValue: \"medium\"\n    },\n    disabled: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Boolean,\n        title: \"Disabled\",\n        defaultValue: false,\n        enabledTitle: \"Yes\",\n        disabledTitle: \"No\"\n    },\n    externalDisabled: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Boolean,\n        title: \"External Disabled\",\n        defaultValue: false,\n        enabledTitle: \"Yes\",\n        disabledTitle: \"No\"\n    },\n    linkedForm: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.ComponentInstance,\n        title: \"Linked Form\",\n        description: \"Link to a FormBuilder component anywhere in your project\"\n    },\n    componentId: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.String,\n        title: \"Component ID\",\n        defaultValue: \"button-123\",\n        description: \"Unique identifier for this button (auto-generated if empty)\"\n    },\n    linkedFormId: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.String,\n        title: \"Linked Form ID\",\n        defaultValue: \"\",\n        description: \"Enter the Form's Component ID to link them (works anywhere in Framer)\"\n    },\n    loading: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Boolean,\n        title: \"Loading\",\n        defaultValue: false,\n        enabledTitle: \"Yes\",\n        disabledTitle: \"No\"\n    },\n    fullWidth: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Boolean,\n        title: \"Full Width\",\n        defaultValue: false,\n        enabledTitle: \"Yes\",\n        disabledTitle: \"No\"\n    },\n    // === ICON SETTINGS ===\n    showIcon: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Boolean,\n        title: \"Show Icon\",\n        defaultValue: false,\n        enabledTitle: \"Show\",\n        disabledTitle: \"Hide\"\n    },\n    icon: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.ComponentInstance,\n        title: \"Icon\",\n        hidden: (param)=>{\n            let { showIcon } = param;\n            return !showIcon;\n        }\n    },\n    iconPosition: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Enum,\n        title: \"Icon Position\",\n        options: [\n            \"left\",\n            \"right\"\n        ],\n        optionTitles: [\n            \"Left\",\n            \"Right\"\n        ],\n        defaultValue: \"left\",\n        hidden: (param)=>{\n            let { showIcon } = param;\n            return !showIcon;\n        }\n    },\n    iconSize: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Number,\n        title: \"Icon Size\",\n        defaultValue: 16,\n        min: 12,\n        max: 24,\n        step: 1,\n        unit: \"px\",\n        hidden: (param)=>{\n            let { showIcon } = param;\n            return !showIcon;\n        }\n    },\n    iconColor: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Icon Color\",\n        defaultValue: \"#FFFFFF\",\n        hidden: (param)=>{\n            let { showIcon } = param;\n            return !showIcon;\n        }\n    },\n    // === CUSTOM STYLING (only shown for custom variant) ===\n    backgroundColor: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Background\",\n        defaultValue: \"#000000\",\n        hidden: (param)=>{\n            let { variant } = param;\n            return variant !== \"custom\";\n        }\n    },\n    textColor: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Text Color\",\n        defaultValue: \"#FFFFFF\",\n        hidden: (param)=>{\n            let { variant } = param;\n            return variant !== \"custom\";\n        }\n    },\n    borderColor: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Border Color\",\n        defaultValue: \"#000000\",\n        hidden: (param)=>{\n            let { variant } = param;\n            return variant !== \"custom\";\n        }\n    },\n    hoverBackgroundColor: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Hover Background\",\n        defaultValue: \"#333333\",\n        hidden: (param)=>{\n            let { variant } = param;\n            return variant !== \"custom\";\n        }\n    },\n    hoverTextColor: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Hover Text\",\n        defaultValue: \"#FFFFFF\",\n        hidden: (param)=>{\n            let { variant } = param;\n            return variant !== \"custom\";\n        }\n    },\n    hoverBorderColor: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Hover Border\",\n        defaultValue: \"#333333\",\n        hidden: (param)=>{\n            let { variant } = param;\n            return variant !== \"custom\";\n        }\n    },\n    // === LAYOUT & STYLING ===\n    borderRadius: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.BorderRadius,\n        title: \"Border Radius\",\n        defaultValue: \"8px\"\n    },\n    padding: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Padding,\n        title: \"Padding\",\n        defaultValue: \"12px 24px\"\n    },\n    // === TYPOGRAPHY ===\n    font: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Font,\n        title: \"Font\",\n        defaultValue: {\n            fontSize: \"14px\",\n            variant: \"Medium\",\n            letterSpacing: \"0\",\n            lineHeight: \"1.2em\"\n        },\n        controls: \"extended\",\n        defaultFontType: \"sans-serif\"\n    },\n    // === EVENTS ===\n    onClick: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.EventHandler,\n        title: \"On Click\"\n    }\n});\nvar _c;\n$RefreshReg$(_c, \"Button\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0J1dHRvbi50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQWdGO0FBQ3ZCO0FBQ1g7QUFFc0M7QUErQnBGOzs7Q0FHQyxHQUNjLFNBQVNVLE9BQU9DLEtBQWtCOztJQUM3QyxNQUFNLEVBQ0ZDLE9BQU8sUUFBUSxFQUNmQyxVQUFVLFNBQVMsRUFDbkJDLE9BQU8sUUFBUSxFQUNmQyxXQUFXLEtBQUssRUFDaEJDLFVBQVUsS0FBSyxFQUNmQyxZQUFZLEtBQUssRUFDakJDLG1CQUFtQixLQUFLLEVBQ3hCQyxVQUFVLEVBQ1ZDLGVBQWUsRUFBRSxFQUNqQkMsV0FBVyxLQUFLLEVBQ2hCQyxJQUFJLEVBQ0pDLGVBQWUsTUFBTSxFQUNyQkMsV0FBVyxFQUFFLEVBQ2JDLFlBQVksU0FBUyxFQUNyQkMsa0JBQWtCLFNBQVMsRUFDM0JDLFlBQVksU0FBUyxFQUNyQkMsY0FBYyxTQUFTLEVBQ3ZCQyx1QkFBdUIsU0FBUyxFQUNoQ0MsaUJBQWlCLFNBQVMsRUFDMUJDLG1CQUFtQixTQUFTLEVBQzVCQyxlQUFlLEtBQUssRUFDcEJDLFVBQVUsV0FBVyxFQUNyQkMsSUFBSSxFQUNKQyxPQUFPLEVBQ1YsR0FBR3hCO0lBRUosTUFBTSxDQUFDeUIsV0FBV0MsYUFBYSxHQUFHcEMsK0NBQVFBLENBQUM7SUFFM0MsNEJBQTRCO0lBQzVCLE1BQU1xQyxpQkFBaUIvQiw2REFBY0EsQ0FBQ1EsWUFBWUc7SUFDbEQsTUFBTXFCLGlCQUFpQmhDLDZEQUFjQSxDQUFDO1FBQUVpQyxZQUFZO1FBQU9DLE9BQU87SUFBRztJQUVyRSxNQUFNQyxhQUFhM0IsWUFBWUc7SUFFL0IsMkJBQTJCO0lBQzNCLDRDQUE0QztJQUM1Qyx1QkFBdUI7SUFDdkIsc0JBQXNCO0lBQ3RCLGNBQWM7SUFDZCxnQ0FBZ0M7SUFDaEMsZ0JBQWdCO0lBQ2hCLG1CQUFtQjtJQUNuQiw4REFBOEQ7SUFDOUQsU0FBUztJQUNULGdDQUFnQztJQUNoQyw2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O0lBQ3pDO0lBQ0FpQixnQkFBZ0I7UUFDWjZFLE1BQU1yRywrQ0FBV0EsQ0FBQ3dILEtBQUs7UUFDdkJqQixPQUFPO1FBQ1BDLGNBQWM7UUFDZFUsUUFBUTtnQkFBQyxFQUFFM0csT0FBTyxFQUFFO21CQUFLQSxZQUFZOztJQUN6QztJQUNBa0Isa0JBQWtCO1FBQ2Q0RSxNQUFNckcsK0NBQVdBLENBQUN3SCxLQUFLO1FBQ3ZCakIsT0FBTztRQUNQQyxjQUFjO1FBQ2RVLFFBQVE7Z0JBQUMsRUFBRTNHLE9BQU8sRUFBRTttQkFBS0EsWUFBWTs7SUFDekM7SUFFQSwyQkFBMkI7SUFDM0JtQixjQUFjO1FBQ1YyRSxNQUFNckcsK0NBQVdBLENBQUN5SCxZQUFZO1FBQzlCbEIsT0FBTztRQUNQQyxjQUFjO0lBQ2xCO0lBQ0E3RSxTQUFTO1FBQ0wwRSxNQUFNckcsK0NBQVdBLENBQUMwSCxPQUFPO1FBQ3pCbkIsT0FBTztRQUNQQyxjQUFjO0lBQ2xCO0lBRUEscUJBQXFCO0lBQ3JCNUUsTUFBTTtRQUNGeUUsTUFBTXJHLCtDQUFXQSxDQUFDMkgsSUFBSTtRQUN0QnBCLE9BQU87UUFDUEMsY0FBYztZQUNWbEIsVUFBVTtZQUNWL0UsU0FBUztZQUNUaUYsZUFBZTtZQUNmQyxZQUFZO1FBQ2hCO1FBQ0FtQyxVQUFVO1FBQ1ZDLGlCQUFpQjtJQUNyQjtJQUVBLGlCQUFpQjtJQUNqQmhHLFNBQVM7UUFDTHdFLE1BQU1yRywrQ0FBV0EsQ0FBQzhILFlBQVk7UUFDOUJ2QixPQUFPO0lBQ1g7QUFDSiIsInNvdXJjZXMiOlsiL1VzZXJzL3ppYm9uL0RvY3VtZW50cy9WaWJlL0N1cnNvci9GcmFtZXIgV29ya3Nob3AvZnJhbWVyLXdvcmtzaG9wL3NyYy9jb21wb25lbnRzL0J1dHRvbi50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgc3RhcnRUcmFuc2l0aW9uLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHsgYWRkUHJvcGVydHlDb250cm9scywgQ29udHJvbFR5cGUgfSBmcm9tIFwiZnJhbWVyXCJcbmltcG9ydCB7IHVzZU1vdGlvblZhbHVlIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIlxuaW1wb3J0IHsgdHlwZSBDU1NQcm9wZXJ0aWVzIH0gZnJvbSBcInJlYWN0XCJcbmltcG9ydCB7IHN1YnNjcmliZVRvQ29tcG9uZW50LCB1bnN1YnNjcmliZUZyb21Db21wb25lbnQgfSBmcm9tIFwiLi9TaW1wbGVHbG9iYWxTdGF0ZVwiXG5cbmludGVyZmFjZSBCdXR0b25Qcm9wcyB7XG4gICAgdGV4dDogc3RyaW5nXG4gICAgdmFyaWFudDogXCJwcmltYXJ5XCIgfCBcInNlY29uZGFyeVwiIHwgXCJvdXRsaW5lXCIgfCBcImdob3N0XCIgfCBcImRhbmdlclwiIHwgXCJjdXN0b21cIlxuICAgIHNpemU6IFwic21hbGxcIiB8IFwibWVkaXVtXCIgfCBcImxhcmdlXCJcbiAgICBkaXNhYmxlZDogYm9vbGVhblxuICAgIGxvYWRpbmc6IGJvb2xlYW5cbiAgICBmdWxsV2lkdGg6IGJvb2xlYW5cbiAgICBleHRlcm5hbERpc2FibGVkPzogYm9vbGVhblxuICAgIGxpbmtlZEZvcm0/OiBhbnlcbiAgICBjb21wb25lbnRJZD86IHN0cmluZ1xuICAgIGxpbmtlZEZvcm1JZD86IHN0cmluZ1xuICAgIHNob3dJY29uOiBib29sZWFuXG4gICAgaWNvbjogYW55XG4gICAgaWNvblBvc2l0aW9uOiBcImxlZnRcIiB8IFwicmlnaHRcIlxuICAgIGljb25TaXplOiBudW1iZXJcbiAgICBpY29uQ29sb3I6IHN0cmluZ1xuICAgIGJhY2tncm91bmRDb2xvcjogc3RyaW5nXG4gICAgdGV4dENvbG9yOiBzdHJpbmdcbiAgICBib3JkZXJDb2xvcjogc3RyaW5nXG4gICAgaG92ZXJCYWNrZ3JvdW5kQ29sb3I6IHN0cmluZ1xuICAgIGhvdmVyVGV4dENvbG9yOiBzdHJpbmdcbiAgICBob3ZlckJvcmRlckNvbG9yOiBzdHJpbmdcbiAgICBib3JkZXJSYWRpdXM6IHN0cmluZ1xuICAgIHBhZGRpbmc6IHN0cmluZ1xuICAgIGZvbnQ6IGFueVxuICAgIHN0eWxlPzogQ1NTUHJvcGVydGllc1xuICAgIG9uQ2xpY2s/OiAoKSA9PiB2b2lkXG59XG5cbi8qKlxuICogQGZyYW1lclN1cHBvcnRlZExheW91dFdpZHRoIGFueS1wcmVmZXItZml4ZWRcbiAqIEBmcmFtZXJTdXBwb3J0ZWRMYXlvdXRIZWlnaHQgYXV0b1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCdXR0b24ocHJvcHM6IEJ1dHRvblByb3BzKSB7XG4gICAgY29uc3Qge1xuICAgICAgICB0ZXh0ID0gXCJCdXR0b25cIixcbiAgICAgICAgdmFyaWFudCA9IFwicHJpbWFyeVwiLFxuICAgICAgICBzaXplID0gXCJtZWRpdW1cIixcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgbG9hZGluZyA9IGZhbHNlLFxuICAgICAgICBmdWxsV2lkdGggPSBmYWxzZSxcbiAgICAgICAgZXh0ZXJuYWxEaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICBsaW5rZWRGb3JtLFxuICAgICAgICBsaW5rZWRGb3JtSWQgPSBcIlwiLFxuICAgICAgICBzaG93SWNvbiA9IGZhbHNlLFxuICAgICAgICBpY29uLFxuICAgICAgICBpY29uUG9zaXRpb24gPSBcImxlZnRcIixcbiAgICAgICAgaWNvblNpemUgPSAxNixcbiAgICAgICAgaWNvbkNvbG9yID0gXCIjRkZGRkZGXCIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvciA9IFwiIzAwMDAwMFwiLFxuICAgICAgICB0ZXh0Q29sb3IgPSBcIiNGRkZGRkZcIixcbiAgICAgICAgYm9yZGVyQ29sb3IgPSBcIiMwMDAwMDBcIixcbiAgICAgICAgaG92ZXJCYWNrZ3JvdW5kQ29sb3IgPSBcIiMzMzMzMzNcIixcbiAgICAgICAgaG92ZXJUZXh0Q29sb3IgPSBcIiNGRkZGRkZcIixcbiAgICAgICAgaG92ZXJCb3JkZXJDb2xvciA9IFwiIzMzMzMzM1wiLFxuICAgICAgICBib3JkZXJSYWRpdXMgPSBcIjhweFwiLFxuICAgICAgICBwYWRkaW5nID0gXCIxMnB4IDI0cHhcIixcbiAgICAgICAgZm9udCxcbiAgICAgICAgb25DbGljayxcbiAgICB9ID0gcHJvcHNcblxuICAgIGNvbnN0IFtpc0hvdmVyZWQsIHNldElzSG92ZXJlZF0gPSB1c2VTdGF0ZShmYWxzZSlcblxuICAgIC8vIE1vdGlvbiB2YWx1ZXMgZm9yIGxpbmtpbmdcbiAgICBjb25zdCBkaXNhYmxlZE1vdGlvbiA9IHVzZU1vdGlvblZhbHVlKGRpc2FibGVkIHx8IGV4dGVybmFsRGlzYWJsZWQpXG4gICAgY29uc3QgZm9ybURhdGFNb3Rpb24gPSB1c2VNb3Rpb25WYWx1ZSh7IGhhc0NvbnRlbnQ6IGZhbHNlLCB2YWx1ZTogXCJcIiB9KVxuXG4gICAgY29uc3QgaXNEaXNhYmxlZCA9IGRpc2FibGVkIHx8IGV4dGVybmFsRGlzYWJsZWRcblxuICAgIC8vIENvbXBvbmVudCBsaW5raW5nIHN5c3RlbVxuICAgIC8vIGNvbnN0IHsgY3JlYXRlTGluayB9ID0gdXNlQ29tcG9uZW50TGluayh7XG4gICAgLy8gICAgIGlkOiBjb21wb25lbnRJZCxcbiAgICAvLyAgICAgdHlwZTogJ2J1dHRvbicsXG4gICAgLy8gICAgIGRhdGE6IHtcbiAgICAvLyAgICAgICAgIGRpc2FibGVkOiBpc0Rpc2FibGVkLFxuICAgIC8vICAgICAgICAgdGV4dCxcbiAgICAvLyAgICAgICAgIHZhcmlhbnQsXG4gICAgLy8gICAgICAgICBoYXNDb250ZW50OiBmYWxzZSAvLyBXaWxsIGJlIHVwZGF0ZWQgYnkgbGlua2VkIGZvcm1cbiAgICAvLyAgICAgfSxcbiAgICAvLyAgICAgb25EYXRhVXBkYXRlOiAoZGF0YSkgPT4ge1xuICAgIC8vICAgICAgICAgLy8gSGFuZGxlIHVwZGF0ZXMgZnJvbSBsaW5rZWQgZm9ybVxuICAgIC8vICAgICAgICAgaWYgKGRhdGEuaGFzQ29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gICAgICAgICAgICAgLy8gVXBkYXRlIGJ1dHRvbiBzdGF0ZSBiYXNlZCBvbiBmb3JtIGNvbnRlbnRcbiAgICAvLyAgICAgICAgICAgICBjb25zb2xlLmxvZygnQnV0dG9uIHJlY2VpdmVkIGZvcm0gdXBkYXRlOicsIGRhdGEpXG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgIH1cbiAgICAvLyB9KVxuXG4gICAgLy8gQXV0by1saW5rIHdpdGggZm9ybSBpZiBJRCBpcyBwcm92aWRlZFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChsaW5rZWRGb3JtSWQgJiYgbGlua2VkRm9ybUlkLnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgICAgIC8vIFN1YnNjcmliZSB0byBmb3JtIHVwZGF0ZXNcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUZvcm1VcGRhdGUgPSAoZm9ybURhdGE6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBidXR0b24gc3RhdGUgYmFzZWQgb24gZm9ybSBkYXRhXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0J1dHRvbiByZWNlaXZlZCBmb3JtIHVwZGF0ZTonLCBmb3JtRGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3Vic2NyaWJlVG9Db21wb25lbnQobGlua2VkRm9ybUlkLCBoYW5kbGVGb3JtVXBkYXRlKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlRnJvbUNvbXBvbmVudChsaW5rZWRGb3JtSWQsIGhhbmRsZUZvcm1VcGRhdGUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbbGlua2VkRm9ybUlkXSlcblxuICAgIC8vIFN5bmMgd2l0aCBsaW5rZWQgZm9ybSBpZiBwcm92aWRlZCAobGVnYWN5IG1ldGhvZClcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobGlua2VkRm9ybSAmJiBsaW5rZWRGb3JtLmdldCkge1xuICAgICAgICAgICAgY29uc3QgZm9ybURhdGEgPSBsaW5rZWRGb3JtLmdldCgpXG4gICAgICAgICAgICBpZiAoZm9ybURhdGEpIHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlZE1vdGlvbi5zZXQoZm9ybURhdGEuZGlzYWJsZWQgfHwgZmFsc2UpXG4gICAgICAgICAgICAgICAgZm9ybURhdGFNb3Rpb24uc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgaGFzQ29udGVudDogZm9ybURhdGEuaGFzQ29udGVudCB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZvcm1EYXRhLnZhbHVlIHx8IFwiXCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2xpbmtlZEZvcm0sIGRpc2FibGVkTW90aW9uLCBmb3JtRGF0YU1vdGlvbl0pXG5cbiAgICBjb25zdCBoYW5kbGVDbGljayA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKCFpc0Rpc2FibGVkICYmICFsb2FkaW5nICYmIG9uQ2xpY2spIHtcbiAgICAgICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiBvbkNsaWNrKCkpXG4gICAgICAgIH1cbiAgICB9LCBbaXNEaXNhYmxlZCwgbG9hZGluZywgb25DbGlja10pXG5cbiAgICBjb25zdCBoYW5kbGVNb3VzZUVudGVyID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0SXNIb3ZlcmVkKHRydWUpKVxuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgaGFuZGxlTW91c2VMZWF2ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldElzSG92ZXJlZChmYWxzZSkpXG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBnZXRWYXJpYW50U3R5bGVzID0gKCkgPT4ge1xuICAgICAgICAvLyBEZWZpbmUgdmFyaWFudC1zcGVjaWZpYyBjb2xvcnNcbiAgICAgICAgY29uc3QgZ2V0VmFyaWFudENvbG9ycyA9ICgpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodmFyaWFudCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJwcmltYXJ5XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZzogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIiNGRkZGRkZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3ZlckJnOiBcIiMzMzMzMzNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdmVyVGV4dDogXCIjRkZGRkZGXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3ZlckJvcmRlcjogXCIjMzMzMzMzXCIsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwic2Vjb25kYXJ5XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZzogXCIjRjVGNUY1XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIiMwMDAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogXCIjRjVGNUY1XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3ZlckJnOiBcIiNFNUU1RTVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdmVyVGV4dDogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3ZlckJvcmRlcjogXCIjRTVFNUU1XCIsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwib3V0bGluZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmc6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiBcIiMwMDAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdmVyQmc6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG92ZXJUZXh0OiBcIiNGRkZGRkZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdmVyQm9yZGVyOiBcIiMwMDAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJnaG9zdFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmc6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3ZlckJnOiBcIiNGNUY1RjVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdmVyVGV4dDogXCIjMDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3ZlckJvcmRlcjogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImRhbmdlclwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmc6IFwiI0ZGNDQ0NFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogXCIjRkZGRkZGXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IFwiI0ZGNDQ0NFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG92ZXJCZzogXCIjQ0MzMzMzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3ZlclRleHQ6IFwiI0ZGRkZGRlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG92ZXJCb3JkZXI6IFwiI0NDMzMzM1wiLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJnOiBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IGJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG92ZXJCZzogaG92ZXJCYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3ZlclRleHQ6IGhvdmVyVGV4dENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG92ZXJCb3JkZXI6IGhvdmVyQm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbG9ycyA9IGdldFZhcmlhbnRDb2xvcnMoKVxuICAgICAgICBcbiAgICAgICAgY29uc3QgYmFzZVN0eWxlcyA9IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogaXNEaXNhYmxlZCA/IFwiI0NDQ0NDQ1wiIDogY29sb3JzLmJnLFxuICAgICAgICAgICAgY29sb3I6IGlzRGlzYWJsZWQgPyBcIiM2NjY2NjZcIiA6IGNvbG9ycy50ZXh0LFxuICAgICAgICAgICAgYm9yZGVyOiBgMXB4IHNvbGlkICR7aXNEaXNhYmxlZCA/IFwiI0NDQ0NDQ1wiIDogY29sb3JzLmJvcmRlcn1gLFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSG92ZXJlZCAmJiAhaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5iYXNlU3R5bGVzLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3JzLmhvdmVyQmcsXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9ycy5ob3ZlclRleHQsXG4gICAgICAgICAgICAgICAgYm9yZGVyOiBgMXB4IHNvbGlkICR7Y29sb3JzLmhvdmVyQm9yZGVyfWAsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYmFzZVN0eWxlc1xuICAgIH1cblxuICAgIGNvbnN0IGdldFNpemVNdWx0aXBsaWVyID0gKCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHNpemUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzbWFsbFwiOiByZXR1cm4gMC43NVxuICAgICAgICAgICAgY2FzZSBcImxhcmdlXCI6IHJldHVybiAxLjI1XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gMVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VQYWRkaW5nID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBwYWRkaW5nVmFsdWVzID0gcGFkZGluZy5zcGxpdCgnICcpLm1hcChwID0+IHBhcnNlSW50KHAucmVwbGFjZSgncHgnLCAnJykpKVxuICAgICAgICBjb25zdCBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XSA9IHBhZGRpbmdWYWx1ZXMubGVuZ3RoID09PSAxIFxuICAgICAgICAgICAgPyBbcGFkZGluZ1ZhbHVlc1swXSwgcGFkZGluZ1ZhbHVlc1swXSwgcGFkZGluZ1ZhbHVlc1swXSwgcGFkZGluZ1ZhbHVlc1swXV1cbiAgICAgICAgICAgIDogcGFkZGluZ1ZhbHVlcy5sZW5ndGggPT09IDJcbiAgICAgICAgICAgID8gW3BhZGRpbmdWYWx1ZXNbMF0sIHBhZGRpbmdWYWx1ZXNbMV0sIHBhZGRpbmdWYWx1ZXNbMF0sIHBhZGRpbmdWYWx1ZXNbMV1dXG4gICAgICAgICAgICA6IHBhZGRpbmdWYWx1ZXMubGVuZ3RoID09PSA0XG4gICAgICAgICAgICA/IHBhZGRpbmdWYWx1ZXNcbiAgICAgICAgICAgIDogWzEyLCAyNCwgMTIsIDI0XSAvLyBmYWxsYmFja1xuXG4gICAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSBnZXRTaXplTXVsdGlwbGllcigpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYWRkaW5nVG9wOiBgJHt0b3AgKiBtdWx0aXBsaWVyfXB4YCxcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodDogYCR7cmlnaHQgKiBtdWx0aXBsaWVyfXB4YCxcbiAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IGAke2JvdHRvbSAqIG11bHRpcGxpZXJ9cHhgLFxuICAgICAgICAgICAgcGFkZGluZ0xlZnQ6IGAke2xlZnQgKiBtdWx0aXBsaWVyfXB4YCxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHZhcmlhbnRTdHlsZXMgPSBnZXRWYXJpYW50U3R5bGVzKClcbiAgICBjb25zdCBwYWRkaW5nU3R5bGVzID0gcGFyc2VQYWRkaW5nKClcblxuICAgIGNvbnN0IGJ1dHRvblN0eWxlczogQ1NTUHJvcGVydGllcyA9IHtcbiAgICAgICAgLi4ucGFkZGluZ1N0eWxlcyxcbiAgICAgICAgLi4udmFyaWFudFN0eWxlcyxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIHdpZHRoOiBmdWxsV2lkdGggPyBcIjEwMCVcIiA6IFwiYXV0b1wiLFxuICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgICAgIGdhcDogXCI4cHhcIixcbiAgICAgICAgY3Vyc29yOiBpc0Rpc2FibGVkIHx8IGxvYWRpbmcgPyBcIm5vdC1hbGxvd2VkXCIgOiBcInBvaW50ZXJcIixcbiAgICAgICAgdHJhbnNpdGlvbjogXCJhbGwgMC4ycyBlYXNlXCIsXG4gICAgICAgIG91dGxpbmU6IFwibm9uZVwiLFxuICAgICAgICAuLi5mb250LFxuICAgICAgICBmb250U2l6ZTogZm9udD8uZm9udFNpemUgfHwgKHNpemUgPT09IFwic21hbGxcIiA/IFwiMTJweFwiIDogc2l6ZSA9PT0gXCJsYXJnZVwiID8gXCIxNnB4XCIgOiBcIjE0cHhcIiksXG4gICAgICAgIGZvbnRXZWlnaHQ6IGZvbnQ/LmZvbnRXZWlnaHQgfHwgXCI1MDBcIixcbiAgICAgICAgbGV0dGVyU3BhY2luZzogZm9udD8ubGV0dGVyU3BhY2luZyB8fCBcIjBcIixcbiAgICAgICAgbGluZUhlaWdodDogZm9udD8ubGluZUhlaWdodCB8fCBcIjEuMmVtXCIsXG4gICAgfVxuXG4gICAgY29uc3QgcmVuZGVySWNvbiA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFzaG93SWNvbiB8fCAhaWNvbikgcmV0dXJuIG51bGxcblxuICAgICAgICBjb25zdCBpY29uU3R5bGU6IENTU1Byb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICB3aWR0aDogYCR7aWNvblNpemV9cHhgLFxuICAgICAgICAgICAgaGVpZ2h0OiBgJHtpY29uU2l6ZX1weGAsXG4gICAgICAgICAgICBjb2xvcjogaXNEaXNhYmxlZCA/IFwiIzY2NjY2NlwiIDogaWNvbkNvbG9yLFxuICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gPGRpdiBzdHlsZT17aWNvblN0eWxlfT57aWNvbn08L2Rpdj5cbiAgICB9XG5cbiAgICBjb25zdCByZW5kZXJMb2FkaW5nU3Bpbm5lciA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFsb2FkaW5nKSByZXR1cm4gbnVsbFxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGAke2ljb25TaXplfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBgJHtpY29uU2l6ZX1weGAsXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlcjogYDJweCBzb2xpZCB0cmFuc3BhcmVudGAsXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlclRvcDogYDJweCBzb2xpZCAke2lzRGlzYWJsZWQgPyBcIiM2NjY2NjZcIiA6IHRleHRDb2xvcn1gLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IFwiNTAlXCIsXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogXCJzcGluIDFzIGxpbmVhciBpbmZpbml0ZVwiLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxzdHlsZT5cbiAgICAgICAgICAgICAgICB7YFxuICAgICAgICAgICAgICAgICAgICBAa2V5ZnJhbWVzIHNwaW4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgMCUgeyB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgMTAwJSB7IHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGB9XG4gICAgICAgICAgICA8L3N0eWxlPlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIC4uLmJ1dHRvblN0eWxlcyxcbiAgICAgICAgICAgICAgICAgICAgLi4ucHJvcHMuc3R5bGUsXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVDbGlja31cbiAgICAgICAgICAgICAgICBvbk1vdXNlRW50ZXI9e2hhbmRsZU1vdXNlRW50ZXJ9XG4gICAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXtoYW5kbGVNb3VzZUxlYXZlfVxuICAgICAgICAgICAgICAgIGRpc2FibGVkPXtpc0Rpc2FibGVkIHx8IGxvYWRpbmd9XG4gICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge3Nob3dJY29uICYmIGljb25Qb3NpdGlvbiA9PT0gXCJsZWZ0XCIgJiYgcmVuZGVySWNvbigpfVxuICAgICAgICAgICAgICAgIHtsb2FkaW5nID8gcmVuZGVyTG9hZGluZ1NwaW5uZXIoKSA6IHRleHR9XG4gICAgICAgICAgICAgICAge3Nob3dJY29uICYmIGljb25Qb3NpdGlvbiA9PT0gXCJyaWdodFwiICYmIHJlbmRlckljb24oKX1cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8Lz5cbiAgICApXG59XG5cbmFkZFByb3BlcnR5Q29udHJvbHMoQnV0dG9uLCB7XG4gICAgLy8gPT09IEJBU0lDIFNFVFRJTkdTID09PVxuICAgIHRleHQ6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuU3RyaW5nLFxuICAgICAgICB0aXRsZTogXCJUZXh0XCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCJCdXR0b25cIixcbiAgICB9LFxuICAgIHZhcmlhbnQ6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuRW51bSxcbiAgICAgICAgdGl0bGU6IFwiVmFyaWFudFwiLFxuICAgICAgICBvcHRpb25zOiBbXCJwcmltYXJ5XCIsIFwic2Vjb25kYXJ5XCIsIFwib3V0bGluZVwiLCBcImdob3N0XCIsIFwiZGFuZ2VyXCIsIFwiY3VzdG9tXCJdLFxuICAgICAgICBvcHRpb25UaXRsZXM6IFtcIlByaW1hcnlcIiwgXCJTZWNvbmRhcnlcIiwgXCJPdXRsaW5lXCIsIFwiR2hvc3RcIiwgXCJEYW5nZXJcIiwgXCJDdXN0b21cIl0sXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCJwcmltYXJ5XCIsXG4gICAgfSxcbiAgICBzaXplOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkVudW0sXG4gICAgICAgIHRpdGxlOiBcIlNpemVcIixcbiAgICAgICAgb3B0aW9uczogW1wic21hbGxcIiwgXCJtZWRpdW1cIiwgXCJsYXJnZVwiXSxcbiAgICAgICAgb3B0aW9uVGl0bGVzOiBbXCJTbWFsbFwiLCBcIk1lZGl1bVwiLCBcIkxhcmdlXCJdLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IFwibWVkaXVtXCIsXG4gICAgfSxcbiAgICBkaXNhYmxlZDoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5Cb29sZWFuLFxuICAgICAgICB0aXRsZTogXCJEaXNhYmxlZFwiLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICAgICAgICBlbmFibGVkVGl0bGU6IFwiWWVzXCIsXG4gICAgICAgIGRpc2FibGVkVGl0bGU6IFwiTm9cIixcbiAgICB9LFxuICAgIGV4dGVybmFsRGlzYWJsZWQ6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuQm9vbGVhbixcbiAgICAgICAgdGl0bGU6IFwiRXh0ZXJuYWwgRGlzYWJsZWRcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgICAgICAgZW5hYmxlZFRpdGxlOiBcIlllc1wiLFxuICAgICAgICBkaXNhYmxlZFRpdGxlOiBcIk5vXCIsXG4gICAgfSxcbiAgICBsaW5rZWRGb3JtOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkNvbXBvbmVudEluc3RhbmNlLFxuICAgICAgICB0aXRsZTogXCJMaW5rZWQgRm9ybVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJMaW5rIHRvIGEgRm9ybUJ1aWxkZXIgY29tcG9uZW50IGFueXdoZXJlIGluIHlvdXIgcHJvamVjdFwiLFxuICAgIH0sXG4gICAgY29tcG9uZW50SWQ6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuU3RyaW5nLFxuICAgICAgICB0aXRsZTogXCJDb21wb25lbnQgSURcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcImJ1dHRvbi0xMjNcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgYnV0dG9uIChhdXRvLWdlbmVyYXRlZCBpZiBlbXB0eSlcIixcbiAgICB9LFxuICAgIGxpbmtlZEZvcm1JZDoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5TdHJpbmcsXG4gICAgICAgIHRpdGxlOiBcIkxpbmtlZCBGb3JtIElEXCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCJcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRW50ZXIgdGhlIEZvcm0ncyBDb21wb25lbnQgSUQgdG8gbGluayB0aGVtICh3b3JrcyBhbnl3aGVyZSBpbiBGcmFtZXIpXCIsXG4gICAgfSxcbiAgICBsb2FkaW5nOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkJvb2xlYW4sXG4gICAgICAgIHRpdGxlOiBcIkxvYWRpbmdcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgICAgICAgZW5hYmxlZFRpdGxlOiBcIlllc1wiLFxuICAgICAgICBkaXNhYmxlZFRpdGxlOiBcIk5vXCIsXG4gICAgfSxcbiAgICBmdWxsV2lkdGg6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuQm9vbGVhbixcbiAgICAgICAgdGl0bGU6IFwiRnVsbCBXaWR0aFwiLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICAgICAgICBlbmFibGVkVGl0bGU6IFwiWWVzXCIsXG4gICAgICAgIGRpc2FibGVkVGl0bGU6IFwiTm9cIixcbiAgICB9LFxuXG4gICAgLy8gPT09IElDT04gU0VUVElOR1MgPT09XG4gICAgc2hvd0ljb246IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuQm9vbGVhbixcbiAgICAgICAgdGl0bGU6IFwiU2hvdyBJY29uXCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gICAgICAgIGVuYWJsZWRUaXRsZTogXCJTaG93XCIsXG4gICAgICAgIGRpc2FibGVkVGl0bGU6IFwiSGlkZVwiLFxuICAgIH0sXG4gICAgaWNvbjoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5Db21wb25lbnRJbnN0YW5jZSxcbiAgICAgICAgdGl0bGU6IFwiSWNvblwiLFxuICAgICAgICBoaWRkZW46ICh7IHNob3dJY29uIH0pID0+ICFzaG93SWNvbixcbiAgICB9LFxuICAgIGljb25Qb3NpdGlvbjoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5FbnVtLFxuICAgICAgICB0aXRsZTogXCJJY29uIFBvc2l0aW9uXCIsXG4gICAgICAgIG9wdGlvbnM6IFtcImxlZnRcIiwgXCJyaWdodFwiXSxcbiAgICAgICAgb3B0aW9uVGl0bGVzOiBbXCJMZWZ0XCIsIFwiUmlnaHRcIl0sXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCJsZWZ0XCIsXG4gICAgICAgIGhpZGRlbjogKHsgc2hvd0ljb24gfSkgPT4gIXNob3dJY29uLFxuICAgIH0sXG4gICAgaWNvblNpemU6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuTnVtYmVyLFxuICAgICAgICB0aXRsZTogXCJJY29uIFNpemVcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiAxNixcbiAgICAgICAgbWluOiAxMixcbiAgICAgICAgbWF4OiAyNCxcbiAgICAgICAgc3RlcDogMSxcbiAgICAgICAgdW5pdDogXCJweFwiLFxuICAgICAgICBoaWRkZW46ICh7IHNob3dJY29uIH0pID0+ICFzaG93SWNvbixcbiAgICB9LFxuICAgIGljb25Db2xvcjoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5Db2xvcixcbiAgICAgICAgdGl0bGU6IFwiSWNvbiBDb2xvclwiLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IFwiI0ZGRkZGRlwiLFxuICAgICAgICBoaWRkZW46ICh7IHNob3dJY29uIH0pID0+ICFzaG93SWNvbixcbiAgICB9LFxuXG4gICAgLy8gPT09IENVU1RPTSBTVFlMSU5HIChvbmx5IHNob3duIGZvciBjdXN0b20gdmFyaWFudCkgPT09XG4gICAgYmFja2dyb3VuZENvbG9yOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkNvbG9yLFxuICAgICAgICB0aXRsZTogXCJCYWNrZ3JvdW5kXCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCIjMDAwMDAwXCIsXG4gICAgICAgIGhpZGRlbjogKHsgdmFyaWFudCB9KSA9PiB2YXJpYW50ICE9PSBcImN1c3RvbVwiLFxuICAgIH0sXG4gICAgdGV4dENvbG9yOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkNvbG9yLFxuICAgICAgICB0aXRsZTogXCJUZXh0IENvbG9yXCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCIjRkZGRkZGXCIsXG4gICAgICAgIGhpZGRlbjogKHsgdmFyaWFudCB9KSA9PiB2YXJpYW50ICE9PSBcImN1c3RvbVwiLFxuICAgIH0sXG4gICAgYm9yZGVyQ29sb3I6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuQ29sb3IsXG4gICAgICAgIHRpdGxlOiBcIkJvcmRlciBDb2xvclwiLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IFwiIzAwMDAwMFwiLFxuICAgICAgICBoaWRkZW46ICh7IHZhcmlhbnQgfSkgPT4gdmFyaWFudCAhPT0gXCJjdXN0b21cIixcbiAgICB9LFxuICAgIGhvdmVyQmFja2dyb3VuZENvbG9yOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkNvbG9yLFxuICAgICAgICB0aXRsZTogXCJIb3ZlciBCYWNrZ3JvdW5kXCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCIjMzMzMzMzXCIsXG4gICAgICAgIGhpZGRlbjogKHsgdmFyaWFudCB9KSA9PiB2YXJpYW50ICE9PSBcImN1c3RvbVwiLFxuICAgIH0sXG4gICAgaG92ZXJUZXh0Q29sb3I6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuQ29sb3IsXG4gICAgICAgIHRpdGxlOiBcIkhvdmVyIFRleHRcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcIiNGRkZGRkZcIixcbiAgICAgICAgaGlkZGVuOiAoeyB2YXJpYW50IH0pID0+IHZhcmlhbnQgIT09IFwiY3VzdG9tXCIsXG4gICAgfSxcbiAgICBob3ZlckJvcmRlckNvbG9yOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkNvbG9yLFxuICAgICAgICB0aXRsZTogXCJIb3ZlciBCb3JkZXJcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcIiMzMzMzMzNcIixcbiAgICAgICAgaGlkZGVuOiAoeyB2YXJpYW50IH0pID0+IHZhcmlhbnQgIT09IFwiY3VzdG9tXCIsXG4gICAgfSxcblxuICAgIC8vID09PSBMQVlPVVQgJiBTVFlMSU5HID09PVxuICAgIGJvcmRlclJhZGl1czoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5Cb3JkZXJSYWRpdXMsXG4gICAgICAgIHRpdGxlOiBcIkJvcmRlciBSYWRpdXNcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcIjhweFwiLFxuICAgIH0sXG4gICAgcGFkZGluZzoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5QYWRkaW5nLFxuICAgICAgICB0aXRsZTogXCJQYWRkaW5nXCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCIxMnB4IDI0cHhcIixcbiAgICB9LFxuXG4gICAgLy8gPT09IFRZUE9HUkFQSFkgPT09XG4gICAgZm9udDoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5Gb250LFxuICAgICAgICB0aXRsZTogXCJGb250XCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZToge1xuICAgICAgICAgICAgZm9udFNpemU6IFwiMTRweFwiLFxuICAgICAgICAgICAgdmFyaWFudDogXCJNZWRpdW1cIixcbiAgICAgICAgICAgIGxldHRlclNwYWNpbmc6IFwiMFwiLFxuICAgICAgICAgICAgbGluZUhlaWdodDogXCIxLjJlbVwiLFxuICAgICAgICB9LFxuICAgICAgICBjb250cm9sczogXCJleHRlbmRlZFwiLFxuICAgICAgICBkZWZhdWx0Rm9udFR5cGU6IFwic2Fucy1zZXJpZlwiLFxuICAgIH0sXG5cbiAgICAvLyA9PT0gRVZFTlRTID09PVxuICAgIG9uQ2xpY2s6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuRXZlbnRIYW5kbGVyLFxuICAgICAgICB0aXRsZTogXCJPbiBDbGlja1wiLFxuICAgIH0sXG59KVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInN0YXJ0VHJhbnNpdGlvbiIsInVzZUVmZmVjdCIsImFkZFByb3BlcnR5Q29udHJvbHMiLCJDb250cm9sVHlwZSIsInVzZU1vdGlvblZhbHVlIiwic3Vic2NyaWJlVG9Db21wb25lbnQiLCJ1bnN1YnNjcmliZUZyb21Db21wb25lbnQiLCJCdXR0b24iLCJwcm9wcyIsInRleHQiLCJ2YXJpYW50Iiwic2l6ZSIsImRpc2FibGVkIiwibG9hZGluZyIsImZ1bGxXaWR0aCIsImV4dGVybmFsRGlzYWJsZWQiLCJsaW5rZWRGb3JtIiwibGlua2VkRm9ybUlkIiwic2hvd0ljb24iLCJpY29uIiwiaWNvblBvc2l0aW9uIiwiaWNvblNpemUiLCJpY29uQ29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJ0ZXh0Q29sb3IiLCJib3JkZXJDb2xvciIsImhvdmVyQmFja2dyb3VuZENvbG9yIiwiaG92ZXJUZXh0Q29sb3IiLCJob3ZlckJvcmRlckNvbG9yIiwiYm9yZGVyUmFkaXVzIiwicGFkZGluZyIsImZvbnQiLCJvbkNsaWNrIiwiaXNIb3ZlcmVkIiwic2V0SXNIb3ZlcmVkIiwiZGlzYWJsZWRNb3Rpb24iLCJmb3JtRGF0YU1vdGlvbiIsImhhc0NvbnRlbnQiLCJ2YWx1ZSIsImlzRGlzYWJsZWQiLCJ0cmltIiwiaGFuZGxlRm9ybVVwZGF0ZSIsImZvcm1EYXRhIiwiY29uc29sZSIsImxvZyIsImdldCIsInNldCIsImhhbmRsZUNsaWNrIiwiaGFuZGxlTW91c2VFbnRlciIsImhhbmRsZU1vdXNlTGVhdmUiLCJnZXRWYXJpYW50U3R5bGVzIiwiZ2V0VmFyaWFudENvbG9ycyIsImJnIiwiYm9yZGVyIiwiaG92ZXJCZyIsImhvdmVyVGV4dCIsImhvdmVyQm9yZGVyIiwiY29sb3JzIiwiYmFzZVN0eWxlcyIsImNvbG9yIiwiZ2V0U2l6ZU11bHRpcGxpZXIiLCJwYXJzZVBhZGRpbmciLCJwYWRkaW5nVmFsdWVzIiwic3BsaXQiLCJtYXAiLCJwIiwicGFyc2VJbnQiLCJyZXBsYWNlIiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwibGVuZ3RoIiwibXVsdGlwbGllciIsInBhZGRpbmdUb3AiLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nQm90dG9tIiwicGFkZGluZ0xlZnQiLCJ2YXJpYW50U3R5bGVzIiwicGFkZGluZ1N0eWxlcyIsImJ1dHRvblN0eWxlcyIsIndpZHRoIiwiZGlzcGxheSIsImFsaWduSXRlbXMiLCJqdXN0aWZ5Q29udGVudCIsImdhcCIsImN1cnNvciIsInRyYW5zaXRpb24iLCJvdXRsaW5lIiwiZm9udFNpemUiLCJmb250V2VpZ2h0IiwibGV0dGVyU3BhY2luZyIsImxpbmVIZWlnaHQiLCJyZW5kZXJJY29uIiwiaWNvblN0eWxlIiwiaGVpZ2h0IiwiZGl2Iiwic3R5bGUiLCJyZW5kZXJMb2FkaW5nU3Bpbm5lciIsImJvcmRlclRvcCIsImFuaW1hdGlvbiIsImJ1dHRvbiIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VMZWF2ZSIsInR5cGUiLCJTdHJpbmciLCJ0aXRsZSIsImRlZmF1bHRWYWx1ZSIsIkVudW0iLCJvcHRpb25zIiwib3B0aW9uVGl0bGVzIiwiQm9vbGVhbiIsImVuYWJsZWRUaXRsZSIsImRpc2FibGVkVGl0bGUiLCJDb21wb25lbnRJbnN0YW5jZSIsImRlc2NyaXB0aW9uIiwiY29tcG9uZW50SWQiLCJoaWRkZW4iLCJOdW1iZXIiLCJtaW4iLCJtYXgiLCJzdGVwIiwidW5pdCIsIkNvbG9yIiwiQm9yZGVyUmFkaXVzIiwiUGFkZGluZyIsIkZvbnQiLCJjb250cm9scyIsImRlZmF1bHRGb250VHlwZSIsIkV2ZW50SGFuZGxlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Button.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/FormBuilderOrg.tsx":
/*!*******************************************!*\
  !*** ./src/components/FormBuilderOrg.tsx ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FormBuilder)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var framer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! framer */ \"(app-pages-browser)/./node_modules/framer/build/esm/framer.debug.js\");\n/* harmony import */ var framer_motion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! framer-motion */ \"(app-pages-browser)/./node_modules/framer-motion/dist/es/value/use-motion-value.mjs\");\n/* harmony import */ var _SimpleGlobalState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SimpleGlobalState */ \"(app-pages-browser)/./src/components/SimpleGlobalState.tsx\");\n// Form component with style customization and multiple input types including chip suggestions\n\nvar _s = $RefreshSig$();\n\n\n\n\n/**\n * @framerSupportedLayoutWidth any-prefer-fixed\n * @framerSupportedLayoutHeight auto\n */ function FormBuilder(props) {\n    _s();\n    const { fieldType = \"text\", label = \"Field Label\", showLabel = true, placeholder = \"Enter text...\", placeholderColor = \"#999999\", required = false, dropdownOptions = [\n        {\n            label: \"Option 1\",\n            value: \"option1\"\n        },\n        {\n            label: \"Option 2\",\n            value: \"option2\"\n        },\n        {\n            label: \"Option 3\",\n            value: \"option3\"\n        }\n    ], radioOptions = [\n        {\n            label: \"Choice A\",\n            value: \"a\"\n        },\n        {\n            label: \"Choice B\",\n            value: \"b\"\n        },\n        {\n            label: \"Choice C\",\n            value: \"c\"\n        }\n    ], chipSuggestions = [\n        \"Suggestion 1\",\n        \"Suggestion 2\",\n        \"Suggestion 3\",\n        \"Suggestion 4\"\n    ], backgroundColor = \"#FFFFFF\", borderColor = \"#EEEEEE\", focusColor = \"#000000\", textColor = \"#000000\", labelColor = \"#000000\", borderRadius = \"8px\", heightMode = \"fixed\", height = 40, padding = \"12px\", labelFont, inputFont, showChips = true, chipBackgroundColor = \"#F5F5F5\", chipTextColor = \"#000000\", chipSelectedBackgroundColor = \"#000000\", chipSelectedTextColor = \"#FFFFFF\", chipBorderColor = \"#EEEEEE\", chipBorderRadius = 16, chipPadding = 8, chipGap = 6, chipFont, showChipBeforeIcon = false, chipBeforeIcon, showChipAfterIcon = false, chipAfterIcon, chipIconSize = 12, showClearButton = true, clearButtonColor = \"#CCCCCC\", showBeforeIcon = false, beforeIcon, showAfterIcon = false, afterIcon, iconSize = 16, showButton = false, buttonText = \"Submit\", buttonEnabledBackground = \"#000000\", buttonEnabledText = \"#FFFFFF\", buttonDisabledBackground = \"#CCCCCC\", buttonDisabledText = \"#666666\", buttonBorderRadius = \"8px\", buttonPadding = \"12px\", buttonFont, buttonState, linkedButton, componentId = \"form-\" + Math.random().toString(36).substr(2, 9) } = props;\n    const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [selectedChips, setSelectedChips] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [isFocused, setIsFocused] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Motion values for linking with external components\n    const buttonDisabledMotion = (0,framer_motion__WEBPACK_IMPORTED_MODULE_4__.useMotionValue)(false);\n    const hasContentMotion = (0,framer_motion__WEBPACK_IMPORTED_MODULE_4__.useMotionValue)(false);\n    // Component linking system - will be initialized after hasContent and isButtonDisabled are calculated\n    // const { createLink, updateData } = useComponentLink({\n    //     id: componentId,\n    //     type: 'form',\n    //     data: {\n    //         hasContent: false, // Will be updated in useEffect\n    //         isButtonDisabled: true, // Will be updated in useEffect\n    //         value,\n    //         selectedChips,\n    //         fieldType,\n    //         label\n    //     },\n    //     onDataUpdate: (data) => {\n    //         // Handle updates from linked components\n    //         console.log('Form received update:', data)\n    //     }\n    // })\n    // Auto-link with button if ID is provided\n    // React.useEffect(() => {\n    //     if (linkedButtonId && linkedButtonId.trim() !== '') {\n    //         createLink(linkedButtonId)\n    //     }\n    // }, [linkedButtonId, createLink])\n    const handleInputChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"FormBuilder.useCallback[handleInputChange]\": (newValue)=>{\n            (0,react__WEBPACK_IMPORTED_MODULE_1__.startTransition)({\n                \"FormBuilder.useCallback[handleInputChange]\": ()=>setValue(newValue)\n            }[\"FormBuilder.useCallback[handleInputChange]\"]);\n        }\n    }[\"FormBuilder.useCallback[handleInputChange]\"], []);\n    const handleChipClick = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"FormBuilder.useCallback[handleChipClick]\": (chip)=>{\n            if (fieldType === \"chips\") {\n                setSelectedChips({\n                    \"FormBuilder.useCallback[handleChipClick]\": (prev)=>prev.includes(chip) ? prev.filter({\n                            \"FormBuilder.useCallback[handleChipClick]\": (c)=>c !== chip\n                        }[\"FormBuilder.useCallback[handleChipClick]\"]) : [\n                            ...prev,\n                            chip\n                        ]\n                }[\"FormBuilder.useCallback[handleChipClick]\"]);\n            } else {\n                // For text and textarea fields, accumulate chips with comma separation\n                if (value.trim() === \"\") {\n                    setValue(chip);\n                } else {\n                    setValue({\n                        \"FormBuilder.useCallback[handleChipClick]\": (prev)=>prev + \", \" + chip\n                    }[\"FormBuilder.useCallback[handleChipClick]\"]);\n                }\n            }\n        }\n    }[\"FormBuilder.useCallback[handleChipClick]\"], [\n        fieldType,\n        value\n    ]);\n    const handleFocus = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"FormBuilder.useCallback[handleFocus]\": ()=>{\n            (0,react__WEBPACK_IMPORTED_MODULE_1__.startTransition)({\n                \"FormBuilder.useCallback[handleFocus]\": ()=>setIsFocused(true)\n            }[\"FormBuilder.useCallback[handleFocus]\"]);\n        }\n    }[\"FormBuilder.useCallback[handleFocus]\"], []);\n    const handleBlur = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"FormBuilder.useCallback[handleBlur]\": ()=>{\n            (0,react__WEBPACK_IMPORTED_MODULE_1__.startTransition)({\n                \"FormBuilder.useCallback[handleBlur]\": ()=>setIsFocused(false)\n            }[\"FormBuilder.useCallback[handleBlur]\"]);\n        }\n    }[\"FormBuilder.useCallback[handleBlur]\"], []);\n    const handleClear = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"FormBuilder.useCallback[handleClear]\": ()=>{\n            setValue(\"\");\n            setSelectedChips([]);\n        }\n    }[\"FormBuilder.useCallback[handleClear]\"], []);\n    const handleButtonClick = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"FormBuilder.useCallback[handleButtonClick]\": ()=>{\n            // Button click handler - can be customized\n            console.log(\"Form submitted with value:\", value);\n        }\n    }[\"FormBuilder.useCallback[handleButtonClick]\"], [\n        value\n    ]);\n    const getInputPadding = ()=>{\n        // Parse padding string (e.g., \"12px\" or \"12px 16px 12px 16px\")\n        const paddingValues = padding.split(' ').map((p)=>parseInt(p.replace('px', '')));\n        const [top, right, bottom, left] = paddingValues.length === 1 ? [\n            paddingValues[0],\n            paddingValues[0],\n            paddingValues[0],\n            paddingValues[0]\n        ] : paddingValues.length === 2 ? [\n            paddingValues[0],\n            paddingValues[1],\n            paddingValues[0],\n            paddingValues[1]\n        ] : paddingValues.length === 4 ? paddingValues : [\n            12,\n            12,\n            12,\n            12\n        ] // fallback\n        ;\n        let leftPadding = left;\n        let rightPadding = right;\n        if (showBeforeIcon && beforeIcon) {\n            leftPadding = left + iconSize + 8;\n        }\n        if (showAfterIcon && afterIcon) {\n            rightPadding = right + iconSize + 8;\n        }\n        if (showClearButton && value && (fieldType === \"text\" || fieldType === \"textarea\")) {\n            rightPadding = Math.max(rightPadding, right + 32);\n        }\n        return {\n            leftPadding,\n            rightPadding,\n            topPadding: top,\n            bottomPadding: bottom\n        };\n    };\n    const { leftPadding, rightPadding, topPadding, bottomPadding } = getInputPadding();\n    const inputStyles = {\n        width: \"100%\",\n        ...heightMode === \"fixed\" && {\n            height: \"\".concat(height, \"px\")\n        },\n        ...heightMode === \"fit\" && {\n            minHeight: \"\".concat(height, \"px\")\n        },\n        paddingLeft: \"\".concat(leftPadding, \"px\"),\n        paddingRight: \"\".concat(rightPadding, \"px\"),\n        paddingTop: \"\".concat(topPadding, \"px\"),\n        paddingBottom: \"\".concat(bottomPadding, \"px\"),\n        backgroundColor,\n        border: \"1px solid \".concat(isFocused ? focusColor : borderColor),\n        borderRadius: borderRadius,\n        color: textColor,\n        outline: \"none\",\n        transition: \"border-color 0.2s ease\",\n        ...inputFont,\n        fontSize: (inputFont === null || inputFont === void 0 ? void 0 : inputFont.fontSize) || \"14px\"\n    };\n    const renderIcon = (icon, position)=>{\n        if (!icon) return null;\n        // Parse padding to get left/right values\n        const paddingValues = padding.split(' ').map((p)=>parseInt(p.replace('px', '')));\n        const [, right, , left] = paddingValues.length === 1 ? [\n            paddingValues[0],\n            paddingValues[0],\n            paddingValues[0],\n            paddingValues[0]\n        ] : paddingValues.length === 2 ? [\n            paddingValues[0],\n            paddingValues[1],\n            paddingValues[0],\n            paddingValues[1]\n        ] : paddingValues.length === 4 ? paddingValues : [\n            12,\n            12,\n            12,\n            12\n        ] // fallback\n        ;\n        const iconStyle = {\n            position: \"absolute\",\n            top: \"50%\",\n            transform: \"translateY(-50%)\",\n            [position === \"before\" ? \"left\" : \"right\"]: position === \"before\" ? \"\".concat(left, \"px\") : \"\".concat(right, \"px\"),\n            width: \"\".concat(iconSize, \"px\"),\n            height: \"\".concat(iconSize, \"px\"),\n            pointerEvents: \"none\",\n            zIndex: 1\n        };\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: iconStyle,\n            children: icon\n        }, void 0, false, {\n            fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n            lineNumber: 305,\n            columnNumber: 16\n        }, this);\n    };\n    const renderChipIcon = (icon)=>{\n        if (!icon) return null;\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                width: \"\".concat(chipIconSize, \"px\"),\n                height: \"\".concat(chipIconSize, \"px\"),\n                display: \"flex\",\n                alignItems: \"center\",\n                justifyContent: \"center\"\n            },\n            children: icon\n        }, void 0, false, {\n            fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n            lineNumber: 312,\n            columnNumber: 13\n        }, this);\n    };\n    // Check if form has content for button state\n    const hasContent = value.trim().length > 0 || selectedChips.length > 0;\n    const isButtonDisabled = buttonState ? buttonState === \"disabled\" : !hasContent;\n    // Update motion values when content changes\n    react__WEBPACK_IMPORTED_MODULE_1___default().useEffect({\n        \"FormBuilder.useEffect\": ()=>{\n            hasContentMotion.set(hasContent);\n            buttonDisabledMotion.set(isButtonDisabled);\n        }\n    }[\"FormBuilder.useEffect\"], [\n        hasContent,\n        isButtonDisabled,\n        hasContentMotion,\n        buttonDisabledMotion\n    ]);\n    // Update component data when form state changes\n    react__WEBPACK_IMPORTED_MODULE_1___default().useEffect({\n        \"FormBuilder.useEffect\": ()=>{\n            (0,_SimpleGlobalState__WEBPACK_IMPORTED_MODULE_3__.setComponentData)(componentId, 'form', {\n                hasContent,\n                isButtonDisabled,\n                value,\n                selectedChips,\n                fieldType,\n                label\n            });\n        }\n    }[\"FormBuilder.useEffect\"], [\n        hasContent,\n        isButtonDisabled,\n        value,\n        selectedChips,\n        fieldType,\n        label,\n        componentId\n    ]);\n    // Sync with linked button if provided\n    react__WEBPACK_IMPORTED_MODULE_1___default().useEffect({\n        \"FormBuilder.useEffect\": ()=>{\n            if (linkedButton && linkedButton.set) {\n                linkedButton.set({\n                    disabled: isButtonDisabled,\n                    hasContent: hasContent,\n                    value: value,\n                    selectedChips: selectedChips\n                });\n            }\n        }\n    }[\"FormBuilder.useEffect\"], [\n        isButtonDisabled,\n        hasContent,\n        value,\n        selectedChips,\n        linkedButton\n    ]);\n    const renderInput = ()=>{\n        switch(fieldType){\n            case \"textarea\":\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        position: \"relative\"\n                    },\n                    children: [\n                        showBeforeIcon && beforeIcon && renderIcon(beforeIcon, \"before\"),\n                        showAfterIcon && afterIcon && renderIcon(afterIcon, \"after\"),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"textarea\", {\n                            value: value,\n                            onChange: (e)=>handleInputChange(e.target.value),\n                            onFocus: handleFocus,\n                            onBlur: handleBlur,\n                            placeholder: placeholder,\n                            required: required,\n                            className: \"form-builder-textarea\",\n                            style: {\n                                ...inputStyles,\n                                minHeight: heightMode === \"fit\" ? \"\".concat(height, \"px\") : undefined,\n                                resize: heightMode === \"fit\" ? \"none\" : \"vertical\",\n                                fontFamily: \"inherit\"\n                            }\n                        }, void 0, false, {\n                            fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                            lineNumber: 371,\n                            columnNumber: 25\n                        }, this),\n                        showClearButton && value && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            type: \"button\",\n                            onClick: handleClear,\n                            style: {\n                                position: \"absolute\",\n                                right: showAfterIcon && afterIcon ? \"\".concat(rightPadding + iconSize + 8, \"px\") : \"8px\",\n                                top: \"8px\",\n                                background: \"none\",\n                                border: \"none\",\n                                cursor: \"pointer\",\n                                color: clearButtonColor,\n                                fontSize: \"16px\",\n                                width: \"24px\",\n                                height: \"24px\",\n                                display: \"flex\",\n                                alignItems: \"center\",\n                                justifyContent: \"center\",\n                                borderRadius: \"50%\",\n                                transition: \"background-color 0.2s ease\",\n                                zIndex: 2\n                            },\n                            onMouseEnter: (e)=>{\n                                e.currentTarget.style.backgroundColor = \"#F0F0F0\";\n                            },\n                            onMouseLeave: (e)=>{\n                                e.currentTarget.style.backgroundColor = \"transparent\";\n                            },\n                            \"aria-label\": \"Clear input\",\n                            children: \"\\xd7\"\n                        }, void 0, false, {\n                            fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                            lineNumber: 387,\n                            columnNumber: 29\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                    lineNumber: 364,\n                    columnNumber: 21\n                }, this);\n            case \"dropdown\":\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        position: \"relative\"\n                    },\n                    children: [\n                        showBeforeIcon && beforeIcon && renderIcon(beforeIcon, \"before\"),\n                        showAfterIcon && afterIcon && renderIcon(afterIcon, \"after\"),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                            value: value,\n                            onChange: (e)=>handleInputChange(e.target.value),\n                            onFocus: handleFocus,\n                            onBlur: handleBlur,\n                            required: required,\n                            \"aria-label\": placeholder,\n                            style: {\n                                ...inputStyles,\n                                cursor: \"pointer\",\n                                appearance: \"none\",\n                                backgroundImage: \"url(\\\"data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='\".concat(encodeURIComponent(textColor), \"' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e\\\")\"),\n                                backgroundRepeat: \"no-repeat\",\n                                backgroundPosition: showAfterIcon && afterIcon ? \"right \".concat(rightPadding + iconSize + 16, \"px center\") : \"right 12px center\",\n                                backgroundSize: \"16px\"\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                    value: \"\",\n                                    children: placeholder\n                                }, void 0, false, {\n                                    fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                                    lineNumber: 456,\n                                    columnNumber: 29\n                                }, this),\n                                dropdownOptions.map((option, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                        value: option.value,\n                                        children: option.label\n                                    }, index, false, {\n                                        fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                                        lineNumber: 458,\n                                        columnNumber: 33\n                                    }, this))\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                            lineNumber: 436,\n                            columnNumber: 25\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                    lineNumber: 429,\n                    columnNumber: 21\n                }, this);\n            case \"radio\":\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        display: \"flex\",\n                        flexDirection: \"column\",\n                        gap: \"8px\"\n                    },\n                    children: radioOptions.map((option, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                            style: {\n                                display: \"flex\",\n                                alignItems: \"center\",\n                                gap: \"8px\",\n                                cursor: \"pointer\",\n                                ...inputFont,\n                                fontSize: (inputFont === null || inputFont === void 0 ? void 0 : inputFont.fontSize) || \"14px\"\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                    type: \"radio\",\n                                    name: \"radio-group\",\n                                    value: option.value,\n                                    checked: value === option.value,\n                                    onChange: (e)=>handleInputChange(e.target.value),\n                                    style: {\n                                        accentColor: focusColor,\n                                        width: \"16px\",\n                                        height: \"16px\"\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                                    lineNumber: 487,\n                                    columnNumber: 33\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    style: {\n                                        color: textColor\n                                    },\n                                    children: option.label\n                                }, void 0, false, {\n                                    fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                                    lineNumber: 501,\n                                    columnNumber: 33\n                                }, this)\n                            ]\n                        }, index, true, {\n                            fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                            lineNumber: 476,\n                            columnNumber: 29\n                        }, this))\n                }, void 0, false, {\n                    fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                    lineNumber: 468,\n                    columnNumber: 21\n                }, this);\n            case \"chips\":\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        ...inputStyles,\n                        minHeight: heightMode === \"fit\" ? \"\".concat(height, \"px\") : undefined,\n                        display: \"flex\",\n                        flexWrap: \"wrap\",\n                        gap: \"6px\",\n                        alignItems: \"center\",\n                        position: \"relative\"\n                    },\n                    onClick: handleFocus,\n                    onBlur: handleBlur,\n                    tabIndex: 0,\n                    children: [\n                        showBeforeIcon && beforeIcon && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                position: \"absolute\",\n                                left: \"\".concat(leftPadding, \"px\"),\n                                top: \"50%\",\n                                transform: \"translateY(-50%)\",\n                                width: \"\".concat(iconSize, \"px\"),\n                                height: \"\".concat(iconSize, \"px\"),\n                                color: \"#000000\",\n                                pointerEvents: \"none\",\n                                zIndex: 1\n                            },\n                            children: beforeIcon\n                        }, void 0, false, {\n                            fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                            lineNumber: 526,\n                            columnNumber: 29\n                        }, this),\n                        showAfterIcon && afterIcon && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                position: \"absolute\",\n                                right: \"\".concat(rightPadding, \"px\"),\n                                top: \"50%\",\n                                transform: \"translateY(-50%)\",\n                                width: \"\".concat(iconSize, \"px\"),\n                                height: \"\".concat(iconSize, \"px\"),\n                                color: \"#000000\",\n                                pointerEvents: \"none\",\n                                zIndex: 1\n                            },\n                            children: afterIcon\n                        }, void 0, false, {\n                            fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                            lineNumber: 543,\n                            columnNumber: 29\n                        }, this),\n                        selectedChips.map((chip, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                style: {\n                                    backgroundColor: chipSelectedBackgroundColor,\n                                    color: chipSelectedTextColor,\n                                    border: \"1px solid \".concat(chipBorderColor),\n                                    padding: \"\".concat(chipPadding, \"px \").concat(chipPadding * 1.5, \"px\"),\n                                    borderRadius: \"\".concat(chipBorderRadius, \"px\"),\n                                    display: \"flex\",\n                                    alignItems: \"center\",\n                                    gap: \"4px\",\n                                    cursor: \"pointer\",\n                                    ...chipFont,\n                                    fontSize: (chipFont === null || chipFont === void 0 ? void 0 : chipFont.fontSize) || \"12px\"\n                                },\n                                onClick: ()=>handleChipClick(chip),\n                                children: [\n                                    showChipBeforeIcon && chipBeforeIcon && renderChipIcon(chipBeforeIcon),\n                                    chip,\n                                    showChipAfterIcon && chipAfterIcon && renderChipIcon(chipAfterIcon),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        style: {\n                                            fontSize: \"10px\"\n                                        },\n                                        children: \"\\xd7\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                                        lineNumber: 585,\n                                        columnNumber: 33\n                                    }, this)\n                                ]\n                            }, index, true, {\n                                fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                                lineNumber: 560,\n                                columnNumber: 29\n                            }, this)),\n                        selectedChips.length === 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            style: {\n                                color: placeholderColor,\n                                fontSize: (inputFont === null || inputFont === void 0 ? void 0 : inputFont.fontSize) || \"14px\",\n                                marginLeft: showBeforeIcon && beforeIcon ? \"\".concat(leftPadding + iconSize + 8, \"px\") : \"0px\"\n                            },\n                            children: placeholder\n                        }, void 0, false, {\n                            fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                            lineNumber: 589,\n                            columnNumber: 29\n                        }, this),\n                        showClearButton && selectedChips.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            type: \"button\",\n                            onClick: handleClear,\n                            style: {\n                                position: \"absolute\",\n                                right: showAfterIcon && afterIcon ? \"\".concat(rightPadding + iconSize + 8, \"px\") : \"8px\",\n                                top: \"8px\",\n                                background: \"none\",\n                                border: \"none\",\n                                cursor: \"pointer\",\n                                color: clearButtonColor,\n                                fontSize: \"16px\",\n                                width: \"24px\",\n                                height: \"24px\",\n                                display: \"flex\",\n                                alignItems: \"center\",\n                                justifyContent: \"center\",\n                                borderRadius: \"50%\",\n                                transition: \"background-color 0.2s ease\",\n                                zIndex: 2\n                            },\n                            onMouseEnter: (e)=>{\n                                e.currentTarget.style.backgroundColor = \"#F0F0F0\";\n                            },\n                            onMouseLeave: (e)=>{\n                                e.currentTarget.style.backgroundColor = \"transparent\";\n                            },\n                            \"aria-label\": \"Clear input\",\n                            children: \"\\xd7\"\n                        }, void 0, false, {\n                            fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                            lineNumber: 603,\n                            columnNumber: 29\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                    lineNumber: 511,\n                    columnNumber: 21\n                }, this);\n            default:\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        position: \"relative\"\n                    },\n                    children: [\n                        showBeforeIcon && beforeIcon && renderIcon(beforeIcon, \"before\"),\n                        showAfterIcon && afterIcon && renderIcon(afterIcon, \"after\"),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                            type: \"text\",\n                            value: value,\n                            onChange: (e)=>handleInputChange(e.target.value),\n                            onFocus: handleFocus,\n                            onBlur: handleBlur,\n                            placeholder: placeholder,\n                            required: required,\n                            className: \"form-builder-input\",\n                            style: inputStyles\n                        }, void 0, false, {\n                            fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                            lineNumber: 652,\n                            columnNumber: 25\n                        }, this),\n                        showClearButton && value && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            type: \"button\",\n                            onClick: handleClear,\n                            style: {\n                                position: \"absolute\",\n                                right: showAfterIcon && afterIcon ? \"\".concat(rightPadding + iconSize + 8, \"px\") : \"8px\",\n                                top: \"8px\",\n                                background: \"none\",\n                                border: \"none\",\n                                cursor: \"pointer\",\n                                color: clearButtonColor,\n                                fontSize: \"16px\",\n                                width: \"24px\",\n                                height: \"24px\",\n                                display: \"flex\",\n                                alignItems: \"center\",\n                                justifyContent: \"center\",\n                                borderRadius: \"50%\",\n                                transition: \"background-color 0.2s ease\",\n                                zIndex: 2\n                            },\n                            onMouseEnter: (e)=>{\n                                e.currentTarget.style.backgroundColor = \"#F0F0F0\";\n                            },\n                            onMouseLeave: (e)=>{\n                                e.currentTarget.style.backgroundColor = \"transparent\";\n                            },\n                            \"aria-label\": \"Clear input\",\n                            children: \"\\xd7\"\n                        }, void 0, false, {\n                            fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                            lineNumber: 664,\n                            columnNumber: 29\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                    lineNumber: 645,\n                    columnNumber: 21\n                }, this);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"style\", {\n                children: \"\\n                    .form-builder-input::placeholder {\\n                        color: \".concat(placeholderColor, \" !important;\\n                    }\\n                    .form-builder-textarea::placeholder {\\n                        color: \").concat(placeholderColor, \" !important;\\n                    }\\n                \")\n            }, void 0, false, {\n                fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                lineNumber: 708,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    ...props.style,\n                    display: \"flex\",\n                    flexDirection: \"column\",\n                    gap: \"8px\",\n                    width: \"100%\"\n                },\n                children: [\n                    showLabel && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                        style: {\n                            color: labelColor,\n                            ...labelFont,\n                            fontSize: (labelFont === null || labelFont === void 0 ? void 0 : labelFont.fontSize) || \"14px\",\n                            fontWeight: (labelFont === null || labelFont === void 0 ? void 0 : labelFont.fontWeight) || \"500\"\n                        },\n                        children: [\n                            label,\n                            required && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                style: {\n                                    color: \"#FF5588\",\n                                    marginLeft: \"2px\"\n                                },\n                                children: \"*\"\n                            }, void 0, false, {\n                                fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                                lineNumber: 738,\n                                columnNumber: 29\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                        lineNumber: 728,\n                        columnNumber: 21\n                    }, this),\n                    renderInput(),\n                    showChips && (fieldType === \"text\" || fieldType === \"textarea\" || fieldType === \"chips\") && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            display: \"flex\",\n                            flexWrap: \"wrap\",\n                            gap: \"\".concat(chipGap, \"px\"),\n                            marginTop: \"4px\"\n                        },\n                        children: chipSuggestions.map((chip, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                type: \"button\",\n                                onClick: ()=>handleChipClick(chip),\n                                style: {\n                                    backgroundColor: selectedChips.includes(chip) ? chipSelectedBackgroundColor : chipBackgroundColor,\n                                    color: selectedChips.includes(chip) ? chipSelectedTextColor : chipTextColor,\n                                    border: \"1px solid \".concat(chipBorderColor),\n                                    borderRadius: \"\".concat(chipBorderRadius, \"px\"),\n                                    padding: \"\".concat(chipPadding, \"px \").concat(chipPadding * 1.5, \"px\"),\n                                    cursor: \"pointer\",\n                                    transition: \"all 0.2s ease\",\n                                    outline: \"none\",\n                                    display: \"flex\",\n                                    alignItems: \"center\",\n                                    gap: \"8px\",\n                                    ...chipFont,\n                                    fontSize: (chipFont === null || chipFont === void 0 ? void 0 : chipFont.fontSize) || \"12px\"\n                                },\n                                onMouseEnter: (e)=>{\n                                    if (!selectedChips.includes(chip)) {\n                                        e.currentTarget.style.backgroundColor = \"#F0F0F0\";\n                                    }\n                                },\n                                onMouseLeave: (e)=>{\n                                    if (!selectedChips.includes(chip)) {\n                                        e.currentTarget.style.backgroundColor = chipBackgroundColor;\n                                    }\n                                },\n                                children: [\n                                    showChipBeforeIcon && chipBeforeIcon && renderChipIcon(chipBeforeIcon),\n                                    chip,\n                                    showChipAfterIcon && chipAfterIcon && renderChipIcon(chipAfterIcon)\n                                ]\n                            }, index, true, {\n                                fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                                lineNumber: 762,\n                                columnNumber: 33\n                            }, this))\n                    }, void 0, false, {\n                        fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                        lineNumber: 753,\n                        columnNumber: 25\n                    }, this),\n                    showButton && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"button\",\n                        onClick: handleButtonClick,\n                        disabled: isButtonDisabled,\n                        style: {\n                            backgroundColor: isButtonDisabled ? buttonDisabledBackground : buttonEnabledBackground,\n                            color: isButtonDisabled ? buttonDisabledText : buttonEnabledText,\n                            border: \"none\",\n                            borderRadius: buttonBorderRadius,\n                            padding: buttonPadding,\n                            cursor: isButtonDisabled ? \"not-allowed\" : \"pointer\",\n                            transition: \"all 0.2s ease\",\n                            outline: \"none\",\n                            marginTop: \"8px\",\n                            ...buttonFont,\n                            fontSize: (buttonFont === null || buttonFont === void 0 ? void 0 : buttonFont.fontSize) || \"14px\",\n                            opacity: isButtonDisabled ? 0.6 : 1\n                        },\n                        children: buttonText\n                    }, void 0, false, {\n                        fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                        lineNumber: 813,\n                        columnNumber: 21\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/FormBuilderOrg.tsx\",\n                lineNumber: 718,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true);\n}\n_s(FormBuilder, \"F8YxJbXMacgIFj3p0T3NR8WCPfI=\", false, function() {\n    return [\n        framer_motion__WEBPACK_IMPORTED_MODULE_4__.useMotionValue,\n        framer_motion__WEBPACK_IMPORTED_MODULE_4__.useMotionValue\n    ];\n});\n_c = FormBuilder;\n(0,framer__WEBPACK_IMPORTED_MODULE_2__.addPropertyControls)(FormBuilder, {\n    // === BASIC SETTINGS ===\n    fieldType: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Enum,\n        title: \"Field Type\",\n        options: [\n            \"text\",\n            \"textarea\",\n            \"dropdown\",\n            \"radio\",\n            \"chips\"\n        ],\n        optionTitles: [\n            \"Text\",\n            \"Text Area\",\n            \"Dropdown\",\n            \"Radio\",\n            \"Chips\"\n        ],\n        defaultValue: \"text\"\n    },\n    required: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Boolean,\n        title: \"Required\",\n        defaultValue: false,\n        enabledTitle: \"Yes\",\n        disabledTitle: \"No\"\n    },\n    // === LABEL SETTINGS ===\n    showLabel: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Boolean,\n        title: \"Show Label\",\n        defaultValue: true,\n        enabledTitle: \"Show\",\n        disabledTitle: \"Hide\"\n    },\n    label: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.String,\n        title: \"Label\",\n        defaultValue: \"Field Label\",\n        hidden: (param)=>{\n            let { showLabel } = param;\n            return !showLabel;\n        }\n    },\n    labelColor: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Label Color\",\n        defaultValue: \"#000000\",\n        hidden: (param)=>{\n            let { showLabel } = param;\n            return !showLabel;\n        }\n    },\n    labelFont: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Font,\n        title: \"Label Font\",\n        defaultValue: {\n            fontSize: \"14px\",\n            variant: \"Medium\",\n            letterSpacing: \"-0.01em\",\n            lineHeight: \"1.2em\"\n        },\n        controls: \"extended\",\n        defaultFontType: \"sans-serif\",\n        hidden: (param)=>{\n            let { showLabel } = param;\n            return !showLabel;\n        }\n    },\n    // === FIELD-SPECIFIC OPTIONS ===\n    dropdownOptions: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Array,\n        title: \"Dropdown Options\",\n        control: {\n            type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Object,\n            controls: {\n                label: {\n                    type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.String,\n                    defaultValue: \"Option\"\n                },\n                value: {\n                    type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.String,\n                    defaultValue: \"option\"\n                }\n            }\n        },\n        defaultValue: [\n            {\n                label: \"Option 1\",\n                value: \"option1\"\n            },\n            {\n                label: \"Option 2\",\n                value: \"option2\"\n            },\n            {\n                label: \"Option 3\",\n                value: \"option3\"\n            }\n        ],\n        hidden: (param)=>{\n            let { fieldType } = param;\n            return fieldType !== \"dropdown\";\n        }\n    },\n    radioOptions: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Array,\n        title: \"Radio Options\",\n        control: {\n            type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Object,\n            controls: {\n                label: {\n                    type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.String,\n                    defaultValue: \"Choice\"\n                },\n                value: {\n                    type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.String,\n                    defaultValue: \"choice\"\n                }\n            }\n        },\n        defaultValue: [\n            {\n                label: \"Choice A\",\n                value: \"a\"\n            },\n            {\n                label: \"Choice B\",\n                value: \"b\"\n            },\n            {\n                label: \"Choice C\",\n                value: \"c\"\n            }\n        ],\n        hidden: (param)=>{\n            let { fieldType } = param;\n            return fieldType !== \"radio\";\n        }\n    },\n    // === INPUT CONTENT ===\n    placeholder: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.String,\n        title: \"Placeholder\",\n        defaultValue: \"Enter text...\",\n        hidden: (param)=>{\n            let { fieldType } = param;\n            return fieldType === \"radio\";\n        }\n    },\n    placeholderColor: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Placeholder Color\",\n        defaultValue: \"#999999\",\n        hidden: (param)=>{\n            let { fieldType } = param;\n            return fieldType === \"radio\";\n        }\n    },\n    // === CLEAR BUTTON ===\n    showClearButton: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Boolean,\n        title: \"Clear Button\",\n        defaultValue: true,\n        enabledTitle: \"Show\",\n        disabledTitle: \"Hide\",\n        hidden: (param)=>{\n            let { fieldType } = param;\n            return fieldType !== \"text\" && fieldType !== \"textarea\" && fieldType !== \"chips\";\n        }\n    },\n    clearButtonColor: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Clear Button Color\",\n        defaultValue: \"#CCCCCC\",\n        hidden: (param)=>{\n            let { fieldType, showClearButton } = param;\n            return !showClearButton || fieldType !== \"text\" && fieldType !== \"textarea\" && fieldType !== \"chips\";\n        }\n    },\n    // === FIELD ICONS ===\n    showBeforeIcon: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Boolean,\n        title: \"Before Icon\",\n        defaultValue: false,\n        enabledTitle: \"Show\",\n        disabledTitle: \"Hide\",\n        hidden: (param)=>{\n            let { fieldType } = param;\n            return fieldType === \"radio\";\n        }\n    },\n    beforeIcon: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.ComponentInstance,\n        title: \"Before Icon\",\n        hidden: (param)=>{\n            let { showBeforeIcon, fieldType } = param;\n            return !showBeforeIcon || fieldType === \"radio\";\n        }\n    },\n    showAfterIcon: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Boolean,\n        title: \"After Icon\",\n        defaultValue: false,\n        enabledTitle: \"Show\",\n        disabledTitle: \"Hide\",\n        hidden: (param)=>{\n            let { fieldType } = param;\n            return fieldType === \"radio\";\n        }\n    },\n    afterIcon: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.ComponentInstance,\n        title: \"After Icon\",\n        hidden: (param)=>{\n            let { showAfterIcon, fieldType } = param;\n            return !showAfterIcon || fieldType === \"radio\";\n        }\n    },\n    iconSize: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Number,\n        title: \"Icon Size\",\n        defaultValue: 16,\n        min: 12,\n        max: 24,\n        step: 1,\n        unit: \"px\",\n        hidden: (param)=>{\n            let { showBeforeIcon, showAfterIcon, fieldType } = param;\n            return !showBeforeIcon && !showAfterIcon || fieldType === \"radio\";\n        }\n    },\n    // === CHIP SETTINGS ===\n    showChips: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Boolean,\n        title: \"Show Chips\",\n        defaultValue: true,\n        enabledTitle: \"Show\",\n        disabledTitle: \"Hide\",\n        hidden: (param)=>{\n            let { fieldType } = param;\n            return fieldType !== \"text\" && fieldType !== \"textarea\" && fieldType !== \"chips\";\n        }\n    },\n    chipSuggestions: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Array,\n        title: \"Chip Suggestions\",\n        control: {\n            type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.String\n        },\n        defaultValue: [\n            \"Suggestion 1\",\n            \"Suggestion 2\",\n            \"Suggestion 3\",\n            \"Suggestion 4\"\n        ],\n        hidden: (param)=>{\n            let { fieldType, showChips } = param;\n            return !showChips || fieldType !== \"text\" && fieldType !== \"textarea\" && fieldType !== \"chips\";\n        }\n    },\n    // === CHIP STYLING ===\n    chipBackgroundColor: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Chip Background\",\n        defaultValue: \"#F5F5F5\",\n        hidden: (param)=>{\n            let { fieldType, showChips } = param;\n            return !showChips || fieldType !== \"text\" && fieldType !== \"textarea\" && fieldType !== \"chips\";\n        }\n    },\n    chipTextColor: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Chip Text\",\n        defaultValue: \"#000000\",\n        hidden: (param)=>{\n            let { fieldType, showChips } = param;\n            return !showChips || fieldType !== \"text\" && fieldType !== \"textarea\" && fieldType !== \"chips\";\n        }\n    },\n    chipSelectedBackgroundColor: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Selected Background\",\n        defaultValue: \"#000000\",\n        hidden: (param)=>{\n            let { fieldType, showChips } = param;\n            return !showChips || fieldType !== \"text\" && fieldType !== \"textarea\" && fieldType !== \"chips\";\n        }\n    },\n    chipSelectedTextColor: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Selected Text\",\n        defaultValue: \"#FFFFFF\",\n        hidden: (param)=>{\n            let { fieldType, showChips } = param;\n            return !showChips || fieldType !== \"text\" && fieldType !== \"textarea\" && fieldType !== \"chips\";\n        }\n    },\n    chipBorderColor: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Chip Border\",\n        defaultValue: \"#EEEEEE\",\n        hidden: (param)=>{\n            let { fieldType, showChips } = param;\n            return !showChips || fieldType !== \"text\" && fieldType !== \"textarea\" && fieldType !== \"chips\";\n        }\n    },\n    chipBorderRadius: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Number,\n        title: \"Chip Radius\",\n        defaultValue: 16,\n        min: 0,\n        max: 30,\n        step: 1,\n        unit: \"px\",\n        hidden: (param)=>{\n            let { fieldType, showChips } = param;\n            return !showChips || fieldType !== \"text\" && fieldType !== \"textarea\" && fieldType !== \"chips\";\n        }\n    },\n    chipPadding: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Number,\n        title: \"Chip Padding\",\n        defaultValue: 8,\n        min: 2,\n        max: 16,\n        step: 1,\n        unit: \"px\",\n        hidden: (param)=>{\n            let { fieldType, showChips } = param;\n            return !showChips || fieldType !== \"text\" && fieldType !== \"textarea\" && fieldType !== \"chips\";\n        }\n    },\n    chipGap: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Number,\n        title: \"Chip Gap\",\n        defaultValue: 6,\n        min: 0,\n        max: 20,\n        step: 1,\n        unit: \"px\",\n        hidden: (param)=>{\n            let { fieldType, showChips } = param;\n            return !showChips || fieldType !== \"text\" && fieldType !== \"textarea\" && fieldType !== \"chips\";\n        }\n    },\n    chipFont: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Font,\n        title: \"Chip Font\",\n        defaultValue: {\n            fontSize: \"12px\",\n            variant: \"Medium\",\n            letterSpacing: \"-0.01em\",\n            lineHeight: \"1.2em\"\n        },\n        controls: \"extended\",\n        defaultFontType: \"sans-serif\",\n        hidden: (param)=>{\n            let { fieldType, showChips } = param;\n            return !showChips || fieldType !== \"text\" && fieldType !== \"textarea\" && fieldType !== \"chips\";\n        }\n    },\n    // === CHIP ICONS ===\n    showChipBeforeIcon: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Boolean,\n        title: \"Chip Before Icon\",\n        defaultValue: false,\n        enabledTitle: \"Show\",\n        disabledTitle: \"Hide\",\n        hidden: (param)=>{\n            let { fieldType, showChips } = param;\n            return !showChips || fieldType !== \"text\" && fieldType !== \"textarea\" && fieldType !== \"chips\";\n        }\n    },\n    chipBeforeIcon: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.ComponentInstance,\n        title: \"Before Icon\",\n        hidden: (param)=>{\n            let { fieldType, showChips, showChipBeforeIcon } = param;\n            return !showChips || !showChipBeforeIcon || fieldType !== \"text\" && fieldType !== \"textarea\" && fieldType !== \"chips\";\n        }\n    },\n    showChipAfterIcon: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Boolean,\n        title: \"Chip After Icon\",\n        defaultValue: false,\n        enabledTitle: \"Show\",\n        disabledTitle: \"Hide\",\n        hidden: (param)=>{\n            let { fieldType, showChips } = param;\n            return !showChips || fieldType !== \"text\" && fieldType !== \"textarea\" && fieldType !== \"chips\";\n        }\n    },\n    chipAfterIcon: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.ComponentInstance,\n        title: \"After Icon\",\n        hidden: (param)=>{\n            let { fieldType, showChips, showChipAfterIcon } = param;\n            return !showChips || !showChipAfterIcon || fieldType !== \"text\" && fieldType !== \"textarea\" && fieldType !== \"chips\";\n        }\n    },\n    chipIconSize: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Number,\n        title: \"Chip Icon Size\",\n        defaultValue: 12,\n        min: 8,\n        max: 20,\n        step: 1,\n        unit: \"px\",\n        hidden: (param)=>{\n            let { fieldType, showChips, showChipBeforeIcon, showChipAfterIcon } = param;\n            return !showChips || !showChipBeforeIcon && !showChipAfterIcon || fieldType !== \"text\" && fieldType !== \"textarea\" && fieldType !== \"chips\";\n        }\n    },\n    // === FIELD STYLING ===\n    backgroundColor: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Background\",\n        defaultValue: \"#FFFFFF\",\n        hidden: (param)=>{\n            let { fieldType } = param;\n            return fieldType === \"radio\";\n        }\n    },\n    borderColor: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Border Color\",\n        defaultValue: \"#EEEEEE\",\n        hidden: (param)=>{\n            let { fieldType } = param;\n            return fieldType === \"radio\";\n        }\n    },\n    focusColor: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Focus Color\",\n        defaultValue: \"#000000\",\n        hidden: (param)=>{\n            let { fieldType } = param;\n            return fieldType === \"radio\";\n        }\n    },\n    textColor: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Text Color\",\n        defaultValue: \"#000000\",\n        hidden: (param)=>{\n            let { fieldType } = param;\n            return fieldType === \"radio\";\n        }\n    },\n    borderRadius: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.BorderRadius,\n        title: \"Border Radius\",\n        defaultValue: \"8px\",\n        hidden: (param)=>{\n            let { fieldType } = param;\n            return fieldType === \"radio\";\n        }\n    },\n    heightMode: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Enum,\n        title: \"Height Mode\",\n        options: [\n            \"fixed\",\n            \"fit\"\n        ],\n        optionTitles: [\n            \"Fixed\",\n            \"Fit\"\n        ],\n        defaultValue: \"fixed\",\n        hidden: (param)=>{\n            let { fieldType } = param;\n            return fieldType === \"radio\";\n        }\n    },\n    height: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Number,\n        title: \"Field Height\",\n        defaultValue: 40,\n        min: 20,\n        max: 100,\n        step: 1,\n        unit: \"px\",\n        hidden: (param)=>{\n            let { fieldType, heightMode } = param;\n            return fieldType === \"radio\" || heightMode === \"fit\";\n        }\n    },\n    padding: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Padding,\n        title: \"Padding\",\n        defaultValue: \"12px\",\n        hidden: (param)=>{\n            let { fieldType } = param;\n            return fieldType === \"radio\";\n        }\n    },\n    // === TYPOGRAPHY ===\n    inputFont: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Font,\n        title: \"Input Font\",\n        defaultValue: {\n            fontSize: \"14px\",\n            variant: \"Regular\",\n            letterSpacing: \"-0.01em\",\n            lineHeight: \"1.3em\"\n        },\n        controls: \"extended\",\n        defaultFontType: \"sans-serif\",\n        hidden: (param)=>{\n            let { fieldType } = param;\n            return fieldType === \"radio\";\n        }\n    },\n    // === BUTTON SETTINGS ===\n    showButton: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Boolean,\n        title: \"Show Button\",\n        defaultValue: false,\n        enabledTitle: \"Show\",\n        disabledTitle: \"Hide\"\n    },\n    buttonText: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.String,\n        title: \"Button Text\",\n        defaultValue: \"Submit\",\n        hidden: (param)=>{\n            let { showButton } = param;\n            return !showButton;\n        }\n    },\n    buttonState: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Enum,\n        title: \"Button State\",\n        options: [\n            \"enabled\",\n            \"disabled\"\n        ],\n        optionTitles: [\n            \"Enabled\",\n            \"Disabled\"\n        ],\n        defaultValue: \"enabled\",\n        hidden: (param)=>{\n            let { showButton } = param;\n            return !showButton;\n        }\n    },\n    linkedButton: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.ComponentInstance,\n        title: \"Linked Button\",\n        description: \"Link to an external Button component anywhere in your project\"\n    },\n    componentId: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.String,\n        title: \"Component ID\",\n        defaultValue: \"form-123\",\n        description: \"Unique identifier for this form (auto-generated if empty)\"\n    },\n    linkedButtonId: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.String,\n        title: \"Linked Button ID\",\n        defaultValue: \"\",\n        description: \"Enter the Button's Component ID to link them (works anywhere in Framer)\"\n    },\n    // === BUTTON STYLING ===\n    buttonEnabledBackground: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Button Background\",\n        defaultValue: \"#000000\",\n        hidden: (param)=>{\n            let { showButton } = param;\n            return !showButton;\n        }\n    },\n    buttonEnabledText: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Button Text Color\",\n        defaultValue: \"#FFFFFF\",\n        hidden: (param)=>{\n            let { showButton } = param;\n            return !showButton;\n        }\n    },\n    buttonDisabledBackground: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Disabled Background\",\n        defaultValue: \"#CCCCCC\",\n        hidden: (param)=>{\n            let { showButton } = param;\n            return !showButton;\n        }\n    },\n    buttonDisabledText: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Color,\n        title: \"Disabled Text Color\",\n        defaultValue: \"#666666\",\n        hidden: (param)=>{\n            let { showButton } = param;\n            return !showButton;\n        }\n    },\n    buttonBorderRadius: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.BorderRadius,\n        title: \"Button Border Radius\",\n        defaultValue: \"8px\",\n        hidden: (param)=>{\n            let { showButton } = param;\n            return !showButton;\n        }\n    },\n    buttonPadding: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Padding,\n        title: \"Button Padding\",\n        defaultValue: \"12px\",\n        hidden: (param)=>{\n            let { showButton } = param;\n            return !showButton;\n        }\n    },\n    buttonFont: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Font,\n        title: \"Button Font\",\n        defaultValue: {\n            fontSize: \"14px\",\n            variant: \"Medium\",\n            letterSpacing: \"0\",\n            lineHeight: \"1.2em\"\n        },\n        controls: \"extended\",\n        defaultFontType: \"sans-serif\",\n        hidden: (param)=>{\n            let { showButton } = param;\n            return !showButton;\n        }\n    }\n});\nvar _c;\n$RefreshReg$(_c, \"FormBuilder\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0Zvcm1CdWlsZGVyT3JnLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsOEZBQThGOzs7QUFNaEY7QUFDMkM7QUFDWDtBQUNRO0FBNkR0RDs7O0NBR0MsR0FDYyxTQUFTUSxZQUFZQyxLQUF1Qjs7SUFDdkQsTUFBTSxFQUNGQyxZQUFZLE1BQU0sRUFDbEJDLFFBQVEsYUFBYSxFQUNyQkMsWUFBWSxJQUFJLEVBQ2hCQyxjQUFjLGVBQWUsRUFDN0JDLG1CQUFtQixTQUFTLEVBQzVCQyxXQUFXLEtBQUssRUFDaEJDLGtCQUFrQjtRQUNkO1lBQUVMLE9BQU87WUFBWU0sT0FBTztRQUFVO1FBQ3RDO1lBQUVOLE9BQU87WUFBWU0sT0FBTztRQUFVO1FBQ3RDO1lBQUVOLE9BQU87WUFBWU0sT0FBTztRQUFVO0tBQ3pDLEVBQ0RDLGVBQWU7UUFDWDtZQUFFUCxPQUFPO1lBQVlNLE9BQU87UUFBSTtRQUNoQztZQUFFTixPQUFPO1lBQVlNLE9BQU87UUFBSTtRQUNoQztZQUFFTixPQUFPO1lBQVlNLE9BQU87UUFBSTtLQUNuQyxFQUNERSxrQkFBa0I7UUFDZDtRQUNBO1FBQ0E7UUFDQTtLQUNILEVBQ0RDLGtCQUFrQixTQUFTLEVBQzNCQyxjQUFjLFNBQVMsRUFDdkJDLGFBQWEsU0FBUyxFQUN0QkMsWUFBWSxTQUFTLEVBQ3JCQyxhQUFhLFNBQVMsRUFDdEJDLGVBQWUsS0FBSyxFQUNwQkMsYUFBYSxPQUFPLEVBQ3BCQyxTQUFTLEVBQUUsRUFDWEMsVUFBVSxNQUFNLEVBQ2hCQyxTQUFTLEVBQ1RDLFNBQVMsRUFDVEMsWUFBWSxJQUFJLEVBQ2hCQyxzQkFBc0IsU0FBUyxFQUMvQkMsZ0JBQWdCLFNBQVMsRUFDekJDLDhCQUE4QixTQUFTLEVBQ3ZDQyx3QkFBd0IsU0FBUyxFQUNqQ0Msa0JBQWtCLFNBQVMsRUFDM0JDLG1CQUFtQixFQUFFLEVBQ3JCQyxjQUFjLENBQUMsRUFDZkMsVUFBVSxDQUFDLEVB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QUNoQjtRQUNBQyxVQUFVO1FBQ1ZDLGlCQUFpQjtRQUNqQlAsUUFBUTtnQkFBQyxFQUFFeEksVUFBVSxFQUFFO21CQUFLLENBQUNBOztJQUNqQztBQUNKIiwic291cmNlcyI6WyIvVXNlcnMvemlib24vRG9jdW1lbnRzL1ZpYmUvQ3Vyc29yL0ZyYW1lciBXb3Jrc2hvcC9mcmFtZXItd29ya3Nob3Avc3JjL2NvbXBvbmVudHMvRm9ybUJ1aWxkZXJPcmcudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZvcm0gY29tcG9uZW50IHdpdGggc3R5bGUgY3VzdG9taXphdGlvbiBhbmQgbXVsdGlwbGUgaW5wdXQgdHlwZXMgaW5jbHVkaW5nIGNoaXAgc3VnZ2VzdGlvbnNcbmltcG9ydCBSZWFjdCwge1xuICAgIHVzZVN0YXRlLFxuICAgIHVzZUNhbGxiYWNrLFxuICAgIHN0YXJ0VHJhbnNpdGlvbixcbiAgICB0eXBlIENTU1Byb3BlcnRpZXMsXG59IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgeyBhZGRQcm9wZXJ0eUNvbnRyb2xzLCBDb250cm9sVHlwZSB9IGZyb20gXCJmcmFtZXJcIlxuaW1wb3J0IHsgdXNlTW90aW9uVmFsdWUgfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXG5pbXBvcnQgeyBzZXRDb21wb25lbnREYXRhIH0gZnJvbSBcIi4vU2ltcGxlR2xvYmFsU3RhdGVcIlxuXG5pbnRlcmZhY2UgRm9ybUJ1aWxkZXJQcm9wcyB7XG4gICAgZmllbGRUeXBlOiBcInRleHRcIiB8IFwidGV4dGFyZWFcIiB8IFwiZHJvcGRvd25cIiB8IFwicmFkaW9cIiB8IFwiY2hpcHNcIlxuICAgIGxhYmVsOiBzdHJpbmdcbiAgICBzaG93TGFiZWw6IGJvb2xlYW5cbiAgICBwbGFjZWhvbGRlcjogc3RyaW5nXG4gICAgcGxhY2Vob2xkZXJDb2xvcjogc3RyaW5nXG4gICAgcmVxdWlyZWQ6IGJvb2xlYW5cbiAgICBkcm9wZG93bk9wdGlvbnM6IHsgbGFiZWw6IHN0cmluZzsgdmFsdWU6IHN0cmluZyB9W11cbiAgICByYWRpb09wdGlvbnM6IHsgbGFiZWw6IHN0cmluZzsgdmFsdWU6IHN0cmluZyB9W11cbiAgICBjaGlwU3VnZ2VzdGlvbnM6IHN0cmluZ1tdXG4gICAgYmFja2dyb3VuZENvbG9yOiBzdHJpbmdcbiAgICBib3JkZXJDb2xvcjogc3RyaW5nXG4gICAgZm9jdXNDb2xvcjogc3RyaW5nXG4gICAgdGV4dENvbG9yOiBzdHJpbmdcbiAgICBsYWJlbENvbG9yOiBzdHJpbmdcbiAgICBib3JkZXJSYWRpdXM6IHN0cmluZ1xuICAgIGhlaWdodE1vZGU6IFwiZml4ZWRcIiB8IFwiZml0XCJcbiAgICBoZWlnaHQ6IG51bWJlclxuICAgIHBhZGRpbmc6IHN0cmluZ1xuICAgIGxhYmVsRm9udDogYW55XG4gICAgaW5wdXRGb250OiBhbnlcbiAgICBzaG93Q2hpcHM6IGJvb2xlYW5cbiAgICBjaGlwQmFja2dyb3VuZENvbG9yOiBzdHJpbmdcbiAgICBjaGlwVGV4dENvbG9yOiBzdHJpbmdcbiAgICBjaGlwU2VsZWN0ZWRCYWNrZ3JvdW5kQ29sb3I6IHN0cmluZ1xuICAgIGNoaXBTZWxlY3RlZFRleHRDb2xvcjogc3RyaW5nXG4gICAgY2hpcEJvcmRlckNvbG9yOiBzdHJpbmdcbiAgICBjaGlwQm9yZGVyUmFkaXVzOiBudW1iZXJcbiAgICBjaGlwUGFkZGluZzogbnVtYmVyXG4gICAgY2hpcEdhcDogbnVtYmVyXG4gICAgY2hpcEZvbnQ6IGFueVxuICAgIHNob3dDaGlwQmVmb3JlSWNvbjogYm9vbGVhblxuICAgIGNoaXBCZWZvcmVJY29uOiBhbnlcbiAgICBzaG93Q2hpcEFmdGVySWNvbjogYm9vbGVhblxuICAgIGNoaXBBZnRlckljb246IGFueVxuICAgIGNoaXBJY29uU2l6ZTogbnVtYmVyXG4gICAgc2hvd0NsZWFyQnV0dG9uOiBib29sZWFuXG4gICAgY2xlYXJCdXR0b25Db2xvcjogc3RyaW5nXG4gICAgc2hvd0JlZm9yZUljb246IGJvb2xlYW5cbiAgICBiZWZvcmVJY29uOiBhbnlcbiAgICBzaG93QWZ0ZXJJY29uOiBib29sZWFuXG4gICAgYWZ0ZXJJY29uOiBhbnlcbiAgICBpY29uU2l6ZTogbnVtYmVyXG4gICAgc2hvd0J1dHRvbjogYm9vbGVhblxuICAgIGJ1dHRvblRleHQ6IHN0cmluZ1xuICAgIGJ1dHRvbkVuYWJsZWRCYWNrZ3JvdW5kOiBzdHJpbmdcbiAgICBidXR0b25FbmFibGVkVGV4dDogc3RyaW5nXG4gICAgYnV0dG9uRGlzYWJsZWRCYWNrZ3JvdW5kOiBzdHJpbmdcbiAgICBidXR0b25EaXNhYmxlZFRleHQ6IHN0cmluZ1xuICAgIGJ1dHRvbkJvcmRlclJhZGl1czogc3RyaW5nXG4gICAgYnV0dG9uUGFkZGluZzogc3RyaW5nXG4gICAgYnV0dG9uRm9udDogYW55XG4gICAgYnV0dG9uU3RhdGU/OiBcImVuYWJsZWRcIiB8IFwiZGlzYWJsZWRcIlxuICAgIGxpbmtlZEJ1dHRvbj86IGFueVxuICAgIGNvbXBvbmVudElkPzogc3RyaW5nXG4gICAgbGlua2VkQnV0dG9uSWQ/OiBzdHJpbmdcbiAgICBzdHlsZT86IENTU1Byb3BlcnRpZXNcbn1cblxuLyoqXG4gKiBAZnJhbWVyU3VwcG9ydGVkTGF5b3V0V2lkdGggYW55LXByZWZlci1maXhlZFxuICogQGZyYW1lclN1cHBvcnRlZExheW91dEhlaWdodCBhdXRvXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZvcm1CdWlsZGVyKHByb3BzOiBGb3JtQnVpbGRlclByb3BzKSB7XG4gICAgY29uc3Qge1xuICAgICAgICBmaWVsZFR5cGUgPSBcInRleHRcIixcbiAgICAgICAgbGFiZWwgPSBcIkZpZWxkIExhYmVsXCIsXG4gICAgICAgIHNob3dMYWJlbCA9IHRydWUsXG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCJFbnRlciB0ZXh0Li4uXCIsXG4gICAgICAgIHBsYWNlaG9sZGVyQ29sb3IgPSBcIiM5OTk5OTlcIixcbiAgICAgICAgcmVxdWlyZWQgPSBmYWxzZSxcbiAgICAgICAgZHJvcGRvd25PcHRpb25zID0gW1xuICAgICAgICAgICAgeyBsYWJlbDogXCJPcHRpb24gMVwiLCB2YWx1ZTogXCJvcHRpb24xXCIgfSxcbiAgICAgICAgICAgIHsgbGFiZWw6IFwiT3B0aW9uIDJcIiwgdmFsdWU6IFwib3B0aW9uMlwiIH0sXG4gICAgICAgICAgICB7IGxhYmVsOiBcIk9wdGlvbiAzXCIsIHZhbHVlOiBcIm9wdGlvbjNcIiB9LFxuICAgICAgICBdLFxuICAgICAgICByYWRpb09wdGlvbnMgPSBbXG4gICAgICAgICAgICB7IGxhYmVsOiBcIkNob2ljZSBBXCIsIHZhbHVlOiBcImFcIiB9LFxuICAgICAgICAgICAgeyBsYWJlbDogXCJDaG9pY2UgQlwiLCB2YWx1ZTogXCJiXCIgfSxcbiAgICAgICAgICAgIHsgbGFiZWw6IFwiQ2hvaWNlIENcIiwgdmFsdWU6IFwiY1wiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGNoaXBTdWdnZXN0aW9ucyA9IFtcbiAgICAgICAgICAgIFwiU3VnZ2VzdGlvbiAxXCIsXG4gICAgICAgICAgICBcIlN1Z2dlc3Rpb24gMlwiLFxuICAgICAgICAgICAgXCJTdWdnZXN0aW9uIDNcIixcbiAgICAgICAgICAgIFwiU3VnZ2VzdGlvbiA0XCIsXG4gICAgICAgIF0sXG4gICAgICAgIGJhY2tncm91bmRDb2xvciA9IFwiI0ZGRkZGRlwiLFxuICAgICAgICBib3JkZXJDb2xvciA9IFwiI0VFRUVFRVwiLFxuICAgICAgICBmb2N1c0NvbG9yID0gXCIjMDAwMDAwXCIsXG4gICAgICAgIHRleHRDb2xvciA9IFwiIzAwMDAwMFwiLFxuICAgICAgICBsYWJlbENvbG9yID0gXCIjMDAwMDAwXCIsXG4gICAgICAgIGJvcmRlclJhZGl1cyA9IFwiOHB4XCIsXG4gICAgICAgIGhlaWdodE1vZGUgPSBcImZpeGVkXCIsXG4gICAgICAgIGhlaWdodCA9IDQwLFxuICAgICAgICBwYWRkaW5nID0gXCIxMnB4XCIsXG4gICAgICAgIGxhYmVsRm9udCxcbiAgICAgICAgaW5wdXRGb250LFxuICAgICAgICBzaG93Q2hpcHMgPSB0cnVlLFxuICAgICAgICBjaGlwQmFja2dyb3VuZENvbG9yID0gXCIjRjVGNUY1XCIsXG4gICAgICAgIGNoaXBUZXh0Q29sb3IgPSBcIiMwMDAwMDBcIixcbiAgICAgICAgY2hpcFNlbGVjdGVkQmFja2dyb3VuZENvbG9yID0gXCIjMDAwMDAwXCIsXG4gICAgICAgIGNoaXBTZWxlY3RlZFRleHRDb2xvciA9IFwiI0ZGRkZGRlwiLFxuICAgICAgICBjaGlwQm9yZGVyQ29sb3IgPSBcIiNFRUVFRUVcIixcbiAgICAgICAgY2hpcEJvcmRlclJhZGl1cyA9IDE2LFxuICAgICAgICBjaGlwUGFkZGluZyA9IDgsXG4gICAgICAgIGNoaXBHYXAgPSA2LFxuICAgICAgICBjaGlwRm9udCxcbiAgICAgICAgc2hvd0NoaXBCZWZvcmVJY29uID0gZmFsc2UsXG4gICAgICAgIGNoaXBCZWZvcmVJY29uLFxuICAgICAgICBzaG93Q2hpcEFmdGVySWNvbiA9IGZhbHNlLFxuICAgICAgICBjaGlwQWZ0ZXJJY29uLFxuICAgICAgICBjaGlwSWNvblNpemUgPSAxMixcbiAgICAgICAgc2hvd0NsZWFyQnV0dG9uID0gdHJ1ZSxcbiAgICAgICAgY2xlYXJCdXR0b25Db2xvciA9IFwiI0NDQ0NDQ1wiLFxuICAgICAgICBzaG93QmVmb3JlSWNvbiA9IGZhbHNlLFxuICAgICAgICBiZWZvcmVJY29uLFxuICAgICAgICBzaG93QWZ0ZXJJY29uID0gZmFsc2UsXG4gICAgICAgIGFmdGVySWNvbixcbiAgICAgICAgaWNvblNpemUgPSAxNixcbiAgICAgICAgc2hvd0J1dHRvbiA9IGZhbHNlLFxuICAgICAgICBidXR0b25UZXh0ID0gXCJTdWJtaXRcIixcbiAgICAgICAgYnV0dG9uRW5hYmxlZEJhY2tncm91bmQgPSBcIiMwMDAwMDBcIixcbiAgICAgICAgYnV0dG9uRW5hYmxlZFRleHQgPSBcIiNGRkZGRkZcIixcbiAgICAgICAgYnV0dG9uRGlzYWJsZWRCYWNrZ3JvdW5kID0gXCIjQ0NDQ0NDXCIsXG4gICAgICAgIGJ1dHRvbkRpc2FibGVkVGV4dCA9IFwiIzY2NjY2NlwiLFxuICAgICAgICBidXR0b25Cb3JkZXJSYWRpdXMgPSBcIjhweFwiLFxuICAgICAgICBidXR0b25QYWRkaW5nID0gXCIxMnB4XCIsXG4gICAgICAgIGJ1dHRvbkZvbnQsXG4gICAgICAgIGJ1dHRvblN0YXRlLFxuICAgICAgICBsaW5rZWRCdXR0b24sXG4gICAgICAgIGNvbXBvbmVudElkID0gXCJmb3JtLVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpLFxuICAgIH0gPSBwcm9wc1xuXG4gICAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSB1c2VTdGF0ZShcIlwiKVxuICAgIGNvbnN0IFtzZWxlY3RlZENoaXBzLCBzZXRTZWxlY3RlZENoaXBzXSA9IHVzZVN0YXRlPHN0cmluZ1tdPihbXSlcbiAgICBjb25zdCBbaXNGb2N1c2VkLCBzZXRJc0ZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpXG5cbiAgICAvLyBNb3Rpb24gdmFsdWVzIGZvciBsaW5raW5nIHdpdGggZXh0ZXJuYWwgY29tcG9uZW50c1xuICAgIGNvbnN0IGJ1dHRvbkRpc2FibGVkTW90aW9uID0gdXNlTW90aW9uVmFsdWUoZmFsc2UpXG4gICAgY29uc3QgaGFzQ29udGVudE1vdGlvbiA9IHVzZU1vdGlvblZhbHVlKGZhbHNlKVxuXG4gICAgLy8gQ29tcG9uZW50IGxpbmtpbmcgc3lzdGVtIC0gd2lsbCBiZSBpbml0aWFsaXplZCBhZnRlciBoYXNDb250ZW50IGFuZCBpc0J1dHRvbkRpc2FibGVkIGFyZSBjYWxjdWxhdGVkXG4gICAgLy8gY29uc3QgeyBjcmVhdGVMaW5rLCB1cGRhdGVEYXRhIH0gPSB1c2VDb21wb25lbnRMaW5rKHtcbiAgICAvLyAgICAgaWQ6IGNvbXBvbmVudElkLFxuICAgIC8vICAgICB0eXBlOiAnZm9ybScsXG4gICAgLy8gICAgIGRhdGE6IHtcbiAgICAvLyAgICAgICAgIGhhc0NvbnRlbnQ6IGZhbHNlLCAvLyBXaWxsIGJlIHVwZGF0ZWQgaW4gdXNlRWZmZWN0XG4gICAgLy8gICAgICAgICBpc0J1dHRvbkRpc2FibGVkOiB0cnVlLCAvLyBXaWxsIGJlIHVwZGF0ZWQgaW4gdXNlRWZmZWN0XG4gICAgLy8gICAgICAgICB2YWx1ZSxcbiAgICAvLyAgICAgICAgIHNlbGVjdGVkQ2hpcHMsXG4gICAgLy8gICAgICAgICBmaWVsZFR5cGUsXG4gICAgLy8gICAgICAgICBsYWJlbFxuICAgIC8vICAgICB9LFxuICAgIC8vICAgICBvbkRhdGFVcGRhdGU6IChkYXRhKSA9PiB7XG4gICAgLy8gICAgICAgICAvLyBIYW5kbGUgdXBkYXRlcyBmcm9tIGxpbmtlZCBjb21wb25lbnRzXG4gICAgLy8gICAgICAgICBjb25zb2xlLmxvZygnRm9ybSByZWNlaXZlZCB1cGRhdGU6JywgZGF0YSlcbiAgICAvLyAgICAgfVxuICAgIC8vIH0pXG5cbiAgICAvLyBBdXRvLWxpbmsgd2l0aCBidXR0b24gaWYgSUQgaXMgcHJvdmlkZWRcbiAgICAvLyBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vICAgICBpZiAobGlua2VkQnV0dG9uSWQgJiYgbGlua2VkQnV0dG9uSWQudHJpbSgpICE9PSAnJykge1xuICAgIC8vICAgICAgICAgY3JlYXRlTGluayhsaW5rZWRCdXR0b25JZClcbiAgICAvLyAgICAgfVxuICAgIC8vIH0sIFtsaW5rZWRCdXR0b25JZCwgY3JlYXRlTGlua10pXG5cbiAgICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IHVzZUNhbGxiYWNrKChuZXdWYWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRWYWx1ZShuZXdWYWx1ZSkpXG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBoYW5kbGVDaGlwQ2xpY2sgPSB1c2VDYWxsYmFjayhcbiAgICAgICAgKGNoaXA6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkVHlwZSA9PT0gXCJjaGlwc1wiKSB7XG4gICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRDaGlwcygocHJldikgPT5cbiAgICAgICAgICAgICAgICAgICAgcHJldi5pbmNsdWRlcyhjaGlwKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBwcmV2LmZpbHRlcigoYykgPT4gYyAhPT0gY2hpcClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogWy4uLnByZXYsIGNoaXBdXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgdGV4dCBhbmQgdGV4dGFyZWEgZmllbGRzLCBhY2N1bXVsYXRlIGNoaXBzIHdpdGggY29tbWEgc2VwYXJhdGlvblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50cmltKCkgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUoY2hpcClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSgocHJldikgPT4gcHJldiArIFwiLCBcIiArIGNoaXApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbZmllbGRUeXBlLCB2YWx1ZV1cbiAgICApXG5cbiAgICBjb25zdCBoYW5kbGVGb2N1cyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldElzRm9jdXNlZCh0cnVlKSlcbiAgICB9LCBbXSlcblxuICAgIGNvbnN0IGhhbmRsZUJsdXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRJc0ZvY3VzZWQoZmFsc2UpKVxuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgaGFuZGxlQ2xlYXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHNldFZhbHVlKFwiXCIpXG4gICAgICAgIHNldFNlbGVjdGVkQ2hpcHMoW10pXG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBoYW5kbGVCdXR0b25DbGljayA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgLy8gQnV0dG9uIGNsaWNrIGhhbmRsZXIgLSBjYW4gYmUgY3VzdG9taXplZFxuICAgICAgICBjb25zb2xlLmxvZyhcIkZvcm0gc3VibWl0dGVkIHdpdGggdmFsdWU6XCIsIHZhbHVlKVxuICAgIH0sIFt2YWx1ZV0pXG5cbiAgICBjb25zdCBnZXRJbnB1dFBhZGRpbmcgPSAoKSA9PiB7XG4gICAgICAgIC8vIFBhcnNlIHBhZGRpbmcgc3RyaW5nIChlLmcuLCBcIjEycHhcIiBvciBcIjEycHggMTZweCAxMnB4IDE2cHhcIilcbiAgICAgICAgY29uc3QgcGFkZGluZ1ZhbHVlcyA9IHBhZGRpbmcuc3BsaXQoJyAnKS5tYXAocCA9PiBwYXJzZUludChwLnJlcGxhY2UoJ3B4JywgJycpKSlcbiAgICAgICAgY29uc3QgW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF0gPSBwYWRkaW5nVmFsdWVzLmxlbmd0aCA9PT0gMSBcbiAgICAgICAgICAgID8gW3BhZGRpbmdWYWx1ZXNbMF0sIHBhZGRpbmdWYWx1ZXNbMF0sIHBhZGRpbmdWYWx1ZXNbMF0sIHBhZGRpbmdWYWx1ZXNbMF1dXG4gICAgICAgICAgICA6IHBhZGRpbmdWYWx1ZXMubGVuZ3RoID09PSAyXG4gICAgICAgICAgICA/IFtwYWRkaW5nVmFsdWVzWzBdLCBwYWRkaW5nVmFsdWVzWzFdLCBwYWRkaW5nVmFsdWVzWzBdLCBwYWRkaW5nVmFsdWVzWzFdXVxuICAgICAgICAgICAgOiBwYWRkaW5nVmFsdWVzLmxlbmd0aCA9PT0gNFxuICAgICAgICAgICAgPyBwYWRkaW5nVmFsdWVzXG4gICAgICAgICAgICA6IFsxMiwgMTIsIDEyLCAxMl0gLy8gZmFsbGJhY2tcblxuICAgICAgICBsZXQgbGVmdFBhZGRpbmcgPSBsZWZ0XG4gICAgICAgIGxldCByaWdodFBhZGRpbmcgPSByaWdodFxuXG4gICAgICAgIGlmIChzaG93QmVmb3JlSWNvbiAmJiBiZWZvcmVJY29uKSB7XG4gICAgICAgICAgICBsZWZ0UGFkZGluZyA9IGxlZnQgKyBpY29uU2l6ZSArIDhcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG93QWZ0ZXJJY29uICYmIGFmdGVySWNvbikge1xuICAgICAgICAgICAgcmlnaHRQYWRkaW5nID0gcmlnaHQgKyBpY29uU2l6ZSArIDhcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHNob3dDbGVhckJ1dHRvbiAmJlxuICAgICAgICAgICAgdmFsdWUgJiZcbiAgICAgICAgICAgIChmaWVsZFR5cGUgPT09IFwidGV4dFwiIHx8IGZpZWxkVHlwZSA9PT0gXCJ0ZXh0YXJlYVwiKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJpZ2h0UGFkZGluZyA9IE1hdGgubWF4KHJpZ2h0UGFkZGluZywgcmlnaHQgKyAzMilcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IGxlZnRQYWRkaW5nLCByaWdodFBhZGRpbmcsIHRvcFBhZGRpbmc6IHRvcCwgYm90dG9tUGFkZGluZzogYm90dG9tIH1cbiAgICB9XG5cbiAgICBjb25zdCB7IGxlZnRQYWRkaW5nLCByaWdodFBhZGRpbmcsIHRvcFBhZGRpbmcsIGJvdHRvbVBhZGRpbmcgfSA9IGdldElucHV0UGFkZGluZygpXG5cbiAgICBjb25zdCBpbnB1dFN0eWxlczogQ1NTUHJvcGVydGllcyA9IHtcbiAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgICAuLi4oaGVpZ2h0TW9kZSA9PT0gXCJmaXhlZFwiICYmIHsgaGVpZ2h0OiBgJHtoZWlnaHR9cHhgIH0pLFxuICAgICAgICAuLi4oaGVpZ2h0TW9kZSA9PT0gXCJmaXRcIiAmJiB7IG1pbkhlaWdodDogYCR7aGVpZ2h0fXB4YCB9KSxcbiAgICAgICAgcGFkZGluZ0xlZnQ6IGAke2xlZnRQYWRkaW5nfXB4YCxcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiBgJHtyaWdodFBhZGRpbmd9cHhgLFxuICAgICAgICBwYWRkaW5nVG9wOiBgJHt0b3BQYWRkaW5nfXB4YCxcbiAgICAgICAgcGFkZGluZ0JvdHRvbTogYCR7Ym90dG9tUGFkZGluZ31weGAsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcixcbiAgICAgICAgYm9yZGVyOiBgMXB4IHNvbGlkICR7aXNGb2N1c2VkID8gZm9jdXNDb2xvciA6IGJvcmRlckNvbG9yfWAsXG4gICAgICAgIGJvcmRlclJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICBjb2xvcjogdGV4dENvbG9yLFxuICAgICAgICBvdXRsaW5lOiBcIm5vbmVcIixcbiAgICAgICAgdHJhbnNpdGlvbjogXCJib3JkZXItY29sb3IgMC4ycyBlYXNlXCIsXG4gICAgICAgIC4uLmlucHV0Rm9udCxcbiAgICAgICAgZm9udFNpemU6IGlucHV0Rm9udD8uZm9udFNpemUgfHwgXCIxNHB4XCIsXG4gICAgfVxuXG5cbiAgICBjb25zdCByZW5kZXJJY29uID0gKFxuICAgICAgICBpY29uOiBhbnksXG4gICAgICAgIHBvc2l0aW9uOiBcImJlZm9yZVwiIHwgXCJhZnRlclwiXG4gICAgKSA9PiB7XG4gICAgICAgIGlmICghaWNvbikgcmV0dXJuIG51bGxcblxuICAgICAgICAvLyBQYXJzZSBwYWRkaW5nIHRvIGdldCBsZWZ0L3JpZ2h0IHZhbHVlc1xuICAgICAgICBjb25zdCBwYWRkaW5nVmFsdWVzID0gcGFkZGluZy5zcGxpdCgnICcpLm1hcChwID0+IHBhcnNlSW50KHAucmVwbGFjZSgncHgnLCAnJykpKVxuICAgICAgICBjb25zdCBbLCByaWdodCwgLCBsZWZ0XSA9IHBhZGRpbmdWYWx1ZXMubGVuZ3RoID09PSAxIFxuICAgICAgICAgICAgPyBbcGFkZGluZ1ZhbHVlc1swXSwgcGFkZGluZ1ZhbHVlc1swXSwgcGFkZGluZ1ZhbHVlc1swXSwgcGFkZGluZ1ZhbHVlc1swXV1cbiAgICAgICAgICAgIDogcGFkZGluZ1ZhbHVlcy5sZW5ndGggPT09IDJcbiAgICAgICAgICAgID8gW3BhZGRpbmdWYWx1ZXNbMF0sIHBhZGRpbmdWYWx1ZXNbMV0sIHBhZGRpbmdWYWx1ZXNbMF0sIHBhZGRpbmdWYWx1ZXNbMV1dXG4gICAgICAgICAgICA6IHBhZGRpbmdWYWx1ZXMubGVuZ3RoID09PSA0XG4gICAgICAgICAgICA/IHBhZGRpbmdWYWx1ZXNcbiAgICAgICAgICAgIDogWzEyLCAxMiwgMTIsIDEyXSAvLyBmYWxsYmFja1xuXG4gICAgICAgIGNvbnN0IGljb25TdHlsZTogQ1NTUHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB0b3A6IFwiNTAlXCIsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgtNTAlKVwiLFxuICAgICAgICAgICAgW3Bvc2l0aW9uID09PSBcImJlZm9yZVwiID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCJdOlxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID09PSBcImJlZm9yZVwiXG4gICAgICAgICAgICAgICAgICAgID8gYCR7bGVmdH1weGBcbiAgICAgICAgICAgICAgICAgICAgOiBgJHtyaWdodH1weGAsXG4gICAgICAgICAgICB3aWR0aDogYCR7aWNvblNpemV9cHhgLFxuICAgICAgICAgICAgaGVpZ2h0OiBgJHtpY29uU2l6ZX1weGAsXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICAgICAgICAgIHpJbmRleDogMSxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiA8ZGl2IHN0eWxlPXtpY29uU3R5bGV9PntpY29ufTwvZGl2PlxuICAgIH1cblxuICAgIGNvbnN0IHJlbmRlckNoaXBJY29uID0gKGljb246IGFueSkgPT4ge1xuICAgICAgICBpZiAoIWljb24pIHJldHVybiBudWxsXG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogYCR7Y2hpcEljb25TaXplfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBgJHtjaGlwSWNvblNpemV9cHhgLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7aWNvbn1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgZm9ybSBoYXMgY29udGVudCBmb3IgYnV0dG9uIHN0YXRlXG4gICAgY29uc3QgaGFzQ29udGVudCA9IHZhbHVlLnRyaW0oKS5sZW5ndGggPiAwIHx8IHNlbGVjdGVkQ2hpcHMubGVuZ3RoID4gMFxuICAgIGNvbnN0IGlzQnV0dG9uRGlzYWJsZWQgPSBidXR0b25TdGF0ZSA/IGJ1dHRvblN0YXRlID09PSBcImRpc2FibGVkXCIgOiAhaGFzQ29udGVudFxuXG4gICAgLy8gVXBkYXRlIG1vdGlvbiB2YWx1ZXMgd2hlbiBjb250ZW50IGNoYW5nZXNcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBoYXNDb250ZW50TW90aW9uLnNldChoYXNDb250ZW50KVxuICAgICAgICBidXR0b25EaXNhYmxlZE1vdGlvbi5zZXQoaXNCdXR0b25EaXNhYmxlZClcbiAgICB9LCBbaGFzQ29udGVudCwgaXNCdXR0b25EaXNhYmxlZCwgaGFzQ29udGVudE1vdGlvbiwgYnV0dG9uRGlzYWJsZWRNb3Rpb25dKVxuXG4gICAgLy8gVXBkYXRlIGNvbXBvbmVudCBkYXRhIHdoZW4gZm9ybSBzdGF0ZSBjaGFuZ2VzXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0Q29tcG9uZW50RGF0YShjb21wb25lbnRJZCwgJ2Zvcm0nLCB7XG4gICAgICAgICAgICBoYXNDb250ZW50LFxuICAgICAgICAgICAgaXNCdXR0b25EaXNhYmxlZCxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgc2VsZWN0ZWRDaGlwcyxcbiAgICAgICAgICAgIGZpZWxkVHlwZSxcbiAgICAgICAgICAgIGxhYmVsXG4gICAgICAgIH0pXG4gICAgfSwgW2hhc0NvbnRlbnQsIGlzQnV0dG9uRGlzYWJsZWQsIHZhbHVlLCBzZWxlY3RlZENoaXBzLCBmaWVsZFR5cGUsIGxhYmVsLCBjb21wb25lbnRJZF0pXG5cbiAgICAvLyBTeW5jIHdpdGggbGlua2VkIGJ1dHRvbiBpZiBwcm92aWRlZFxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChsaW5rZWRCdXR0b24gJiYgbGlua2VkQnV0dG9uLnNldCkge1xuICAgICAgICAgICAgbGlua2VkQnV0dG9uLnNldCh7XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGlzQnV0dG9uRGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgaGFzQ29udGVudDogaGFzQ29udGVudCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRDaGlwczogc2VsZWN0ZWRDaGlwc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH0sIFtpc0J1dHRvbkRpc2FibGVkLCBoYXNDb250ZW50LCB2YWx1ZSwgc2VsZWN0ZWRDaGlwcywgbGlua2VkQnV0dG9uXSlcblxuICAgIGNvbnN0IHJlbmRlcklucHV0ID0gKCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGZpZWxkVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiIH19PlxuICAgICAgICAgICAgICAgICAgICAgICAge3Nob3dCZWZvcmVJY29uICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlSWNvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckljb24oYmVmb3JlSWNvbiwgXCJiZWZvcmVcIil9XG4gICAgICAgICAgICAgICAgICAgICAgICB7c2hvd0FmdGVySWNvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVySWNvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckljb24oYWZ0ZXJJY29uLCBcImFmdGVyXCIpfVxuICAgICAgICAgICAgICAgICAgICAgICAgPHRleHRhcmVhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gaGFuZGxlSW5wdXRDaGFuZ2UoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRm9jdXM9e2hhbmRsZUZvY3VzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQmx1cj17aGFuZGxlQmx1cn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj17cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ9e3JlcXVpcmVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZvcm0tYnVpbGRlci10ZXh0YXJlYVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uaW5wdXRTdHlsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkhlaWdodDogaGVpZ2h0TW9kZSA9PT0gXCJmaXRcIiA/IGAke2hlaWdodH1weGAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6ZTogaGVpZ2h0TW9kZSA9PT0gXCJmaXRcIiA/IFwibm9uZVwiIDogXCJ2ZXJ0aWNhbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBcImluaGVyaXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtzaG93Q2xlYXJCdXR0b24gJiYgdmFsdWUgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZUNsZWFyfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dBZnRlckljb24gJiYgYWZ0ZXJJY29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYCR7cmlnaHRQYWRkaW5nICsgaWNvblNpemUgKyA4fXB4YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiOHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IFwiOHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNsZWFyQnV0dG9uQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogXCIxNnB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogXCIyNHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiMjRweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IFwiNTAlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBcImJhY2tncm91bmQtY29sb3IgMC4ycyBlYXNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VFbnRlcj17KGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY3VycmVudFRhcmdldC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiI0YwRjBGMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17KGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY3VycmVudFRhcmdldC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidHJhbnNwYXJlbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiQ2xlYXIgaW5wdXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgw5dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgY2FzZSBcImRyb3Bkb3duXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiIH19PlxuICAgICAgICAgICAgICAgICAgICAgICAge3Nob3dCZWZvcmVJY29uICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlSWNvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckljb24oYmVmb3JlSWNvbiwgXCJiZWZvcmVcIil9XG4gICAgICAgICAgICAgICAgICAgICAgICB7c2hvd0FmdGVySWNvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVySWNvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckljb24oYWZ0ZXJJY29uLCBcImFmdGVyXCIpfVxuICAgICAgICAgICAgICAgICAgICAgICAgPHNlbGVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IGhhbmRsZUlucHV0Q2hhbmdlKGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkZvY3VzPXtoYW5kbGVGb2N1c31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkJsdXI9e2hhbmRsZUJsdXJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ9e3JlcXVpcmVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9e3BsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmlucHV0U3R5bGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBlYXJhbmNlOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiBgdXJsKFwiZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9VVRGLTgsJTNjc3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zycgdmlld0JveD0nMCAwIDI0IDI0JyBmaWxsPSdub25lJyBzdHJva2U9JyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRleHRDb2xvcil9JyBzdHJva2Utd2lkdGg9JzInIHN0cm9rZS1saW5lY2FwPSdyb3VuZCcgc3Ryb2tlLWxpbmVqb2luPSdyb3VuZCclM2UlM2Nwb2x5bGluZSBwb2ludHM9JzYsOSAxMiwxNSAxOCw5JyUzZSUzYy9wb2x5bGluZSUzZSUzYy9zdmclM2VcIilgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kUmVwZWF0OiBcIm5vLXJlcGVhdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93QWZ0ZXJJY29uICYmIGFmdGVySWNvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYHJpZ2h0ICR7cmlnaHRQYWRkaW5nICsgaWNvblNpemUgKyAxNn1weCBjZW50ZXJgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcInJpZ2h0IDEycHggY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRTaXplOiBcIjE2cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIj57cGxhY2Vob2xkZXJ9PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2Ryb3Bkb3duT3B0aW9ucy5tYXAoKG9wdGlvbiwgaW5kZXgpID0+IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiBrZXk9e2luZGV4fSB2YWx1ZT17b3B0aW9uLnZhbHVlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtvcHRpb24ubGFiZWx9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgY2FzZSBcInJhZGlvXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhcDogXCI4cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtyYWRpb09wdGlvbnMubWFwKChvcHRpb24sIGluZGV4KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17aW5kZXh9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXA6IFwiOHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uaW5wdXRGb250LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IGlucHV0Rm9udD8uZm9udFNpemUgfHwgXCIxNHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwicmFkaW8tZ3JvdXBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e29wdGlvbi52YWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e3ZhbHVlID09PSBvcHRpb24udmFsdWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlSW5wdXRDaGFuZ2UoZS50YXJnZXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VudENvbG9yOiBmb2N1c0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcIjE2cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiMTZweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9e3sgY29sb3I6IHRleHRDb2xvciB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtvcHRpb24ubGFiZWx9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgY2FzZSBcImNoaXBzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5pbnB1dFN0eWxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5IZWlnaHQ6IGhlaWdodE1vZGUgPT09IFwiZml0XCIgPyBgJHtoZWlnaHR9cHhgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsZXhXcmFwOiBcIndyYXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXA6IFwiNnB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZUZvY3VzfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25CbHVyPXtoYW5kbGVCbHVyfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg9ezB9XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtzaG93QmVmb3JlSWNvbiAmJiBiZWZvcmVJY29uICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogYCR7bGVmdFBhZGRpbmd9cHhgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBcIjUwJVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoLTUwJSlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBgJHtpY29uU2l6ZX1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGAke2ljb25TaXplfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIiMwMDAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgekluZGV4OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2JlZm9yZUljb259XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAge3Nob3dBZnRlckljb24gJiYgYWZ0ZXJJY29uICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGAke3JpZ2h0UGFkZGluZ31weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IFwiNTAlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgtNTAlKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGAke2ljb25TaXplfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogYCR7aWNvblNpemV9cHhgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwiIzAwMDAwMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7YWZ0ZXJJY29ufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHtzZWxlY3RlZENoaXBzLm1hcCgoY2hpcCwgaW5kZXgpID0+IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2luZGV4fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaXBTZWxlY3RlZEJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjaGlwU2VsZWN0ZWRUZXh0Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IGAxcHggc29saWQgJHtjaGlwQm9yZGVyQ29sb3J9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IGAke2NoaXBQYWRkaW5nfXB4ICR7Y2hpcFBhZGRpbmcgKiAxLjV9cHhgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBgJHtjaGlwQm9yZGVyUmFkaXVzfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhcDogXCI0cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jaGlwRm9udCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBjaGlwRm9udD8uZm9udFNpemUgfHwgXCIxMnB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGhhbmRsZUNoaXBDbGljayhjaGlwKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzaG93Q2hpcEJlZm9yZUljb24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaXBCZWZvcmVJY29uICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJDaGlwSWNvbihjaGlwQmVmb3JlSWNvbil9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjaGlwfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c2hvd0NoaXBBZnRlckljb24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaXBBZnRlckljb24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckNoaXBJY29uKGNoaXBBZnRlckljb24pfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBzdHlsZT17eyBmb250U2l6ZTogXCIxMHB4XCIgfX0+w5c8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgICAgICAgICAgICB7c2VsZWN0ZWRDaGlwcy5sZW5ndGggPT09IDAgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogcGxhY2Vob2xkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBpbnB1dEZvbnQ/LmZvbnRTaXplIHx8IFwiMTRweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0JlZm9yZUljb24gJiYgYmVmb3JlSWNvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYCR7bGVmdFBhZGRpbmcgKyBpY29uU2l6ZSArIDh9cHhgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjBweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3BsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICB7c2hvd0NsZWFyQnV0dG9uICYmIHNlbGVjdGVkQ2hpcHMubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlQ2xlYXJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0FmdGVySWNvbiAmJiBhZnRlckljb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHtyaWdodFBhZGRpbmcgKyBpY29uU2l6ZSArIDh9cHhgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCI4cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogXCI4cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY2xlYXJCdXR0b25Db2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBcIjE2cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcIjI0cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCIyNHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCI1MCVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IFwiYmFja2dyb3VuZC1jb2xvciAwLjJzIGVhc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpJbmRleDogMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyPXsoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnN0eWxlLmJhY2tncm91bmRDb2xvciA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIjRjBGMEYwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXsoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnN0eWxlLmJhY2tncm91bmRDb2xvciA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0cmFuc3BhcmVudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJDbGVhciBpbnB1dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDDl1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgcG9zaXRpb246IFwicmVsYXRpdmVcIiB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtzaG93QmVmb3JlSWNvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUljb24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJJY29uKGJlZm9yZUljb24sIFwiYmVmb3JlXCIpfVxuICAgICAgICAgICAgICAgICAgICAgICAge3Nob3dBZnRlckljb24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlckljb24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJJY29uKGFmdGVySWNvbiwgXCJhZnRlclwiKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBoYW5kbGVJbnB1dENoYW5nZShlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Gb2N1cz17aGFuZGxlRm9jdXN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25CbHVyPXtoYW5kbGVCbHVyfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPXtwbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZD17cmVxdWlyZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1idWlsZGVyLWlucHV0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17aW5wdXRTdHlsZXN9XG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAge3Nob3dDbGVhckJ1dHRvbiAmJiB2YWx1ZSAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlQ2xlYXJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0FmdGVySWNvbiAmJiBhZnRlckljb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHtyaWdodFBhZGRpbmcgKyBpY29uU2l6ZSArIDh9cHhgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCI4cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogXCI4cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY2xlYXJCdXR0b25Db2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBcIjE2cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcIjI0cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCIyNHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCI1MCVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IFwiYmFja2dyb3VuZC1jb2xvciAwLjJzIGVhc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpJbmRleDogMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUVudGVyPXsoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnN0eWxlLmJhY2tncm91bmRDb2xvciA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIjRjBGMEYwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXsoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnN0eWxlLmJhY2tncm91bmRDb2xvciA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0cmFuc3BhcmVudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJDbGVhciBpbnB1dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDDl1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxzdHlsZT5cbiAgICAgICAgICAgICAgICB7YFxuICAgICAgICAgICAgICAgICAgICAuZm9ybS1idWlsZGVyLWlucHV0OjpwbGFjZWhvbGRlciB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJHtwbGFjZWhvbGRlckNvbG9yfSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC5mb3JtLWJ1aWxkZXItdGV4dGFyZWE6OnBsYWNlaG9sZGVyIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAke3BsYWNlaG9sZGVyQ29sb3J9ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBgfVxuICAgICAgICAgICAgPC9zdHlsZT5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAuLi5wcm9wcy5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgIGdhcDogXCI4cHhcIixcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge3Nob3dMYWJlbCAmJiAoXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogbGFiZWxDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5sYWJlbEZvbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IGxhYmVsRm9udD8uZm9udFNpemUgfHwgXCIxNHB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodDogbGFiZWxGb250Py5mb250V2VpZ2h0IHx8IFwiNTAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICB7bGFiZWx9XG4gICAgICAgICAgICAgICAgICAgICAgICB7cmVxdWlyZWQgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7IGNvbG9yOiBcIiNGRjU1ODhcIiwgbWFyZ2luTGVmdDogXCIycHhcIiB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAgICAgIHtyZW5kZXJJbnB1dCgpfVxuXG4gICAgICAgICAgICAgICAge3Nob3dDaGlwcyAmJlxuICAgICAgICAgICAgICAgICAgICAoZmllbGRUeXBlID09PSBcInRleHRcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRUeXBlID09PSBcInRleHRhcmVhXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkVHlwZSA9PT0gXCJjaGlwc1wiKSAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsZXhXcmFwOiBcIndyYXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FwOiBgJHtjaGlwR2FwfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBcIjRweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2NoaXBTdWdnZXN0aW9ucy5tYXAoKGNoaXAsIGluZGV4KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17aW5kZXh9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGhhbmRsZUNoaXBDbGljayhjaGlwKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBzZWxlY3RlZENoaXBzLmluY2x1ZGVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNoaXBTZWxlY3RlZEJhY2tncm91bmRDb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNoaXBCYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHNlbGVjdGVkQ2hpcHMuaW5jbHVkZXMoY2hpcClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjaGlwU2VsZWN0ZWRUZXh0Q29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjaGlwVGV4dENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogYDFweCBzb2xpZCAke2NoaXBCb3JkZXJDb2xvcn1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogYCR7Y2hpcEJvcmRlclJhZGl1c31weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogYCR7Y2hpcFBhZGRpbmd9cHggJHtjaGlwUGFkZGluZyAqIDEuNX1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBcImFsbCAwLjJzIGVhc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhcDogXCI4cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jaGlwRm9udCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogY2hpcEZvbnQ/LmZvbnRTaXplIHx8IFwiMTJweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VFbnRlcj17KGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGVkQ2hpcHMuaW5jbHVkZXMoY2hpcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnN0eWxlLmJhY2tncm91bmRDb2xvciA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiNGMEYwRjBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU9eyhlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxlY3RlZENoaXBzLmluY2x1ZGVzKGNoaXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuY3VycmVudFRhcmdldC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpcEJhY2tncm91bmRDb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzaG93Q2hpcEJlZm9yZUljb24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlwQmVmb3JlSWNvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckNoaXBJY29uKGNoaXBCZWZvcmVJY29uKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjaGlwfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3Nob3dDaGlwQWZ0ZXJJY29uICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpcEFmdGVySWNvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckNoaXBJY29uKGNoaXBBZnRlckljb24pfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICApfVxuXG4gICAgICAgICAgICAgICAge3Nob3dCdXR0b24gJiYgKFxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZUJ1dHRvbkNsaWNrfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzQnV0dG9uRGlzYWJsZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogaXNCdXR0b25EaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGJ1dHRvbkRpc2FibGVkQmFja2dyb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGJ1dHRvbkVuYWJsZWRCYWNrZ3JvdW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBpc0J1dHRvbkRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYnV0dG9uRGlzYWJsZWRUZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYnV0dG9uRW5hYmxlZFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IGJ1dHRvbkJvcmRlclJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBidXR0b25QYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogaXNCdXR0b25EaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwibm90LWFsbG93ZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwicG9pbnRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IFwiYWxsIDAuMnMgZWFzZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmU6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogXCI4cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5idXR0b25Gb250LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBidXR0b25Gb250Py5mb250U2l6ZSB8fCBcIjE0cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBpc0J1dHRvbkRpc2FibGVkID8gMC42IDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtidXR0b25UZXh0fVxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvPlxuICAgIClcbn1cblxuYWRkUHJvcGVydHlDb250cm9scyhGb3JtQnVpbGRlciwge1xuICAgIC8vID09PSBCQVNJQyBTRVRUSU5HUyA9PT1cbiAgICBmaWVsZFR5cGU6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuRW51bSxcbiAgICAgICAgdGl0bGU6IFwiRmllbGQgVHlwZVwiLFxuICAgICAgICBvcHRpb25zOiBbXCJ0ZXh0XCIsIFwidGV4dGFyZWFcIiwgXCJkcm9wZG93blwiLCBcInJhZGlvXCIsIFwiY2hpcHNcIl0sXG4gICAgICAgIG9wdGlvblRpdGxlczogW1wiVGV4dFwiLCBcIlRleHQgQXJlYVwiLCBcIkRyb3Bkb3duXCIsIFwiUmFkaW9cIiwgXCJDaGlwc1wiXSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcInRleHRcIixcbiAgICB9LFxuICAgIHJlcXVpcmVkOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkJvb2xlYW4sXG4gICAgICAgIHRpdGxlOiBcIlJlcXVpcmVkXCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gICAgICAgIGVuYWJsZWRUaXRsZTogXCJZZXNcIixcbiAgICAgICAgZGlzYWJsZWRUaXRsZTogXCJOb1wiLFxuICAgIH0sXG5cbiAgICAvLyA9PT0gTEFCRUwgU0VUVElOR1MgPT09XG4gICAgc2hvd0xhYmVsOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkJvb2xlYW4sXG4gICAgICAgIHRpdGxlOiBcIlNob3cgTGFiZWxcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICAgICAgICBlbmFibGVkVGl0bGU6IFwiU2hvd1wiLFxuICAgICAgICBkaXNhYmxlZFRpdGxlOiBcIkhpZGVcIixcbiAgICB9LFxuICAgIGxhYmVsOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLlN0cmluZyxcbiAgICAgICAgdGl0bGU6IFwiTGFiZWxcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcIkZpZWxkIExhYmVsXCIsXG4gICAgICAgIGhpZGRlbjogKHsgc2hvd0xhYmVsIH0pID0+ICFzaG93TGFiZWwsXG4gICAgfSxcbiAgICBsYWJlbENvbG9yOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkNvbG9yLFxuICAgICAgICB0aXRsZTogXCJMYWJlbCBDb2xvclwiLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IFwiIzAwMDAwMFwiLFxuICAgICAgICBoaWRkZW46ICh7IHNob3dMYWJlbCB9KSA9PiAhc2hvd0xhYmVsLFxuICAgIH0sXG4gICAgbGFiZWxGb250OiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkZvbnQsXG4gICAgICAgIHRpdGxlOiBcIkxhYmVsIEZvbnRcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB7XG4gICAgICAgICAgICBmb250U2l6ZTogXCIxNHB4XCIsXG4gICAgICAgICAgICB2YXJpYW50OiBcIk1lZGl1bVwiLFxuICAgICAgICAgICAgbGV0dGVyU3BhY2luZzogXCItMC4wMWVtXCIsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiBcIjEuMmVtXCIsXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRyb2xzOiBcImV4dGVuZGVkXCIsXG4gICAgICAgIGRlZmF1bHRGb250VHlwZTogXCJzYW5zLXNlcmlmXCIsXG4gICAgICAgIGhpZGRlbjogKHsgc2hvd0xhYmVsIH0pID0+ICFzaG93TGFiZWwsXG4gICAgfSxcblxuICAgIC8vID09PSBGSUVMRC1TUEVDSUZJQyBPUFRJT05TID09PVxuICAgIGRyb3Bkb3duT3B0aW9uczoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5BcnJheSxcbiAgICAgICAgdGl0bGU6IFwiRHJvcGRvd24gT3B0aW9uc1wiLFxuICAgICAgICBjb250cm9sOiB7XG4gICAgICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5PYmplY3QsXG4gICAgICAgICAgICBjb250cm9sczoge1xuICAgICAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLlN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBcIk9wdGlvblwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuU3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IFwib3B0aW9uXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogW1xuICAgICAgICAgICAgeyBsYWJlbDogXCJPcHRpb24gMVwiLCB2YWx1ZTogXCJvcHRpb24xXCIgfSxcbiAgICAgICAgICAgIHsgbGFiZWw6IFwiT3B0aW9uIDJcIiwgdmFsdWU6IFwib3B0aW9uMlwiIH0sXG4gICAgICAgICAgICB7IGxhYmVsOiBcIk9wdGlvbiAzXCIsIHZhbHVlOiBcIm9wdGlvbjNcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBoaWRkZW46ICh7IGZpZWxkVHlwZSB9KSA9PiBmaWVsZFR5cGUgIT09IFwiZHJvcGRvd25cIixcbiAgICB9LFxuICAgIHJhZGlvT3B0aW9uczoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5BcnJheSxcbiAgICAgICAgdGl0bGU6IFwiUmFkaW8gT3B0aW9uc1wiLFxuICAgICAgICBjb250cm9sOiB7XG4gICAgICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5PYmplY3QsXG4gICAgICAgICAgICBjb250cm9sczoge1xuICAgICAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLlN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBcIkNob2ljZVwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuU3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IFwiY2hvaWNlXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogW1xuICAgICAgICAgICAgeyBsYWJlbDogXCJDaG9pY2UgQVwiLCB2YWx1ZTogXCJhXCIgfSxcbiAgICAgICAgICAgIHsgbGFiZWw6IFwiQ2hvaWNlIEJcIiwgdmFsdWU6IFwiYlwiIH0sXG4gICAgICAgICAgICB7IGxhYmVsOiBcIkNob2ljZSBDXCIsIHZhbHVlOiBcImNcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBoaWRkZW46ICh7IGZpZWxkVHlwZSB9KSA9PiBmaWVsZFR5cGUgIT09IFwicmFkaW9cIixcbiAgICB9LFxuXG4gICAgLy8gPT09IElOUFVUIENPTlRFTlQgPT09XG4gICAgcGxhY2Vob2xkZXI6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuU3RyaW5nLFxuICAgICAgICB0aXRsZTogXCJQbGFjZWhvbGRlclwiLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IFwiRW50ZXIgdGV4dC4uLlwiLFxuICAgICAgICBoaWRkZW46ICh7IGZpZWxkVHlwZSB9KSA9PiBmaWVsZFR5cGUgPT09IFwicmFkaW9cIixcbiAgICB9LFxuICAgIHBsYWNlaG9sZGVyQ29sb3I6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuQ29sb3IsXG4gICAgICAgIHRpdGxlOiBcIlBsYWNlaG9sZGVyIENvbG9yXCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCIjOTk5OTk5XCIsXG4gICAgICAgIGhpZGRlbjogKHsgZmllbGRUeXBlIH0pID0+IGZpZWxkVHlwZSA9PT0gXCJyYWRpb1wiLFxuICAgIH0sXG5cbiAgICAvLyA9PT0gQ0xFQVIgQlVUVE9OID09PVxuICAgIHNob3dDbGVhckJ1dHRvbjoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5Cb29sZWFuLFxuICAgICAgICB0aXRsZTogXCJDbGVhciBCdXR0b25cIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICAgICAgICBlbmFibGVkVGl0bGU6IFwiU2hvd1wiLFxuICAgICAgICBkaXNhYmxlZFRpdGxlOiBcIkhpZGVcIixcbiAgICAgICAgaGlkZGVuOiAoeyBmaWVsZFR5cGUgfSkgPT5cbiAgICAgICAgICAgIGZpZWxkVHlwZSAhPT0gXCJ0ZXh0XCIgJiYgZmllbGRUeXBlICE9PSBcInRleHRhcmVhXCIgJiYgZmllbGRUeXBlICE9PSBcImNoaXBzXCIsXG4gICAgfSxcbiAgICBjbGVhckJ1dHRvbkNvbG9yOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkNvbG9yLFxuICAgICAgICB0aXRsZTogXCJDbGVhciBCdXR0b24gQ29sb3JcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcIiNDQ0NDQ0NcIixcbiAgICAgICAgaGlkZGVuOiAoeyBmaWVsZFR5cGUsIHNob3dDbGVhckJ1dHRvbiB9KSA9PlxuICAgICAgICAgICAgIXNob3dDbGVhckJ1dHRvbiB8fFxuICAgICAgICAgICAgKGZpZWxkVHlwZSAhPT0gXCJ0ZXh0XCIgJiYgZmllbGRUeXBlICE9PSBcInRleHRhcmVhXCIgJiYgZmllbGRUeXBlICE9PSBcImNoaXBzXCIpLFxuICAgIH0sXG5cbiAgICAvLyA9PT0gRklFTEQgSUNPTlMgPT09XG4gICAgc2hvd0JlZm9yZUljb246IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuQm9vbGVhbixcbiAgICAgICAgdGl0bGU6IFwiQmVmb3JlIEljb25cIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgICAgICAgZW5hYmxlZFRpdGxlOiBcIlNob3dcIixcbiAgICAgICAgZGlzYWJsZWRUaXRsZTogXCJIaWRlXCIsXG4gICAgICAgIGhpZGRlbjogKHsgZmllbGRUeXBlIH0pID0+IGZpZWxkVHlwZSA9PT0gXCJyYWRpb1wiLFxuICAgIH0sXG4gICAgYmVmb3JlSWNvbjoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5Db21wb25lbnRJbnN0YW5jZSxcbiAgICAgICAgdGl0bGU6IFwiQmVmb3JlIEljb25cIixcbiAgICAgICAgaGlkZGVuOiAoeyBzaG93QmVmb3JlSWNvbiwgZmllbGRUeXBlIH0pID0+XG4gICAgICAgICAgICAhc2hvd0JlZm9yZUljb24gfHwgZmllbGRUeXBlID09PSBcInJhZGlvXCIsXG4gICAgfSxcbiAgICBzaG93QWZ0ZXJJY29uOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkJvb2xlYW4sXG4gICAgICAgIHRpdGxlOiBcIkFmdGVyIEljb25cIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgICAgICAgZW5hYmxlZFRpdGxlOiBcIlNob3dcIixcbiAgICAgICAgZGlzYWJsZWRUaXRsZTogXCJIaWRlXCIsXG4gICAgICAgIGhpZGRlbjogKHsgZmllbGRUeXBlIH0pID0+IGZpZWxkVHlwZSA9PT0gXCJyYWRpb1wiLFxuICAgIH0sXG4gICAgYWZ0ZXJJY29uOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkNvbXBvbmVudEluc3RhbmNlLFxuICAgICAgICB0aXRsZTogXCJBZnRlciBJY29uXCIsXG4gICAgICAgIGhpZGRlbjogKHsgc2hvd0FmdGVySWNvbiwgZmllbGRUeXBlIH0pID0+XG4gICAgICAgICAgICAhc2hvd0FmdGVySWNvbiB8fCBmaWVsZFR5cGUgPT09IFwicmFkaW9cIixcbiAgICB9LFxuICAgIGljb25TaXplOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLk51bWJlcixcbiAgICAgICAgdGl0bGU6IFwiSWNvbiBTaXplXCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogMTYsXG4gICAgICAgIG1pbjogMTIsXG4gICAgICAgIG1heDogMjQsXG4gICAgICAgIHN0ZXA6IDEsXG4gICAgICAgIHVuaXQ6IFwicHhcIixcbiAgICAgICAgaGlkZGVuOiAoeyBzaG93QmVmb3JlSWNvbiwgc2hvd0FmdGVySWNvbiwgZmllbGRUeXBlIH0pID0+XG4gICAgICAgICAgICAoIXNob3dCZWZvcmVJY29uICYmICFzaG93QWZ0ZXJJY29uKSB8fCBmaWVsZFR5cGUgPT09IFwicmFkaW9cIixcbiAgICB9LFxuXG4gICAgLy8gPT09IENISVAgU0VUVElOR1MgPT09XG4gICAgc2hvd0NoaXBzOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkJvb2xlYW4sXG4gICAgICAgIHRpdGxlOiBcIlNob3cgQ2hpcHNcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICAgICAgICBlbmFibGVkVGl0bGU6IFwiU2hvd1wiLFxuICAgICAgICBkaXNhYmxlZFRpdGxlOiBcIkhpZGVcIixcbiAgICAgICAgaGlkZGVuOiAoeyBmaWVsZFR5cGUgfSkgPT5cbiAgICAgICAgICAgIGZpZWxkVHlwZSAhPT0gXCJ0ZXh0XCIgJiZcbiAgICAgICAgICAgIGZpZWxkVHlwZSAhPT0gXCJ0ZXh0YXJlYVwiICYmXG4gICAgICAgICAgICBmaWVsZFR5cGUgIT09IFwiY2hpcHNcIixcbiAgICB9LFxuICAgIGNoaXBTdWdnZXN0aW9uczoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5BcnJheSxcbiAgICAgICAgdGl0bGU6IFwiQ2hpcCBTdWdnZXN0aW9uc1wiLFxuICAgICAgICBjb250cm9sOiB7XG4gICAgICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5TdHJpbmcsXG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogW1xuICAgICAgICAgICAgXCJTdWdnZXN0aW9uIDFcIixcbiAgICAgICAgICAgIFwiU3VnZ2VzdGlvbiAyXCIsXG4gICAgICAgICAgICBcIlN1Z2dlc3Rpb24gM1wiLFxuICAgICAgICAgICAgXCJTdWdnZXN0aW9uIDRcIixcbiAgICAgICAgXSxcbiAgICAgICAgaGlkZGVuOiAoeyBmaWVsZFR5cGUsIHNob3dDaGlwcyB9KSA9PlxuICAgICAgICAgICAgIXNob3dDaGlwcyB8fFxuICAgICAgICAgICAgKGZpZWxkVHlwZSAhPT0gXCJ0ZXh0XCIgJiZcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGUgIT09IFwidGV4dGFyZWFcIiAmJlxuICAgICAgICAgICAgICAgIGZpZWxkVHlwZSAhPT0gXCJjaGlwc1wiKSxcbiAgICB9LFxuXG4gICAgLy8gPT09IENISVAgU1RZTElORyA9PT1cbiAgICBjaGlwQmFja2dyb3VuZENvbG9yOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkNvbG9yLFxuICAgICAgICB0aXRsZTogXCJDaGlwIEJhY2tncm91bmRcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcIiNGNUY1RjVcIixcbiAgICAgICAgaGlkZGVuOiAoeyBmaWVsZFR5cGUsIHNob3dDaGlwcyB9KSA9PlxuICAgICAgICAgICAgIXNob3dDaGlwcyB8fFxuICAgICAgICAgICAgKGZpZWxkVHlwZSAhPT0gXCJ0ZXh0XCIgJiZcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGUgIT09IFwidGV4dGFyZWFcIiAmJlxuICAgICAgICAgICAgICAgIGZpZWxkVHlwZSAhPT0gXCJjaGlwc1wiKSxcbiAgICB9LFxuICAgIGNoaXBUZXh0Q29sb3I6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuQ29sb3IsXG4gICAgICAgIHRpdGxlOiBcIkNoaXAgVGV4dFwiLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IFwiIzAwMDAwMFwiLFxuICAgICAgICBoaWRkZW46ICh7IGZpZWxkVHlwZSwgc2hvd0NoaXBzIH0pID0+XG4gICAgICAgICAgICAhc2hvd0NoaXBzIHx8XG4gICAgICAgICAgICAoZmllbGRUeXBlICE9PSBcInRleHRcIiAmJlxuICAgICAgICAgICAgICAgIGZpZWxkVHlwZSAhPT0gXCJ0ZXh0YXJlYVwiICYmXG4gICAgICAgICAgICAgICAgZmllbGRUeXBlICE9PSBcImNoaXBzXCIpLFxuICAgIH0sXG4gICAgY2hpcFNlbGVjdGVkQmFja2dyb3VuZENvbG9yOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkNvbG9yLFxuICAgICAgICB0aXRsZTogXCJTZWxlY3RlZCBCYWNrZ3JvdW5kXCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCIjMDAwMDAwXCIsXG4gICAgICAgIGhpZGRlbjogKHsgZmllbGRUeXBlLCBzaG93Q2hpcHMgfSkgPT5cbiAgICAgICAgICAgICFzaG93Q2hpcHMgfHxcbiAgICAgICAgICAgIChmaWVsZFR5cGUgIT09IFwidGV4dFwiICYmXG4gICAgICAgICAgICAgICAgZmllbGRUeXBlICE9PSBcInRleHRhcmVhXCIgJiZcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGUgIT09IFwiY2hpcHNcIiksXG4gICAgfSxcbiAgICBjaGlwU2VsZWN0ZWRUZXh0Q29sb3I6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuQ29sb3IsXG4gICAgICAgIHRpdGxlOiBcIlNlbGVjdGVkIFRleHRcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcIiNGRkZGRkZcIixcbiAgICAgICAgaGlkZGVuOiAoeyBmaWVsZFR5cGUsIHNob3dDaGlwcyB9KSA9PlxuICAgICAgICAgICAgIXNob3dDaGlwcyB8fFxuICAgICAgICAgICAgKGZpZWxkVHlwZSAhPT0gXCJ0ZXh0XCIgJiZcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGUgIT09IFwidGV4dGFyZWFcIiAmJlxuICAgICAgICAgICAgICAgIGZpZWxkVHlwZSAhPT0gXCJjaGlwc1wiKSxcbiAgICB9LFxuICAgIGNoaXBCb3JkZXJDb2xvcjoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5Db2xvcixcbiAgICAgICAgdGl0bGU6IFwiQ2hpcCBCb3JkZXJcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcIiNFRUVFRUVcIixcbiAgICAgICAgaGlkZGVuOiAoeyBmaWVsZFR5cGUsIHNob3dDaGlwcyB9KSA9PlxuICAgICAgICAgICAgIXNob3dDaGlwcyB8fFxuICAgICAgICAgICAgKGZpZWxkVHlwZSAhPT0gXCJ0ZXh0XCIgJiZcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGUgIT09IFwidGV4dGFyZWFcIiAmJlxuICAgICAgICAgICAgICAgIGZpZWxkVHlwZSAhPT0gXCJjaGlwc1wiKSxcbiAgICB9LFxuICAgIGNoaXBCb3JkZXJSYWRpdXM6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuTnVtYmVyLFxuICAgICAgICB0aXRsZTogXCJDaGlwIFJhZGl1c1wiLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IDE2LFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogMzAsXG4gICAgICAgIHN0ZXA6IDEsXG4gICAgICAgIHVuaXQ6IFwicHhcIixcbiAgICAgICAgaGlkZGVuOiAoeyBmaWVsZFR5cGUsIHNob3dDaGlwcyB9KSA9PlxuICAgICAgICAgICAgIXNob3dDaGlwcyB8fFxuICAgICAgICAgICAgKGZpZWxkVHlwZSAhPT0gXCJ0ZXh0XCIgJiZcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGUgIT09IFwidGV4dGFyZWFcIiAmJlxuICAgICAgICAgICAgICAgIGZpZWxkVHlwZSAhPT0gXCJjaGlwc1wiKSxcbiAgICB9LFxuICAgIGNoaXBQYWRkaW5nOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLk51bWJlcixcbiAgICAgICAgdGl0bGU6IFwiQ2hpcCBQYWRkaW5nXCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogOCxcbiAgICAgICAgbWluOiAyLFxuICAgICAgICBtYXg6IDE2LFxuICAgICAgICBzdGVwOiAxLFxuICAgICAgICB1bml0OiBcInB4XCIsXG4gICAgICAgIGhpZGRlbjogKHsgZmllbGRUeXBlLCBzaG93Q2hpcHMgfSkgPT5cbiAgICAgICAgICAgICFzaG93Q2hpcHMgfHxcbiAgICAgICAgICAgIChmaWVsZFR5cGUgIT09IFwidGV4dFwiICYmXG4gICAgICAgICAgICAgICAgZmllbGRUeXBlICE9PSBcInRleHRhcmVhXCIgJiZcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGUgIT09IFwiY2hpcHNcIiksXG4gICAgfSxcbiAgICBjaGlwR2FwOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLk51bWJlcixcbiAgICAgICAgdGl0bGU6IFwiQ2hpcCBHYXBcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiA2LFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogMjAsXG4gICAgICAgIHN0ZXA6IDEsXG4gICAgICAgIHVuaXQ6IFwicHhcIixcbiAgICAgICAgaGlkZGVuOiAoeyBmaWVsZFR5cGUsIHNob3dDaGlwcyB9KSA9PlxuICAgICAgICAgICAgIXNob3dDaGlwcyB8fFxuICAgICAgICAgICAgKGZpZWxkVHlwZSAhPT0gXCJ0ZXh0XCIgJiZcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGUgIT09IFwidGV4dGFyZWFcIiAmJlxuICAgICAgICAgICAgICAgIGZpZWxkVHlwZSAhPT0gXCJjaGlwc1wiKSxcbiAgICB9LFxuICAgIGNoaXBGb250OiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkZvbnQsXG4gICAgICAgIHRpdGxlOiBcIkNoaXAgRm9udFwiLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHtcbiAgICAgICAgICAgIGZvbnRTaXplOiBcIjEycHhcIixcbiAgICAgICAgICAgIHZhcmlhbnQ6IFwiTWVkaXVtXCIsXG4gICAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiBcIi0wLjAxZW1cIixcbiAgICAgICAgICAgIGxpbmVIZWlnaHQ6IFwiMS4yZW1cIixcbiAgICAgICAgfSxcbiAgICAgICAgY29udHJvbHM6IFwiZXh0ZW5kZWRcIixcbiAgICAgICAgZGVmYXVsdEZvbnRUeXBlOiBcInNhbnMtc2VyaWZcIixcbiAgICAgICAgaGlkZGVuOiAoeyBmaWVsZFR5cGUsIHNob3dDaGlwcyB9KSA9PlxuICAgICAgICAgICAgIXNob3dDaGlwcyB8fFxuICAgICAgICAgICAgKGZpZWxkVHlwZSAhPT0gXCJ0ZXh0XCIgJiZcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGUgIT09IFwidGV4dGFyZWFcIiAmJlxuICAgICAgICAgICAgICAgIGZpZWxkVHlwZSAhPT0gXCJjaGlwc1wiKSxcbiAgICB9LFxuXG4gICAgLy8gPT09IENISVAgSUNPTlMgPT09XG4gICAgc2hvd0NoaXBCZWZvcmVJY29uOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkJvb2xlYW4sXG4gICAgICAgIHRpdGxlOiBcIkNoaXAgQmVmb3JlIEljb25cIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgICAgICAgZW5hYmxlZFRpdGxlOiBcIlNob3dcIixcbiAgICAgICAgZGlzYWJsZWRUaXRsZTogXCJIaWRlXCIsXG4gICAgICAgIGhpZGRlbjogKHsgZmllbGRUeXBlLCBzaG93Q2hpcHMgfSkgPT5cbiAgICAgICAgICAgICFzaG93Q2hpcHMgfHxcbiAgICAgICAgICAgIChmaWVsZFR5cGUgIT09IFwidGV4dFwiICYmXG4gICAgICAgICAgICAgICAgZmllbGRUeXBlICE9PSBcInRleHRhcmVhXCIgJiZcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGUgIT09IFwiY2hpcHNcIiksXG4gICAgfSxcbiAgICBjaGlwQmVmb3JlSWNvbjoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5Db21wb25lbnRJbnN0YW5jZSxcbiAgICAgICAgdGl0bGU6IFwiQmVmb3JlIEljb25cIixcbiAgICAgICAgaGlkZGVuOiAoeyBmaWVsZFR5cGUsIHNob3dDaGlwcywgc2hvd0NoaXBCZWZvcmVJY29uIH0pID0+XG4gICAgICAgICAgICAhc2hvd0NoaXBzIHx8XG4gICAgICAgICAgICAhc2hvd0NoaXBCZWZvcmVJY29uIHx8XG4gICAgICAgICAgICAoZmllbGRUeXBlICE9PSBcInRleHRcIiAmJlxuICAgICAgICAgICAgICAgIGZpZWxkVHlwZSAhPT0gXCJ0ZXh0YXJlYVwiICYmXG4gICAgICAgICAgICAgICAgZmllbGRUeXBlICE9PSBcImNoaXBzXCIpLFxuICAgIH0sXG4gICAgc2hvd0NoaXBBZnRlckljb246IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuQm9vbGVhbixcbiAgICAgICAgdGl0bGU6IFwiQ2hpcCBBZnRlciBJY29uXCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gICAgICAgIGVuYWJsZWRUaXRsZTogXCJTaG93XCIsXG4gICAgICAgIGRpc2FibGVkVGl0bGU6IFwiSGlkZVwiLFxuICAgICAgICBoaWRkZW46ICh7IGZpZWxkVHlwZSwgc2hvd0NoaXBzIH0pID0+XG4gICAgICAgICAgICAhc2hvd0NoaXBzIHx8XG4gICAgICAgICAgICAoZmllbGRUeXBlICE9PSBcInRleHRcIiAmJlxuICAgICAgICAgICAgICAgIGZpZWxkVHlwZSAhPT0gXCJ0ZXh0YXJlYVwiICYmXG4gICAgICAgICAgICAgICAgZmllbGRUeXBlICE9PSBcImNoaXBzXCIpLFxuICAgIH0sXG4gICAgY2hpcEFmdGVySWNvbjoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5Db21wb25lbnRJbnN0YW5jZSxcbiAgICAgICAgdGl0bGU6IFwiQWZ0ZXIgSWNvblwiLFxuICAgICAgICBoaWRkZW46ICh7IGZpZWxkVHlwZSwgc2hvd0NoaXBzLCBzaG93Q2hpcEFmdGVySWNvbiB9KSA9PlxuICAgICAgICAgICAgIXNob3dDaGlwcyB8fFxuICAgICAgICAgICAgIXNob3dDaGlwQWZ0ZXJJY29uIHx8XG4gICAgICAgICAgICAoZmllbGRUeXBlICE9PSBcInRleHRcIiAmJlxuICAgICAgICAgICAgICAgIGZpZWxkVHlwZSAhPT0gXCJ0ZXh0YXJlYVwiICYmXG4gICAgICAgICAgICAgICAgZmllbGRUeXBlICE9PSBcImNoaXBzXCIpLFxuICAgIH0sXG4gICAgY2hpcEljb25TaXplOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLk51bWJlcixcbiAgICAgICAgdGl0bGU6IFwiQ2hpcCBJY29uIFNpemVcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiAxMixcbiAgICAgICAgbWluOiA4LFxuICAgICAgICBtYXg6IDIwLFxuICAgICAgICBzdGVwOiAxLFxuICAgICAgICB1bml0OiBcInB4XCIsXG4gICAgICAgIGhpZGRlbjogKHtcbiAgICAgICAgICAgIGZpZWxkVHlwZSxcbiAgICAgICAgICAgIHNob3dDaGlwcyxcbiAgICAgICAgICAgIHNob3dDaGlwQmVmb3JlSWNvbixcbiAgICAgICAgICAgIHNob3dDaGlwQWZ0ZXJJY29uLFxuICAgICAgICB9KSA9PlxuICAgICAgICAgICAgIXNob3dDaGlwcyB8fFxuICAgICAgICAgICAgKCFzaG93Q2hpcEJlZm9yZUljb24gJiYgIXNob3dDaGlwQWZ0ZXJJY29uKSB8fFxuICAgICAgICAgICAgKGZpZWxkVHlwZSAhPT0gXCJ0ZXh0XCIgJiZcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGUgIT09IFwidGV4dGFyZWFcIiAmJlxuICAgICAgICAgICAgICAgIGZpZWxkVHlwZSAhPT0gXCJjaGlwc1wiKSxcbiAgICB9LFxuXG4gICAgLy8gPT09IEZJRUxEIFNUWUxJTkcgPT09XG4gICAgYmFja2dyb3VuZENvbG9yOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkNvbG9yLFxuICAgICAgICB0aXRsZTogXCJCYWNrZ3JvdW5kXCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCIjRkZGRkZGXCIsXG4gICAgICAgIGhpZGRlbjogKHsgZmllbGRUeXBlIH0pID0+IGZpZWxkVHlwZSA9PT0gXCJyYWRpb1wiLFxuICAgIH0sXG4gICAgYm9yZGVyQ29sb3I6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuQ29sb3IsXG4gICAgICAgIHRpdGxlOiBcIkJvcmRlciBDb2xvclwiLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IFwiI0VFRUVFRVwiLFxuICAgICAgICBoaWRkZW46ICh7IGZpZWxkVHlwZSB9KSA9PiBmaWVsZFR5cGUgPT09IFwicmFkaW9cIixcbiAgICB9LFxuICAgIGZvY3VzQ29sb3I6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuQ29sb3IsXG4gICAgICAgIHRpdGxlOiBcIkZvY3VzIENvbG9yXCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCIjMDAwMDAwXCIsXG4gICAgICAgIGhpZGRlbjogKHsgZmllbGRUeXBlIH0pID0+IGZpZWxkVHlwZSA9PT0gXCJyYWRpb1wiLFxuICAgIH0sXG4gICAgdGV4dENvbG9yOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkNvbG9yLFxuICAgICAgICB0aXRsZTogXCJUZXh0IENvbG9yXCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCIjMDAwMDAwXCIsXG4gICAgICAgIGhpZGRlbjogKHsgZmllbGRUeXBlIH0pID0+IGZpZWxkVHlwZSA9PT0gXCJyYWRpb1wiLFxuICAgIH0sXG4gICAgYm9yZGVyUmFkaXVzOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkJvcmRlclJhZGl1cyxcbiAgICAgICAgdGl0bGU6IFwiQm9yZGVyIFJhZGl1c1wiLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IFwiOHB4XCIsXG4gICAgICAgIGhpZGRlbjogKHsgZmllbGRUeXBlIH0pID0+IGZpZWxkVHlwZSA9PT0gXCJyYWRpb1wiLFxuICAgIH0sXG4gICAgaGVpZ2h0TW9kZToge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5FbnVtLFxuICAgICAgICB0aXRsZTogXCJIZWlnaHQgTW9kZVwiLFxuICAgICAgICBvcHRpb25zOiBbXCJmaXhlZFwiLCBcImZpdFwiXSxcbiAgICAgICAgb3B0aW9uVGl0bGVzOiBbXCJGaXhlZFwiLCBcIkZpdFwiXSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcImZpeGVkXCIsXG4gICAgICAgIGhpZGRlbjogKHsgZmllbGRUeXBlIH0pID0+IGZpZWxkVHlwZSA9PT0gXCJyYWRpb1wiLFxuICAgIH0sXG4gICAgaGVpZ2h0OiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLk51bWJlcixcbiAgICAgICAgdGl0bGU6IFwiRmllbGQgSGVpZ2h0XCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogNDAsXG4gICAgICAgIG1pbjogMjAsXG4gICAgICAgIG1heDogMTAwLFxuICAgICAgICBzdGVwOiAxLFxuICAgICAgICB1bml0OiBcInB4XCIsXG4gICAgICAgIGhpZGRlbjogKHsgZmllbGRUeXBlLCBoZWlnaHRNb2RlIH0pID0+IGZpZWxkVHlwZSA9PT0gXCJyYWRpb1wiIHx8IGhlaWdodE1vZGUgPT09IFwiZml0XCIsXG4gICAgfSxcbiAgICBwYWRkaW5nOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLlBhZGRpbmcsXG4gICAgICAgIHRpdGxlOiBcIlBhZGRpbmdcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcIjEycHhcIixcbiAgICAgICAgaGlkZGVuOiAoeyBmaWVsZFR5cGUgfSkgPT4gZmllbGRUeXBlID09PSBcInJhZGlvXCIsXG4gICAgfSxcblxuICAgIC8vID09PSBUWVBPR1JBUEhZID09PVxuICAgIGlucHV0Rm9udDoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5Gb250LFxuICAgICAgICB0aXRsZTogXCJJbnB1dCBGb250XCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZToge1xuICAgICAgICAgICAgZm9udFNpemU6IFwiMTRweFwiLFxuICAgICAgICAgICAgdmFyaWFudDogXCJSZWd1bGFyXCIsXG4gICAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiBcIi0wLjAxZW1cIixcbiAgICAgICAgICAgIGxpbmVIZWlnaHQ6IFwiMS4zZW1cIixcbiAgICAgICAgfSxcbiAgICAgICAgY29udHJvbHM6IFwiZXh0ZW5kZWRcIixcbiAgICAgICAgZGVmYXVsdEZvbnRUeXBlOiBcInNhbnMtc2VyaWZcIixcbiAgICAgICAgaGlkZGVuOiAoeyBmaWVsZFR5cGUgfSkgPT4gZmllbGRUeXBlID09PSBcInJhZGlvXCIsXG4gICAgfSxcblxuICAgIC8vID09PSBCVVRUT04gU0VUVElOR1MgPT09XG4gICAgc2hvd0J1dHRvbjoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5Cb29sZWFuLFxuICAgICAgICB0aXRsZTogXCJTaG93IEJ1dHRvblwiLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICAgICAgICBlbmFibGVkVGl0bGU6IFwiU2hvd1wiLFxuICAgICAgICBkaXNhYmxlZFRpdGxlOiBcIkhpZGVcIixcbiAgICB9LFxuICAgIGJ1dHRvblRleHQ6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuU3RyaW5nLFxuICAgICAgICB0aXRsZTogXCJCdXR0b24gVGV4dFwiLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IFwiU3VibWl0XCIsXG4gICAgICAgIGhpZGRlbjogKHsgc2hvd0J1dHRvbiB9KSA9PiAhc2hvd0J1dHRvbixcbiAgICB9LFxuICAgIGJ1dHRvblN0YXRlOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkVudW0sXG4gICAgICAgIHRpdGxlOiBcIkJ1dHRvbiBTdGF0ZVwiLFxuICAgICAgICBvcHRpb25zOiBbXCJlbmFibGVkXCIsIFwiZGlzYWJsZWRcIl0sXG4gICAgICAgIG9wdGlvblRpdGxlczogW1wiRW5hYmxlZFwiLCBcIkRpc2FibGVkXCJdLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IFwiZW5hYmxlZFwiLFxuICAgICAgICBoaWRkZW46ICh7IHNob3dCdXR0b24gfSkgPT4gIXNob3dCdXR0b24sXG4gICAgfSxcbiAgICBsaW5rZWRCdXR0b246IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuQ29tcG9uZW50SW5zdGFuY2UsXG4gICAgICAgIHRpdGxlOiBcIkxpbmtlZCBCdXR0b25cIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiTGluayB0byBhbiBleHRlcm5hbCBCdXR0b24gY29tcG9uZW50IGFueXdoZXJlIGluIHlvdXIgcHJvamVjdFwiLFxuICAgIH0sXG4gICAgY29tcG9uZW50SWQ6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuU3RyaW5nLFxuICAgICAgICB0aXRsZTogXCJDb21wb25lbnQgSURcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcImZvcm0tMTIzXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGZvcm0gKGF1dG8tZ2VuZXJhdGVkIGlmIGVtcHR5KVwiLFxuICAgIH0sXG4gICAgbGlua2VkQnV0dG9uSWQ6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuU3RyaW5nLFxuICAgICAgICB0aXRsZTogXCJMaW5rZWQgQnV0dG9uIElEXCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCJcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRW50ZXIgdGhlIEJ1dHRvbidzIENvbXBvbmVudCBJRCB0byBsaW5rIHRoZW0gKHdvcmtzIGFueXdoZXJlIGluIEZyYW1lcilcIixcbiAgICB9LFxuXG4gICAgLy8gPT09IEJVVFRPTiBTVFlMSU5HID09PVxuICAgIGJ1dHRvbkVuYWJsZWRCYWNrZ3JvdW5kOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkNvbG9yLFxuICAgICAgICB0aXRsZTogXCJCdXR0b24gQmFja2dyb3VuZFwiLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IFwiIzAwMDAwMFwiLFxuICAgICAgICBoaWRkZW46ICh7IHNob3dCdXR0b24gfSkgPT4gIXNob3dCdXR0b24sXG4gICAgfSxcbiAgICBidXR0b25FbmFibGVkVGV4dDoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5Db2xvcixcbiAgICAgICAgdGl0bGU6IFwiQnV0dG9uIFRleHQgQ29sb3JcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcIiNGRkZGRkZcIixcbiAgICAgICAgaGlkZGVuOiAoeyBzaG93QnV0dG9uIH0pID0+ICFzaG93QnV0dG9uLFxuICAgIH0sXG4gICAgYnV0dG9uRGlzYWJsZWRCYWNrZ3JvdW5kOiB7XG4gICAgICAgIHR5cGU6IENvbnRyb2xUeXBlLkNvbG9yLFxuICAgICAgICB0aXRsZTogXCJEaXNhYmxlZCBCYWNrZ3JvdW5kXCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCIjQ0NDQ0NDXCIsXG4gICAgICAgIGhpZGRlbjogKHsgc2hvd0J1dHRvbiB9KSA9PiAhc2hvd0J1dHRvbixcbiAgICB9LFxuICAgIGJ1dHRvbkRpc2FibGVkVGV4dDoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5Db2xvcixcbiAgICAgICAgdGl0bGU6IFwiRGlzYWJsZWQgVGV4dCBDb2xvclwiLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IFwiIzY2NjY2NlwiLFxuICAgICAgICBoaWRkZW46ICh7IHNob3dCdXR0b24gfSkgPT4gIXNob3dCdXR0b24sXG4gICAgfSxcbiAgICBidXR0b25Cb3JkZXJSYWRpdXM6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuQm9yZGVyUmFkaXVzLFxuICAgICAgICB0aXRsZTogXCJCdXR0b24gQm9yZGVyIFJhZGl1c1wiLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IFwiOHB4XCIsXG4gICAgICAgIGhpZGRlbjogKHsgc2hvd0J1dHRvbiB9KSA9PiAhc2hvd0J1dHRvbixcbiAgICB9LFxuICAgIGJ1dHRvblBhZGRpbmc6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuUGFkZGluZyxcbiAgICAgICAgdGl0bGU6IFwiQnV0dG9uIFBhZGRpbmdcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcIjEycHhcIixcbiAgICAgICAgaGlkZGVuOiAoeyBzaG93QnV0dG9uIH0pID0+ICFzaG93QnV0dG9uLFxuICAgIH0sXG4gICAgYnV0dG9uRm9udDoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5Gb250LFxuICAgICAgICB0aXRsZTogXCJCdXR0b24gRm9udFwiLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHtcbiAgICAgICAgICAgIGZvbnRTaXplOiBcIjE0cHhcIixcbiAgICAgICAgICAgIHZhcmlhbnQ6IFwiTWVkaXVtXCIsXG4gICAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiBcIjBcIixcbiAgICAgICAgICAgIGxpbmVIZWlnaHQ6IFwiMS4yZW1cIixcbiAgICAgICAgfSxcbiAgICAgICAgY29udHJvbHM6IFwiZXh0ZW5kZWRcIixcbiAgICAgICAgZGVmYXVsdEZvbnRUeXBlOiBcInNhbnMtc2VyaWZcIixcbiAgICAgICAgaGlkZGVuOiAoeyBzaG93QnV0dG9uIH0pID0+ICFzaG93QnV0dG9uLFxuICAgIH0sXG59KVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInN0YXJ0VHJhbnNpdGlvbiIsImFkZFByb3BlcnR5Q29udHJvbHMiLCJDb250cm9sVHlwZSIsInVzZU1vdGlvblZhbHVlIiwic2V0Q29tcG9uZW50RGF0YSIsIkZvcm1CdWlsZGVyIiwicHJvcHMiLCJmaWVsZFR5cGUiLCJsYWJlbCIsInNob3dMYWJlbCIsInBsYWNlaG9sZGVyIiwicGxhY2Vob2xkZXJDb2xvciIsInJlcXVpcmVkIiwiZHJvcGRvd25PcHRpb25zIiwidmFsdWUiLCJyYWRpb09wdGlvbnMiLCJjaGlwU3VnZ2VzdGlvbnMiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJDb2xvciIsImZvY3VzQ29sb3IiLCJ0ZXh0Q29sb3IiLCJsYWJlbENvbG9yIiwiYm9yZGVyUmFkaXVzIiwiaGVpZ2h0TW9kZSIsImhlaWdodCIsInBhZGRpbmciLCJsYWJlbEZvbnQiLCJpbnB1dEZvbnQiLCJzaG93Q2hpcHMiLCJjaGlwQmFja2dyb3VuZENvbG9yIiwiY2hpcFRleHRDb2xvciIsImNoaXBTZWxlY3RlZEJhY2tncm91bmRDb2xvciIsImNoaXBTZWxlY3RlZFRleHRDb2xvciIsImNoaXBCb3JkZXJDb2xvciIsImNoaXBCb3JkZXJSYWRpdXMiLCJjaGlwUGFkZGluZyIsImNoaXBHYXAiLCJjaGlwRm9udCIsInNob3dDaGlwQmVmb3JlSWNvbiIsImNoaXBCZWZvcmVJY29uIiwic2hvd0NoaXBBZnRlckljb24iLCJjaGlwQWZ0ZXJJY29uIiwiY2hpcEljb25TaXplIiwic2hvd0NsZWFyQnV0dG9uIiwiY2xlYXJCdXR0b25Db2xvciIsInNob3dCZWZvcmVJY29uIiwiYmVmb3JlSWNvbiIsInNob3dBZnRlckljb24iLCJhZnRlckljb24iLCJpY29uU2l6ZSIsInNob3dCdXR0b24iLCJidXR0b25UZXh0IiwiYnV0dG9uRW5hYmxlZEJhY2tncm91bmQiLCJidXR0b25FbmFibGVkVGV4dCIsImJ1dHRvbkRpc2FibGVkQmFja2dyb3VuZCIsImJ1dHRvbkRpc2FibGVkVGV4dCIsImJ1dHRvbkJvcmRlclJhZGl1cyIsImJ1dHRvblBhZGRpbmciLCJidXR0b25Gb250IiwiYnV0dG9uU3RhdGUiLCJsaW5rZWRCdXR0b24iLCJjb21wb25lbnRJZCIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsInNldFZhbHVlIiwic2VsZWN0ZWRDaGlwcyIsInNldFNlbGVjdGVkQ2hpcHMiLCJpc0ZvY3VzZWQiLCJzZXRJc0ZvY3VzZWQiLCJidXR0b25EaXNhYmxlZE1vdGlvbiIsImhhc0NvbnRlbnRNb3Rpb24iLCJoYW5kbGVJbnB1dENoYW5nZSIsIm5ld1ZhbHVlIiwiaGFuZGxlQ2hpcENsaWNrIiwiY2hpcCIsInByZXYiLCJpbmNsdWRlcyIsImZpbHRlciIsImMiLCJ0cmltIiwiaGFuZGxlRm9jdXMiLCJoYW5kbGVCbHVyIiwiaGFuZGxlQ2xlYXIiLCJoYW5kbGVCdXR0b25DbGljayIsImNvbnNvbGUiLCJsb2ciLCJnZXRJbnB1dFBhZGRpbmciLCJwYWRkaW5nVmFsdWVzIiwic3BsaXQiLCJtYXAiLCJwIiwicGFyc2VJbnQiLCJyZXBsYWNlIiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwibGVuZ3RoIiwibGVmdFBhZGRpbmciLCJyaWdodFBhZGRpbmciLCJtYXgiLCJ0b3BQYWRkaW5nIiwiYm90dG9tUGFkZGluZyIsImlucHV0U3R5bGVzIiwid2lkdGgiLCJtaW5IZWlnaHQiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwiYm9yZGVyIiwiY29sb3IiLCJvdXRsaW5lIiwidHJhbnNpdGlvbiIsImZvbnRTaXplIiwicmVuZGVySWNvbiIsImljb24iLCJwb3NpdGlvbiIsImljb25TdHlsZSIsInRyYW5zZm9ybSIsInBvaW50ZXJFdmVudHMiLCJ6SW5kZXgiLCJkaXYiLCJzdHlsZSIsInJlbmRlckNoaXBJY29uIiwiZGlzcGxheSIsImFsaWduSXRlbXMiLCJqdXN0aWZ5Q29udGVudCIsImhhc0NvbnRlbnQiLCJpc0J1dHRvbkRpc2FibGVkIiwidXNlRWZmZWN0Iiwic2V0IiwiZGlzYWJsZWQiLCJyZW5kZXJJbnB1dCIsInRleHRhcmVhIiwib25DaGFuZ2UiLCJlIiwidGFyZ2V0Iiwib25Gb2N1cyIsIm9uQmx1ciIsImNsYXNzTmFtZSIsInVuZGVmaW5lZCIsInJlc2l6ZSIsImZvbnRGYW1pbHkiLCJidXR0b24iLCJ0eXBlIiwib25DbGljayIsImJhY2tncm91bmQiLCJjdXJzb3IiLCJvbk1vdXNlRW50ZXIiLCJjdXJyZW50VGFyZ2V0Iiwib25Nb3VzZUxlYXZlIiwiYXJpYS1sYWJlbCIsInNlbGVjdCIsImFwcGVhcmFuY2UiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJlbmNvZGVVUklDb21wb25lbnQiLCJiYWNrZ3JvdW5kUmVwZWF0IiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYmFja2dyb3VuZFNpemUiLCJvcHRpb24iLCJpbmRleCIsImZsZXhEaXJlY3Rpb24iLCJnYXAiLCJpbnB1dCIsIm5hbWUiLCJjaGVja2VkIiwiYWNjZW50Q29sb3IiLCJzcGFuIiwiZmxleFdyYXAiLCJ0YWJJbmRleCIsIm1hcmdpbkxlZnQiLCJmb250V2VpZ2h0IiwibWFyZ2luVG9wIiwib3BhY2l0eSIsIkVudW0iLCJ0aXRsZSIsIm9wdGlvbnMiLCJvcHRpb25UaXRsZXMiLCJkZWZhdWx0VmFsdWUiLCJCb29sZWFuIiwiZW5hYmxlZFRpdGxlIiwiZGlzYWJsZWRUaXRsZSIsIlN0cmluZyIsImhpZGRlbiIsIkNvbG9yIiwiRm9udCIsInZhcmlhbnQiLCJsZXR0ZXJTcGFjaW5nIiwibGluZUhlaWdodCIsImNvbnRyb2xzIiwiZGVmYXVsdEZvbnRUeXBlIiwiQXJyYXkiLCJjb250cm9sIiwiT2JqZWN0IiwiQ29tcG9uZW50SW5zdGFuY2UiLCJOdW1iZXIiLCJtaW4iLCJzdGVwIiwidW5pdCIsIkJvcmRlclJhZGl1cyIsIlBhZGRpbmciLCJkZXNjcmlwdGlvbiIsImxpbmtlZEJ1dHRvbklkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/FormBuilderOrg.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/LinkingTest.tsx":
/*!****************************************!*\
  !*** ./src/components/LinkingTest.tsx ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LinkingTest)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var framer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! framer */ \"(app-pages-browser)/./node_modules/framer/build/esm/framer.debug.js\");\n/* harmony import */ var _FormBuilderOrg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FormBuilderOrg */ \"(app-pages-browser)/./src/components/FormBuilderOrg.tsx\");\n/* harmony import */ var _Button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Button */ \"(app-pages-browser)/./src/components/Button.tsx\");\n\n\n\n\n\n/**\n * @framerSupportedLayoutWidth any-prefer-fixed\n * @framerSupportedLayoutHeight auto\n */ function LinkingTest(props) {\n    const { testMode = \"simple\", formId = \"test-form\", buttonId = \"test-button\" } = props;\n    const getTestConfig = ()=>{\n        switch(testMode){\n            case \"simple\":\n                return {\n                    formId: \"simple-form\",\n                    buttonId: \"simple-button\",\n                    formLabel: \"Simple Test\",\n                    buttonText: \"Test Link\"\n                };\n            case \"advanced\":\n                return {\n                    formId: \"advanced-form\",\n                    buttonId: \"advanced-button\",\n                    formLabel: \"Advanced Test\",\n                    buttonText: \"Advanced Link\"\n                };\n            case \"custom\":\n                return {\n                    formId,\n                    buttonId,\n                    formLabel: \"Custom Test\",\n                    buttonText: \"Custom Link\"\n                };\n            default:\n                return {\n                    formId: \"default-form\",\n                    buttonId: \"default-button\",\n                    formLabel: \"Default Test\",\n                    buttonText: \"Default Link\"\n                };\n        }\n    };\n    const config = getTestConfig();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            display: \"flex\",\n            flexDirection: \"column\",\n            gap: \"16px\",\n            padding: \"20px\",\n            border: \"2px solid #E5E7EB\",\n            borderRadius: \"12px\",\n            backgroundColor: \"#F9FAFB\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    padding: \"12px\",\n                    backgroundColor: \"#3B82F6\",\n                    color: \"white\",\n                    borderRadius: \"8px\",\n                    textAlign: \"center\",\n                    fontWeight: \"600\"\n                },\n                children: \"\\uD83D\\uDD17 ID-Based Linking Test\"\n            }, void 0, false, {\n                fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/LinkingTest.tsx\",\n                lineNumber: 68,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    display: \"flex\",\n                    gap: \"16px\",\n                    alignItems: \"flex-start\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            flex: 1\n                        },\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_FormBuilderOrg__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                            fieldType: \"text\",\n                            label: config.formLabel,\n                            showLabel: true,\n                            placeholder: \"Type to test linking...\",\n                            placeholderColor: \"#9CA3AF\",\n                            required: true,\n                            showChips: true,\n                            chipSuggestions: [\n                                \"test1\",\n                                \"test2\",\n                                \"test3\"\n                            ],\n                            backgroundColor: \"#FFFFFF\",\n                            borderColor: \"#E5E7EB\",\n                            focusColor: \"#3B82F6\",\n                            textColor: \"#111827\",\n                            labelColor: \"#374151\",\n                            borderRadius: \"8px\",\n                            heightMode: \"fixed\",\n                            height: 40,\n                            padding: \"12px 16px\",\n                            showClearButton: true,\n                            clearButtonColor: \"#9CA3AF\",\n                            showButton: false,\n                            componentId: config.formId,\n                            linkedButtonId: config.buttonId\n                        }, void 0, false, {\n                            fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/LinkingTest.tsx\",\n                            lineNumber: 85,\n                            columnNumber: 21\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/LinkingTest.tsx\",\n                        lineNumber: 84,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            flex: \"0 0 auto\"\n                        },\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Button__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                            text: config.buttonText,\n                            variant: \"primary\",\n                            size: \"medium\",\n                            disabled: false,\n                            loading: false,\n                            fullWidth: false,\n                            externalDisabled: false,\n                            borderRadius: \"8px\",\n                            padding: \"12px 24px\",\n                            componentId: config.buttonId,\n                            linkedFormId: config.formId\n                        }, void 0, false, {\n                            fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/LinkingTest.tsx\",\n                            lineNumber: 112,\n                            columnNumber: 21\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/LinkingTest.tsx\",\n                        lineNumber: 111,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/LinkingTest.tsx\",\n                lineNumber: 79,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    padding: \"8px 12px\",\n                    backgroundColor: \"#F3F4F6\",\n                    borderRadius: \"6px\",\n                    fontSize: \"12px\",\n                    color: \"#6B7280\",\n                    fontFamily: \"monospace\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                        children: \"Form ID:\"\n                    }, void 0, false, {\n                        fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/LinkingTest.tsx\",\n                        lineNumber: 136,\n                        columnNumber: 17\n                    }, this),\n                    \" \",\n                    config.formId,\n                    \" | \",\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                        children: \"Button ID:\"\n                    }, void 0, false, {\n                        fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/LinkingTest.tsx\",\n                        lineNumber: 136,\n                        columnNumber: 61\n                    }, this),\n                    \" \",\n                    config.buttonId\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/LinkingTest.tsx\",\n                lineNumber: 128,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/zibon/Documents/Vibe/Cursor/Framer Workshop/framer-workshop/src/components/LinkingTest.tsx\",\n        lineNumber: 59,\n        columnNumber: 9\n    }, this);\n}\n_c = LinkingTest;\n(0,framer__WEBPACK_IMPORTED_MODULE_2__.addPropertyControls)(LinkingTest, {\n    testMode: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.Enum,\n        title: \"Test Mode\",\n        options: [\n            \"simple\",\n            \"advanced\",\n            \"custom\"\n        ],\n        optionTitles: [\n            \"Simple\",\n            \"Advanced\",\n            \"Custom\"\n        ],\n        defaultValue: \"simple\"\n    },\n    formId: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.String,\n        title: \"Custom Form ID\",\n        defaultValue: \"test-form\",\n        description: \"Custom form ID (only used in custom mode)\",\n        hidden: (param)=>{\n            let { testMode } = param;\n            return testMode !== \"custom\";\n        }\n    },\n    buttonId: {\n        type: framer__WEBPACK_IMPORTED_MODULE_2__.ControlType.String,\n        title: \"Custom Button ID\",\n        defaultValue: \"test-button\",\n        description: \"Custom button ID (only used in custom mode)\",\n        hidden: (param)=>{\n            let { testMode } = param;\n            return testMode !== \"custom\";\n        }\n    }\n});\nvar _c;\n$RefreshReg$(_c, \"LinkingTest\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0xpbmtpbmdUZXN0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF5QjtBQUNnQztBQUNmO0FBQ2I7QUFRN0I7OztDQUdDLEdBQ2MsU0FBU0ssWUFBWUMsS0FBdUI7SUFDdkQsTUFBTSxFQUNGQyxXQUFXLFFBQVEsRUFDbkJDLFNBQVMsV0FBVyxFQUNwQkMsV0FBVyxhQUFhLEVBQzNCLEdBQUdIO0lBRUosTUFBTUksZ0JBQWdCO1FBQ2xCLE9BQVFIO1lBQ0osS0FBSztnQkFDRCxPQUFPO29CQUNIQyxRQUFRO29CQUNSQyxVQUFVO29CQUNWRSxXQUFXO29CQUNYQyxZQUFZO2dCQUNoQjtZQUNKLEtBQUs7Z0JBQ0QsT0FBTztvQkFDSEosUUFBUTtvQkFDUkMsVUFBVTtvQkFDVkUsV0FBVztvQkFDWEMsWUFBWTtnQkFDaEI7WUFDSixLQUFLO2dCQUNELE9BQU87b0JBQ0hKO29CQUNBQztvQkFDQUUsV0FBVztvQkFDWEMsWUFBWTtnQkFDaEI7WUFDSjtnQkFDSSxPQUFPO29CQUNISixRQUFRO29CQUNSQyxVQUFVO29CQUNWRSxXQUFXO29CQUNYQyxZQUFZO2dCQUNoQjtRQUNSO0lBQ0o7SUFFQSxNQUFNQyxTQUFTSDtJQUVmLHFCQUNJLDhEQUFDSTtRQUFJQyxPQUFPO1lBQ1JDLFNBQVM7WUFDVEMsZUFBZTtZQUNmQyxLQUFLO1lBQ0xDLFNBQVM7WUFDVEMsUUFBUTtZQUNSQyxjQUFjO1lBQ2RDLGlCQUFpQjtRQUNyQjs7MEJBQ0ksOERBQUNSO2dCQUFJQyxPQUFPO29CQUNSSSxTQUFTO29CQUNURyxpQkFBaUI7b0JBQ2pCQyxPQUFPO29CQUNQRixjQUFjO29CQUNkRyxXQUFXO29CQUNYQyxZQUFZO2dCQUNoQjswQkFBRzs7Ozs7OzBCQUlILDhEQUFDWDtnQkFBSUMsT0FBTztvQkFDUkMsU0FBUztvQkFDVEUsS0FBSztvQkFDTFEsWUFBWTtnQkFDaEI7O2tDQUNJLDhEQUFDWjt3QkFBSUMsT0FBTzs0QkFBRVksTUFBTTt3QkFBRTtrQ0FDbEIsNEVBQUN4Qix1REFBV0E7NEJBQ1J5QixXQUFVOzRCQUNWQyxPQUFPaEIsT0FBT0YsU0FBUzs0QkFDdkJtQixXQUFXOzRCQUNYQyxhQUFZOzRCQUNaQyxrQkFBaUI7NEJBQ2pCQyxVQUFVOzRCQUNWQyxXQUFXOzRCQUNYQyxpQkFBaUI7Z0NBQUM7Z0NBQVM7Z0NBQVM7NkJBQVE7NEJBQzVDYixpQkFBZ0I7NEJBQ2hCYyxhQUFZOzRCQUNaQyxZQUFXOzRCQUNYQyxXQUFVOzRCQUNWQyxZQUFXOzRCQUNYbEIsY0FBYTs0QkFDYm1CLFlBQVc7NEJBQ1hDLFFBQVE7NEJBQ1J0QixTQUFROzRCQUNSdUIsaUJBQWlCOzRCQUNqQkMsa0JBQWlCOzRCQUNqQkMsWUFBWTs0QkFDWkMsYUFBYWhDLE9BQU9MLE1BQU07NEJBQzFCc0MsZ0JBQWdCakMsT0FBT0osUUFBUTs7Ozs7Ozs7Ozs7a0NBSXZDLDhEQUFDSzt3QkFBSUMsT0FBTzs0QkFBRVksTUFBTTt3QkFBVztrQ0FDM0IsNEVBQUN2QiwrQ0FBTUE7NEJBQ0gyQyxNQUFNbEMsT0FBT0QsVUFBVTs0QkFDdkJvQyxTQUFROzRCQUNSQyxNQUFLOzRCQUNMQyxVQUFVOzRCQUNWQyxTQUFTOzRCQUNUQyxXQUFXOzRCQUNYQyxrQkFBa0I7NEJBQ2xCaEMsY0FBYTs0QkFDYkYsU0FBUTs0QkFDUjBCLGFBQWFoQyxPQUFPSixRQUFROzRCQUM1QjZDLGNBQWN6QyxPQUFPTCxNQUFNOzs7Ozs7Ozs7Ozs7Ozs7OzswQkFLdkMsOERBQUNNO2dCQUFJQyxPQUFPO29CQUNSSSxTQUFTO29CQUNURyxpQkFBaUI7b0JBQ2pCRCxjQUFjO29CQUNka0MsVUFBVTtvQkFDVmhDLE9BQU87b0JBQ1BpQyxZQUFZO2dCQUNoQjs7a0NBQ0ksOERBQUNDO2tDQUFPOzs7Ozs7b0JBQWlCO29CQUFFNUMsT0FBT0wsTUFBTTtvQkFBQztrQ0FBRyw4REFBQ2lEO2tDQUFPOzs7Ozs7b0JBQW1CO29CQUFFNUMsT0FBT0osUUFBUTs7Ozs7Ozs7Ozs7OztBQUl4RztLQTVId0JKO0FBOEh4QkosMkRBQW1CQSxDQUFDSSxhQUFhO0lBQzdCRSxVQUFVO1FBQ05tRCxNQUFNeEQsK0NBQVdBLENBQUN5RCxJQUFJO1FBQ3RCQyxPQUFPO1FBQ1BDLFNBQVM7WUFBQztZQUFVO1lBQVk7U0FBUztRQUN6Q0MsY0FBYztZQUFDO1lBQVU7WUFBWTtTQUFTO1FBQzlDQyxjQUFjO0lBQ2xCO0lBQ0F2RCxRQUFRO1FBQ0prRCxNQUFNeEQsK0NBQVdBLENBQUM4RCxNQUFNO1FBQ3hCSixPQUFPO1FBQ1BHLGNBQWM7UUFDZEUsYUFBYTtRQUNiQyxRQUFRO2dCQUFDLEVBQUUzRCxRQUFRLEVBQUU7bUJBQUtBLGFBQWE7O0lBQzNDO0lBQ0FFLFVBQVU7UUFDTmlELE1BQU14RCwrQ0FBV0EsQ0FBQzhELE1BQU07UUFDeEJKLE9BQU87UUFDUEcsY0FBYztRQUNkRSxhQUFhO1FBQ2JDLFFBQVE7Z0JBQUMsRUFBRTNELFFBQVEsRUFBRTttQkFBS0EsYUFBYTs7SUFDM0M7QUFDSiIsInNvdXJjZXMiOlsiL1VzZXJzL3ppYm9uL0RvY3VtZW50cy9WaWJlL0N1cnNvci9GcmFtZXIgV29ya3Nob3AvZnJhbWVyLXdvcmtzaG9wL3NyYy9jb21wb25lbnRzL0xpbmtpbmdUZXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCJcbmltcG9ydCB7IGFkZFByb3BlcnR5Q29udHJvbHMsIENvbnRyb2xUeXBlIH0gZnJvbSBcImZyYW1lclwiXG5pbXBvcnQgRm9ybUJ1aWxkZXIgZnJvbSBcIi4vRm9ybUJ1aWxkZXJPcmdcIlxuaW1wb3J0IEJ1dHRvbiBmcm9tIFwiLi9CdXR0b25cIlxuXG5pbnRlcmZhY2UgTGlua2luZ1Rlc3RQcm9wcyB7XG4gICAgdGVzdE1vZGU6IFwic2ltcGxlXCIgfCBcImFkdmFuY2VkXCIgfCBcImN1c3RvbVwiXG4gICAgZm9ybUlkOiBzdHJpbmdcbiAgICBidXR0b25JZDogc3RyaW5nXG59XG5cbi8qKlxuICogQGZyYW1lclN1cHBvcnRlZExheW91dFdpZHRoIGFueS1wcmVmZXItZml4ZWRcbiAqIEBmcmFtZXJTdXBwb3J0ZWRMYXlvdXRIZWlnaHQgYXV0b1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMaW5raW5nVGVzdChwcm9wczogTGlua2luZ1Rlc3RQcm9wcykge1xuICAgIGNvbnN0IHtcbiAgICAgICAgdGVzdE1vZGUgPSBcInNpbXBsZVwiLFxuICAgICAgICBmb3JtSWQgPSBcInRlc3QtZm9ybVwiLFxuICAgICAgICBidXR0b25JZCA9IFwidGVzdC1idXR0b25cIixcbiAgICB9ID0gcHJvcHNcblxuICAgIGNvbnN0IGdldFRlc3RDb25maWcgPSAoKSA9PiB7XG4gICAgICAgIHN3aXRjaCAodGVzdE1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzaW1wbGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBmb3JtSWQ6IFwic2ltcGxlLWZvcm1cIixcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uSWQ6IFwic2ltcGxlLWJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICBmb3JtTGFiZWw6IFwiU2ltcGxlIFRlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uVGV4dDogXCJUZXN0IExpbmtcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJhZHZhbmNlZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1JZDogXCJhZHZhbmNlZC1mb3JtXCIsXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbklkOiBcImFkdmFuY2VkLWJ1dHRvblwiLCBcbiAgICAgICAgICAgICAgICAgICAgZm9ybUxhYmVsOiBcIkFkdmFuY2VkIFRlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uVGV4dDogXCJBZHZhbmNlZCBMaW5rXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiY3VzdG9tXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybUlkLFxuICAgICAgICAgICAgICAgICAgICBidXR0b25JZCxcbiAgICAgICAgICAgICAgICAgICAgZm9ybUxhYmVsOiBcIkN1c3RvbSBUZXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvblRleHQ6IFwiQ3VzdG9tIExpbmtcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybUlkOiBcImRlZmF1bHQtZm9ybVwiLFxuICAgICAgICAgICAgICAgICAgICBidXR0b25JZDogXCJkZWZhdWx0LWJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICBmb3JtTGFiZWw6IFwiRGVmYXVsdCBUZXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvblRleHQ6IFwiRGVmYXVsdCBMaW5rXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjb25maWcgPSBnZXRUZXN0Q29uZmlnKClcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgc3R5bGU9e3tcbiAgICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICAgICAgICAgIGdhcDogXCIxNnB4XCIsXG4gICAgICAgICAgICBwYWRkaW5nOiBcIjIwcHhcIixcbiAgICAgICAgICAgIGJvcmRlcjogXCIycHggc29saWQgI0U1RTdFQlwiLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjEycHhcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjRjlGQUZCXCJcbiAgICAgICAgfX0+XG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogXCIxMnB4XCIsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzQjgyRjZcIixcbiAgICAgICAgICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCI4cHhcIixcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogXCI2MDBcIlxuICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAg8J+UlyBJRC1CYXNlZCBMaW5raW5nIFRlc3RcbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICAgICAgZ2FwOiBcIjE2cHhcIixcbiAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiBcImZsZXgtc3RhcnRcIlxuICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBmbGV4OiAxIH19PlxuICAgICAgICAgICAgICAgICAgICA8Rm9ybUJ1aWxkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkVHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9e2NvbmZpZy5mb3JtTGFiZWx9XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93TGFiZWw9e3RydWV9XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlR5cGUgdG8gdGVzdCBsaW5raW5nLi4uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyQ29sb3I9XCIjOUNBM0FGXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkPXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0NoaXBzPXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpcFN1Z2dlc3Rpb25zPXtbXCJ0ZXN0MVwiLCBcInRlc3QyXCIsIFwidGVzdDNcIl19XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I9XCIjRkZGRkZGXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yPVwiI0U1RTdFQlwiXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0NvbG9yPVwiIzNCODJGNlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Q29sb3I9XCIjMTExODI3XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsQ29sb3I9XCIjMzc0MTUxXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1cz1cIjhweFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHRNb2RlPVwiZml4ZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0PXs0MH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc9XCIxMnB4IDE2cHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0NsZWFyQnV0dG9uPXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJCdXR0b25Db2xvcj1cIiM5Q0EzQUZcIlxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0J1dHRvbj17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRJZD17Y29uZmlnLmZvcm1JZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtlZEJ1dHRvbklkPXtjb25maWcuYnV0dG9uSWR9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBmbGV4OiBcIjAgMCBhdXRvXCIgfX0+XG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9e2NvbmZpZy5idXR0b25UZXh0fVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFudD1cInByaW1hcnlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZT1cIm1lZGl1bVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nPXtmYWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxXaWR0aD17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlcm5hbERpc2FibGVkPXtmYWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1cz1cIjhweFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nPVwiMTJweCAyNHB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudElkPXtjb25maWcuYnV0dG9uSWR9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rZWRGb3JtSWQ9e2NvbmZpZy5mb3JtSWR9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBzdHlsZT17e1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IFwiOHB4IDEycHhcIixcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI0YzRjRGNlwiLFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCI2cHhcIixcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogXCIxMnB4XCIsXG4gICAgICAgICAgICAgICAgY29sb3I6IFwiIzZCNzI4MFwiLFxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IFwibW9ub3NwYWNlXCJcbiAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgIDxzdHJvbmc+Rm9ybSBJRDo8L3N0cm9uZz4ge2NvbmZpZy5mb3JtSWR9IHwgPHN0cm9uZz5CdXR0b24gSUQ6PC9zdHJvbmc+IHtjb25maWcuYnV0dG9uSWR9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgKVxufVxuXG5hZGRQcm9wZXJ0eUNvbnRyb2xzKExpbmtpbmdUZXN0LCB7XG4gICAgdGVzdE1vZGU6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuRW51bSxcbiAgICAgICAgdGl0bGU6IFwiVGVzdCBNb2RlXCIsXG4gICAgICAgIG9wdGlvbnM6IFtcInNpbXBsZVwiLCBcImFkdmFuY2VkXCIsIFwiY3VzdG9tXCJdLFxuICAgICAgICBvcHRpb25UaXRsZXM6IFtcIlNpbXBsZVwiLCBcIkFkdmFuY2VkXCIsIFwiQ3VzdG9tXCJdLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IFwic2ltcGxlXCIsXG4gICAgfSxcbiAgICBmb3JtSWQ6IHtcbiAgICAgICAgdHlwZTogQ29udHJvbFR5cGUuU3RyaW5nLFxuICAgICAgICB0aXRsZTogXCJDdXN0b20gRm9ybSBJRFwiLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IFwidGVzdC1mb3JtXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkN1c3RvbSBmb3JtIElEIChvbmx5IHVzZWQgaW4gY3VzdG9tIG1vZGUpXCIsXG4gICAgICAgIGhpZGRlbjogKHsgdGVzdE1vZGUgfSkgPT4gdGVzdE1vZGUgIT09IFwiY3VzdG9tXCIsXG4gICAgfSxcbiAgICBidXR0b25JZDoge1xuICAgICAgICB0eXBlOiBDb250cm9sVHlwZS5TdHJpbmcsXG4gICAgICAgIHRpdGxlOiBcIkN1c3RvbSBCdXR0b24gSURcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcInRlc3QtYnV0dG9uXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkN1c3RvbSBidXR0b24gSUQgKG9ubHkgdXNlZCBpbiBjdXN0b20gbW9kZSlcIixcbiAgICAgICAgaGlkZGVuOiAoeyB0ZXN0TW9kZSB9KSA9PiB0ZXN0TW9kZSAhPT0gXCJjdXN0b21cIixcbiAgICB9LFxufSlcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImFkZFByb3BlcnR5Q29udHJvbHMiLCJDb250cm9sVHlwZSIsIkZvcm1CdWlsZGVyIiwiQnV0dG9uIiwiTGlua2luZ1Rlc3QiLCJwcm9wcyIsInRlc3RNb2RlIiwiZm9ybUlkIiwiYnV0dG9uSWQiLCJnZXRUZXN0Q29uZmlnIiwiZm9ybUxhYmVsIiwiYnV0dG9uVGV4dCIsImNvbmZpZyIsImRpdiIsInN0eWxlIiwiZGlzcGxheSIsImZsZXhEaXJlY3Rpb24iLCJnYXAiLCJwYWRkaW5nIiwiYm9yZGVyIiwiYm9yZGVyUmFkaXVzIiwiYmFja2dyb3VuZENvbG9yIiwiY29sb3IiLCJ0ZXh0QWxpZ24iLCJmb250V2VpZ2h0IiwiYWxpZ25JdGVtcyIsImZsZXgiLCJmaWVsZFR5cGUiLCJsYWJlbCIsInNob3dMYWJlbCIsInBsYWNlaG9sZGVyIiwicGxhY2Vob2xkZXJDb2xvciIsInJlcXVpcmVkIiwic2hvd0NoaXBzIiwiY2hpcFN1Z2dlc3Rpb25zIiwiYm9yZGVyQ29sb3IiLCJmb2N1c0NvbG9yIiwidGV4dENvbG9yIiwibGFiZWxDb2xvciIsImhlaWdodE1vZGUiLCJoZWlnaHQiLCJzaG93Q2xlYXJCdXR0b24iLCJjbGVhckJ1dHRvbkNvbG9yIiwic2hvd0J1dHRvbiIsImNvbXBvbmVudElkIiwibGlua2VkQnV0dG9uSWQiLCJ0ZXh0IiwidmFyaWFudCIsInNpemUiLCJkaXNhYmxlZCIsImxvYWRpbmciLCJmdWxsV2lkdGgiLCJleHRlcm5hbERpc2FibGVkIiwibGlua2VkRm9ybUlkIiwiZm9udFNpemUiLCJmb250RmFtaWx5Iiwic3Ryb25nIiwidHlwZSIsIkVudW0iLCJ0aXRsZSIsIm9wdGlvbnMiLCJvcHRpb25UaXRsZXMiLCJkZWZhdWx0VmFsdWUiLCJTdHJpbmciLCJkZXNjcmlwdGlvbiIsImhpZGRlbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/LinkingTest.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/SimpleGlobalState.tsx":
/*!**********************************************!*\
  !*** ./src/components/SimpleGlobalState.tsx ***!
  \**********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SimpleGlobalState),\n/* harmony export */   getComponentData: () => (/* binding */ getComponentData),\n/* harmony export */   setComponentData: () => (/* binding */ setComponentData),\n/* harmony export */   subscribeToComponent: () => (/* binding */ subscribeToComponent),\n/* harmony export */   unsubscribeFromComponent: () => (/* binding */ unsubscribeFromComponent)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var framer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framer */ \"(app-pages-browser)/./node_modules/framer/build/esm/framer.debug.js\");\n\n\n/**\n * @framerSupportedLayoutWidth any-prefer-fixed\n * @framerSupportedLayoutHeight auto\n */ function SimpleGlobalState(props) {\n    // This component is invisible but provides global state functionality\n    return null;\n}\n_c = SimpleGlobalState;\n// Very simple global state - just use a plain object\nlet globalState = {};\n// Helper functions for global state management\nconst setComponentData = (id, type, data)=>{\n    globalState[id] = {\n        id,\n        type,\n        data\n    };\n    console.log(\"GlobalState: Set data for \".concat(id, \":\"), data);\n};\nconst getComponentData = (id)=>{\n    return globalState[id];\n};\nconst subscribeToComponent = (id, callback)=>{\n    console.log(\"GlobalState: Subscribed to \".concat(id));\n// Simple implementation - just log for now\n};\nconst unsubscribeFromComponent = (id, callback)=>{\n    console.log(\"GlobalState: Unsubscribed from \".concat(id));\n// Simple implementation - just log for now\n};\n(0,framer__WEBPACK_IMPORTED_MODULE_1__.addPropertyControls)(SimpleGlobalState, {\n});\nvar _c;\n$RefreshReg$(_c, \"SimpleGlobalState\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1NpbXBsZUdsb2JhbFN0YXRlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF5QjtBQUNnQztBQU16RDs7O0NBR0MsR0FDYyxTQUFTRSxrQkFBa0JDLEtBQTZCO0lBQ3JFLHNFQUFzRTtJQUN0RSxPQUFPO0FBQ1Q7S0FId0JEO0FBS3hCLHFEQUFxRDtBQUNyRCxJQUFJRSxjQUFtQixDQUFDO0FBRXhCLCtDQUErQztBQUN4QyxNQUFNQyxtQkFBbUIsQ0FBQ0MsSUFBWUMsTUFBeUJDO0lBQ3BFSixXQUFXLENBQUNFLEdBQUcsR0FBRztRQUFFQTtRQUFJQztRQUFNQztJQUFLO0lBQ25DQyxRQUFRQyxHQUFHLENBQUMsNkJBQWdDLE9BQUhKLElBQUcsTUFBSUU7QUFDbEQsRUFBQztBQUVNLE1BQU1HLG1CQUFtQixDQUFDTDtJQUMvQixPQUFPRixXQUFXLENBQUNFLEdBQUc7QUFDeEIsRUFBQztBQUVNLE1BQU1NLHVCQUF1QixDQUFDTixJQUFZTztJQUMvQ0osUUFBUUMsR0FBRyxDQUFDLDhCQUFpQyxPQUFISjtBQUMxQywyQ0FBMkM7QUFDN0MsRUFBQztBQUVNLE1BQU1RLDJCQUEyQixDQUFDUixJQUFZTztJQUNuREosUUFBUUMsR0FBRyxDQUFDLGtDQUFxQyxPQUFISjtBQUM5QywyQ0FBMkM7QUFDN0MsRUFBQztBQUVETCwyREFBbUJBLENBQUNDLG1CQUFtQjtBQUV2QyIsInNvdXJjZXMiOlsiL1VzZXJzL3ppYm9uL0RvY3VtZW50cy9WaWJlL0N1cnNvci9GcmFtZXIgV29ya3Nob3AvZnJhbWVyLXdvcmtzaG9wL3NyYy9jb21wb25lbnRzL1NpbXBsZUdsb2JhbFN0YXRlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCJcbmltcG9ydCB7IGFkZFByb3BlcnR5Q29udHJvbHMsIENvbnRyb2xUeXBlIH0gZnJvbSBcImZyYW1lclwiXG5cbmludGVyZmFjZSBTaW1wbGVHbG9iYWxTdGF0ZVByb3BzIHtcbiAgLy8gVGhpcyBjb21wb25lbnQgZG9lc24ndCBuZWVkIGFueSBwcm9wcywgaXQganVzdCBwcm92aWRlcyBnbG9iYWwgc3RhdGUgZnVuY3Rpb25hbGl0eVxufVxuXG4vKipcbiAqIEBmcmFtZXJTdXBwb3J0ZWRMYXlvdXRXaWR0aCBhbnktcHJlZmVyLWZpeGVkXG4gKiBAZnJhbWVyU3VwcG9ydGVkTGF5b3V0SGVpZ2h0IGF1dG9cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2ltcGxlR2xvYmFsU3RhdGUocHJvcHM6IFNpbXBsZUdsb2JhbFN0YXRlUHJvcHMpIHtcbiAgLy8gVGhpcyBjb21wb25lbnQgaXMgaW52aXNpYmxlIGJ1dCBwcm92aWRlcyBnbG9iYWwgc3RhdGUgZnVuY3Rpb25hbGl0eVxuICByZXR1cm4gbnVsbFxufVxuXG4vLyBWZXJ5IHNpbXBsZSBnbG9iYWwgc3RhdGUgLSBqdXN0IHVzZSBhIHBsYWluIG9iamVjdFxubGV0IGdsb2JhbFN0YXRlOiBhbnkgPSB7fVxuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciBnbG9iYWwgc3RhdGUgbWFuYWdlbWVudFxuZXhwb3J0IGNvbnN0IHNldENvbXBvbmVudERhdGEgPSAoaWQ6IHN0cmluZywgdHlwZTogJ2Zvcm0nIHwgJ2J1dHRvbicsIGRhdGE6IGFueSkgPT4ge1xuICBnbG9iYWxTdGF0ZVtpZF0gPSB7IGlkLCB0eXBlLCBkYXRhIH1cbiAgY29uc29sZS5sb2coYEdsb2JhbFN0YXRlOiBTZXQgZGF0YSBmb3IgJHtpZH06YCwgZGF0YSlcbn1cblxuZXhwb3J0IGNvbnN0IGdldENvbXBvbmVudERhdGEgPSAoaWQ6IHN0cmluZykgPT4ge1xuICByZXR1cm4gZ2xvYmFsU3RhdGVbaWRdXG59XG5cbmV4cG9ydCBjb25zdCBzdWJzY3JpYmVUb0NvbXBvbmVudCA9IChpZDogc3RyaW5nLCBjYWxsYmFjazogKGRhdGE6IGFueSkgPT4gdm9pZCkgPT4ge1xuICBjb25zb2xlLmxvZyhgR2xvYmFsU3RhdGU6IFN1YnNjcmliZWQgdG8gJHtpZH1gKVxuICAvLyBTaW1wbGUgaW1wbGVtZW50YXRpb24gLSBqdXN0IGxvZyBmb3Igbm93XG59XG5cbmV4cG9ydCBjb25zdCB1bnN1YnNjcmliZUZyb21Db21wb25lbnQgPSAoaWQ6IHN0cmluZywgY2FsbGJhY2s6IChkYXRhOiBhbnkpID0+IHZvaWQpID0+IHtcbiAgY29uc29sZS5sb2coYEdsb2JhbFN0YXRlOiBVbnN1YnNjcmliZWQgZnJvbSAke2lkfWApXG4gIC8vIFNpbXBsZSBpbXBsZW1lbnRhdGlvbiAtIGp1c3QgbG9nIGZvciBub3dcbn1cblxuYWRkUHJvcGVydHlDb250cm9scyhTaW1wbGVHbG9iYWxTdGF0ZSwge1xuICAvLyBObyB2aXNpYmxlIGNvbnRyb2xzIG5lZWRlZCBmb3IgdGhpcyBjb21wb25lbnRcbn0pXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJhZGRQcm9wZXJ0eUNvbnRyb2xzIiwiU2ltcGxlR2xvYmFsU3RhdGUiLCJwcm9wcyIsImdsb2JhbFN0YXRlIiwic2V0Q29tcG9uZW50RGF0YSIsImlkIiwidHlwZSIsImRhdGEiLCJjb25zb2xlIiwibG9nIiwiZ2V0Q29tcG9uZW50RGF0YSIsInN1YnNjcmliZVRvQ29tcG9uZW50IiwiY2FsbGJhY2siLCJ1bnN1YnNjcmliZUZyb21Db21wb25lbnQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/SimpleGlobalState.tsx\n"));

/***/ })

}]);